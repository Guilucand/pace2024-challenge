/* automatically generated by rust-bindgen 0.69.4 */

pub const _STDIO_H: u32 = 1;
pub const _FEATURES_H: u32 = 1;
pub const _DEFAULT_SOURCE: u32 = 1;
pub const __GLIBC_USE_ISOC2X: u32 = 0;
pub const __USE_ISOC11: u32 = 1;
pub const __USE_ISOC99: u32 = 1;
pub const __USE_ISOC95: u32 = 1;
pub const __USE_POSIX_IMPLICITLY: u32 = 1;
pub const _POSIX_SOURCE: u32 = 1;
pub const _POSIX_C_SOURCE: u32 = 200809;
pub const __USE_POSIX: u32 = 1;
pub const __USE_POSIX2: u32 = 1;
pub const __USE_POSIX199309: u32 = 1;
pub const __USE_POSIX199506: u32 = 1;
pub const __USE_XOPEN2K: u32 = 1;
pub const __USE_XOPEN2K8: u32 = 1;
pub const _ATFILE_SOURCE: u32 = 1;
pub const __WORDSIZE: u32 = 64;
pub const __WORDSIZE_TIME64_COMPAT32: u32 = 1;
pub const __SYSCALL_WORDSIZE: u32 = 64;
pub const __TIMESIZE: u32 = 64;
pub const __USE_MISC: u32 = 1;
pub const __USE_ATFILE: u32 = 1;
pub const __USE_FORTIFY_LEVEL: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_GETS: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_SCANF: u32 = 0;
pub const __GLIBC_USE_C2X_STRTOL: u32 = 0;
pub const _STDC_PREDEF_H: u32 = 1;
pub const __STDC_IEC_559__: u32 = 1;
pub const __STDC_IEC_60559_BFP__: u32 = 201404;
pub const __STDC_IEC_559_COMPLEX__: u32 = 1;
pub const __STDC_IEC_60559_COMPLEX__: u32 = 201404;
pub const __STDC_ISO_10646__: u32 = 201706;
pub const __GNU_LIBRARY__: u32 = 6;
pub const __GLIBC__: u32 = 2;
pub const __GLIBC_MINOR__: u32 = 38;
pub const _SYS_CDEFS_H: u32 = 1;
pub const __glibc_c99_flexarr_available: u32 = 1;
pub const __LDOUBLE_REDIRECTS_TO_FLOAT128_ABI: u32 = 0;
pub const __HAVE_GENERIC_SELECTION: u32 = 1;
pub const __GLIBC_USE_LIB_EXT2: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT_C2X: u32 = 0;
pub const __GLIBC_USE_IEC_60559_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT_C2X: u32 = 0;
pub const __GLIBC_USE_IEC_60559_TYPES_EXT: u32 = 0;
pub const _BITS_TYPES_H: u32 = 1;
pub const _BITS_TYPESIZES_H: u32 = 1;
pub const __OFF_T_MATCHES_OFF64_T: u32 = 1;
pub const __INO_T_MATCHES_INO64_T: u32 = 1;
pub const __RLIM_T_MATCHES_RLIM64_T: u32 = 1;
pub const __STATFS_MATCHES_STATFS64: u32 = 1;
pub const __KERNEL_OLD_TIMEVAL_MATCHES_TIMEVAL64: u32 = 1;
pub const __FD_SETSIZE: u32 = 1024;
pub const _BITS_TIME64_H: u32 = 1;
pub const _____fpos_t_defined: u32 = 1;
pub const ____mbstate_t_defined: u32 = 1;
pub const _____fpos64_t_defined: u32 = 1;
pub const ____FILE_defined: u32 = 1;
pub const __FILE_defined: u32 = 1;
pub const __struct_FILE_defined: u32 = 1;
pub const _IO_EOF_SEEN: u32 = 16;
pub const _IO_ERR_SEEN: u32 = 32;
pub const _IO_USER_LOCK: u32 = 32768;
pub const __cookie_io_functions_t_defined: u32 = 1;
pub const _IOFBF: u32 = 0;
pub const _IOLBF: u32 = 1;
pub const _IONBF: u32 = 2;
pub const BUFSIZ: u32 = 8192;
pub const EOF: i32 = -1;
pub const SEEK_SET: u32 = 0;
pub const SEEK_CUR: u32 = 1;
pub const SEEK_END: u32 = 2;
pub const P_tmpdir: &[u8; 5] = b"/tmp\0";
pub const L_tmpnam: u32 = 20;
pub const TMP_MAX: u32 = 238328;
pub const _BITS_STDIO_LIM_H: u32 = 1;
pub const FILENAME_MAX: u32 = 4096;
pub const L_ctermid: u32 = 9;
pub const FOPEN_MAX: u32 = 16;
pub const __HAVE_FLOAT128: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT128: u32 = 0;
pub const __HAVE_FLOAT64X: u32 = 1;
pub const __HAVE_FLOAT64X_LONG_DOUBLE: u32 = 1;
pub const __HAVE_FLOAT16: u32 = 0;
pub const __HAVE_FLOAT32: u32 = 1;
pub const __HAVE_FLOAT64: u32 = 1;
pub const __HAVE_FLOAT32X: u32 = 1;
pub const __HAVE_FLOAT128X: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT16: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT32: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT64: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT32X: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT64X: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT128X: u32 = 0;
pub const __HAVE_FLOATN_NOT_TYPEDEF: u32 = 0;
pub const _STDINT_H: u32 = 1;
pub const _BITS_WCHAR_H: u32 = 1;
pub const _BITS_STDINT_INTN_H: u32 = 1;
pub const _BITS_STDINT_UINTN_H: u32 = 1;
pub const INT8_MIN: i32 = -128;
pub const INT16_MIN: i32 = -32768;
pub const INT32_MIN: i32 = -2147483648;
pub const INT8_MAX: u32 = 127;
pub const INT16_MAX: u32 = 32767;
pub const INT32_MAX: u32 = 2147483647;
pub const UINT8_MAX: u32 = 255;
pub const UINT16_MAX: u32 = 65535;
pub const UINT32_MAX: u32 = 4294967295;
pub const INT_LEAST8_MIN: i32 = -128;
pub const INT_LEAST16_MIN: i32 = -32768;
pub const INT_LEAST32_MIN: i32 = -2147483648;
pub const INT_LEAST8_MAX: u32 = 127;
pub const INT_LEAST16_MAX: u32 = 32767;
pub const INT_LEAST32_MAX: u32 = 2147483647;
pub const UINT_LEAST8_MAX: u32 = 255;
pub const UINT_LEAST16_MAX: u32 = 65535;
pub const UINT_LEAST32_MAX: u32 = 4294967295;
pub const INT_FAST8_MIN: i32 = -128;
pub const INT_FAST16_MIN: i64 = -9223372036854775808;
pub const INT_FAST32_MIN: i64 = -9223372036854775808;
pub const INT_FAST8_MAX: u32 = 127;
pub const INT_FAST16_MAX: u64 = 9223372036854775807;
pub const INT_FAST32_MAX: u64 = 9223372036854775807;
pub const UINT_FAST8_MAX: u32 = 255;
pub const UINT_FAST16_MAX: i32 = -1;
pub const UINT_FAST32_MAX: i32 = -1;
pub const INTPTR_MIN: i64 = -9223372036854775808;
pub const INTPTR_MAX: u64 = 9223372036854775807;
pub const UINTPTR_MAX: i32 = -1;
pub const PTRDIFF_MIN: i64 = -9223372036854775808;
pub const PTRDIFF_MAX: u64 = 9223372036854775807;
pub const SIG_ATOMIC_MIN: i32 = -2147483648;
pub const SIG_ATOMIC_MAX: u32 = 2147483647;
pub const SIZE_MAX: i32 = -1;
pub const WINT_MIN: u32 = 0;
pub const WINT_MAX: u32 = 4294967295;
pub const _MATH_H: u32 = 1;
pub const _BITS_LIBM_SIMD_DECL_STUBS_H: u32 = 1;
pub const __FP_LOGB0_IS_MIN: u32 = 1;
pub const __FP_LOGBNAN_IS_MIN: u32 = 1;
pub const FP_ILOGB0: i32 = -2147483648;
pub const FP_ILOGBNAN: i32 = -2147483648;
pub const __MATH_DECLARING_DOUBLE: u32 = 1;
pub const __MATH_DECLARING_FLOATN: u32 = 0;
pub const __MATH_DECLARE_LDOUBLE: u32 = 1;
pub const MATH_ERRNO: u32 = 1;
pub const MATH_ERREXCEPT: u32 = 2;
pub const math_errhandling: u32 = 3;
pub const M_E: f64 = 2.718281828459045;
pub const M_LOG2E: f64 = 1.4426950408889634;
pub const M_LOG10E: f64 = 0.4342944819032518;
pub const M_LN2: f64 = 0.6931471805599453;
pub const M_LN10: f64 = 2.302585092994046;
pub const M_PI: f64 = 3.141592653589793;
pub const M_PI_2: f64 = 1.5707963267948966;
pub const M_PI_4: f64 = 0.7853981633974483;
pub const M_1_PI: f64 = 0.3183098861837907;
pub const M_2_PI: f64 = 0.6366197723675814;
pub const M_2_SQRTPI: f64 = 1.1283791670955126;
pub const M_SQRT2: f64 = 1.4142135623730951;
pub const M_SQRT1_2: f64 = 0.7071067811865476;
pub const _LIBC_LIMITS_H_: u32 = 1;
pub const MB_LEN_MAX: u32 = 16;
pub const _BITS_POSIX1_LIM_H: u32 = 1;
pub const _POSIX_AIO_LISTIO_MAX: u32 = 2;
pub const _POSIX_AIO_MAX: u32 = 1;
pub const _POSIX_ARG_MAX: u32 = 4096;
pub const _POSIX_CHILD_MAX: u32 = 25;
pub const _POSIX_DELAYTIMER_MAX: u32 = 32;
pub const _POSIX_HOST_NAME_MAX: u32 = 255;
pub const _POSIX_LINK_MAX: u32 = 8;
pub const _POSIX_LOGIN_NAME_MAX: u32 = 9;
pub const _POSIX_MAX_CANON: u32 = 255;
pub const _POSIX_MAX_INPUT: u32 = 255;
pub const _POSIX_MQ_OPEN_MAX: u32 = 8;
pub const _POSIX_MQ_PRIO_MAX: u32 = 32;
pub const _POSIX_NAME_MAX: u32 = 14;
pub const _POSIX_NGROUPS_MAX: u32 = 8;
pub const _POSIX_OPEN_MAX: u32 = 20;
pub const _POSIX_PATH_MAX: u32 = 256;
pub const _POSIX_PIPE_BUF: u32 = 512;
pub const _POSIX_RE_DUP_MAX: u32 = 255;
pub const _POSIX_RTSIG_MAX: u32 = 8;
pub const _POSIX_SEM_NSEMS_MAX: u32 = 256;
pub const _POSIX_SEM_VALUE_MAX: u32 = 32767;
pub const _POSIX_SIGQUEUE_MAX: u32 = 32;
pub const _POSIX_SSIZE_MAX: u32 = 32767;
pub const _POSIX_STREAM_MAX: u32 = 8;
pub const _POSIX_SYMLINK_MAX: u32 = 255;
pub const _POSIX_SYMLOOP_MAX: u32 = 8;
pub const _POSIX_TIMER_MAX: u32 = 32;
pub const _POSIX_TTY_NAME_MAX: u32 = 9;
pub const _POSIX_TZNAME_MAX: u32 = 6;
pub const _POSIX_CLOCKRES_MIN: u32 = 20000000;
pub const NR_OPEN: u32 = 1024;
pub const NGROUPS_MAX: u32 = 65536;
pub const ARG_MAX: u32 = 131072;
pub const LINK_MAX: u32 = 127;
pub const MAX_CANON: u32 = 255;
pub const MAX_INPUT: u32 = 255;
pub const NAME_MAX: u32 = 255;
pub const PATH_MAX: u32 = 4096;
pub const PIPE_BUF: u32 = 4096;
pub const XATTR_NAME_MAX: u32 = 255;
pub const XATTR_SIZE_MAX: u32 = 65536;
pub const XATTR_LIST_MAX: u32 = 65536;
pub const RTSIG_MAX: u32 = 32;
pub const _POSIX_THREAD_KEYS_MAX: u32 = 128;
pub const PTHREAD_KEYS_MAX: u32 = 1024;
pub const _POSIX_THREAD_DESTRUCTOR_ITERATIONS: u32 = 4;
pub const PTHREAD_DESTRUCTOR_ITERATIONS: u32 = 4;
pub const _POSIX_THREAD_THREADS_MAX: u32 = 64;
pub const AIO_PRIO_DELTA_MAX: u32 = 20;
pub const PTHREAD_STACK_MIN: u32 = 16384;
pub const DELAYTIMER_MAX: u32 = 2147483647;
pub const TTY_NAME_MAX: u32 = 32;
pub const LOGIN_NAME_MAX: u32 = 256;
pub const HOST_NAME_MAX: u32 = 64;
pub const MQ_PRIO_MAX: u32 = 32768;
pub const SEM_VALUE_MAX: u32 = 2147483647;
pub const _BITS_POSIX2_LIM_H: u32 = 1;
pub const _POSIX2_BC_BASE_MAX: u32 = 99;
pub const _POSIX2_BC_DIM_MAX: u32 = 2048;
pub const _POSIX2_BC_SCALE_MAX: u32 = 99;
pub const _POSIX2_BC_STRING_MAX: u32 = 1000;
pub const _POSIX2_COLL_WEIGHTS_MAX: u32 = 2;
pub const _POSIX2_EXPR_NEST_MAX: u32 = 32;
pub const _POSIX2_LINE_MAX: u32 = 2048;
pub const _POSIX2_RE_DUP_MAX: u32 = 255;
pub const _POSIX2_CHARCLASS_NAME_MAX: u32 = 14;
pub const BC_BASE_MAX: u32 = 99;
pub const BC_DIM_MAX: u32 = 2048;
pub const BC_SCALE_MAX: u32 = 99;
pub const BC_STRING_MAX: u32 = 1000;
pub const COLL_WEIGHTS_MAX: u32 = 255;
pub const EXPR_NEST_MAX: u32 = 32;
pub const LINE_MAX: u32 = 2048;
pub const CHARCLASS_NAME_MAX: u32 = 2048;
pub const RE_DUP_MAX: u32 = 32767;
pub const _ASSERT_H: u32 = 1;
pub const CMAKE_BUILD_TYPE: &[u8; 8] = b"Release\0";
pub const SCIP_VERSION_MAJOR: u32 = 9;
pub const SCIP_VERSION_MINOR: u32 = 0;
pub const SCIP_VERSION_PATCH: u32 = 0;
pub const SCIP_VERSION_SUB: u32 = 0;
pub const SCIP_VERSION_API: u32 = 114;
pub const SCIP_HAVE_VARIADIC_MACROS: u32 = 1;
pub const TRUE: u32 = 1;
pub const FALSE: u32 = 0;
pub const SCIP_VERSION: u32 = 900;
pub const SCIP_SUBVERSION: u32 = 0;
pub const SCIP_APIVERSION: u32 = 114;
pub const SCIP_COPYRIGHT: &[u8; 52] = b"Copyright (c) 2002-2024 Zuse Institute Berlin (ZIB)\0";
pub const SCIP_VARTYPE_BINARY_CHAR: u8 = 66u8;
pub const SCIP_VARTYPE_INTEGER_CHAR: u8 = 73u8;
pub const SCIP_VARTYPE_IMPLINT_CHAR: u8 = 77u8;
pub const SCIP_VARTYPE_CONTINUOUS_CHAR: u8 = 67u8;
pub const SCIP_LONGINT_FORMAT: &[u8; 4] = b"lld\0";
pub const SCIP_REAL_FORMAT: &[u8; 3] = b"lf\0";
pub const SCIP_DEFAULT_INFINITY: f64 = 100000000000000000000.0;
pub const SCIP_DEFAULT_EPSILON: f64 = 0.000000001;
pub const SCIP_DEFAULT_SUMEPSILON: f64 = 0.000001;
pub const SCIP_DEFAULT_FEASTOL: f64 = 0.000001;
pub const SCIP_DEFAULT_CHECKFEASTOLFAC: f64 = 1.0;
pub const SCIP_DEFAULT_LPFEASTOLFACTOR: f64 = 1.0;
pub const SCIP_DEFAULT_DUALFEASTOL: f64 = 0.0000001;
pub const SCIP_DEFAULT_BARRIERCONVTOL: f64 = 0.0000000001;
pub const SCIP_DEFAULT_BOUNDSTREPS: f64 = 0.05;
pub const SCIP_DEFAULT_PSEUDOCOSTEPS: f64 = 0.1;
pub const SCIP_DEFAULT_PSEUDOCOSTDELTA: f64 = 0.0001;
pub const SCIP_DEFAULT_RECOMPFAC: f64 = 10000000.0;
pub const SCIP_DEFAULT_HUGEVAL: f64 = 1000000000000000.0;
pub const SCIP_MAXEPSILON: f64 = 0.001;
pub const SCIP_MINEPSILON: f64 = 0.00000000000000000001;
pub const SCIP_MAXSTRLEN: u32 = 1024;
pub const SCIP_SPACECONTROL: &[u8; 7] = b" tnvfr\0";
pub const SCIP_MAXMEMSIZE: u32 = 0;
pub const SCIP_HASHSIZE_PARAMS: u32 = 2048;
pub const SCIP_HASHSIZE_NAMES: u32 = 500;
pub const SCIP_HASHSIZE_CUTPOOLS: u32 = 500;
pub const SCIP_HASHSIZE_CLIQUES: u32 = 500;
pub const SCIP_HASHSIZE_NAMES_SMALL: u32 = 100;
pub const SCIP_HASHSIZE_CUTPOOLS_SMALL: u32 = 100;
pub const SCIP_HASHSIZE_CLIQUES_SMALL: u32 = 100;
pub const SCIP_HASHSIZE_VBC: u32 = 500;
pub const SCIP_DEFAULT_MEM_ARRAYGROWFAC: f64 = 1.2;
pub const SCIP_DEFAULT_MEM_ARRAYGROWINIT: u32 = 4;
pub const SCIP_MAXTREEDEPTH: u32 = 1073741822;
pub const SCIP_PROBINGSCORE_PENALTYRATIO: u32 = 2;
pub const _STDLIB_H: u32 = 1;
pub const WNOHANG: u32 = 1;
pub const WUNTRACED: u32 = 2;
pub const WSTOPPED: u32 = 2;
pub const WEXITED: u32 = 4;
pub const WCONTINUED: u32 = 8;
pub const WNOWAIT: u32 = 16777216;
pub const __WNOTHREAD: u32 = 536870912;
pub const __WALL: u32 = 1073741824;
pub const __WCLONE: u32 = 2147483648;
pub const __W_CONTINUED: u32 = 65535;
pub const __WCOREFLAG: u32 = 128;
pub const __ldiv_t_defined: u32 = 1;
pub const __lldiv_t_defined: u32 = 1;
pub const RAND_MAX: u32 = 2147483647;
pub const EXIT_FAILURE: u32 = 1;
pub const EXIT_SUCCESS: u32 = 0;
pub const _SYS_TYPES_H: u32 = 1;
pub const __clock_t_defined: u32 = 1;
pub const __clockid_t_defined: u32 = 1;
pub const __time_t_defined: u32 = 1;
pub const __timer_t_defined: u32 = 1;
pub const __BIT_TYPES_DEFINED__: u32 = 1;
pub const _ENDIAN_H: u32 = 1;
pub const _BITS_ENDIAN_H: u32 = 1;
pub const __LITTLE_ENDIAN: u32 = 1234;
pub const __BIG_ENDIAN: u32 = 4321;
pub const __PDP_ENDIAN: u32 = 3412;
pub const _BITS_ENDIANNESS_H: u32 = 1;
pub const __BYTE_ORDER: u32 = 1234;
pub const __FLOAT_WORD_ORDER: u32 = 1234;
pub const LITTLE_ENDIAN: u32 = 1234;
pub const BIG_ENDIAN: u32 = 4321;
pub const PDP_ENDIAN: u32 = 3412;
pub const BYTE_ORDER: u32 = 1234;
pub const _BITS_BYTESWAP_H: u32 = 1;
pub const _BITS_UINTN_IDENTITY_H: u32 = 1;
pub const _SYS_SELECT_H: u32 = 1;
pub const __sigset_t_defined: u32 = 1;
pub const __timeval_defined: u32 = 1;
pub const _STRUCT_TIMESPEC: u32 = 1;
pub const FD_SETSIZE: u32 = 1024;
pub const _BITS_PTHREADTYPES_COMMON_H: u32 = 1;
pub const _THREAD_SHARED_TYPES_H: u32 = 1;
pub const _BITS_PTHREADTYPES_ARCH_H: u32 = 1;
pub const __SIZEOF_PTHREAD_MUTEX_T: u32 = 40;
pub const __SIZEOF_PTHREAD_ATTR_T: u32 = 56;
pub const __SIZEOF_PTHREAD_RWLOCK_T: u32 = 56;
pub const __SIZEOF_PTHREAD_BARRIER_T: u32 = 32;
pub const __SIZEOF_PTHREAD_MUTEXATTR_T: u32 = 4;
pub const __SIZEOF_PTHREAD_COND_T: u32 = 48;
pub const __SIZEOF_PTHREAD_CONDATTR_T: u32 = 4;
pub const __SIZEOF_PTHREAD_RWLOCKATTR_T: u32 = 8;
pub const __SIZEOF_PTHREAD_BARRIERATTR_T: u32 = 4;
pub const _THREAD_MUTEX_INTERNAL_H: u32 = 1;
pub const __PTHREAD_MUTEX_HAVE_PREV: u32 = 1;
pub const __have_pthread_attr_t: u32 = 1;
pub const _ALLOCA_H: u32 = 1;
pub const SCIP_PRESOLTIMING_NONE: u32 = 2;
pub const SCIP_PRESOLTIMING_FAST: u32 = 4;
pub const SCIP_PRESOLTIMING_MEDIUM: u32 = 8;
pub const SCIP_PRESOLTIMING_EXHAUSTIVE: u32 = 16;
pub const SCIP_PRESOLTIMING_FINAL: u32 = 32;
pub const SCIP_PRESOLTIMING_ALWAYS: u32 = 28;
pub const SCIP_PRESOLTIMING_MAX: u32 = 60;
pub const SCIP_PROPTIMING_BEFORELP: u32 = 1;
pub const SCIP_PROPTIMING_DURINGLPLOOP: u32 = 2;
pub const SCIP_PROPTIMING_AFTERLPLOOP: u32 = 4;
pub const SCIP_PROPTIMING_AFTERLPNODE: u32 = 8;
pub const SCIP_PROPTIMING_ALWAYS: u32 = 15;
pub const SCIP_HEURTIMING_BEFORENODE: u32 = 1;
pub const SCIP_HEURTIMING_DURINGLPLOOP: u32 = 2;
pub const SCIP_HEURTIMING_AFTERLPLOOP: u32 = 4;
pub const SCIP_HEURTIMING_AFTERLPNODE: u32 = 8;
pub const SCIP_HEURTIMING_AFTERPSEUDONODE: u32 = 16;
pub const SCIP_HEURTIMING_AFTERLPPLUNGE: u32 = 32;
pub const SCIP_HEURTIMING_AFTERPSEUDOPLUNGE: u32 = 64;
pub const SCIP_HEURTIMING_DURINGPRICINGLOOP: u32 = 128;
pub const SCIP_HEURTIMING_BEFOREPRESOL: u32 = 256;
pub const SCIP_HEURTIMING_DURINGPRESOLLOOP: u32 = 512;
pub const SCIP_HEURTIMING_AFTERPROPLOOP: u32 = 1024;
pub const SCIP_HEURTIMING_AFTERNODE: u32 = 24;
pub const SCIP_HEURTIMING_AFTERPLUNGE: u32 = 96;
pub const _INTTYPES_H: u32 = 1;
pub const ____gwchar_t_defined: u32 = 1;
pub const __PRI64_PREFIX: &[u8; 2] = b"l\0";
pub const __PRIPTR_PREFIX: &[u8; 2] = b"l\0";
pub const PRId8: &[u8; 2] = b"d\0";
pub const PRId16: &[u8; 2] = b"d\0";
pub const PRId32: &[u8; 2] = b"d\0";
pub const PRId64: &[u8; 3] = b"ld\0";
pub const PRIdLEAST8: &[u8; 2] = b"d\0";
pub const PRIdLEAST16: &[u8; 2] = b"d\0";
pub const PRIdLEAST32: &[u8; 2] = b"d\0";
pub const PRIdLEAST64: &[u8; 3] = b"ld\0";
pub const PRIdFAST8: &[u8; 2] = b"d\0";
pub const PRIdFAST16: &[u8; 3] = b"ld\0";
pub const PRIdFAST32: &[u8; 3] = b"ld\0";
pub const PRIdFAST64: &[u8; 3] = b"ld\0";
pub const PRIi8: &[u8; 2] = b"i\0";
pub const PRIi16: &[u8; 2] = b"i\0";
pub const PRIi32: &[u8; 2] = b"i\0";
pub const PRIi64: &[u8; 3] = b"li\0";
pub const PRIiLEAST8: &[u8; 2] = b"i\0";
pub const PRIiLEAST16: &[u8; 2] = b"i\0";
pub const PRIiLEAST32: &[u8; 2] = b"i\0";
pub const PRIiLEAST64: &[u8; 3] = b"li\0";
pub const PRIiFAST8: &[u8; 2] = b"i\0";
pub const PRIiFAST16: &[u8; 3] = b"li\0";
pub const PRIiFAST32: &[u8; 3] = b"li\0";
pub const PRIiFAST64: &[u8; 3] = b"li\0";
pub const PRIo8: &[u8; 2] = b"o\0";
pub const PRIo16: &[u8; 2] = b"o\0";
pub const PRIo32: &[u8; 2] = b"o\0";
pub const PRIo64: &[u8; 3] = b"lo\0";
pub const PRIoLEAST8: &[u8; 2] = b"o\0";
pub const PRIoLEAST16: &[u8; 2] = b"o\0";
pub const PRIoLEAST32: &[u8; 2] = b"o\0";
pub const PRIoLEAST64: &[u8; 3] = b"lo\0";
pub const PRIoFAST8: &[u8; 2] = b"o\0";
pub const PRIoFAST16: &[u8; 3] = b"lo\0";
pub const PRIoFAST32: &[u8; 3] = b"lo\0";
pub const PRIoFAST64: &[u8; 3] = b"lo\0";
pub const PRIu8: &[u8; 2] = b"u\0";
pub const PRIu16: &[u8; 2] = b"u\0";
pub const PRIu32: &[u8; 2] = b"u\0";
pub const PRIu64: &[u8; 3] = b"lu\0";
pub const PRIuLEAST8: &[u8; 2] = b"u\0";
pub const PRIuLEAST16: &[u8; 2] = b"u\0";
pub const PRIuLEAST32: &[u8; 2] = b"u\0";
pub const PRIuLEAST64: &[u8; 3] = b"lu\0";
pub const PRIuFAST8: &[u8; 2] = b"u\0";
pub const PRIuFAST16: &[u8; 3] = b"lu\0";
pub const PRIuFAST32: &[u8; 3] = b"lu\0";
pub const PRIuFAST64: &[u8; 3] = b"lu\0";
pub const PRIx8: &[u8; 2] = b"x\0";
pub const PRIx16: &[u8; 2] = b"x\0";
pub const PRIx32: &[u8; 2] = b"x\0";
pub const PRIx64: &[u8; 3] = b"lx\0";
pub const PRIxLEAST8: &[u8; 2] = b"x\0";
pub const PRIxLEAST16: &[u8; 2] = b"x\0";
pub const PRIxLEAST32: &[u8; 2] = b"x\0";
pub const PRIxLEAST64: &[u8; 3] = b"lx\0";
pub const PRIxFAST8: &[u8; 2] = b"x\0";
pub const PRIxFAST16: &[u8; 3] = b"lx\0";
pub const PRIxFAST32: &[u8; 3] = b"lx\0";
pub const PRIxFAST64: &[u8; 3] = b"lx\0";
pub const PRIX8: &[u8; 2] = b"X\0";
pub const PRIX16: &[u8; 2] = b"X\0";
pub const PRIX32: &[u8; 2] = b"X\0";
pub const PRIX64: &[u8; 3] = b"lX\0";
pub const PRIXLEAST8: &[u8; 2] = b"X\0";
pub const PRIXLEAST16: &[u8; 2] = b"X\0";
pub const PRIXLEAST32: &[u8; 2] = b"X\0";
pub const PRIXLEAST64: &[u8; 3] = b"lX\0";
pub const PRIXFAST8: &[u8; 2] = b"X\0";
pub const PRIXFAST16: &[u8; 3] = b"lX\0";
pub const PRIXFAST32: &[u8; 3] = b"lX\0";
pub const PRIXFAST64: &[u8; 3] = b"lX\0";
pub const PRIdMAX: &[u8; 3] = b"ld\0";
pub const PRIiMAX: &[u8; 3] = b"li\0";
pub const PRIoMAX: &[u8; 3] = b"lo\0";
pub const PRIuMAX: &[u8; 3] = b"lu\0";
pub const PRIxMAX: &[u8; 3] = b"lx\0";
pub const PRIXMAX: &[u8; 3] = b"lX\0";
pub const PRIdPTR: &[u8; 3] = b"ld\0";
pub const PRIiPTR: &[u8; 3] = b"li\0";
pub const PRIoPTR: &[u8; 3] = b"lo\0";
pub const PRIuPTR: &[u8; 3] = b"lu\0";
pub const PRIxPTR: &[u8; 3] = b"lx\0";
pub const PRIXPTR: &[u8; 3] = b"lX\0";
pub const SCNd8: &[u8; 4] = b"hhd\0";
pub const SCNd16: &[u8; 3] = b"hd\0";
pub const SCNd32: &[u8; 2] = b"d\0";
pub const SCNd64: &[u8; 3] = b"ld\0";
pub const SCNdLEAST8: &[u8; 4] = b"hhd\0";
pub const SCNdLEAST16: &[u8; 3] = b"hd\0";
pub const SCNdLEAST32: &[u8; 2] = b"d\0";
pub const SCNdLEAST64: &[u8; 3] = b"ld\0";
pub const SCNdFAST8: &[u8; 4] = b"hhd\0";
pub const SCNdFAST16: &[u8; 3] = b"ld\0";
pub const SCNdFAST32: &[u8; 3] = b"ld\0";
pub const SCNdFAST64: &[u8; 3] = b"ld\0";
pub const SCNi8: &[u8; 4] = b"hhi\0";
pub const SCNi16: &[u8; 3] = b"hi\0";
pub const SCNi32: &[u8; 2] = b"i\0";
pub const SCNi64: &[u8; 3] = b"li\0";
pub const SCNiLEAST8: &[u8; 4] = b"hhi\0";
pub const SCNiLEAST16: &[u8; 3] = b"hi\0";
pub const SCNiLEAST32: &[u8; 2] = b"i\0";
pub const SCNiLEAST64: &[u8; 3] = b"li\0";
pub const SCNiFAST8: &[u8; 4] = b"hhi\0";
pub const SCNiFAST16: &[u8; 3] = b"li\0";
pub const SCNiFAST32: &[u8; 3] = b"li\0";
pub const SCNiFAST64: &[u8; 3] = b"li\0";
pub const SCNu8: &[u8; 4] = b"hhu\0";
pub const SCNu16: &[u8; 3] = b"hu\0";
pub const SCNu32: &[u8; 2] = b"u\0";
pub const SCNu64: &[u8; 3] = b"lu\0";
pub const SCNuLEAST8: &[u8; 4] = b"hhu\0";
pub const SCNuLEAST16: &[u8; 3] = b"hu\0";
pub const SCNuLEAST32: &[u8; 2] = b"u\0";
pub const SCNuLEAST64: &[u8; 3] = b"lu\0";
pub const SCNuFAST8: &[u8; 4] = b"hhu\0";
pub const SCNuFAST16: &[u8; 3] = b"lu\0";
pub const SCNuFAST32: &[u8; 3] = b"lu\0";
pub const SCNuFAST64: &[u8; 3] = b"lu\0";
pub const SCNo8: &[u8; 4] = b"hho\0";
pub const SCNo16: &[u8; 3] = b"ho\0";
pub const SCNo32: &[u8; 2] = b"o\0";
pub const SCNo64: &[u8; 3] = b"lo\0";
pub const SCNoLEAST8: &[u8; 4] = b"hho\0";
pub const SCNoLEAST16: &[u8; 3] = b"ho\0";
pub const SCNoLEAST32: &[u8; 2] = b"o\0";
pub const SCNoLEAST64: &[u8; 3] = b"lo\0";
pub const SCNoFAST8: &[u8; 4] = b"hho\0";
pub const SCNoFAST16: &[u8; 3] = b"lo\0";
pub const SCNoFAST32: &[u8; 3] = b"lo\0";
pub const SCNoFAST64: &[u8; 3] = b"lo\0";
pub const SCNx8: &[u8; 4] = b"hhx\0";
pub const SCNx16: &[u8; 3] = b"hx\0";
pub const SCNx32: &[u8; 2] = b"x\0";
pub const SCNx64: &[u8; 3] = b"lx\0";
pub const SCNxLEAST8: &[u8; 4] = b"hhx\0";
pub const SCNxLEAST16: &[u8; 3] = b"hx\0";
pub const SCNxLEAST32: &[u8; 2] = b"x\0";
pub const SCNxLEAST64: &[u8; 3] = b"lx\0";
pub const SCNxFAST8: &[u8; 4] = b"hhx\0";
pub const SCNxFAST16: &[u8; 3] = b"lx\0";
pub const SCNxFAST32: &[u8; 3] = b"lx\0";
pub const SCNxFAST64: &[u8; 3] = b"lx\0";
pub const SCNdMAX: &[u8; 3] = b"ld\0";
pub const SCNiMAX: &[u8; 3] = b"li\0";
pub const SCNoMAX: &[u8; 3] = b"lo\0";
pub const SCNuMAX: &[u8; 3] = b"lu\0";
pub const SCNxMAX: &[u8; 3] = b"lx\0";
pub const SCNdPTR: &[u8; 3] = b"ld\0";
pub const SCNiPTR: &[u8; 3] = b"li\0";
pub const SCNoPTR: &[u8; 3] = b"lo\0";
pub const SCNuPTR: &[u8; 3] = b"lu\0";
pub const SCNxPTR: &[u8; 3] = b"lx\0";
pub const SCIP_EVENTTYPE_FORMAT: &[u8; 3] = b"lx\0";
pub const NLOCKTYPES: u32 = 2;
pub const SCIP_DIVETYPE_NONE: u32 = 0;
pub const SCIP_DIVETYPE_INTEGRALITY: u32 = 1;
pub const SCIP_DIVETYPE_SOS1VARIABLE: u32 = 2;
pub const SCIP_HEURDISPCHAR_LNS: u8 = 76u8;
pub const SCIP_HEURDISPCHAR_DIVING: u8 = 100u8;
pub const SCIP_HEURDISPCHAR_ITERATIVE: u8 = 105u8;
pub const SCIP_HEURDISPCHAR_OBJDIVING: u8 = 111u8;
pub const SCIP_HEURDISPCHAR_PROP: u8 = 112u8;
pub const SCIP_HEURDISPCHAR_ROUNDING: u8 = 114u8;
pub const SCIP_HEURDISPCHAR_TRIVIAL: u8 = 116u8;
pub const SCIP_EXPR_MAXINITESTIMATES: u32 = 10;
pub const SCIP_EXPRITER_MAXNACTIVE: u32 = 5;
pub const SCIP_EXPRITER_ENTEREXPR: u32 = 1;
pub const SCIP_EXPRITER_VISITINGCHILD: u32 = 2;
pub const SCIP_EXPRITER_VISITEDCHILD: u32 = 4;
pub const SCIP_EXPRITER_LEAVEEXPR: u32 = 8;
pub const SCIP_EXPRITER_ALLSTAGES: u32 = 15;
pub const SCIP_EXPRPRINT_EXPRSTRING: u32 = 1;
pub const SCIP_EXPRPRINT_EXPRHDLR: u32 = 2;
pub const SCIP_EXPRPRINT_NUSES: u32 = 4;
pub const SCIP_EXPRPRINT_EVALVALUE: u32 = 8;
pub const SCIP_EXPRPRINT_EVALTAG: u32 = 24;
pub const SCIP_EXPRPRINT_ACTIVITY: u32 = 32;
pub const SCIP_EXPRPRINT_ACTIVITYTAG: u32 = 96;
pub const SCIP_EXPRPRINT_OWNER: u32 = 128;
pub const SCIP_EXPRPRINT_ALL: u32 = 255;
pub const SCIP_NLPPARAM_DEFAULT_VERBLEVEL: u32 = 0;
pub const SCIP_DECOMP_LINKVAR: i32 = -1;
pub const SCIP_DECOMP_LINKCONS: i32 = -2;
pub const _STRING_H: u32 = 1;
pub const _BITS_TYPES_LOCALE_T_H: u32 = 1;
pub const _BITS_TYPES___LOCALE_T_H: u32 = 1;
pub const _STRINGS_H: u32 = 1;
pub const QUAD_EPSILON: f64 = 0.000000000001;
pub const SCIP_NLHDLR_METHOD_NONE: u32 = 0;
pub const SCIP_NLHDLR_METHOD_SEPABELOW: u32 = 1;
pub const SCIP_NLHDLR_METHOD_SEPAABOVE: u32 = 2;
pub const SCIP_NLHDLR_METHOD_SEPABOTH: u32 = 3;
pub const SCIP_NLHDLR_METHOD_ACTIVITY: u32 = 4;
pub const SCIP_NLHDLR_METHOD_ALL: u32 = 7;
pub const SCIP_MAXVERTEXPOLYDIM: u32 = 14;
pub const SYM_COMPUTETIMING_BEFOREPRESOL: u32 = 0;
pub const SYM_COMPUTETIMING_DURINGPRESOL: u32 = 1;
pub const SYM_COMPUTETIMING_AFTERPRESOL: u32 = 2;
pub const ARTIFICIALVARNAMEPREFIX: &[u8; 14] = b"andresultant_\0";
pub type __gnuc_va_list = __builtin_va_list;
pub type __u_char = ::std::os::raw::c_uchar;
pub type __u_short = ::std::os::raw::c_ushort;
pub type __u_int = ::std::os::raw::c_uint;
pub type __u_long = ::std::os::raw::c_ulong;
pub type __int8_t = ::std::os::raw::c_schar;
pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __int16_t = ::std::os::raw::c_short;
pub type __uint16_t = ::std::os::raw::c_ushort;
pub type __int32_t = ::std::os::raw::c_int;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __int64_t = ::std::os::raw::c_long;
pub type __uint64_t = ::std::os::raw::c_ulong;
pub type __int_least8_t = __int8_t;
pub type __uint_least8_t = __uint8_t;
pub type __int_least16_t = __int16_t;
pub type __uint_least16_t = __uint16_t;
pub type __int_least32_t = __int32_t;
pub type __uint_least32_t = __uint32_t;
pub type __int_least64_t = __int64_t;
pub type __uint_least64_t = __uint64_t;
pub type __quad_t = ::std::os::raw::c_long;
pub type __u_quad_t = ::std::os::raw::c_ulong;
pub type __intmax_t = ::std::os::raw::c_long;
pub type __uintmax_t = ::std::os::raw::c_ulong;
pub type __dev_t = ::std::os::raw::c_ulong;
pub type __uid_t = ::std::os::raw::c_uint;
pub type __gid_t = ::std::os::raw::c_uint;
pub type __ino_t = ::std::os::raw::c_ulong;
pub type __ino64_t = ::std::os::raw::c_ulong;
pub type __mode_t = ::std::os::raw::c_uint;
pub type __nlink_t = ::std::os::raw::c_ulong;
pub type __off_t = ::std::os::raw::c_long;
pub type __off64_t = ::std::os::raw::c_long;
pub type __pid_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __fsid_t {
    pub __val: [::std::os::raw::c_int; 2usize],
}
#[test]
fn bindgen_test_layout___fsid_t() {
    const UNINIT: ::std::mem::MaybeUninit<__fsid_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__fsid_t>(),
        8usize,
        concat!("Size of: ", stringify!(__fsid_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__fsid_t>(),
        4usize,
        concat!("Alignment of ", stringify!(__fsid_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__val) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__fsid_t),
            "::",
            stringify!(__val)
        )
    );
}
pub type __clock_t = ::std::os::raw::c_long;
pub type __rlim_t = ::std::os::raw::c_ulong;
pub type __rlim64_t = ::std::os::raw::c_ulong;
pub type __id_t = ::std::os::raw::c_uint;
pub type __time_t = ::std::os::raw::c_long;
pub type __useconds_t = ::std::os::raw::c_uint;
pub type __suseconds_t = ::std::os::raw::c_long;
pub type __suseconds64_t = ::std::os::raw::c_long;
pub type __daddr_t = ::std::os::raw::c_int;
pub type __key_t = ::std::os::raw::c_int;
pub type __clockid_t = ::std::os::raw::c_int;
pub type __timer_t = *mut ::std::os::raw::c_void;
pub type __blksize_t = ::std::os::raw::c_long;
pub type __blkcnt_t = ::std::os::raw::c_long;
pub type __blkcnt64_t = ::std::os::raw::c_long;
pub type __fsblkcnt_t = ::std::os::raw::c_ulong;
pub type __fsblkcnt64_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt64_t = ::std::os::raw::c_ulong;
pub type __fsword_t = ::std::os::raw::c_long;
pub type __ssize_t = ::std::os::raw::c_long;
pub type __syscall_slong_t = ::std::os::raw::c_long;
pub type __syscall_ulong_t = ::std::os::raw::c_ulong;
pub type __loff_t = __off64_t;
pub type __caddr_t = *mut ::std::os::raw::c_char;
pub type __intptr_t = ::std::os::raw::c_long;
pub type __socklen_t = ::std::os::raw::c_uint;
pub type __sig_atomic_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __mbstate_t {
    pub __count: ::std::os::raw::c_int,
    pub __value: __mbstate_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union __mbstate_t__bindgen_ty_1 {
    pub __wch: ::std::os::raw::c_uint,
    pub __wchb: [::std::os::raw::c_char; 4usize],
}
#[test]
fn bindgen_test_layout___mbstate_t__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<__mbstate_t__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__mbstate_t__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(__mbstate_t__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<__mbstate_t__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(__mbstate_t__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__wch) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t__bindgen_ty_1),
            "::",
            stringify!(__wch)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__wchb) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t__bindgen_ty_1),
            "::",
            stringify!(__wchb)
        )
    );
}
#[test]
fn bindgen_test_layout___mbstate_t() {
    const UNINIT: ::std::mem::MaybeUninit<__mbstate_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__mbstate_t>(),
        8usize,
        concat!("Size of: ", stringify!(__mbstate_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__mbstate_t>(),
        4usize,
        concat!("Alignment of ", stringify!(__mbstate_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__count) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t),
            "::",
            stringify!(__count)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__value) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t),
            "::",
            stringify!(__value)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _G_fpos_t {
    pub __pos: __off_t,
    pub __state: __mbstate_t,
}
#[test]
fn bindgen_test_layout__G_fpos_t() {
    const UNINIT: ::std::mem::MaybeUninit<_G_fpos_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_G_fpos_t>(),
        16usize,
        concat!("Size of: ", stringify!(_G_fpos_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_G_fpos_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_G_fpos_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__pos) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_G_fpos_t),
            "::",
            stringify!(__pos)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__state) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_G_fpos_t),
            "::",
            stringify!(__state)
        )
    );
}
pub type __fpos_t = _G_fpos_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _G_fpos64_t {
    pub __pos: __off64_t,
    pub __state: __mbstate_t,
}
#[test]
fn bindgen_test_layout__G_fpos64_t() {
    const UNINIT: ::std::mem::MaybeUninit<_G_fpos64_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_G_fpos64_t>(),
        16usize,
        concat!("Size of: ", stringify!(_G_fpos64_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_G_fpos64_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_G_fpos64_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__pos) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_G_fpos64_t),
            "::",
            stringify!(__pos)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__state) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_G_fpos64_t),
            "::",
            stringify!(__state)
        )
    );
}
pub type __fpos64_t = _G_fpos64_t;
pub type __FILE = _IO_FILE;
pub type FILE = _IO_FILE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_marker {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_codecvt {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_wide_data {
    _unused: [u8; 0],
}
pub type _IO_lock_t = ::std::os::raw::c_void;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_FILE {
    pub _flags: ::std::os::raw::c_int,
    pub _IO_read_ptr: *mut ::std::os::raw::c_char,
    pub _IO_read_end: *mut ::std::os::raw::c_char,
    pub _IO_read_base: *mut ::std::os::raw::c_char,
    pub _IO_write_base: *mut ::std::os::raw::c_char,
    pub _IO_write_ptr: *mut ::std::os::raw::c_char,
    pub _IO_write_end: *mut ::std::os::raw::c_char,
    pub _IO_buf_base: *mut ::std::os::raw::c_char,
    pub _IO_buf_end: *mut ::std::os::raw::c_char,
    pub _IO_save_base: *mut ::std::os::raw::c_char,
    pub _IO_backup_base: *mut ::std::os::raw::c_char,
    pub _IO_save_end: *mut ::std::os::raw::c_char,
    pub _markers: *mut _IO_marker,
    pub _chain: *mut _IO_FILE,
    pub _fileno: ::std::os::raw::c_int,
    pub _flags2: ::std::os::raw::c_int,
    pub _old_offset: __off_t,
    pub _cur_column: ::std::os::raw::c_ushort,
    pub _vtable_offset: ::std::os::raw::c_schar,
    pub _shortbuf: [::std::os::raw::c_char; 1usize],
    pub _lock: *mut _IO_lock_t,
    pub _offset: __off64_t,
    pub _codecvt: *mut _IO_codecvt,
    pub _wide_data: *mut _IO_wide_data,
    pub _freeres_list: *mut _IO_FILE,
    pub _freeres_buf: *mut ::std::os::raw::c_void,
    pub __pad5: usize,
    pub _mode: ::std::os::raw::c_int,
    pub _unused2: [::std::os::raw::c_char; 20usize],
}
#[test]
fn bindgen_test_layout__IO_FILE() {
    const UNINIT: ::std::mem::MaybeUninit<_IO_FILE> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_IO_FILE>(),
        216usize,
        concat!("Size of: ", stringify!(_IO_FILE))
    );
    assert_eq!(
        ::std::mem::align_of::<_IO_FILE>(),
        8usize,
        concat!("Alignment of ", stringify!(_IO_FILE))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._flags) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._IO_read_ptr) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_read_ptr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._IO_read_end) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_read_end)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._IO_read_base) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_read_base)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._IO_write_base) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_write_base)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._IO_write_ptr) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_write_ptr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._IO_write_end) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_write_end)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._IO_buf_base) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_buf_base)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._IO_buf_end) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_buf_end)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._IO_save_base) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_save_base)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._IO_backup_base) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_backup_base)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._IO_save_end) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_save_end)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._markers) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_markers)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._chain) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_chain)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._fileno) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_fileno)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._flags2) as usize - ptr as usize },
        116usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_flags2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._old_offset) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_old_offset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._cur_column) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_cur_column)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._vtable_offset) as usize - ptr as usize },
        130usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_vtable_offset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._shortbuf) as usize - ptr as usize },
        131usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_shortbuf)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._lock) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_lock)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._offset) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_offset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._codecvt) as usize - ptr as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_codecvt)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._wide_data) as usize - ptr as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_wide_data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._freeres_list) as usize - ptr as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_freeres_list)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._freeres_buf) as usize - ptr as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_freeres_buf)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__pad5) as usize - ptr as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(__pad5)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._mode) as usize - ptr as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_mode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._unused2) as usize - ptr as usize },
        196usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_unused2)
        )
    );
}
pub type cookie_read_function_t = ::std::option::Option<
    unsafe extern "C" fn(
        __cookie: *mut ::std::os::raw::c_void,
        __buf: *mut ::std::os::raw::c_char,
        __nbytes: usize,
    ) -> __ssize_t,
>;
pub type cookie_write_function_t = ::std::option::Option<
    unsafe extern "C" fn(
        __cookie: *mut ::std::os::raw::c_void,
        __buf: *const ::std::os::raw::c_char,
        __nbytes: usize,
    ) -> __ssize_t,
>;
pub type cookie_seek_function_t = ::std::option::Option<
    unsafe extern "C" fn(
        __cookie: *mut ::std::os::raw::c_void,
        __pos: *mut __off64_t,
        __w: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int,
>;
pub type cookie_close_function_t = ::std::option::Option<
    unsafe extern "C" fn(__cookie: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_cookie_io_functions_t {
    pub read: cookie_read_function_t,
    pub write: cookie_write_function_t,
    pub seek: cookie_seek_function_t,
    pub close: cookie_close_function_t,
}
#[test]
fn bindgen_test_layout__IO_cookie_io_functions_t() {
    const UNINIT: ::std::mem::MaybeUninit<_IO_cookie_io_functions_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_IO_cookie_io_functions_t>(),
        32usize,
        concat!("Size of: ", stringify!(_IO_cookie_io_functions_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_IO_cookie_io_functions_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_IO_cookie_io_functions_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).read) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_cookie_io_functions_t),
            "::",
            stringify!(read)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).write) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_cookie_io_functions_t),
            "::",
            stringify!(write)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).seek) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_cookie_io_functions_t),
            "::",
            stringify!(seek)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).close) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_cookie_io_functions_t),
            "::",
            stringify!(close)
        )
    );
}
pub type cookie_io_functions_t = _IO_cookie_io_functions_t;
pub type va_list = __gnuc_va_list;
pub type off_t = __off_t;
pub type fpos_t = __fpos_t;
extern "C" {
    pub static mut stdin: *mut FILE;
}
extern "C" {
    pub static mut stdout: *mut FILE;
}
extern "C" {
    pub static mut stderr: *mut FILE;
}
extern "C" {
    pub fn remove(__filename: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rename(
        __old: *const ::std::os::raw::c_char,
        __new: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn renameat(
        __oldfd: ::std::os::raw::c_int,
        __old: *const ::std::os::raw::c_char,
        __newfd: ::std::os::raw::c_int,
        __new: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fclose(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn tmpfile() -> *mut FILE;
}
extern "C" {
    pub fn tmpnam(arg1: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn tmpnam_r(__s: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn tempnam(
        __dir: *const ::std::os::raw::c_char,
        __pfx: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn fflush(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fflush_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fopen(
        __filename: *const ::std::os::raw::c_char,
        __modes: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn freopen(
        __filename: *const ::std::os::raw::c_char,
        __modes: *const ::std::os::raw::c_char,
        __stream: *mut FILE,
    ) -> *mut FILE;
}
extern "C" {
    pub fn fdopen(__fd: ::std::os::raw::c_int, __modes: *const ::std::os::raw::c_char)
        -> *mut FILE;
}
extern "C" {
    pub fn fopencookie(
        __magic_cookie: *mut ::std::os::raw::c_void,
        __modes: *const ::std::os::raw::c_char,
        __io_funcs: cookie_io_functions_t,
    ) -> *mut FILE;
}
extern "C" {
    pub fn fmemopen(
        __s: *mut ::std::os::raw::c_void,
        __len: usize,
        __modes: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn open_memstream(
        __bufloc: *mut *mut ::std::os::raw::c_char,
        __sizeloc: *mut usize,
    ) -> *mut FILE;
}
extern "C" {
    pub fn setbuf(__stream: *mut FILE, __buf: *mut ::std::os::raw::c_char);
}
extern "C" {
    pub fn setvbuf(
        __stream: *mut FILE,
        __buf: *mut ::std::os::raw::c_char,
        __modes: ::std::os::raw::c_int,
        __n: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setbuffer(__stream: *mut FILE, __buf: *mut ::std::os::raw::c_char, __size: usize);
}
extern "C" {
    pub fn setlinebuf(__stream: *mut FILE);
}
extern "C" {
    pub fn fprintf(
        __stream: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn printf(__format: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sprintf(
        __s: *mut ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vfprintf(
        __s: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vprintf(
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vsprintf(
        __s: *mut ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn snprintf(
        __s: *mut ::std::os::raw::c_char,
        __maxlen: ::std::os::raw::c_ulong,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vsnprintf(
        __s: *mut ::std::os::raw::c_char,
        __maxlen: ::std::os::raw::c_ulong,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vasprintf(
        __ptr: *mut *mut ::std::os::raw::c_char,
        __f: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __asprintf(
        __ptr: *mut *mut ::std::os::raw::c_char,
        __fmt: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn asprintf(
        __ptr: *mut *mut ::std::os::raw::c_char,
        __fmt: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vdprintf(
        __fd: ::std::os::raw::c_int,
        __fmt: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn dprintf(
        __fd: ::std::os::raw::c_int,
        __fmt: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fscanf(
        __stream: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn scanf(__format: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sscanf(
        __s: *const ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
pub type _Float32 = f32;
pub type _Float64 = f64;
pub type _Float32x = f64;
pub type _Float64x = u128;
extern "C" {
    #[link_name = "\u{1}__isoc99_fscanf"]
    pub fn fscanf1(
        __stream: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_scanf"]
    pub fn scanf1(__format: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_sscanf"]
    pub fn sscanf1(
        __s: *const ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vfscanf(
        __s: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vscanf(
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vsscanf(
        __s: *const ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_vfscanf"]
    pub fn vfscanf1(
        __s: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_vscanf"]
    pub fn vscanf1(
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_vsscanf"]
    pub fn vsscanf1(
        __s: *const ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgetc(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getc(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getchar() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getc_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getchar_unlocked() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgetc_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fputc(__c: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putc(__c: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putchar(__c: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fputc_unlocked(__c: ::std::os::raw::c_int, __stream: *mut FILE)
        -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putc_unlocked(__c: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putchar_unlocked(__c: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getw(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putw(__w: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgets(
        __s: *mut ::std::os::raw::c_char,
        __n: ::std::os::raw::c_int,
        __stream: *mut FILE,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn __getdelim(
        __lineptr: *mut *mut ::std::os::raw::c_char,
        __n: *mut usize,
        __delimiter: ::std::os::raw::c_int,
        __stream: *mut FILE,
    ) -> __ssize_t;
}
extern "C" {
    pub fn getdelim(
        __lineptr: *mut *mut ::std::os::raw::c_char,
        __n: *mut usize,
        __delimiter: ::std::os::raw::c_int,
        __stream: *mut FILE,
    ) -> __ssize_t;
}
extern "C" {
    pub fn getline(
        __lineptr: *mut *mut ::std::os::raw::c_char,
        __n: *mut usize,
        __stream: *mut FILE,
    ) -> __ssize_t;
}
extern "C" {
    pub fn fputs(__s: *const ::std::os::raw::c_char, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn puts(__s: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ungetc(__c: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fread(
        __ptr: *mut ::std::os::raw::c_void,
        __size: ::std::os::raw::c_ulong,
        __n: ::std::os::raw::c_ulong,
        __stream: *mut FILE,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn fwrite(
        __ptr: *const ::std::os::raw::c_void,
        __size: ::std::os::raw::c_ulong,
        __n: ::std::os::raw::c_ulong,
        __s: *mut FILE,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn fread_unlocked(
        __ptr: *mut ::std::os::raw::c_void,
        __size: usize,
        __n: usize,
        __stream: *mut FILE,
    ) -> usize;
}
extern "C" {
    pub fn fwrite_unlocked(
        __ptr: *const ::std::os::raw::c_void,
        __size: usize,
        __n: usize,
        __stream: *mut FILE,
    ) -> usize;
}
extern "C" {
    pub fn fseek(
        __stream: *mut FILE,
        __off: ::std::os::raw::c_long,
        __whence: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ftell(__stream: *mut FILE) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn rewind(__stream: *mut FILE);
}
extern "C" {
    pub fn fseeko(
        __stream: *mut FILE,
        __off: __off_t,
        __whence: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ftello(__stream: *mut FILE) -> __off_t;
}
extern "C" {
    pub fn fgetpos(__stream: *mut FILE, __pos: *mut fpos_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fsetpos(__stream: *mut FILE, __pos: *const fpos_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clearerr(__stream: *mut FILE);
}
extern "C" {
    pub fn feof(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ferror(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clearerr_unlocked(__stream: *mut FILE);
}
extern "C" {
    pub fn feof_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ferror_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn perror(__s: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn fileno(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fileno_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pclose(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn popen(
        __command: *const ::std::os::raw::c_char,
        __modes: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn ctermid(__s: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn flockfile(__stream: *mut FILE);
}
extern "C" {
    pub fn ftrylockfile(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn funlockfile(__stream: *mut FILE);
}
extern "C" {
    pub fn __uflow(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __overflow(arg1: *mut FILE, arg2: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
pub type int_least8_t = __int_least8_t;
pub type int_least16_t = __int_least16_t;
pub type int_least32_t = __int_least32_t;
pub type int_least64_t = __int_least64_t;
pub type uint_least8_t = __uint_least8_t;
pub type uint_least16_t = __uint_least16_t;
pub type uint_least32_t = __uint_least32_t;
pub type uint_least64_t = __uint_least64_t;
pub type int_fast8_t = ::std::os::raw::c_schar;
pub type int_fast16_t = ::std::os::raw::c_long;
pub type int_fast32_t = ::std::os::raw::c_long;
pub type int_fast64_t = ::std::os::raw::c_long;
pub type uint_fast8_t = ::std::os::raw::c_uchar;
pub type uint_fast16_t = ::std::os::raw::c_ulong;
pub type uint_fast32_t = ::std::os::raw::c_ulong;
pub type uint_fast64_t = ::std::os::raw::c_ulong;
pub type intmax_t = __intmax_t;
pub type uintmax_t = __uintmax_t;
pub type float_t = f32;
pub type double_t = f64;
extern "C" {
    pub fn __fpclassify(__value: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __signbit(__value: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __isinf(__value: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __finite(__value: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __isnan(__value: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __iseqsig(__x: f64, __y: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __issignaling(__value: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn acos(__x: f64) -> f64;
}
extern "C" {
    pub fn __acos(__x: f64) -> f64;
}
extern "C" {
    pub fn asin(__x: f64) -> f64;
}
extern "C" {
    pub fn __asin(__x: f64) -> f64;
}
extern "C" {
    pub fn atan(__x: f64) -> f64;
}
extern "C" {
    pub fn __atan(__x: f64) -> f64;
}
extern "C" {
    pub fn atan2(__y: f64, __x: f64) -> f64;
}
extern "C" {
    pub fn __atan2(__y: f64, __x: f64) -> f64;
}
extern "C" {
    pub fn cos(__x: f64) -> f64;
}
extern "C" {
    pub fn __cos(__x: f64) -> f64;
}
extern "C" {
    pub fn sin(__x: f64) -> f64;
}
extern "C" {
    pub fn __sin(__x: f64) -> f64;
}
extern "C" {
    pub fn tan(__x: f64) -> f64;
}
extern "C" {
    pub fn __tan(__x: f64) -> f64;
}
extern "C" {
    pub fn cosh(__x: f64) -> f64;
}
extern "C" {
    pub fn __cosh(__x: f64) -> f64;
}
extern "C" {
    pub fn sinh(__x: f64) -> f64;
}
extern "C" {
    pub fn __sinh(__x: f64) -> f64;
}
extern "C" {
    pub fn tanh(__x: f64) -> f64;
}
extern "C" {
    pub fn __tanh(__x: f64) -> f64;
}
extern "C" {
    pub fn acosh(__x: f64) -> f64;
}
extern "C" {
    pub fn __acosh(__x: f64) -> f64;
}
extern "C" {
    pub fn asinh(__x: f64) -> f64;
}
extern "C" {
    pub fn __asinh(__x: f64) -> f64;
}
extern "C" {
    pub fn atanh(__x: f64) -> f64;
}
extern "C" {
    pub fn __atanh(__x: f64) -> f64;
}
extern "C" {
    pub fn exp(__x: f64) -> f64;
}
extern "C" {
    pub fn __exp(__x: f64) -> f64;
}
extern "C" {
    pub fn frexp(__x: f64, __exponent: *mut ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn __frexp(__x: f64, __exponent: *mut ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn ldexp(__x: f64, __exponent: ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn __ldexp(__x: f64, __exponent: ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn log(__x: f64) -> f64;
}
extern "C" {
    pub fn __log(__x: f64) -> f64;
}
extern "C" {
    pub fn log10(__x: f64) -> f64;
}
extern "C" {
    pub fn __log10(__x: f64) -> f64;
}
extern "C" {
    pub fn modf(__x: f64, __iptr: *mut f64) -> f64;
}
extern "C" {
    pub fn __modf(__x: f64, __iptr: *mut f64) -> f64;
}
extern "C" {
    pub fn expm1(__x: f64) -> f64;
}
extern "C" {
    pub fn __expm1(__x: f64) -> f64;
}
extern "C" {
    pub fn log1p(__x: f64) -> f64;
}
extern "C" {
    pub fn __log1p(__x: f64) -> f64;
}
extern "C" {
    pub fn logb(__x: f64) -> f64;
}
extern "C" {
    pub fn __logb(__x: f64) -> f64;
}
extern "C" {
    pub fn exp2(__x: f64) -> f64;
}
extern "C" {
    pub fn __exp2(__x: f64) -> f64;
}
extern "C" {
    pub fn log2(__x: f64) -> f64;
}
extern "C" {
    pub fn __log2(__x: f64) -> f64;
}
extern "C" {
    pub fn pow(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __pow(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn sqrt(__x: f64) -> f64;
}
extern "C" {
    pub fn __sqrt(__x: f64) -> f64;
}
extern "C" {
    pub fn hypot(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __hypot(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn cbrt(__x: f64) -> f64;
}
extern "C" {
    pub fn __cbrt(__x: f64) -> f64;
}
extern "C" {
    pub fn ceil(__x: f64) -> f64;
}
extern "C" {
    pub fn __ceil(__x: f64) -> f64;
}
extern "C" {
    pub fn fabs(__x: f64) -> f64;
}
extern "C" {
    pub fn __fabs(__x: f64) -> f64;
}
extern "C" {
    pub fn floor(__x: f64) -> f64;
}
extern "C" {
    pub fn __floor(__x: f64) -> f64;
}
extern "C" {
    pub fn fmod(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __fmod(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn isinf(__value: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn finite(__value: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn drem(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __drem(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn significand(__x: f64) -> f64;
}
extern "C" {
    pub fn __significand(__x: f64) -> f64;
}
extern "C" {
    pub fn copysign(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __copysign(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn nan(__tagb: *const ::std::os::raw::c_char) -> f64;
}
extern "C" {
    pub fn __nan(__tagb: *const ::std::os::raw::c_char) -> f64;
}
extern "C" {
    pub fn isnan(__value: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn j0(arg1: f64) -> f64;
}
extern "C" {
    pub fn __j0(arg1: f64) -> f64;
}
extern "C" {
    pub fn j1(arg1: f64) -> f64;
}
extern "C" {
    pub fn __j1(arg1: f64) -> f64;
}
extern "C" {
    pub fn jn(arg1: ::std::os::raw::c_int, arg2: f64) -> f64;
}
extern "C" {
    pub fn __jn(arg1: ::std::os::raw::c_int, arg2: f64) -> f64;
}
extern "C" {
    pub fn y0(arg1: f64) -> f64;
}
extern "C" {
    pub fn __y0(arg1: f64) -> f64;
}
extern "C" {
    pub fn y1(arg1: f64) -> f64;
}
extern "C" {
    pub fn __y1(arg1: f64) -> f64;
}
extern "C" {
    pub fn yn(arg1: ::std::os::raw::c_int, arg2: f64) -> f64;
}
extern "C" {
    pub fn __yn(arg1: ::std::os::raw::c_int, arg2: f64) -> f64;
}
extern "C" {
    pub fn erf(arg1: f64) -> f64;
}
extern "C" {
    pub fn __erf(arg1: f64) -> f64;
}
extern "C" {
    pub fn erfc(arg1: f64) -> f64;
}
extern "C" {
    pub fn __erfc(arg1: f64) -> f64;
}
extern "C" {
    pub fn lgamma(arg1: f64) -> f64;
}
extern "C" {
    pub fn __lgamma(arg1: f64) -> f64;
}
extern "C" {
    pub fn tgamma(arg1: f64) -> f64;
}
extern "C" {
    pub fn __tgamma(arg1: f64) -> f64;
}
extern "C" {
    pub fn gamma(arg1: f64) -> f64;
}
extern "C" {
    pub fn __gamma(arg1: f64) -> f64;
}
extern "C" {
    pub fn lgamma_r(arg1: f64, __signgamp: *mut ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn __lgamma_r(arg1: f64, __signgamp: *mut ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn rint(__x: f64) -> f64;
}
extern "C" {
    pub fn __rint(__x: f64) -> f64;
}
extern "C" {
    pub fn nextafter(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __nextafter(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn nexttoward(__x: f64, __y: u128) -> f64;
}
extern "C" {
    pub fn __nexttoward(__x: f64, __y: u128) -> f64;
}
extern "C" {
    pub fn remainder(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __remainder(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn scalbn(__x: f64, __n: ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn __scalbn(__x: f64, __n: ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn ilogb(__x: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __ilogb(__x: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn scalbln(__x: f64, __n: ::std::os::raw::c_long) -> f64;
}
extern "C" {
    pub fn __scalbln(__x: f64, __n: ::std::os::raw::c_long) -> f64;
}
extern "C" {
    pub fn nearbyint(__x: f64) -> f64;
}
extern "C" {
    pub fn __nearbyint(__x: f64) -> f64;
}
extern "C" {
    pub fn round(__x: f64) -> f64;
}
extern "C" {
    pub fn __round(__x: f64) -> f64;
}
extern "C" {
    pub fn trunc(__x: f64) -> f64;
}
extern "C" {
    pub fn __trunc(__x: f64) -> f64;
}
extern "C" {
    pub fn remquo(__x: f64, __y: f64, __quo: *mut ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn __remquo(__x: f64, __y: f64, __quo: *mut ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn lrint(__x: f64) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn __lrint(__x: f64) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn llrint(__x: f64) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn __llrint(__x: f64) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn lround(__x: f64) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn __lround(__x: f64) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn llround(__x: f64) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn __llround(__x: f64) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn fdim(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __fdim(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn fmax(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __fmax(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn fmin(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __fmin(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn fma(__x: f64, __y: f64, __z: f64) -> f64;
}
extern "C" {
    pub fn __fma(__x: f64, __y: f64, __z: f64) -> f64;
}
extern "C" {
    pub fn scalb(__x: f64, __n: f64) -> f64;
}
extern "C" {
    pub fn __scalb(__x: f64, __n: f64) -> f64;
}
extern "C" {
    pub fn __fpclassifyf(__value: f32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __signbitf(__value: f32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __isinff(__value: f32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __finitef(__value: f32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __isnanf(__value: f32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __iseqsigf(__x: f32, __y: f32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __issignalingf(__value: f32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn acosf(__x: f32) -> f32;
}
extern "C" {
    pub fn __acosf(__x: f32) -> f32;
}
extern "C" {
    pub fn asinf(__x: f32) -> f32;
}
extern "C" {
    pub fn __asinf(__x: f32) -> f32;
}
extern "C" {
    pub fn atanf(__x: f32) -> f32;
}
extern "C" {
    pub fn __atanf(__x: f32) -> f32;
}
extern "C" {
    pub fn atan2f(__y: f32, __x: f32) -> f32;
}
extern "C" {
    pub fn __atan2f(__y: f32, __x: f32) -> f32;
}
extern "C" {
    pub fn cosf(__x: f32) -> f32;
}
extern "C" {
    pub fn __cosf(__x: f32) -> f32;
}
extern "C" {
    pub fn sinf(__x: f32) -> f32;
}
extern "C" {
    pub fn __sinf(__x: f32) -> f32;
}
extern "C" {
    pub fn tanf(__x: f32) -> f32;
}
extern "C" {
    pub fn __tanf(__x: f32) -> f32;
}
extern "C" {
    pub fn coshf(__x: f32) -> f32;
}
extern "C" {
    pub fn __coshf(__x: f32) -> f32;
}
extern "C" {
    pub fn sinhf(__x: f32) -> f32;
}
extern "C" {
    pub fn __sinhf(__x: f32) -> f32;
}
extern "C" {
    pub fn tanhf(__x: f32) -> f32;
}
extern "C" {
    pub fn __tanhf(__x: f32) -> f32;
}
extern "C" {
    pub fn acoshf(__x: f32) -> f32;
}
extern "C" {
    pub fn __acoshf(__x: f32) -> f32;
}
extern "C" {
    pub fn asinhf(__x: f32) -> f32;
}
extern "C" {
    pub fn __asinhf(__x: f32) -> f32;
}
extern "C" {
    pub fn atanhf(__x: f32) -> f32;
}
extern "C" {
    pub fn __atanhf(__x: f32) -> f32;
}
extern "C" {
    pub fn expf(__x: f32) -> f32;
}
extern "C" {
    pub fn __expf(__x: f32) -> f32;
}
extern "C" {
    pub fn frexpf(__x: f32, __exponent: *mut ::std::os::raw::c_int) -> f32;
}
extern "C" {
    pub fn __frexpf(__x: f32, __exponent: *mut ::std::os::raw::c_int) -> f32;
}
extern "C" {
    pub fn ldexpf(__x: f32, __exponent: ::std::os::raw::c_int) -> f32;
}
extern "C" {
    pub fn __ldexpf(__x: f32, __exponent: ::std::os::raw::c_int) -> f32;
}
extern "C" {
    pub fn logf(__x: f32) -> f32;
}
extern "C" {
    pub fn __logf(__x: f32) -> f32;
}
extern "C" {
    pub fn log10f(__x: f32) -> f32;
}
extern "C" {
    pub fn __log10f(__x: f32) -> f32;
}
extern "C" {
    pub fn modff(__x: f32, __iptr: *mut f32) -> f32;
}
extern "C" {
    pub fn __modff(__x: f32, __iptr: *mut f32) -> f32;
}
extern "C" {
    pub fn expm1f(__x: f32) -> f32;
}
extern "C" {
    pub fn __expm1f(__x: f32) -> f32;
}
extern "C" {
    pub fn log1pf(__x: f32) -> f32;
}
extern "C" {
    pub fn __log1pf(__x: f32) -> f32;
}
extern "C" {
    pub fn logbf(__x: f32) -> f32;
}
extern "C" {
    pub fn __logbf(__x: f32) -> f32;
}
extern "C" {
    pub fn exp2f(__x: f32) -> f32;
}
extern "C" {
    pub fn __exp2f(__x: f32) -> f32;
}
extern "C" {
    pub fn log2f(__x: f32) -> f32;
}
extern "C" {
    pub fn __log2f(__x: f32) -> f32;
}
extern "C" {
    pub fn powf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn __powf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn sqrtf(__x: f32) -> f32;
}
extern "C" {
    pub fn __sqrtf(__x: f32) -> f32;
}
extern "C" {
    pub fn hypotf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn __hypotf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn cbrtf(__x: f32) -> f32;
}
extern "C" {
    pub fn __cbrtf(__x: f32) -> f32;
}
extern "C" {
    pub fn ceilf(__x: f32) -> f32;
}
extern "C" {
    pub fn __ceilf(__x: f32) -> f32;
}
extern "C" {
    pub fn fabsf(__x: f32) -> f32;
}
extern "C" {
    pub fn __fabsf(__x: f32) -> f32;
}
extern "C" {
    pub fn floorf(__x: f32) -> f32;
}
extern "C" {
    pub fn __floorf(__x: f32) -> f32;
}
extern "C" {
    pub fn fmodf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn __fmodf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn isinff(__value: f32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn finitef(__value: f32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn dremf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn __dremf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn significandf(__x: f32) -> f32;
}
extern "C" {
    pub fn __significandf(__x: f32) -> f32;
}
extern "C" {
    pub fn copysignf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn __copysignf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn nanf(__tagb: *const ::std::os::raw::c_char) -> f32;
}
extern "C" {
    pub fn __nanf(__tagb: *const ::std::os::raw::c_char) -> f32;
}
extern "C" {
    pub fn isnanf(__value: f32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn j0f(arg1: f32) -> f32;
}
extern "C" {
    pub fn __j0f(arg1: f32) -> f32;
}
extern "C" {
    pub fn j1f(arg1: f32) -> f32;
}
extern "C" {
    pub fn __j1f(arg1: f32) -> f32;
}
extern "C" {
    pub fn jnf(arg1: ::std::os::raw::c_int, arg2: f32) -> f32;
}
extern "C" {
    pub fn __jnf(arg1: ::std::os::raw::c_int, arg2: f32) -> f32;
}
extern "C" {
    pub fn y0f(arg1: f32) -> f32;
}
extern "C" {
    pub fn __y0f(arg1: f32) -> f32;
}
extern "C" {
    pub fn y1f(arg1: f32) -> f32;
}
extern "C" {
    pub fn __y1f(arg1: f32) -> f32;
}
extern "C" {
    pub fn ynf(arg1: ::std::os::raw::c_int, arg2: f32) -> f32;
}
extern "C" {
    pub fn __ynf(arg1: ::std::os::raw::c_int, arg2: f32) -> f32;
}
extern "C" {
    pub fn erff(arg1: f32) -> f32;
}
extern "C" {
    pub fn __erff(arg1: f32) -> f32;
}
extern "C" {
    pub fn erfcf(arg1: f32) -> f32;
}
extern "C" {
    pub fn __erfcf(arg1: f32) -> f32;
}
extern "C" {
    pub fn lgammaf(arg1: f32) -> f32;
}
extern "C" {
    pub fn __lgammaf(arg1: f32) -> f32;
}
extern "C" {
    pub fn tgammaf(arg1: f32) -> f32;
}
extern "C" {
    pub fn __tgammaf(arg1: f32) -> f32;
}
extern "C" {
    pub fn gammaf(arg1: f32) -> f32;
}
extern "C" {
    pub fn __gammaf(arg1: f32) -> f32;
}
extern "C" {
    pub fn lgammaf_r(arg1: f32, __signgamp: *mut ::std::os::raw::c_int) -> f32;
}
extern "C" {
    pub fn __lgammaf_r(arg1: f32, __signgamp: *mut ::std::os::raw::c_int) -> f32;
}
extern "C" {
    pub fn rintf(__x: f32) -> f32;
}
extern "C" {
    pub fn __rintf(__x: f32) -> f32;
}
extern "C" {
    pub fn nextafterf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn __nextafterf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn nexttowardf(__x: f32, __y: u128) -> f32;
}
extern "C" {
    pub fn __nexttowardf(__x: f32, __y: u128) -> f32;
}
extern "C" {
    pub fn remainderf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn __remainderf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn scalbnf(__x: f32, __n: ::std::os::raw::c_int) -> f32;
}
extern "C" {
    pub fn __scalbnf(__x: f32, __n: ::std::os::raw::c_int) -> f32;
}
extern "C" {
    pub fn ilogbf(__x: f32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __ilogbf(__x: f32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn scalblnf(__x: f32, __n: ::std::os::raw::c_long) -> f32;
}
extern "C" {
    pub fn __scalblnf(__x: f32, __n: ::std::os::raw::c_long) -> f32;
}
extern "C" {
    pub fn nearbyintf(__x: f32) -> f32;
}
extern "C" {
    pub fn __nearbyintf(__x: f32) -> f32;
}
extern "C" {
    pub fn roundf(__x: f32) -> f32;
}
extern "C" {
    pub fn __roundf(__x: f32) -> f32;
}
extern "C" {
    pub fn truncf(__x: f32) -> f32;
}
extern "C" {
    pub fn __truncf(__x: f32) -> f32;
}
extern "C" {
    pub fn remquof(__x: f32, __y: f32, __quo: *mut ::std::os::raw::c_int) -> f32;
}
extern "C" {
    pub fn __remquof(__x: f32, __y: f32, __quo: *mut ::std::os::raw::c_int) -> f32;
}
extern "C" {
    pub fn lrintf(__x: f32) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn __lrintf(__x: f32) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn llrintf(__x: f32) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn __llrintf(__x: f32) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn lroundf(__x: f32) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn __lroundf(__x: f32) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn llroundf(__x: f32) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn __llroundf(__x: f32) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn fdimf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn __fdimf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn fmaxf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn __fmaxf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn fminf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn __fminf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn fmaf(__x: f32, __y: f32, __z: f32) -> f32;
}
extern "C" {
    pub fn __fmaf(__x: f32, __y: f32, __z: f32) -> f32;
}
extern "C" {
    pub fn scalbf(__x: f32, __n: f32) -> f32;
}
extern "C" {
    pub fn __scalbf(__x: f32, __n: f32) -> f32;
}
extern "C" {
    pub fn __fpclassifyl(__value: u128) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __signbitl(__value: u128) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __isinfl(__value: u128) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __finitel(__value: u128) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __isnanl(__value: u128) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __iseqsigl(__x: u128, __y: u128) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __issignalingl(__value: u128) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn acosl(__x: u128) -> u128;
}
extern "C" {
    pub fn __acosl(__x: u128) -> u128;
}
extern "C" {
    pub fn asinl(__x: u128) -> u128;
}
extern "C" {
    pub fn __asinl(__x: u128) -> u128;
}
extern "C" {
    pub fn atanl(__x: u128) -> u128;
}
extern "C" {
    pub fn __atanl(__x: u128) -> u128;
}
extern "C" {
    pub fn atan2l(__y: u128, __x: u128) -> u128;
}
extern "C" {
    pub fn __atan2l(__y: u128, __x: u128) -> u128;
}
extern "C" {
    pub fn cosl(__x: u128) -> u128;
}
extern "C" {
    pub fn __cosl(__x: u128) -> u128;
}
extern "C" {
    pub fn sinl(__x: u128) -> u128;
}
extern "C" {
    pub fn __sinl(__x: u128) -> u128;
}
extern "C" {
    pub fn tanl(__x: u128) -> u128;
}
extern "C" {
    pub fn __tanl(__x: u128) -> u128;
}
extern "C" {
    pub fn coshl(__x: u128) -> u128;
}
extern "C" {
    pub fn __coshl(__x: u128) -> u128;
}
extern "C" {
    pub fn sinhl(__x: u128) -> u128;
}
extern "C" {
    pub fn __sinhl(__x: u128) -> u128;
}
extern "C" {
    pub fn tanhl(__x: u128) -> u128;
}
extern "C" {
    pub fn __tanhl(__x: u128) -> u128;
}
extern "C" {
    pub fn acoshl(__x: u128) -> u128;
}
extern "C" {
    pub fn __acoshl(__x: u128) -> u128;
}
extern "C" {
    pub fn asinhl(__x: u128) -> u128;
}
extern "C" {
    pub fn __asinhl(__x: u128) -> u128;
}
extern "C" {
    pub fn atanhl(__x: u128) -> u128;
}
extern "C" {
    pub fn __atanhl(__x: u128) -> u128;
}
extern "C" {
    pub fn expl(__x: u128) -> u128;
}
extern "C" {
    pub fn __expl(__x: u128) -> u128;
}
extern "C" {
    pub fn frexpl(__x: u128, __exponent: *mut ::std::os::raw::c_int) -> u128;
}
extern "C" {
    pub fn __frexpl(__x: u128, __exponent: *mut ::std::os::raw::c_int) -> u128;
}
extern "C" {
    pub fn ldexpl(__x: u128, __exponent: ::std::os::raw::c_int) -> u128;
}
extern "C" {
    pub fn __ldexpl(__x: u128, __exponent: ::std::os::raw::c_int) -> u128;
}
extern "C" {
    pub fn logl(__x: u128) -> u128;
}
extern "C" {
    pub fn __logl(__x: u128) -> u128;
}
extern "C" {
    pub fn log10l(__x: u128) -> u128;
}
extern "C" {
    pub fn __log10l(__x: u128) -> u128;
}
extern "C" {
    pub fn modfl(__x: u128, __iptr: *mut u128) -> u128;
}
extern "C" {
    pub fn __modfl(__x: u128, __iptr: *mut u128) -> u128;
}
extern "C" {
    pub fn expm1l(__x: u128) -> u128;
}
extern "C" {
    pub fn __expm1l(__x: u128) -> u128;
}
extern "C" {
    pub fn log1pl(__x: u128) -> u128;
}
extern "C" {
    pub fn __log1pl(__x: u128) -> u128;
}
extern "C" {
    pub fn logbl(__x: u128) -> u128;
}
extern "C" {
    pub fn __logbl(__x: u128) -> u128;
}
extern "C" {
    pub fn exp2l(__x: u128) -> u128;
}
extern "C" {
    pub fn __exp2l(__x: u128) -> u128;
}
extern "C" {
    pub fn log2l(__x: u128) -> u128;
}
extern "C" {
    pub fn __log2l(__x: u128) -> u128;
}
extern "C" {
    pub fn powl(__x: u128, __y: u128) -> u128;
}
extern "C" {
    pub fn __powl(__x: u128, __y: u128) -> u128;
}
extern "C" {
    pub fn sqrtl(__x: u128) -> u128;
}
extern "C" {
    pub fn __sqrtl(__x: u128) -> u128;
}
extern "C" {
    pub fn hypotl(__x: u128, __y: u128) -> u128;
}
extern "C" {
    pub fn __hypotl(__x: u128, __y: u128) -> u128;
}
extern "C" {
    pub fn cbrtl(__x: u128) -> u128;
}
extern "C" {
    pub fn __cbrtl(__x: u128) -> u128;
}
extern "C" {
    pub fn ceill(__x: u128) -> u128;
}
extern "C" {
    pub fn __ceill(__x: u128) -> u128;
}
extern "C" {
    pub fn fabsl(__x: u128) -> u128;
}
extern "C" {
    pub fn __fabsl(__x: u128) -> u128;
}
extern "C" {
    pub fn floorl(__x: u128) -> u128;
}
extern "C" {
    pub fn __floorl(__x: u128) -> u128;
}
extern "C" {
    pub fn fmodl(__x: u128, __y: u128) -> u128;
}
extern "C" {
    pub fn __fmodl(__x: u128, __y: u128) -> u128;
}
extern "C" {
    pub fn isinfl(__value: u128) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn finitel(__value: u128) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn dreml(__x: u128, __y: u128) -> u128;
}
extern "C" {
    pub fn __dreml(__x: u128, __y: u128) -> u128;
}
extern "C" {
    pub fn significandl(__x: u128) -> u128;
}
extern "C" {
    pub fn __significandl(__x: u128) -> u128;
}
extern "C" {
    pub fn copysignl(__x: u128, __y: u128) -> u128;
}
extern "C" {
    pub fn __copysignl(__x: u128, __y: u128) -> u128;
}
extern "C" {
    pub fn nanl(__tagb: *const ::std::os::raw::c_char) -> u128;
}
extern "C" {
    pub fn __nanl(__tagb: *const ::std::os::raw::c_char) -> u128;
}
extern "C" {
    pub fn isnanl(__value: u128) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn j0l(arg1: u128) -> u128;
}
extern "C" {
    pub fn __j0l(arg1: u128) -> u128;
}
extern "C" {
    pub fn j1l(arg1: u128) -> u128;
}
extern "C" {
    pub fn __j1l(arg1: u128) -> u128;
}
extern "C" {
    pub fn jnl(arg1: ::std::os::raw::c_int, arg2: u128) -> u128;
}
extern "C" {
    pub fn __jnl(arg1: ::std::os::raw::c_int, arg2: u128) -> u128;
}
extern "C" {
    pub fn y0l(arg1: u128) -> u128;
}
extern "C" {
    pub fn __y0l(arg1: u128) -> u128;
}
extern "C" {
    pub fn y1l(arg1: u128) -> u128;
}
extern "C" {
    pub fn __y1l(arg1: u128) -> u128;
}
extern "C" {
    pub fn ynl(arg1: ::std::os::raw::c_int, arg2: u128) -> u128;
}
extern "C" {
    pub fn __ynl(arg1: ::std::os::raw::c_int, arg2: u128) -> u128;
}
extern "C" {
    pub fn erfl(arg1: u128) -> u128;
}
extern "C" {
    pub fn __erfl(arg1: u128) -> u128;
}
extern "C" {
    pub fn erfcl(arg1: u128) -> u128;
}
extern "C" {
    pub fn __erfcl(arg1: u128) -> u128;
}
extern "C" {
    pub fn lgammal(arg1: u128) -> u128;
}
extern "C" {
    pub fn __lgammal(arg1: u128) -> u128;
}
extern "C" {
    pub fn tgammal(arg1: u128) -> u128;
}
extern "C" {
    pub fn __tgammal(arg1: u128) -> u128;
}
extern "C" {
    pub fn gammal(arg1: u128) -> u128;
}
extern "C" {
    pub fn __gammal(arg1: u128) -> u128;
}
extern "C" {
    pub fn lgammal_r(arg1: u128, __signgamp: *mut ::std::os::raw::c_int) -> u128;
}
extern "C" {
    pub fn __lgammal_r(arg1: u128, __signgamp: *mut ::std::os::raw::c_int) -> u128;
}
extern "C" {
    pub fn rintl(__x: u128) -> u128;
}
extern "C" {
    pub fn __rintl(__x: u128) -> u128;
}
extern "C" {
    pub fn nextafterl(__x: u128, __y: u128) -> u128;
}
extern "C" {
    pub fn __nextafterl(__x: u128, __y: u128) -> u128;
}
extern "C" {
    pub fn nexttowardl(__x: u128, __y: u128) -> u128;
}
extern "C" {
    pub fn __nexttowardl(__x: u128, __y: u128) -> u128;
}
extern "C" {
    pub fn remainderl(__x: u128, __y: u128) -> u128;
}
extern "C" {
    pub fn __remainderl(__x: u128, __y: u128) -> u128;
}
extern "C" {
    pub fn scalbnl(__x: u128, __n: ::std::os::raw::c_int) -> u128;
}
extern "C" {
    pub fn __scalbnl(__x: u128, __n: ::std::os::raw::c_int) -> u128;
}
extern "C" {
    pub fn ilogbl(__x: u128) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __ilogbl(__x: u128) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn scalblnl(__x: u128, __n: ::std::os::raw::c_long) -> u128;
}
extern "C" {
    pub fn __scalblnl(__x: u128, __n: ::std::os::raw::c_long) -> u128;
}
extern "C" {
    pub fn nearbyintl(__x: u128) -> u128;
}
extern "C" {
    pub fn __nearbyintl(__x: u128) -> u128;
}
extern "C" {
    pub fn roundl(__x: u128) -> u128;
}
extern "C" {
    pub fn __roundl(__x: u128) -> u128;
}
extern "C" {
    pub fn truncl(__x: u128) -> u128;
}
extern "C" {
    pub fn __truncl(__x: u128) -> u128;
}
extern "C" {
    pub fn remquol(__x: u128, __y: u128, __quo: *mut ::std::os::raw::c_int) -> u128;
}
extern "C" {
    pub fn __remquol(__x: u128, __y: u128, __quo: *mut ::std::os::raw::c_int) -> u128;
}
extern "C" {
    pub fn lrintl(__x: u128) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn __lrintl(__x: u128) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn llrintl(__x: u128) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn __llrintl(__x: u128) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn lroundl(__x: u128) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn __lroundl(__x: u128) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn llroundl(__x: u128) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn __llroundl(__x: u128) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn fdiml(__x: u128, __y: u128) -> u128;
}
extern "C" {
    pub fn __fdiml(__x: u128, __y: u128) -> u128;
}
extern "C" {
    pub fn fmaxl(__x: u128, __y: u128) -> u128;
}
extern "C" {
    pub fn __fmaxl(__x: u128, __y: u128) -> u128;
}
extern "C" {
    pub fn fminl(__x: u128, __y: u128) -> u128;
}
extern "C" {
    pub fn __fminl(__x: u128, __y: u128) -> u128;
}
extern "C" {
    pub fn fmal(__x: u128, __y: u128, __z: u128) -> u128;
}
extern "C" {
    pub fn __fmal(__x: u128, __y: u128, __z: u128) -> u128;
}
extern "C" {
    pub fn scalbl(__x: u128, __n: u128) -> u128;
}
extern "C" {
    pub fn __scalbl(__x: u128, __n: u128) -> u128;
}
extern "C" {
    pub static mut signgam: ::std::os::raw::c_int;
}
pub const FP_NAN: _bindgen_ty_1 = 0;
pub const FP_INFINITE: _bindgen_ty_1 = 1;
pub const FP_ZERO: _bindgen_ty_1 = 2;
pub const FP_SUBNORMAL: _bindgen_ty_1 = 3;
pub const FP_NORMAL: _bindgen_ty_1 = 4;
pub type _bindgen_ty_1 = ::std::os::raw::c_uint;
extern "C" {
    pub fn __assert_fail(
        __assertion: *const ::std::os::raw::c_char,
        __file: *const ::std::os::raw::c_char,
        __line: ::std::os::raw::c_uint,
        __function: *const ::std::os::raw::c_char,
    ) -> !;
}
extern "C" {
    pub fn __assert_perror_fail(
        __errnum: ::std::os::raw::c_int,
        __file: *const ::std::os::raw::c_char,
        __line: ::std::os::raw::c_uint,
        __function: *const ::std::os::raw::c_char,
    ) -> !;
}
extern "C" {
    pub fn __assert(
        __assertion: *const ::std::os::raw::c_char,
        __file: *const ::std::os::raw::c_char,
        __line: ::std::os::raw::c_int,
    ) -> !;
}
pub type wchar_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct div_t {
    pub quot: ::std::os::raw::c_int,
    pub rem: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_div_t() {
    const UNINIT: ::std::mem::MaybeUninit<div_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<div_t>(),
        8usize,
        concat!("Size of: ", stringify!(div_t))
    );
    assert_eq!(
        ::std::mem::align_of::<div_t>(),
        4usize,
        concat!("Alignment of ", stringify!(div_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).quot) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(div_t),
            "::",
            stringify!(quot)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rem) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(div_t),
            "::",
            stringify!(rem)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ldiv_t {
    pub quot: ::std::os::raw::c_long,
    pub rem: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_ldiv_t() {
    const UNINIT: ::std::mem::MaybeUninit<ldiv_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ldiv_t>(),
        16usize,
        concat!("Size of: ", stringify!(ldiv_t))
    );
    assert_eq!(
        ::std::mem::align_of::<ldiv_t>(),
        8usize,
        concat!("Alignment of ", stringify!(ldiv_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).quot) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ldiv_t),
            "::",
            stringify!(quot)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rem) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ldiv_t),
            "::",
            stringify!(rem)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lldiv_t {
    pub quot: ::std::os::raw::c_longlong,
    pub rem: ::std::os::raw::c_longlong,
}
#[test]
fn bindgen_test_layout_lldiv_t() {
    const UNINIT: ::std::mem::MaybeUninit<lldiv_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<lldiv_t>(),
        16usize,
        concat!("Size of: ", stringify!(lldiv_t))
    );
    assert_eq!(
        ::std::mem::align_of::<lldiv_t>(),
        8usize,
        concat!("Alignment of ", stringify!(lldiv_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).quot) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lldiv_t),
            "::",
            stringify!(quot)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rem) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lldiv_t),
            "::",
            stringify!(rem)
        )
    );
}
extern "C" {
    pub fn __ctype_get_mb_cur_max() -> usize;
}
extern "C" {
    pub fn atof(__nptr: *const ::std::os::raw::c_char) -> f64;
}
extern "C" {
    pub fn atoi(__nptr: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn atol(__nptr: *const ::std::os::raw::c_char) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn atoll(__nptr: *const ::std::os::raw::c_char) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn strtod(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
    ) -> f64;
}
extern "C" {
    pub fn strtof(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
    ) -> f32;
}
extern "C" {
    pub fn strtold(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
    ) -> u128;
}
extern "C" {
    pub fn strtol(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn strtoul(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strtoq(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn strtouq(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn strtoll(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn strtoull(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn l64a(__n: ::std::os::raw::c_long) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn a64l(__s: *const ::std::os::raw::c_char) -> ::std::os::raw::c_long;
}
pub type u_char = __u_char;
pub type u_short = __u_short;
pub type u_int = __u_int;
pub type u_long = __u_long;
pub type quad_t = __quad_t;
pub type u_quad_t = __u_quad_t;
pub type fsid_t = __fsid_t;
pub type loff_t = __loff_t;
pub type ino_t = __ino_t;
pub type dev_t = __dev_t;
pub type gid_t = __gid_t;
pub type mode_t = __mode_t;
pub type nlink_t = __nlink_t;
pub type uid_t = __uid_t;
pub type pid_t = __pid_t;
pub type id_t = __id_t;
pub type daddr_t = __daddr_t;
pub type caddr_t = __caddr_t;
pub type key_t = __key_t;
pub type clock_t = __clock_t;
pub type clockid_t = __clockid_t;
pub type time_t = __time_t;
pub type timer_t = __timer_t;
pub type ulong = ::std::os::raw::c_ulong;
pub type ushort = ::std::os::raw::c_ushort;
pub type uint = ::std::os::raw::c_uint;
pub type u_int8_t = __uint8_t;
pub type u_int16_t = __uint16_t;
pub type u_int32_t = __uint32_t;
pub type u_int64_t = __uint64_t;
pub type register_t = ::std::os::raw::c_long;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __sigset_t {
    pub __val: [::std::os::raw::c_ulong; 16usize],
}
#[test]
fn bindgen_test_layout___sigset_t() {
    const UNINIT: ::std::mem::MaybeUninit<__sigset_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__sigset_t>(),
        128usize,
        concat!("Size of: ", stringify!(__sigset_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__sigset_t>(),
        8usize,
        concat!("Alignment of ", stringify!(__sigset_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__val) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__sigset_t),
            "::",
            stringify!(__val)
        )
    );
}
pub type sigset_t = __sigset_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timeval {
    pub tv_sec: __time_t,
    pub tv_usec: __suseconds_t,
}
#[test]
fn bindgen_test_layout_timeval() {
    const UNINIT: ::std::mem::MaybeUninit<timeval> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<timeval>(),
        16usize,
        concat!("Size of: ", stringify!(timeval))
    );
    assert_eq!(
        ::std::mem::align_of::<timeval>(),
        8usize,
        concat!("Alignment of ", stringify!(timeval))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tv_sec) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(timeval),
            "::",
            stringify!(tv_sec)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tv_usec) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(timeval),
            "::",
            stringify!(tv_usec)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timespec {
    pub tv_sec: __time_t,
    pub tv_nsec: __syscall_slong_t,
}
#[test]
fn bindgen_test_layout_timespec() {
    const UNINIT: ::std::mem::MaybeUninit<timespec> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<timespec>(),
        16usize,
        concat!("Size of: ", stringify!(timespec))
    );
    assert_eq!(
        ::std::mem::align_of::<timespec>(),
        8usize,
        concat!("Alignment of ", stringify!(timespec))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tv_sec) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(timespec),
            "::",
            stringify!(tv_sec)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tv_nsec) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(timespec),
            "::",
            stringify!(tv_nsec)
        )
    );
}
pub type suseconds_t = __suseconds_t;
pub type __fd_mask = ::std::os::raw::c_long;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fd_set {
    pub __fds_bits: [__fd_mask; 16usize],
}
#[test]
fn bindgen_test_layout_fd_set() {
    const UNINIT: ::std::mem::MaybeUninit<fd_set> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<fd_set>(),
        128usize,
        concat!("Size of: ", stringify!(fd_set))
    );
    assert_eq!(
        ::std::mem::align_of::<fd_set>(),
        8usize,
        concat!("Alignment of ", stringify!(fd_set))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fds_bits) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(fd_set),
            "::",
            stringify!(__fds_bits)
        )
    );
}
pub type fd_mask = __fd_mask;
extern "C" {
    pub fn select(
        __nfds: ::std::os::raw::c_int,
        __readfds: *mut fd_set,
        __writefds: *mut fd_set,
        __exceptfds: *mut fd_set,
        __timeout: *mut timeval,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pselect(
        __nfds: ::std::os::raw::c_int,
        __readfds: *mut fd_set,
        __writefds: *mut fd_set,
        __exceptfds: *mut fd_set,
        __timeout: *const timespec,
        __sigmask: *const __sigset_t,
    ) -> ::std::os::raw::c_int;
}
pub type blksize_t = __blksize_t;
pub type blkcnt_t = __blkcnt_t;
pub type fsblkcnt_t = __fsblkcnt_t;
pub type fsfilcnt_t = __fsfilcnt_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub union __atomic_wide_counter {
    pub __value64: ::std::os::raw::c_ulonglong,
    pub __value32: __atomic_wide_counter__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __atomic_wide_counter__bindgen_ty_1 {
    pub __low: ::std::os::raw::c_uint,
    pub __high: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout___atomic_wide_counter__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<__atomic_wide_counter__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__atomic_wide_counter__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(__atomic_wide_counter__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<__atomic_wide_counter__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(__atomic_wide_counter__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__low) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__atomic_wide_counter__bindgen_ty_1),
            "::",
            stringify!(__low)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__high) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__atomic_wide_counter__bindgen_ty_1),
            "::",
            stringify!(__high)
        )
    );
}
#[test]
fn bindgen_test_layout___atomic_wide_counter() {
    const UNINIT: ::std::mem::MaybeUninit<__atomic_wide_counter> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__atomic_wide_counter>(),
        8usize,
        concat!("Size of: ", stringify!(__atomic_wide_counter))
    );
    assert_eq!(
        ::std::mem::align_of::<__atomic_wide_counter>(),
        8usize,
        concat!("Alignment of ", stringify!(__atomic_wide_counter))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__value64) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__atomic_wide_counter),
            "::",
            stringify!(__value64)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__value32) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__atomic_wide_counter),
            "::",
            stringify!(__value32)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_internal_list {
    pub __prev: *mut __pthread_internal_list,
    pub __next: *mut __pthread_internal_list,
}
#[test]
fn bindgen_test_layout___pthread_internal_list() {
    const UNINIT: ::std::mem::MaybeUninit<__pthread_internal_list> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__pthread_internal_list>(),
        16usize,
        concat!("Size of: ", stringify!(__pthread_internal_list))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_internal_list>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_internal_list))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__prev) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_internal_list),
            "::",
            stringify!(__prev)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__next) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_internal_list),
            "::",
            stringify!(__next)
        )
    );
}
pub type __pthread_list_t = __pthread_internal_list;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_internal_slist {
    pub __next: *mut __pthread_internal_slist,
}
#[test]
fn bindgen_test_layout___pthread_internal_slist() {
    const UNINIT: ::std::mem::MaybeUninit<__pthread_internal_slist> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__pthread_internal_slist>(),
        8usize,
        concat!("Size of: ", stringify!(__pthread_internal_slist))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_internal_slist>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_internal_slist))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__next) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_internal_slist),
            "::",
            stringify!(__next)
        )
    );
}
pub type __pthread_slist_t = __pthread_internal_slist;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_mutex_s {
    pub __lock: ::std::os::raw::c_int,
    pub __count: ::std::os::raw::c_uint,
    pub __owner: ::std::os::raw::c_int,
    pub __nusers: ::std::os::raw::c_uint,
    pub __kind: ::std::os::raw::c_int,
    pub __spins: ::std::os::raw::c_short,
    pub __elision: ::std::os::raw::c_short,
    pub __list: __pthread_list_t,
}
#[test]
fn bindgen_test_layout___pthread_mutex_s() {
    const UNINIT: ::std::mem::MaybeUninit<__pthread_mutex_s> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__pthread_mutex_s>(),
        40usize,
        concat!("Size of: ", stringify!(__pthread_mutex_s))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_mutex_s>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_mutex_s))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__lock) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__lock)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__count) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__count)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__owner) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__owner)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__nusers) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__nusers)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__kind) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__kind)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__spins) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__spins)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__elision) as usize - ptr as usize },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__elision)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__list) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__list)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_rwlock_arch_t {
    pub __readers: ::std::os::raw::c_uint,
    pub __writers: ::std::os::raw::c_uint,
    pub __wrphase_futex: ::std::os::raw::c_uint,
    pub __writers_futex: ::std::os::raw::c_uint,
    pub __pad3: ::std::os::raw::c_uint,
    pub __pad4: ::std::os::raw::c_uint,
    pub __cur_writer: ::std::os::raw::c_int,
    pub __shared: ::std::os::raw::c_int,
    pub __rwelision: ::std::os::raw::c_schar,
    pub __pad1: [::std::os::raw::c_uchar; 7usize],
    pub __pad2: ::std::os::raw::c_ulong,
    pub __flags: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout___pthread_rwlock_arch_t() {
    const UNINIT: ::std::mem::MaybeUninit<__pthread_rwlock_arch_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__pthread_rwlock_arch_t>(),
        56usize,
        concat!("Size of: ", stringify!(__pthread_rwlock_arch_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_rwlock_arch_t>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_rwlock_arch_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__readers) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__readers)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__writers) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__writers)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__wrphase_futex) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__wrphase_futex)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__writers_futex) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__writers_futex)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__pad3) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__pad3)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__pad4) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__pad4)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__cur_writer) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__cur_writer)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__shared) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__shared)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__rwelision) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__rwelision)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__pad1) as usize - ptr as usize },
        33usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__pad1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__pad2) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__pad2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__flags) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__flags)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __pthread_cond_s {
    pub __wseq: __atomic_wide_counter,
    pub __g1_start: __atomic_wide_counter,
    pub __g_refs: [::std::os::raw::c_uint; 2usize],
    pub __g_size: [::std::os::raw::c_uint; 2usize],
    pub __g1_orig_size: ::std::os::raw::c_uint,
    pub __wrefs: ::std::os::raw::c_uint,
    pub __g_signals: [::std::os::raw::c_uint; 2usize],
}
#[test]
fn bindgen_test_layout___pthread_cond_s() {
    const UNINIT: ::std::mem::MaybeUninit<__pthread_cond_s> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__pthread_cond_s>(),
        48usize,
        concat!("Size of: ", stringify!(__pthread_cond_s))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_cond_s>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_cond_s))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__wseq) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__wseq)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__g1_start) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__g1_start)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__g_refs) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__g_refs)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__g_size) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__g_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__g1_orig_size) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__g1_orig_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__wrefs) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__wrefs)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__g_signals) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__g_signals)
        )
    );
}
pub type __tss_t = ::std::os::raw::c_uint;
pub type __thrd_t = ::std::os::raw::c_ulong;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __once_flag {
    pub __data: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout___once_flag() {
    const UNINIT: ::std::mem::MaybeUninit<__once_flag> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__once_flag>(),
        4usize,
        concat!("Size of: ", stringify!(__once_flag))
    );
    assert_eq!(
        ::std::mem::align_of::<__once_flag>(),
        4usize,
        concat!("Alignment of ", stringify!(__once_flag))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__once_flag),
            "::",
            stringify!(__data)
        )
    );
}
pub type pthread_t = ::std::os::raw::c_ulong;
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_mutexattr_t {
    pub __size: [::std::os::raw::c_char; 4usize],
    pub __align: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_pthread_mutexattr_t() {
    const UNINIT: ::std::mem::MaybeUninit<pthread_mutexattr_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<pthread_mutexattr_t>(),
        4usize,
        concat!("Size of: ", stringify!(pthread_mutexattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_mutexattr_t>(),
        4usize,
        concat!("Alignment of ", stringify!(pthread_mutexattr_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutexattr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__align) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutexattr_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_condattr_t {
    pub __size: [::std::os::raw::c_char; 4usize],
    pub __align: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_pthread_condattr_t() {
    const UNINIT: ::std::mem::MaybeUninit<pthread_condattr_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<pthread_condattr_t>(),
        4usize,
        concat!("Size of: ", stringify!(pthread_condattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_condattr_t>(),
        4usize,
        concat!("Alignment of ", stringify!(pthread_condattr_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_condattr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__align) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_condattr_t),
            "::",
            stringify!(__align)
        )
    );
}
pub type pthread_key_t = ::std::os::raw::c_uint;
pub type pthread_once_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_attr_t {
    pub __size: [::std::os::raw::c_char; 56usize],
    pub __align: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_pthread_attr_t() {
    const UNINIT: ::std::mem::MaybeUninit<pthread_attr_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<pthread_attr_t>(),
        56usize,
        concat!("Size of: ", stringify!(pthread_attr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_attr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_attr_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_attr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__align) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_attr_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_mutex_t {
    pub __data: __pthread_mutex_s,
    pub __size: [::std::os::raw::c_char; 40usize],
    pub __align: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_pthread_mutex_t() {
    const UNINIT: ::std::mem::MaybeUninit<pthread_mutex_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<pthread_mutex_t>(),
        40usize,
        concat!("Size of: ", stringify!(pthread_mutex_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_mutex_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_mutex_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutex_t),
            "::",
            stringify!(__data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutex_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__align) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutex_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_cond_t {
    pub __data: __pthread_cond_s,
    pub __size: [::std::os::raw::c_char; 48usize],
    pub __align: ::std::os::raw::c_longlong,
}
#[test]
fn bindgen_test_layout_pthread_cond_t() {
    const UNINIT: ::std::mem::MaybeUninit<pthread_cond_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<pthread_cond_t>(),
        48usize,
        concat!("Size of: ", stringify!(pthread_cond_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_cond_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_cond_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_cond_t),
            "::",
            stringify!(__data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_cond_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__align) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_cond_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_rwlock_t {
    pub __data: __pthread_rwlock_arch_t,
    pub __size: [::std::os::raw::c_char; 56usize],
    pub __align: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_pthread_rwlock_t() {
    const UNINIT: ::std::mem::MaybeUninit<pthread_rwlock_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<pthread_rwlock_t>(),
        56usize,
        concat!("Size of: ", stringify!(pthread_rwlock_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_rwlock_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_rwlock_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlock_t),
            "::",
            stringify!(__data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlock_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__align) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlock_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_rwlockattr_t {
    pub __size: [::std::os::raw::c_char; 8usize],
    pub __align: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_pthread_rwlockattr_t() {
    const UNINIT: ::std::mem::MaybeUninit<pthread_rwlockattr_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<pthread_rwlockattr_t>(),
        8usize,
        concat!("Size of: ", stringify!(pthread_rwlockattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_rwlockattr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_rwlockattr_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlockattr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__align) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlockattr_t),
            "::",
            stringify!(__align)
        )
    );
}
pub type pthread_spinlock_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_barrier_t {
    pub __size: [::std::os::raw::c_char; 32usize],
    pub __align: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_pthread_barrier_t() {
    const UNINIT: ::std::mem::MaybeUninit<pthread_barrier_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<pthread_barrier_t>(),
        32usize,
        concat!("Size of: ", stringify!(pthread_barrier_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_barrier_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_barrier_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_barrier_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__align) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_barrier_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_barrierattr_t {
    pub __size: [::std::os::raw::c_char; 4usize],
    pub __align: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_pthread_barrierattr_t() {
    const UNINIT: ::std::mem::MaybeUninit<pthread_barrierattr_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<pthread_barrierattr_t>(),
        4usize,
        concat!("Size of: ", stringify!(pthread_barrierattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_barrierattr_t>(),
        4usize,
        concat!("Alignment of ", stringify!(pthread_barrierattr_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_barrierattr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__align) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_barrierattr_t),
            "::",
            stringify!(__align)
        )
    );
}
extern "C" {
    pub fn random() -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn srandom(__seed: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn initstate(
        __seed: ::std::os::raw::c_uint,
        __statebuf: *mut ::std::os::raw::c_char,
        __statelen: usize,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn setstate(__statebuf: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct random_data {
    pub fptr: *mut i32,
    pub rptr: *mut i32,
    pub state: *mut i32,
    pub rand_type: ::std::os::raw::c_int,
    pub rand_deg: ::std::os::raw::c_int,
    pub rand_sep: ::std::os::raw::c_int,
    pub end_ptr: *mut i32,
}
#[test]
fn bindgen_test_layout_random_data() {
    const UNINIT: ::std::mem::MaybeUninit<random_data> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<random_data>(),
        48usize,
        concat!("Size of: ", stringify!(random_data))
    );
    assert_eq!(
        ::std::mem::align_of::<random_data>(),
        8usize,
        concat!("Alignment of ", stringify!(random_data))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fptr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(random_data),
            "::",
            stringify!(fptr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rptr) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(random_data),
            "::",
            stringify!(rptr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).state) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(random_data),
            "::",
            stringify!(state)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rand_type) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(random_data),
            "::",
            stringify!(rand_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rand_deg) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(random_data),
            "::",
            stringify!(rand_deg)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rand_sep) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(random_data),
            "::",
            stringify!(rand_sep)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).end_ptr) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(random_data),
            "::",
            stringify!(end_ptr)
        )
    );
}
extern "C" {
    pub fn random_r(__buf: *mut random_data, __result: *mut i32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn srandom_r(
        __seed: ::std::os::raw::c_uint,
        __buf: *mut random_data,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn initstate_r(
        __seed: ::std::os::raw::c_uint,
        __statebuf: *mut ::std::os::raw::c_char,
        __statelen: usize,
        __buf: *mut random_data,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setstate_r(
        __statebuf: *mut ::std::os::raw::c_char,
        __buf: *mut random_data,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rand() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn srand(__seed: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn rand_r(__seed: *mut ::std::os::raw::c_uint) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn drand48() -> f64;
}
extern "C" {
    pub fn erand48(__xsubi: *mut ::std::os::raw::c_ushort) -> f64;
}
extern "C" {
    pub fn lrand48() -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn nrand48(__xsubi: *mut ::std::os::raw::c_ushort) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn mrand48() -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn jrand48(__xsubi: *mut ::std::os::raw::c_ushort) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn srand48(__seedval: ::std::os::raw::c_long);
}
extern "C" {
    pub fn seed48(__seed16v: *mut ::std::os::raw::c_ushort) -> *mut ::std::os::raw::c_ushort;
}
extern "C" {
    pub fn lcong48(__param: *mut ::std::os::raw::c_ushort);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct drand48_data {
    pub __x: [::std::os::raw::c_ushort; 3usize],
    pub __old_x: [::std::os::raw::c_ushort; 3usize],
    pub __c: ::std::os::raw::c_ushort,
    pub __init: ::std::os::raw::c_ushort,
    pub __a: ::std::os::raw::c_ulonglong,
}
#[test]
fn bindgen_test_layout_drand48_data() {
    const UNINIT: ::std::mem::MaybeUninit<drand48_data> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<drand48_data>(),
        24usize,
        concat!("Size of: ", stringify!(drand48_data))
    );
    assert_eq!(
        ::std::mem::align_of::<drand48_data>(),
        8usize,
        concat!("Alignment of ", stringify!(drand48_data))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__x) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(drand48_data),
            "::",
            stringify!(__x)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__old_x) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(drand48_data),
            "::",
            stringify!(__old_x)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__c) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(drand48_data),
            "::",
            stringify!(__c)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__init) as usize - ptr as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(drand48_data),
            "::",
            stringify!(__init)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__a) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(drand48_data),
            "::",
            stringify!(__a)
        )
    );
}
extern "C" {
    pub fn drand48_r(__buffer: *mut drand48_data, __result: *mut f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn erand48_r(
        __xsubi: *mut ::std::os::raw::c_ushort,
        __buffer: *mut drand48_data,
        __result: *mut f64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn lrand48_r(
        __buffer: *mut drand48_data,
        __result: *mut ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nrand48_r(
        __xsubi: *mut ::std::os::raw::c_ushort,
        __buffer: *mut drand48_data,
        __result: *mut ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mrand48_r(
        __buffer: *mut drand48_data,
        __result: *mut ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn jrand48_r(
        __xsubi: *mut ::std::os::raw::c_ushort,
        __buffer: *mut drand48_data,
        __result: *mut ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn srand48_r(
        __seedval: ::std::os::raw::c_long,
        __buffer: *mut drand48_data,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn seed48_r(
        __seed16v: *mut ::std::os::raw::c_ushort,
        __buffer: *mut drand48_data,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn lcong48_r(
        __param: *mut ::std::os::raw::c_ushort,
        __buffer: *mut drand48_data,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn arc4random() -> __uint32_t;
}
extern "C" {
    pub fn arc4random_buf(__buf: *mut ::std::os::raw::c_void, __size: usize);
}
extern "C" {
    pub fn arc4random_uniform(__upper_bound: __uint32_t) -> __uint32_t;
}
extern "C" {
    pub fn malloc(__size: ::std::os::raw::c_ulong) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn calloc(
        __nmemb: ::std::os::raw::c_ulong,
        __size: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn realloc(
        __ptr: *mut ::std::os::raw::c_void,
        __size: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn free(__ptr: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn reallocarray(
        __ptr: *mut ::std::os::raw::c_void,
        __nmemb: usize,
        __size: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn alloca(__size: ::std::os::raw::c_ulong) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn valloc(__size: usize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn posix_memalign(
        __memptr: *mut *mut ::std::os::raw::c_void,
        __alignment: usize,
        __size: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aligned_alloc(
        __alignment: ::std::os::raw::c_ulong,
        __size: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn abort() -> !;
}
extern "C" {
    pub fn atexit(__func: ::std::option::Option<unsafe extern "C" fn()>) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn at_quick_exit(
        __func: ::std::option::Option<unsafe extern "C" fn()>,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn on_exit(
        __func: ::std::option::Option<
            unsafe extern "C" fn(
                __status: ::std::os::raw::c_int,
                __arg: *mut ::std::os::raw::c_void,
            ),
        >,
        __arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn exit(__status: ::std::os::raw::c_int) -> !;
}
extern "C" {
    pub fn quick_exit(__status: ::std::os::raw::c_int) -> !;
}
extern "C" {
    pub fn _Exit(__status: ::std::os::raw::c_int) -> !;
}
extern "C" {
    pub fn getenv(__name: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn putenv(__string: *mut ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setenv(
        __name: *const ::std::os::raw::c_char,
        __value: *const ::std::os::raw::c_char,
        __replace: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn unsetenv(__name: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clearenv() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mktemp(__template: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn mkstemp(__template: *mut ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mkstemps(
        __template: *mut ::std::os::raw::c_char,
        __suffixlen: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mkdtemp(__template: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn system(__command: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn realpath(
        __name: *const ::std::os::raw::c_char,
        __resolved: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
pub type __compar_fn_t = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *const ::std::os::raw::c_void,
        arg2: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
extern "C" {
    pub fn bsearch(
        __key: *const ::std::os::raw::c_void,
        __base: *const ::std::os::raw::c_void,
        __nmemb: usize,
        __size: usize,
        __compar: __compar_fn_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn qsort(
        __base: *mut ::std::os::raw::c_void,
        __nmemb: usize,
        __size: usize,
        __compar: __compar_fn_t,
    );
}
extern "C" {
    pub fn abs(__x: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn labs(__x: ::std::os::raw::c_long) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn llabs(__x: ::std::os::raw::c_longlong) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn div(__numer: ::std::os::raw::c_int, __denom: ::std::os::raw::c_int) -> div_t;
}
extern "C" {
    pub fn ldiv(__numer: ::std::os::raw::c_long, __denom: ::std::os::raw::c_long) -> ldiv_t;
}
extern "C" {
    pub fn lldiv(
        __numer: ::std::os::raw::c_longlong,
        __denom: ::std::os::raw::c_longlong,
    ) -> lldiv_t;
}
extern "C" {
    pub fn ecvt(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn fcvt(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn gcvt(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn qecvt(
        __value: u128,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn qfcvt(
        __value: u128,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn qgcvt(
        __value: u128,
        __ndigit: ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ecvt_r(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __len: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fcvt_r(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __len: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn qecvt_r(
        __value: u128,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __len: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn qfcvt_r(
        __value: u128,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __len: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mblen(__s: *const ::std::os::raw::c_char, __n: usize) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mbtowc(
        __pwc: *mut wchar_t,
        __s: *const ::std::os::raw::c_char,
        __n: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wctomb(__s: *mut ::std::os::raw::c_char, __wchar: wchar_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mbstowcs(__pwcs: *mut wchar_t, __s: *const ::std::os::raw::c_char, __n: usize) -> usize;
}
extern "C" {
    pub fn wcstombs(__s: *mut ::std::os::raw::c_char, __pwcs: *const wchar_t, __n: usize) -> usize;
}
extern "C" {
    pub fn rpmatch(__response: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getsubopt(
        __optionp: *mut *mut ::std::os::raw::c_char,
        __tokens: *const *mut ::std::os::raw::c_char,
        __valuep: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getloadavg(__loadavg: *mut f64, __nelem: ::std::os::raw::c_int)
        -> ::std::os::raw::c_int;
}
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone)]
pub struct max_align_t {
    pub __clang_max_align_nonce1: ::std::os::raw::c_longlong,
    pub __bindgen_padding_0: u64,
    pub __clang_max_align_nonce2: u128,
}
#[test]
fn bindgen_test_layout_max_align_t() {
    const UNINIT: ::std::mem::MaybeUninit<max_align_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<max_align_t>(),
        32usize,
        concat!("Size of: ", stringify!(max_align_t))
    );
    assert_eq!(
        ::std::mem::align_of::<max_align_t>(),
        16usize,
        concat!("Alignment of ", stringify!(max_align_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__clang_max_align_nonce1) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(max_align_t),
            "::",
            stringify!(__clang_max_align_nonce1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__clang_max_align_nonce2) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(max_align_t),
            "::",
            stringify!(__clang_max_align_nonce2)
        )
    );
}
extern "C" {
    #[doc = " allocates array and initializes it with 0; returns NULL if memory allocation failed"]
    pub fn BMSallocClearMemory_call(
        num: usize,
        typesize: usize,
        filename: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " allocates memory; returns NULL if memory allocation failed"]
    pub fn BMSallocMemory_call(
        size: usize,
        filename: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " allocates array; returns NULL if memory allocation failed"]
    pub fn BMSallocMemoryArray_call(
        num: usize,
        typesize: usize,
        filename: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " allocates memory; returns NULL if memory allocation failed"]
    pub fn BMSreallocMemory_call(
        ptr: *mut ::std::os::raw::c_void,
        size: usize,
        filename: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " reallocates array; returns NULL if memory allocation failed"]
    pub fn BMSreallocMemoryArray_call(
        ptr: *mut ::std::os::raw::c_void,
        num: usize,
        typesize: usize,
        filename: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " clears a memory element (i.e. fills it with zeros)"]
    pub fn BMSclearMemory_call(ptr: *mut ::std::os::raw::c_void, size: usize);
}
extern "C" {
    #[doc = " copies the contents of one memory element into another memory element"]
    pub fn BMScopyMemory_call(
        ptr: *mut ::std::os::raw::c_void,
        source: *const ::std::os::raw::c_void,
        size: usize,
    );
}
extern "C" {
    #[doc = " moves the contents of one memory element into another memory element, should be used if both elements overlap,\n  otherwise BMScopyMemory is faster"]
    pub fn BMSmoveMemory_call(
        ptr: *mut ::std::os::raw::c_void,
        source: *const ::std::os::raw::c_void,
        size: usize,
    );
}
extern "C" {
    #[doc = " allocates memory and copies the contents of the given memory element into the new memory element"]
    pub fn BMSduplicateMemory_call(
        source: *const ::std::os::raw::c_void,
        size: usize,
        filename: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " allocates array and copies the contents of the given source array into the new array"]
    pub fn BMSduplicateMemoryArray_call(
        source: *const ::std::os::raw::c_void,
        num: usize,
        typesize: usize,
        filename: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " frees an allocated memory element and sets pointer to NULL"]
    pub fn BMSfreeMemory_call(
        ptr: *mut *mut ::std::os::raw::c_void,
        filename: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " frees an allocated memory element if pointer is not NULL and sets pointer to NULL"]
    pub fn BMSfreeMemoryNull_call(
        ptr: *mut *mut ::std::os::raw::c_void,
        filename: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " returns the size of an allocated memory element"]
    pub fn BMSgetPointerSize_call(ptr: *const ::std::os::raw::c_void) -> usize;
}
extern "C" {
    #[doc = " outputs information about currently allocated memory to the screen"]
    pub fn BMSdisplayMemory_call();
}
extern "C" {
    #[doc = " displays a warning message on the screen, if allocated memory exists"]
    pub fn BMScheckEmptyMemory_call();
}
extern "C" {
    #[doc = " returns total number of allocated bytes"]
    pub fn BMSgetMemoryUsed_call() -> ::std::os::raw::c_longlong;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct BMS_ChkMem {
    _unused: [u8; 0],
}
#[doc = " Chunk Memory Management\n\n Efficient memory management for multiple objects of the same size"]
pub type BMS_CHKMEM = BMS_ChkMem;
extern "C" {
    #[doc = " aligns the given byte size corresponding to the minimal alignment for chunk and block memory"]
    pub fn BMSalignMemsize(size: *mut usize);
}
extern "C" {
    #[doc = " checks whether the given size meets the alignment conditions for chunk and block memory"]
    pub fn BMSisAligned(size: usize) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " creates a new chunk block data structure"]
    pub fn BMScreateChunkMemory_call(
        size: usize,
        initchunksize: ::std::os::raw::c_int,
        garbagefactor: ::std::os::raw::c_int,
        filename: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_int,
    ) -> *mut BMS_CHKMEM;
}
extern "C" {
    #[doc = " clears a chunk block data structure"]
    pub fn BMSclearChunkMemory_call(
        chkmem: *mut BMS_CHKMEM,
        filename: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " destroys and frees a chunk block data structure"]
    pub fn BMSdestroyChunkMemory_call(
        chkmem: *mut *mut BMS_CHKMEM,
        filename: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " allocates a memory element of the given chunk block"]
    pub fn BMSallocChunkMemory_call(
        chkmem: *mut BMS_CHKMEM,
        size: usize,
        filename: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " duplicates a given memory element by allocating a new element of the same chunk block and copying the data"]
    pub fn BMSduplicateChunkMemory_call(
        chkmem: *mut BMS_CHKMEM,
        source: *const ::std::os::raw::c_void,
        size: usize,
        filename: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " frees a memory element of the given chunk block and sets pointer to NULL"]
    pub fn BMSfreeChunkMemory_call(
        chkmem: *mut BMS_CHKMEM,
        ptr: *mut *mut ::std::os::raw::c_void,
        size: usize,
        filename: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " frees a memory element of the given chunk block if pointer is not NULL and sets pointer to NULL"]
    pub fn BMSfreeChunkMemoryNull_call(
        chkmem: *mut BMS_CHKMEM,
        ptr: *mut *mut ::std::os::raw::c_void,
        size: usize,
        filename: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " calls garbage collection of chunk block and frees chunks without allocated memory elements"]
    pub fn BMSgarbagecollectChunkMemory_call(chkmem: *mut BMS_CHKMEM);
}
extern "C" {
    #[doc = " returns the number of allocated bytes in the chunk block"]
    pub fn BMSgetChunkMemoryUsed_call(chkmem: *const BMS_CHKMEM) -> ::std::os::raw::c_longlong;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct BMS_BlkMem {
    _unused: [u8; 0],
}
#[doc = " Block Memory Management\n\n Efficient memory management for objects of varying sizes"]
pub type BMS_BLKMEM = BMS_BlkMem;
extern "C" {
    #[doc = " creates a block memory allocation data structure"]
    pub fn BMScreateBlockMemory_call(
        initchunksize: ::std::os::raw::c_int,
        garbagefactor: ::std::os::raw::c_int,
        filename: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_int,
    ) -> *mut BMS_BLKMEM;
}
extern "C" {
    #[doc = " frees all chunk blocks in the block memory"]
    pub fn BMSclearBlockMemory_call(
        blkmem: *mut BMS_BLKMEM,
        filename: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " clears and deletes block memory"]
    pub fn BMSdestroyBlockMemory_call(
        blkmem: *mut *mut BMS_BLKMEM,
        filename: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " allocates memory in the block memory pool"]
    pub fn BMSallocBlockMemory_call(
        blkmem: *mut BMS_BLKMEM,
        size: usize,
        filename: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " allocates memory in the block memory pool and clears it"]
    pub fn BMSallocClearBlockMemory_call(
        blkmem: *mut BMS_BLKMEM,
        size: usize,
        filename: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " allocates array in the block memory pool"]
    pub fn BMSallocBlockMemoryArray_call(
        blkmem: *mut BMS_BLKMEM,
        num: usize,
        typesize: usize,
        filename: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " allocates array in the block memory pool and clears it"]
    pub fn BMSallocClearBlockMemoryArray_call(
        blkmem: *mut BMS_BLKMEM,
        num: usize,
        typesize: usize,
        filename: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " resizes memory element in the block memory pool and copies the data"]
    pub fn BMSreallocBlockMemory_call(
        blkmem: *mut BMS_BLKMEM,
        ptr: *mut ::std::os::raw::c_void,
        oldsize: usize,
        newsize: usize,
        filename: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " resizes array in the block memory pool and copies the data"]
    pub fn BMSreallocBlockMemoryArray_call(
        blkmem: *mut BMS_BLKMEM,
        ptr: *mut ::std::os::raw::c_void,
        oldnum: usize,
        newnum: usize,
        typesize: usize,
        filename: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " duplicates memory element in the block memory pool and copies the data"]
    pub fn BMSduplicateBlockMemory_call(
        blkmem: *mut BMS_BLKMEM,
        source: *const ::std::os::raw::c_void,
        size: usize,
        filename: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " duplicates array in the block memory pool and copies the data"]
    pub fn BMSduplicateBlockMemoryArray_call(
        blkmem: *mut BMS_BLKMEM,
        source: *const ::std::os::raw::c_void,
        num: usize,
        typesize: usize,
        filename: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " frees memory element in the block memory pool and sets pointer to NULL"]
    pub fn BMSfreeBlockMemory_call(
        blkmem: *mut BMS_BLKMEM,
        ptr: *mut *mut ::std::os::raw::c_void,
        size: usize,
        filename: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " frees memory element in the block memory pool if pointer is not NULL and sets pointer to NULL"]
    pub fn BMSfreeBlockMemoryNull_call(
        blkmem: *mut BMS_BLKMEM,
        ptr: *mut *mut ::std::os::raw::c_void,
        size: usize,
        filename: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " calls garbage collection of block memory, frees chunks without allocated memory elements, and frees\n  chunk blocks without any chunks"]
    pub fn BMSgarbagecollectBlockMemory_call(blkmem: *mut BMS_BLKMEM);
}
extern "C" {
    #[doc = " returns the number of allocated bytes in the block memory"]
    pub fn BMSgetBlockMemoryAllocated_call(blkmem: *const BMS_BLKMEM)
        -> ::std::os::raw::c_longlong;
}
extern "C" {
    #[doc = " returns the number of used bytes in the block memory"]
    pub fn BMSgetBlockMemoryUsed_call(blkmem: *const BMS_BLKMEM) -> ::std::os::raw::c_longlong;
}
extern "C" {
    #[doc = " returns the number of allocated but not used bytes in the block memory"]
    pub fn BMSgetBlockMemoryUnused_call(blkmem: *const BMS_BLKMEM) -> ::std::os::raw::c_longlong;
}
extern "C" {
    #[doc = " returns the maximal number of used bytes in the block memory"]
    pub fn BMSgetBlockMemoryUsedMax_call(blkmem: *const BMS_BLKMEM) -> ::std::os::raw::c_longlong;
}
extern "C" {
    #[doc = " returns the maximal number of allocated but not used bytes in the block memory"]
    pub fn BMSgetBlockMemoryUnusedMax_call(blkmem: *const BMS_BLKMEM)
        -> ::std::os::raw::c_longlong;
}
extern "C" {
    #[doc = " returns the maximal number of allocated bytes in the block memory"]
    pub fn BMSgetBlockMemoryAllocatedMax_call(
        blkmem: *const BMS_BLKMEM,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    #[doc = " returns the size of the given memory element; returns 0, if the element is not member of the block memory"]
    pub fn BMSgetBlockPointerSize_call(
        blkmem: *const BMS_BLKMEM,
        ptr: *const ::std::os::raw::c_void,
    ) -> usize;
}
extern "C" {
    #[doc = " outputs allocation diagnostics of block memory"]
    pub fn BMSdisplayBlockMemory_call(blkmem: *const BMS_BLKMEM);
}
extern "C" {
    #[doc = " outputs error messages, if there are allocated elements in the block memory and returns number of unfreed bytes"]
    pub fn BMScheckEmptyBlockMemory_call(blkmem: *const BMS_BLKMEM) -> ::std::os::raw::c_longlong;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct BMS_BufMem {
    _unused: [u8; 0],
}
#[doc = " Buffer Memory Management\n\n Efficient memory management for temporary objects"]
pub type BMS_BUFMEM = BMS_BufMem;
extern "C" {
    #[doc = " creates memory buffer storage"]
    pub fn BMScreateBufferMemory_call(
        arraygrowfac: f64,
        arraygrowinit: ::std::os::raw::c_int,
        clean: ::std::os::raw::c_uint,
        filename: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_int,
    ) -> *mut BMS_BUFMEM;
}
extern "C" {
    #[doc = " destroys buffer memory"]
    pub fn BMSdestroyBufferMemory_call(
        buffer: *mut *mut BMS_BUFMEM,
        filename: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " set arraygrowfac"]
    pub fn BMSsetBufferMemoryArraygrowfac(buffer: *mut BMS_BUFMEM, arraygrowfac: f64);
}
extern "C" {
    #[doc = " set arraygrowinit"]
    pub fn BMSsetBufferMemoryArraygrowinit(
        buffer: *mut BMS_BUFMEM,
        arraygrowinit: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " allocates the next unused buffer"]
    pub fn BMSallocBufferMemory_call(
        buffer: *mut BMS_BUFMEM,
        size: usize,
        filename: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " allocates the next unused buffer array"]
    pub fn BMSallocBufferMemoryArray_call(
        buffer: *mut BMS_BUFMEM,
        num: usize,
        typesize: usize,
        filename: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " allocates the next unused buffer and clears it"]
    pub fn BMSallocClearBufferMemoryArray_call(
        buffer: *mut BMS_BUFMEM,
        num: usize,
        typesize: usize,
        filename: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " reallocates the buffer to at least the given size"]
    pub fn BMSreallocBufferMemory_call(
        buffer: *mut BMS_BUFMEM,
        ptr: *mut ::std::os::raw::c_void,
        size: usize,
        filename: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " reallocates an array in the buffer to at least the given size"]
    pub fn BMSreallocBufferMemoryArray_call(
        buffer: *mut BMS_BUFMEM,
        ptr: *mut ::std::os::raw::c_void,
        num: usize,
        typesize: usize,
        filename: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " allocates the next unused buffer and copies the given memory into the buffer"]
    pub fn BMSduplicateBufferMemory_call(
        buffer: *mut BMS_BUFMEM,
        source: *const ::std::os::raw::c_void,
        size: usize,
        filename: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " allocates an array in the next unused buffer and copies the given memory into the buffer"]
    pub fn BMSduplicateBufferMemoryArray_call(
        buffer: *mut BMS_BUFMEM,
        source: *const ::std::os::raw::c_void,
        num: usize,
        typesize: usize,
        filename: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " frees a buffer and sets pointer to NULL"]
    pub fn BMSfreeBufferMemory_call(
        buffer: *mut BMS_BUFMEM,
        ptr: *mut *mut ::std::os::raw::c_void,
        filename: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " frees a buffer if pointer is not NULL and sets pointer to NULL"]
    pub fn BMSfreeBufferMemoryNull_call(
        buffer: *mut BMS_BUFMEM,
        ptr: *mut *mut ::std::os::raw::c_void,
        filename: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " gets number of used buffers"]
    pub fn BMSgetNUsedBufferMemory(buffer: *mut BMS_BUFMEM) -> usize;
}
extern "C" {
    #[doc = " returns the number of allocated bytes in the buffer memory"]
    pub fn BMSgetBufferMemoryUsed(bufmem: *const BMS_BUFMEM) -> ::std::os::raw::c_longlong;
}
extern "C" {
    #[doc = " outputs statistics about currently allocated buffers to the screen"]
    pub fn BMSprintBufferMemory(buffer: *mut BMS_BUFMEM);
}
#[doc = "< normal termination"]
pub const SCIP_Retcode_SCIP_OKAY: SCIP_Retcode = 1;
#[doc = "< unspecified error"]
pub const SCIP_Retcode_SCIP_ERROR: SCIP_Retcode = 0;
#[doc = "< insufficient memory error"]
pub const SCIP_Retcode_SCIP_NOMEMORY: SCIP_Retcode = -1;
#[doc = "< read error"]
pub const SCIP_Retcode_SCIP_READERROR: SCIP_Retcode = -2;
#[doc = "< write error"]
pub const SCIP_Retcode_SCIP_WRITEERROR: SCIP_Retcode = -3;
#[doc = "< file not found error"]
pub const SCIP_Retcode_SCIP_NOFILE: SCIP_Retcode = -4;
#[doc = "< cannot create file"]
pub const SCIP_Retcode_SCIP_FILECREATEERROR: SCIP_Retcode = -5;
#[doc = "< error in LP solver"]
pub const SCIP_Retcode_SCIP_LPERROR: SCIP_Retcode = -6;
#[doc = "< no problem exists"]
pub const SCIP_Retcode_SCIP_NOPROBLEM: SCIP_Retcode = -7;
#[doc = "< method cannot be called at this time in solution process"]
pub const SCIP_Retcode_SCIP_INVALIDCALL: SCIP_Retcode = -8;
#[doc = "< error in input data"]
pub const SCIP_Retcode_SCIP_INVALIDDATA: SCIP_Retcode = -9;
#[doc = "< method returned an invalid result code"]
pub const SCIP_Retcode_SCIP_INVALIDRESULT: SCIP_Retcode = -10;
#[doc = "< a required plugin was not found"]
pub const SCIP_Retcode_SCIP_PLUGINNOTFOUND: SCIP_Retcode = -11;
#[doc = "< the parameter with the given name was not found"]
pub const SCIP_Retcode_SCIP_PARAMETERUNKNOWN: SCIP_Retcode = -12;
#[doc = "< the parameter is not of the expected type"]
pub const SCIP_Retcode_SCIP_PARAMETERWRONGTYPE: SCIP_Retcode = -13;
#[doc = "< the value is invalid for the given parameter"]
pub const SCIP_Retcode_SCIP_PARAMETERWRONGVAL: SCIP_Retcode = -14;
#[doc = "< the given key is already existing in table"]
pub const SCIP_Retcode_SCIP_KEYALREADYEXISTING: SCIP_Retcode = -15;
#[doc = "< maximal branching depth level exceeded"]
pub const SCIP_Retcode_SCIP_MAXDEPTHLEVEL: SCIP_Retcode = -16;
#[doc = "< no branching could be created"]
pub const SCIP_Retcode_SCIP_BRANCHERROR: SCIP_Retcode = -17;
#[doc = "< function not implemented"]
pub const SCIP_Retcode_SCIP_NOTIMPLEMENTED: SCIP_Retcode = -18;
#[doc = " return codes for SCIP methods: non-positive return codes are errors"]
pub type SCIP_Retcode = ::std::os::raw::c_int;
#[doc = " return codes for SCIP methods: non-positive return codes are errors"]
pub use self::SCIP_Retcode as SCIP_RETCODE;
#[doc = "< the method was not executed"]
pub const SCIP_Result_SCIP_DIDNOTRUN: SCIP_Result = 1;
#[doc = "< the method was not executed, but should be called again later"]
pub const SCIP_Result_SCIP_DELAYED: SCIP_Result = 2;
#[doc = "< the method was executed, but failed finding anything"]
pub const SCIP_Result_SCIP_DIDNOTFIND: SCIP_Result = 3;
#[doc = "< no infeasibility could be found"]
pub const SCIP_Result_SCIP_FEASIBLE: SCIP_Result = 4;
#[doc = "< an infeasibility was detected"]
pub const SCIP_Result_SCIP_INFEASIBLE: SCIP_Result = 5;
#[doc = "< an unboundedness was detected"]
pub const SCIP_Result_SCIP_UNBOUNDED: SCIP_Result = 6;
#[doc = "< the current node is infeasible and can be cut off"]
pub const SCIP_Result_SCIP_CUTOFF: SCIP_Result = 7;
#[doc = "< the method added a cutting plane"]
pub const SCIP_Result_SCIP_SEPARATED: SCIP_Result = 8;
#[doc = "< the method added a cutting plane and a new separation round should immediately start"]
pub const SCIP_Result_SCIP_NEWROUND: SCIP_Result = 9;
#[doc = "< the method reduced the domain of a variable"]
pub const SCIP_Result_SCIP_REDUCEDDOM: SCIP_Result = 10;
#[doc = "< the method added a constraint"]
pub const SCIP_Result_SCIP_CONSADDED: SCIP_Result = 11;
#[doc = "< the method changed a constraint"]
pub const SCIP_Result_SCIP_CONSCHANGED: SCIP_Result = 12;
#[doc = "< the method created a branching"]
pub const SCIP_Result_SCIP_BRANCHED: SCIP_Result = 13;
#[doc = "< the current node's LP must be solved"]
pub const SCIP_Result_SCIP_SOLVELP: SCIP_Result = 14;
#[doc = "< the method found a feasible primal solution"]
pub const SCIP_Result_SCIP_FOUNDSOL: SCIP_Result = 15;
#[doc = "< the method interrupted its execution, but can continue if needed"]
pub const SCIP_Result_SCIP_SUSPENDED: SCIP_Result = 16;
#[doc = "< the method was successfully executed"]
pub const SCIP_Result_SCIP_SUCCESS: SCIP_Result = 17;
#[doc = "< the processing of the branch-and-bound node should stopped and continued later"]
pub const SCIP_Result_SCIP_DELAYNODE: SCIP_Result = 18;
#[doc = " result codes for SCIP callback methods"]
pub type SCIP_Result = ::std::os::raw::c_uint;
#[doc = " result codes for SCIP callback methods"]
pub use self::SCIP_Result as SCIP_RESULT;
#[doc = "< use default clock type"]
pub const SCIP_ClockType_SCIP_CLOCKTYPE_DEFAULT: SCIP_ClockType = 0;
#[doc = "< use CPU clock"]
pub const SCIP_ClockType_SCIP_CLOCKTYPE_CPU: SCIP_ClockType = 1;
#[doc = "< use wall clock"]
pub const SCIP_ClockType_SCIP_CLOCKTYPE_WALL: SCIP_ClockType = 2;
pub type SCIP_ClockType = ::std::os::raw::c_uint;
pub use self::SCIP_ClockType as SCIP_CLOCKTYPE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_Clock {
    _unused: [u8; 0],
}
pub type SCIP_CLOCK = SCIP_Clock;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_CPUClock {
    _unused: [u8; 0],
}
pub type SCIP_CPUCLOCK = SCIP_CPUClock;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_WallClock {
    _unused: [u8; 0],
}
pub type SCIP_WALLCLOCK = SCIP_WallClock;
#[doc = "< one-sided confidence level 75 %, two-sided 50 %"]
pub const SCIP_Confidencelevel_SCIP_CONFIDENCELEVEL_MIN: SCIP_Confidencelevel = 0;
#[doc = "< (one-sided) confidence level 87.5 %, two-sided 75 %"]
pub const SCIP_Confidencelevel_SCIP_CONFIDENCELEVEL_LOW: SCIP_Confidencelevel = 1;
#[doc = "< (one-sided) confidence level 90 %, two-sided 80 %"]
pub const SCIP_Confidencelevel_SCIP_CONFIDENCELEVEL_MEDIUM: SCIP_Confidencelevel = 2;
#[doc = "< (one-sided) confidence level 95 %, two-sided 90 %"]
pub const SCIP_Confidencelevel_SCIP_CONFIDENCELEVEL_HIGH: SCIP_Confidencelevel = 3;
#[doc = "< (one-sided) confidence level 97.5 %, two-sided 95 %"]
pub const SCIP_Confidencelevel_SCIP_CONFIDENCELEVEL_MAX: SCIP_Confidencelevel = 4;
#[doc = " represents different confidence levels for (one-sided) hypothesis testing; in order to obtain two-sided confidence\n  levels, calculate 2 * c - 1, i.e., if the one-sided confidence level is 90 %, the two-sided level is 80 %"]
pub type SCIP_Confidencelevel = ::std::os::raw::c_uint;
#[doc = " represents different confidence levels for (one-sided) hypothesis testing; in order to obtain two-sided confidence\n  levels, calculate 2 * c - 1, i.e., if the one-sided confidence level is 90 %, the two-sided level is 80 %"]
pub use self::SCIP_Confidencelevel as SCIP_CONFIDENCELEVEL;
#[doc = "< the hashmap did not store a single element yet, type unknown"]
pub const SCIP_Hashmaptype_SCIP_HASHMAPTYPE_UNKNOWN: SCIP_Hashmaptype = 0;
#[doc = "< the hashmap stores pointers %"]
pub const SCIP_Hashmaptype_SCIP_HASHMAPTYPE_POINTER: SCIP_Hashmaptype = 1;
#[doc = "< the hashmap stores reals"]
pub const SCIP_Hashmaptype_SCIP_HASHMAPTYPE_REAL: SCIP_Hashmaptype = 2;
#[doc = "< the hashmap stores ints"]
pub const SCIP_Hashmaptype_SCIP_HASHMAPTYPE_INT: SCIP_Hashmaptype = 3;
#[doc = " type of hashmap: are pointers, reals or ints stored, or unknown"]
pub type SCIP_Hashmaptype = ::std::os::raw::c_uint;
#[doc = " type of hashmap: are pointers, reals or ints stored, or unknown"]
pub use self::SCIP_Hashmaptype as SCIP_HASHMAPTYPE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_SparseSol {
    _unused: [u8; 0],
}
#[doc = " Sparse solution data structure\n\n  - \\ref SparseSol \"List of all available methods\""]
pub type SCIP_SPARSESOL = SCIP_SparseSol;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_Queue {
    _unused: [u8; 0],
}
#[doc = " (circular) Queue data structure\n\n  - \\ref Queue \"List of all available methods\""]
pub type SCIP_QUEUE = SCIP_Queue;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_PQueue {
    _unused: [u8; 0],
}
#[doc = " Priority queue data structure\n\n  - \\ref PriorityQueue \"List of all available methods\""]
pub type SCIP_PQUEUE = SCIP_PQueue;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_HashTable {
    _unused: [u8; 0],
}
#[doc = " Hash table data structure\n\n  - \\ref HashTable \"List of all available methods\""]
pub type SCIP_HASHTABLE = SCIP_HashTable;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_MultiHash {
    _unused: [u8; 0],
}
#[doc = " Hash table data structure which allows multiple occurences of an element\n\n  - \\ref MultiHash \"List of all available methods\""]
pub type SCIP_MULTIHASH = SCIP_MultiHash;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_MultiHashList {
    _unused: [u8; 0],
}
#[doc = " Hash table element list to store single elements of a multi hash table"]
pub type SCIP_MULTIHASHLIST = SCIP_MultiHashList;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_HashMapEntry {
    _unused: [u8; 0],
}
#[doc = " Hash map entry"]
pub type SCIP_HASHMAPENTRY = SCIP_HashMapEntry;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_HashMap {
    _unused: [u8; 0],
}
#[doc = " Hash map data structure\n\n  - \\ref HashMap \"List of all available methods\""]
pub type SCIP_HASHMAP = SCIP_HashMap;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_HashSet {
    _unused: [u8; 0],
}
#[doc = " Hash set data structure\n\n  - \\ref HashMap \"List of all available methods\""]
pub type SCIP_HASHSET = SCIP_HashSet;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_RealArray {
    _unused: [u8; 0],
}
#[doc = " dynamic array for storing SCIP_Real values"]
pub type SCIP_REALARRAY = SCIP_RealArray;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_IntArray {
    _unused: [u8; 0],
}
#[doc = " dynamic array for storing int values"]
pub type SCIP_INTARRAY = SCIP_IntArray;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_BoolArray {
    _unused: [u8; 0],
}
#[doc = " dynamic array for storing SCIP_Bool values"]
pub type SCIP_BOOLARRAY = SCIP_BoolArray;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_PtrArray {
    _unused: [u8; 0],
}
#[doc = " dynamic array for storing pointers"]
pub type SCIP_PTRARRAY = SCIP_PtrArray;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_RandNumGen {
    _unused: [u8; 0],
}
#[doc = " random number generator"]
pub type SCIP_RANDNUMGEN = SCIP_RandNumGen;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_ResourceActivity {
    _unused: [u8; 0],
}
#[doc = " Resource activity data structure\n\n  - \\ref ResourceActivity \"List of all available methods\""]
pub type SCIP_RESOURCEACTIVITY = SCIP_ResourceActivity;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_Profile {
    _unused: [u8; 0],
}
#[doc = " Resource profile data structure\n\n  - \\ref ResourceProfile \"List of all available methods\""]
pub type SCIP_PROFILE = SCIP_Profile;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_Digraph {
    _unused: [u8; 0],
}
#[doc = " Directed graph data structure (stored as adjacency list)\n\n  - \\ref DirectedGraph \"List of all available methods\""]
pub type SCIP_DIGRAPH = SCIP_Digraph;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_Bt {
    _unused: [u8; 0],
}
#[doc = " Binary tree data structure\n\n  - \\ref BinaryTree \"List of all available methods\""]
pub type SCIP_BT = SCIP_Bt;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_BtNode {
    _unused: [u8; 0],
}
#[doc = " search node of \\ref SCIP_BT \"binary tree\""]
pub type SCIP_BTNODE = SCIP_BtNode;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_Regression {
    _unused: [u8; 0],
}
#[doc = " regression data structure to compute an incremental linear regression of paired observations\n\n  - \\ref Regression \"List of all available methods\""]
pub type SCIP_REGRESSION = SCIP_Regression;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_DisjointSet {
    _unused: [u8; 0],
}
#[doc = " disjoint set (disjoint set (union find)) data structure for querying and updating connectedness of a graph with integer vertices 0,...,n - 1\n\n  - \\ref DisjointSet \"List of available methods\""]
pub type SCIP_DISJOINTSET = SCIP_DisjointSet;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_RowPrep {
    _unused: [u8; 0],
}
#[doc = " a linear inequality row in preparation to become a SCIP_ROW\n\n Used to assemble data that could eventually make a SCIP_ROW.\n @note Only one-sided rows are allowed here."]
pub type SCIP_ROWPREP = SCIP_RowPrep;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Scip {
    _unused: [u8; 0],
}
pub type SCIP = Scip;
pub type SCIP_PRESOLTIMING = ::std::os::raw::c_uint;
pub type SCIP_PROPTIMING = ::std::os::raw::c_uint;
pub type SCIP_HEURTIMING = ::std::os::raw::c_uint;
#[doc = "< bool values: TRUE or FALSE"]
pub const SCIP_ParamType_SCIP_PARAMTYPE_BOOL: SCIP_ParamType = 0;
#[doc = "< integer values"]
pub const SCIP_ParamType_SCIP_PARAMTYPE_INT: SCIP_ParamType = 1;
#[doc = "< long integer values"]
pub const SCIP_ParamType_SCIP_PARAMTYPE_LONGINT: SCIP_ParamType = 2;
#[doc = "< real values"]
pub const SCIP_ParamType_SCIP_PARAMTYPE_REAL: SCIP_ParamType = 3;
#[doc = "< characters"]
pub const SCIP_ParamType_SCIP_PARAMTYPE_CHAR: SCIP_ParamType = 4;
#[doc = "< strings: arrays of characters"]
pub const SCIP_ParamType_SCIP_PARAMTYPE_STRING: SCIP_ParamType = 5;
#[doc = " possible parameter types"]
pub type SCIP_ParamType = ::std::os::raw::c_uint;
#[doc = " possible parameter types"]
pub use self::SCIP_ParamType as SCIP_PARAMTYPE;
#[doc = "< use default values"]
pub const SCIP_ParamSetting_SCIP_PARAMSETTING_DEFAULT: SCIP_ParamSetting = 0;
#[doc = "< set to aggressive settings"]
pub const SCIP_ParamSetting_SCIP_PARAMSETTING_AGGRESSIVE: SCIP_ParamSetting = 1;
#[doc = "< set to fast settings"]
pub const SCIP_ParamSetting_SCIP_PARAMSETTING_FAST: SCIP_ParamSetting = 2;
#[doc = "< turn off"]
pub const SCIP_ParamSetting_SCIP_PARAMSETTING_OFF: SCIP_ParamSetting = 3;
#[doc = " possible parameter settings - used to determine the behavior of different SCIP components, e.g., heuristics, separators, ..."]
pub type SCIP_ParamSetting = ::std::os::raw::c_uint;
#[doc = " possible parameter settings - used to determine the behavior of different SCIP components, e.g., heuristics, separators, ..."]
pub use self::SCIP_ParamSetting as SCIP_PARAMSETTING;
#[doc = "< use default values"]
pub const SCIP_ParamEmphasis_SCIP_PARAMEMPHASIS_DEFAULT: SCIP_ParamEmphasis = 0;
#[doc = "< get CP like search (e.g. no LP relaxation)"]
pub const SCIP_ParamEmphasis_SCIP_PARAMEMPHASIS_CPSOLVER: SCIP_ParamEmphasis = 1;
#[doc = "< solve easy problems fast"]
pub const SCIP_ParamEmphasis_SCIP_PARAMEMPHASIS_EASYCIP: SCIP_ParamEmphasis = 2;
#[doc = "< detect feasibility fast"]
pub const SCIP_ParamEmphasis_SCIP_PARAMEMPHASIS_FEASIBILITY: SCIP_ParamEmphasis = 3;
#[doc = "< be capable to handle hard LPs"]
pub const SCIP_ParamEmphasis_SCIP_PARAMEMPHASIS_HARDLP: SCIP_ParamEmphasis = 4;
#[doc = "< prove optimality fast"]
pub const SCIP_ParamEmphasis_SCIP_PARAMEMPHASIS_OPTIMALITY: SCIP_ParamEmphasis = 5;
#[doc = "< get a feasible and \"fast\" counting process"]
pub const SCIP_ParamEmphasis_SCIP_PARAMEMPHASIS_COUNTER: SCIP_ParamEmphasis = 6;
#[doc = "< feasibility phase settings during 3-phase solving approach"]
pub const SCIP_ParamEmphasis_SCIP_PARAMEMPHASIS_PHASEFEAS: SCIP_ParamEmphasis = 7;
#[doc = "< improvement phase settings during 3-phase solving approach"]
pub const SCIP_ParamEmphasis_SCIP_PARAMEMPHASIS_PHASEIMPROVE: SCIP_ParamEmphasis = 8;
#[doc = "< proof phase settings during 3-phase solving approach"]
pub const SCIP_ParamEmphasis_SCIP_PARAMEMPHASIS_PHASEPROOF: SCIP_ParamEmphasis = 9;
#[doc = "< emphasis parameters for increased numerical safety"]
pub const SCIP_ParamEmphasis_SCIP_PARAMEMPHASIS_NUMERICS: SCIP_ParamEmphasis = 10;
#[doc = "< do not try to avoid running into memory limit"]
pub const SCIP_ParamEmphasis_SCIP_PARAMEMPHASIS_BENCHMARK: SCIP_ParamEmphasis = 11;
#[doc = " possible parameter emphases - used to determine the general SCIP behavior"]
pub type SCIP_ParamEmphasis = ::std::os::raw::c_uint;
#[doc = " possible parameter emphases - used to determine the general SCIP behavior"]
pub use self::SCIP_ParamEmphasis as SCIP_PARAMEMPHASIS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_Param {
    _unused: [u8; 0],
}
pub type SCIP_PARAM = SCIP_Param;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_ParamData {
    _unused: [u8; 0],
}
pub type SCIP_PARAMDATA = SCIP_ParamData;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_ParamSet {
    _unused: [u8; 0],
}
pub type SCIP_PARAMSET = SCIP_ParamSet;
pub type __gwchar_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct imaxdiv_t {
    pub quot: ::std::os::raw::c_long,
    pub rem: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_imaxdiv_t() {
    const UNINIT: ::std::mem::MaybeUninit<imaxdiv_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<imaxdiv_t>(),
        16usize,
        concat!("Size of: ", stringify!(imaxdiv_t))
    );
    assert_eq!(
        ::std::mem::align_of::<imaxdiv_t>(),
        8usize,
        concat!("Alignment of ", stringify!(imaxdiv_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).quot) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(imaxdiv_t),
            "::",
            stringify!(quot)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rem) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(imaxdiv_t),
            "::",
            stringify!(rem)
        )
    );
}
extern "C" {
    pub fn imaxabs(__n: intmax_t) -> intmax_t;
}
extern "C" {
    pub fn imaxdiv(__numer: intmax_t, __denom: intmax_t) -> imaxdiv_t;
}
extern "C" {
    pub fn strtoimax(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> intmax_t;
}
extern "C" {
    pub fn strtoumax(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> uintmax_t;
}
extern "C" {
    pub fn wcstoimax(
        __nptr: *const __gwchar_t,
        __endptr: *mut *mut __gwchar_t,
        __base: ::std::os::raw::c_int,
    ) -> intmax_t;
}
extern "C" {
    pub fn wcstoumax(
        __nptr: *const __gwchar_t,
        __endptr: *mut *mut __gwchar_t,
        __base: ::std::os::raw::c_int,
    ) -> uintmax_t;
}
pub type SCIP_EVENTTYPE = u64;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_Eventhdlr {
    _unused: [u8; 0],
}
pub type SCIP_EVENTHDLR = SCIP_Eventhdlr;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_EventhdlrData {
    _unused: [u8; 0],
}
pub type SCIP_EVENTHDLRDATA = SCIP_EventhdlrData;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_Event {
    _unused: [u8; 0],
}
pub type SCIP_EVENT = SCIP_Event;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_EventVarAdded {
    _unused: [u8; 0],
}
pub type SCIP_EVENTVARADDED = SCIP_EventVarAdded;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_EventVarDeleted {
    _unused: [u8; 0],
}
pub type SCIP_EVENTVARDELETED = SCIP_EventVarDeleted;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_EventVarFixed {
    _unused: [u8; 0],
}
pub type SCIP_EVENTVARFIXED = SCIP_EventVarFixed;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_EventVarUnlocked {
    _unused: [u8; 0],
}
pub type SCIP_EVENTVARUNLOCKED = SCIP_EventVarUnlocked;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_EventObjChg {
    _unused: [u8; 0],
}
pub type SCIP_EVENTOBJCHG = SCIP_EventObjChg;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_EventBdChg {
    _unused: [u8; 0],
}
pub type SCIP_EVENTBDCHG = SCIP_EventBdChg;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_EventHole {
    _unused: [u8; 0],
}
pub type SCIP_EVENTHOLE = SCIP_EventHole;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_EventImplAdd {
    _unused: [u8; 0],
}
pub type SCIP_EVENTIMPLADD = SCIP_EventImplAdd;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_EventTypeChg {
    _unused: [u8; 0],
}
pub type SCIP_EVENTTYPECHG = SCIP_EventTypeChg;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_EventRowAddedSepa {
    _unused: [u8; 0],
}
pub type SCIP_EVENTROWADDEDSEPA = SCIP_EventRowAddedSepa;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_EventRowDeletedSepa {
    _unused: [u8; 0],
}
pub type SCIP_EVENTROWDELETEDSEPA = SCIP_EventRowDeletedSepa;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_EventRowAddedLP {
    _unused: [u8; 0],
}
pub type SCIP_EVENTROWADDEDLP = SCIP_EventRowAddedLP;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_EventRowDeletedLP {
    _unused: [u8; 0],
}
pub type SCIP_EVENTROWDELETEDLP = SCIP_EventRowDeletedLP;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_EventRowCoefChanged {
    _unused: [u8; 0],
}
pub type SCIP_EVENTROWCOEFCHANGED = SCIP_EventRowCoefChanged;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_EventRowConstChanged {
    _unused: [u8; 0],
}
pub type SCIP_EVENTROWCONSTCHANGED = SCIP_EventRowConstChanged;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_EventRowSideChanged {
    _unused: [u8; 0],
}
pub type SCIP_EVENTROWSIDECHANGED = SCIP_EventRowSideChanged;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_EventData {
    _unused: [u8; 0],
}
pub type SCIP_EVENTDATA = SCIP_EventData;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_EventFilter {
    _unused: [u8; 0],
}
pub type SCIP_EVENTFILTER = SCIP_EventFilter;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_EventQueue {
    _unused: [u8; 0],
}
pub type SCIP_EVENTQUEUE = SCIP_EventQueue;
#[doc = "< LP was not solved, no solution exists"]
pub const SCIP_LPSolStat_SCIP_LPSOLSTAT_NOTSOLVED: SCIP_LPSolStat = 0;
#[doc = "< LP was solved to optimality"]
pub const SCIP_LPSolStat_SCIP_LPSOLSTAT_OPTIMAL: SCIP_LPSolStat = 1;
#[doc = "< LP is primal infeasible"]
pub const SCIP_LPSolStat_SCIP_LPSOLSTAT_INFEASIBLE: SCIP_LPSolStat = 2;
#[doc = "< LP has a primal unbounded ray"]
pub const SCIP_LPSolStat_SCIP_LPSOLSTAT_UNBOUNDEDRAY: SCIP_LPSolStat = 3;
#[doc = "< objective limit was reached during optimization"]
pub const SCIP_LPSolStat_SCIP_LPSOLSTAT_OBJLIMIT: SCIP_LPSolStat = 4;
#[doc = "< iteration limit was reached during optimization"]
pub const SCIP_LPSolStat_SCIP_LPSOLSTAT_ITERLIMIT: SCIP_LPSolStat = 5;
#[doc = "< time limit was reached during optimization"]
pub const SCIP_LPSolStat_SCIP_LPSOLSTAT_TIMELIMIT: SCIP_LPSolStat = 6;
#[doc = "< an error occured during optimization"]
pub const SCIP_LPSolStat_SCIP_LPSOLSTAT_ERROR: SCIP_LPSolStat = 7;
#[doc = " solution status after solving LP"]
pub type SCIP_LPSolStat = ::std::os::raw::c_uint;
#[doc = " solution status after solving LP"]
pub use self::SCIP_LPSolStat as SCIP_LPSOLSTAT;
#[doc = "< lower bound"]
pub const SCIP_BoundType_SCIP_BOUNDTYPE_LOWER: SCIP_BoundType = 0;
#[doc = "< upper bound"]
pub const SCIP_BoundType_SCIP_BOUNDTYPE_UPPER: SCIP_BoundType = 1;
#[doc = " type of variable bound: lower or upper bound"]
pub type SCIP_BoundType = ::std::os::raw::c_uint;
#[doc = " type of variable bound: lower or upper bound"]
pub use self::SCIP_BoundType as SCIP_BOUNDTYPE;
#[doc = "< left hand side"]
pub const SCIP_SideType_SCIP_SIDETYPE_LEFT: SCIP_SideType = 0;
#[doc = "< right hand side"]
pub const SCIP_SideType_SCIP_SIDETYPE_RIGHT: SCIP_SideType = 1;
#[doc = " type of row side: left hand or right hand side"]
pub type SCIP_SideType = ::std::os::raw::c_uint;
#[doc = " type of row side: left hand or right hand side"]
pub use self::SCIP_SideType as SCIP_SIDETYPE;
#[doc = "< unspecified origin of row"]
pub const SCIP_RowOriginType_SCIP_ROWORIGINTYPE_UNSPEC: SCIP_RowOriginType = 0;
#[doc = "< row created by a constraint handler"]
pub const SCIP_RowOriginType_SCIP_ROWORIGINTYPE_CONSHDLR: SCIP_RowOriginType = 1;
#[doc = "< row created by a constraint"]
pub const SCIP_RowOriginType_SCIP_ROWORIGINTYPE_CONS: SCIP_RowOriginType = 2;
#[doc = "< row created by separator"]
pub const SCIP_RowOriginType_SCIP_ROWORIGINTYPE_SEPA: SCIP_RowOriginType = 3;
#[doc = "< row created by reoptimization"]
pub const SCIP_RowOriginType_SCIP_ROWORIGINTYPE_REOPT: SCIP_RowOriginType = 4;
#[doc = " type of origin of row"]
pub type SCIP_RowOriginType = ::std::os::raw::c_uint;
#[doc = " type of origin of row"]
pub use self::SCIP_RowOriginType as SCIP_ROWORIGINTYPE;
#[doc = "< primal simplex"]
pub const SCIP_LPAlgo_SCIP_LPALGO_PRIMALSIMPLEX: SCIP_LPAlgo = 0;
#[doc = "< dual simplex"]
pub const SCIP_LPAlgo_SCIP_LPALGO_DUALSIMPLEX: SCIP_LPAlgo = 1;
#[doc = "< barrier algorithm"]
pub const SCIP_LPAlgo_SCIP_LPALGO_BARRIER: SCIP_LPAlgo = 2;
#[doc = "< barrier algorithm with crossover"]
pub const SCIP_LPAlgo_SCIP_LPALGO_BARRIERCROSSOVER: SCIP_LPAlgo = 3;
#[doc = " type of LP algorithm"]
pub type SCIP_LPAlgo = ::std::os::raw::c_uint;
#[doc = " type of LP algorithm"]
pub use self::SCIP_LPAlgo as SCIP_LPALGO;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_ColSolVals {
    _unused: [u8; 0],
}
pub type SCIP_COLSOLVALS = SCIP_ColSolVals;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_RowSolVals {
    _unused: [u8; 0],
}
pub type SCIP_ROWSOLVALS = SCIP_RowSolVals;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_LpSolVals {
    _unused: [u8; 0],
}
pub type SCIP_LPSOLVALS = SCIP_LpSolVals;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_Col {
    _unused: [u8; 0],
}
#[doc = " column of an LP\n\n  - \\ref PublicColumnMethods \"List of all available methods\""]
pub type SCIP_COL = SCIP_Col;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_Row {
    _unused: [u8; 0],
}
#[doc = " row of an LP\n\n  - \\ref PublicRowMethods \"List of all available methods\""]
pub type SCIP_ROW = SCIP_Row;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_Lp {
    _unused: [u8; 0],
}
#[doc = " LP structure\n\n  - \\ref PublicLPMethods \"List of all available methods\""]
pub type SCIP_LP = SCIP_Lp;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_NlRow {
    _unused: [u8; 0],
}
pub type SCIP_NLROW = SCIP_NlRow;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_Nlp {
    _unused: [u8; 0],
}
pub type SCIP_NLP = SCIP_Nlp;
#[doc = "< variable belongs to original problem"]
pub const SCIP_Varstatus_SCIP_VARSTATUS_ORIGINAL: SCIP_Varstatus = 0;
#[doc = "< variable is a loose variable of the transformed problem"]
pub const SCIP_Varstatus_SCIP_VARSTATUS_LOOSE: SCIP_Varstatus = 1;
#[doc = "< variable is a column of the transformed problem"]
pub const SCIP_Varstatus_SCIP_VARSTATUS_COLUMN: SCIP_Varstatus = 2;
#[doc = "< variable is fixed to specific value in the transformed problem"]
pub const SCIP_Varstatus_SCIP_VARSTATUS_FIXED: SCIP_Varstatus = 3;
#[doc = "< variable is aggregated to x = a*y + c in the transformed problem"]
pub const SCIP_Varstatus_SCIP_VARSTATUS_AGGREGATED: SCIP_Varstatus = 4;
#[doc = "< variable is aggregated to x = a_1*y_1 + ... + a_k*y_k + c"]
pub const SCIP_Varstatus_SCIP_VARSTATUS_MULTAGGR: SCIP_Varstatus = 5;
#[doc = "< variable is the negation of an original or transformed variable"]
pub const SCIP_Varstatus_SCIP_VARSTATUS_NEGATED: SCIP_Varstatus = 6;
#[doc = " status of problem variables"]
pub type SCIP_Varstatus = ::std::os::raw::c_uint;
#[doc = " status of problem variables"]
pub use self::SCIP_Varstatus as SCIP_VARSTATUS;
#[doc = "< binary variable: \\f$ x \\in \\{0,1\\} \\f$"]
pub const SCIP_Vartype_SCIP_VARTYPE_BINARY: SCIP_Vartype = 0;
#[doc = "< integer variable: \\f$ x in \\{lb, \\dots, ub\\} \\f$"]
pub const SCIP_Vartype_SCIP_VARTYPE_INTEGER: SCIP_Vartype = 1;
#[doc = "< continuous variable with optional integrality restriction:\nassigning a fractional value for the variable is feasible and the solver will not enforce\nintegrality for this variable, but it may treat the variable as if an additional integrality\nrestriction exists in certain cases, e.g., during boundtightening;\ntypically, this variable type is used for implicit integer variables, that is, variables which\nare known to take an integral value in a feasible or optimal solution due to other constraints or\noptimality conditions"]
pub const SCIP_Vartype_SCIP_VARTYPE_IMPLINT: SCIP_Vartype = 2;
#[doc = "< continuous variable: \\f$ lb \\leq x \\leq ub \\f$"]
pub const SCIP_Vartype_SCIP_VARTYPE_CONTINUOUS: SCIP_Vartype = 3;
#[doc = " variable type"]
pub type SCIP_Vartype = ::std::os::raw::c_uint;
#[doc = " variable type"]
pub use self::SCIP_Vartype as SCIP_VARTYPE;
#[doc = "< dynamic bound changes with size information of arrays"]
pub const SCIP_DomchgType_SCIP_DOMCHGTYPE_DYNAMIC: SCIP_DomchgType = 0;
#[doc = "< static domain changes: number of entries equals size of arrays"]
pub const SCIP_DomchgType_SCIP_DOMCHGTYPE_BOTH: SCIP_DomchgType = 1;
#[doc = "< static domain changes without any hole changes"]
pub const SCIP_DomchgType_SCIP_DOMCHGTYPE_BOUND: SCIP_DomchgType = 2;
#[doc = " domain change data type"]
pub type SCIP_DomchgType = ::std::os::raw::c_uint;
#[doc = " domain change data type"]
pub use self::SCIP_DomchgType as SCIP_DOMCHGTYPE;
#[doc = "< bound change was due to a branching decision"]
pub const SCIP_BoundchgType_SCIP_BOUNDCHGTYPE_BRANCHING: SCIP_BoundchgType = 0;
#[doc = "< bound change was due to an inference of a constraint (domain propagation)"]
pub const SCIP_BoundchgType_SCIP_BOUNDCHGTYPE_CONSINFER: SCIP_BoundchgType = 1;
#[doc = "< bound change was due to an inference of a domain propagator"]
pub const SCIP_BoundchgType_SCIP_BOUNDCHGTYPE_PROPINFER: SCIP_BoundchgType = 2;
#[doc = " bound change type"]
pub type SCIP_BoundchgType = ::std::os::raw::c_uint;
#[doc = " bound change type"]
pub use self::SCIP_BoundchgType as SCIP_BOUNDCHGTYPE;
#[doc = "< variable locks for model and check constraints"]
pub const SCIP_LockType_SCIP_LOCKTYPE_MODEL: SCIP_LockType = 0;
#[doc = "< variable locks for conflict constraints"]
pub const SCIP_LockType_SCIP_LOCKTYPE_CONFLICT: SCIP_LockType = 1;
pub type SCIP_LockType = ::std::os::raw::c_uint;
pub use self::SCIP_LockType as SCIP_LOCKTYPE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_DomChgBound {
    _unused: [u8; 0],
}
pub type SCIP_DOMCHGBOUND = SCIP_DomChgBound;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_DomChgBoth {
    _unused: [u8; 0],
}
pub type SCIP_DOMCHGBOTH = SCIP_DomChgBoth;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_DomChgDyn {
    _unused: [u8; 0],
}
pub type SCIP_DOMCHGDYN = SCIP_DomChgDyn;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SCIP_DomChg {
    _unused: [u8; 0],
}
pub type SCIP_DOMCHG = SCIP_DomChg;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_BoundChg {
    _unused: [u8; 0],
}
pub type SCIP_BOUNDCHG = SCIP_BoundChg;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_BdChgIdx {
    _unused: [u8; 0],
}
pub type SCIP_BDCHGIDX = SCIP_BdChgIdx;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_BdChgInfo {
    _unused: [u8; 0],
}
pub type SCIP_BDCHGINFO = SCIP_BdChgInfo;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_BranchingData {
    _unused: [u8; 0],
}
pub type SCIP_BRANCHINGDATA = SCIP_BranchingData;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_InferenceData {
    _unused: [u8; 0],
}
pub type SCIP_INFERENCEDATA = SCIP_InferenceData;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_HoleChg {
    _unused: [u8; 0],
}
pub type SCIP_HOLECHG = SCIP_HoleChg;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_Hole {
    _unused: [u8; 0],
}
pub type SCIP_HOLE = SCIP_Hole;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_Holelist {
    _unused: [u8; 0],
}
pub type SCIP_HOLELIST = SCIP_Holelist;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_Dom {
    _unused: [u8; 0],
}
pub type SCIP_DOM = SCIP_Dom;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_Original {
    _unused: [u8; 0],
}
pub type SCIP_ORIGINAL = SCIP_Original;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_Aggregate {
    _unused: [u8; 0],
}
pub type SCIP_AGGREGATE = SCIP_Aggregate;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_Multaggr {
    _unused: [u8; 0],
}
pub type SCIP_MULTAGGR = SCIP_Multaggr;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_Negate {
    _unused: [u8; 0],
}
pub type SCIP_NEGATE = SCIP_Negate;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_Var {
    _unused: [u8; 0],
}
pub type SCIP_VAR = SCIP_Var;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_VarData {
    _unused: [u8; 0],
}
pub type SCIP_VARDATA = SCIP_VarData;
#[doc = "< maximization of objective function"]
pub const SCIP_Objsense_SCIP_OBJSENSE_MAXIMIZE: SCIP_Objsense = -1;
#[doc = "< minimization of objective function (the default)"]
pub const SCIP_Objsense_SCIP_OBJSENSE_MINIMIZE: SCIP_Objsense = 1;
#[doc = " objective sense: minimization or maximization"]
pub type SCIP_Objsense = ::std::os::raw::c_int;
#[doc = " objective sense: minimization or maximization"]
pub use self::SCIP_Objsense as SCIP_OBJSENSE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_Prob {
    _unused: [u8; 0],
}
pub type SCIP_PROB = SCIP_Prob;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_ProbData {
    _unused: [u8; 0],
}
pub type SCIP_PROBDATA = SCIP_ProbData;
#[doc = "< the focus node, whose data is stored in the tree data structure"]
pub const SCIP_NodeType_SCIP_NODETYPE_FOCUSNODE: SCIP_NodeType = 0;
#[doc = "< temporary child node of the focus or refocused node used for probing"]
pub const SCIP_NodeType_SCIP_NODETYPE_PROBINGNODE: SCIP_NodeType = 1;
#[doc = "< unsolved sibling of the focus node"]
pub const SCIP_NodeType_SCIP_NODETYPE_SIBLING: SCIP_NodeType = 2;
#[doc = "< unsolved child of the focus node"]
pub const SCIP_NodeType_SCIP_NODETYPE_CHILD: SCIP_NodeType = 3;
#[doc = "< unsolved leaf of the tree, stored in the tree's queue"]
pub const SCIP_NodeType_SCIP_NODETYPE_LEAF: SCIP_NodeType = 4;
#[doc = "< temporary type of focus node, if it was solved completely"]
pub const SCIP_NodeType_SCIP_NODETYPE_DEADEND: SCIP_NodeType = 5;
#[doc = "< fork without LP solution"]
pub const SCIP_NodeType_SCIP_NODETYPE_JUNCTION: SCIP_NodeType = 6;
#[doc = "< fork without LP solution and added rows and columns"]
pub const SCIP_NodeType_SCIP_NODETYPE_PSEUDOFORK: SCIP_NodeType = 7;
#[doc = "< fork with solved LP and added rows and columns"]
pub const SCIP_NodeType_SCIP_NODETYPE_FORK: SCIP_NodeType = 8;
#[doc = "< fork with solved LP and arbitrarily changed rows and columns"]
pub const SCIP_NodeType_SCIP_NODETYPE_SUBROOT: SCIP_NodeType = 9;
#[doc = "< junction, fork, or subroot that was refocused for domain propagation"]
pub const SCIP_NodeType_SCIP_NODETYPE_REFOCUSNODE: SCIP_NodeType = 10;
pub type SCIP_NodeType = ::std::os::raw::c_uint;
pub use self::SCIP_NodeType as SCIP_NODETYPE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_Probingnode {
    _unused: [u8; 0],
}
pub type SCIP_PROBINGNODE = SCIP_Probingnode;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_Sibling {
    _unused: [u8; 0],
}
pub type SCIP_SIBLING = SCIP_Sibling;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_Child {
    _unused: [u8; 0],
}
pub type SCIP_CHILD = SCIP_Child;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_Leaf {
    _unused: [u8; 0],
}
pub type SCIP_LEAF = SCIP_Leaf;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_Junction {
    _unused: [u8; 0],
}
pub type SCIP_JUNCTION = SCIP_Junction;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_Pseudofork {
    _unused: [u8; 0],
}
pub type SCIP_PSEUDOFORK = SCIP_Pseudofork;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_Fork {
    _unused: [u8; 0],
}
pub type SCIP_FORK = SCIP_Fork;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_Subroot {
    _unused: [u8; 0],
}
pub type SCIP_SUBROOT = SCIP_Subroot;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_Node {
    _unused: [u8; 0],
}
pub type SCIP_NODE = SCIP_Node;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_PendingBdchg {
    _unused: [u8; 0],
}
pub type SCIP_PENDINGBDCHG = SCIP_PendingBdchg;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_Tree {
    _unused: [u8; 0],
}
pub type SCIP_TREE = SCIP_Tree;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_Bandit {
    _unused: [u8; 0],
}
#[doc = " data structure for bandit algorithms"]
pub type SCIP_BANDIT = SCIP_Bandit;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_BanditVTable {
    _unused: [u8; 0],
}
#[doc = " virtual function table for bandit callbacks"]
pub type SCIP_BANDITVTABLE = SCIP_BanditVTable;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_BanditData {
    _unused: [u8; 0],
}
#[doc = " data structure for specific bandit algorithm implementation"]
pub type SCIP_BANDITDATA = SCIP_BanditData;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_BranchCand {
    _unused: [u8; 0],
}
pub type SCIP_BRANCHCAND = SCIP_BranchCand;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_Branchrule {
    _unused: [u8; 0],
}
pub type SCIP_BRANCHRULE = SCIP_Branchrule;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_BranchruleData {
    _unused: [u8; 0],
}
pub type SCIP_BRANCHRULEDATA = SCIP_BranchruleData;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_Treemodel {
    _unused: [u8; 0],
}
pub type SCIP_TREEMODEL = SCIP_Treemodel;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_Conflicthdlr {
    _unused: [u8; 0],
}
pub type SCIP_CONFLICTHDLR = SCIP_Conflicthdlr;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_ConflicthdlrData {
    _unused: [u8; 0],
}
pub type SCIP_CONFLICTHDLRDATA = SCIP_ConflicthdlrData;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_ConflictSet {
    _unused: [u8; 0],
}
pub type SCIP_CONFLICTSET = SCIP_ConflictSet;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_ProofSet {
    _unused: [u8; 0],
}
pub type SCIP_PROOFSET = SCIP_ProofSet;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_LPBdChgs {
    _unused: [u8; 0],
}
pub type SCIP_LPBDCHGS = SCIP_LPBdChgs;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_Conflict {
    _unused: [u8; 0],
}
pub type SCIP_CONFLICT = SCIP_Conflict;
#[doc = "< unknown type"]
pub const SCIP_ConflictType_SCIP_CONFTYPE_UNKNOWN: SCIP_ConflictType = 0;
#[doc = "< conflict results from propagation"]
pub const SCIP_ConflictType_SCIP_CONFTYPE_PROPAGATION: SCIP_ConflictType = 1;
#[doc = "< conflict results from an infeasible LP relaxation"]
pub const SCIP_ConflictType_SCIP_CONFTYPE_INFEASLP: SCIP_ConflictType = 2;
#[doc = "< conflict results from a boundexceeding LP relaxation"]
pub const SCIP_ConflictType_SCIP_CONFTYPE_BNDEXCEEDING: SCIP_ConflictType = 3;
#[doc = "< alternative proof of an infeasible LP relaxation"]
pub const SCIP_ConflictType_SCIP_CONFTYPE_ALTINFPROOF: SCIP_ConflictType = 4;
#[doc = "< alternative proof of a boundexceeding LP relaxation"]
pub const SCIP_ConflictType_SCIP_CONFTYPE_ALTBNDPROOF: SCIP_ConflictType = 5;
#[doc = " types of conflicts"]
pub type SCIP_ConflictType = ::std::os::raw::c_uint;
#[doc = " types of conflicts"]
pub use self::SCIP_ConflictType as SCIP_CONFTYPE;
#[doc = "< no presolving"]
pub const SCIP_ConflictPresolStrat_SCIP_CONFPRES_DISABLED: SCIP_ConflictPresolStrat = 0;
#[doc = "< keep variables contributing with its local bound"]
pub const SCIP_ConflictPresolStrat_SCIP_CONFPRES_ONLYLOCAL: SCIP_ConflictPresolStrat = 1;
#[doc = "< keep variables contributing with its global bound"]
pub const SCIP_ConflictPresolStrat_SCIP_CONFPRES_ONLYGLOBAL: SCIP_ConflictPresolStrat = 2;
#[doc = "< keep variables contributing with its global bound and add a few\n   variables contributing with its local bound such that the\n   constraint is not globally redundant"]
pub const SCIP_ConflictPresolStrat_SCIP_CONFPRES_BOTH: SCIP_ConflictPresolStrat = 3;
#[doc = " dualray presolving strategy"]
pub type SCIP_ConflictPresolStrat = ::std::os::raw::c_uint;
#[doc = " dualray presolving strategy"]
pub use self::SCIP_ConflictPresolStrat as SCIP_CONFPRES;
#[doc = "< solution describes original variables; non-cached elements are zero"]
pub const SCIP_SolOrigin_SCIP_SOLORIGIN_ORIGINAL: SCIP_SolOrigin = 0;
#[doc = "< all non-cached elements in solution are equal to zero"]
pub const SCIP_SolOrigin_SCIP_SOLORIGIN_ZERO: SCIP_SolOrigin = 1;
#[doc = "< all non-cached elements in solution are equal to current LP solution"]
pub const SCIP_SolOrigin_SCIP_SOLORIGIN_LPSOL: SCIP_SolOrigin = 2;
#[doc = "< all non-cached elements in solution are equal to current NLP solution"]
pub const SCIP_SolOrigin_SCIP_SOLORIGIN_NLPSOL: SCIP_SolOrigin = 3;
#[doc = "< all non-cached elements in solution are equal to current relaxation solution"]
pub const SCIP_SolOrigin_SCIP_SOLORIGIN_RELAXSOL: SCIP_SolOrigin = 4;
#[doc = "< all non-cached elements in solution are equal to current pseudo solution"]
pub const SCIP_SolOrigin_SCIP_SOLORIGIN_PSEUDOSOL: SCIP_SolOrigin = 5;
#[doc = "< solution describes original solution; all non-cached elements in solution\n   are treated as being an arbitrary value in the variable's bounds"]
pub const SCIP_SolOrigin_SCIP_SOLORIGIN_PARTIAL: SCIP_SolOrigin = 6;
#[doc = "< all non-cached elements in solution are unknown; they have to be treated\n   as being an arbitrary value in the variable's bounds"]
pub const SCIP_SolOrigin_SCIP_SOLORIGIN_UNKNOWN: SCIP_SolOrigin = 7;
#[doc = " origin of solution: where to retrieve uncached elements"]
pub type SCIP_SolOrigin = ::std::os::raw::c_uint;
#[doc = " origin of solution: where to retrieve uncached elements"]
pub use self::SCIP_SolOrigin as SCIP_SOLORIGIN;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_Sol {
    _unused: [u8; 0],
}
pub type SCIP_SOL = SCIP_Sol;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_Viol {
    _unused: [u8; 0],
}
pub type SCIP_VIOL = SCIP_Viol;
#[doc = "< type of solution unspecified (the default)"]
pub const SCIP_SolType_SCIP_SOLTYPE_UNKNOWN: SCIP_SolType = 0;
#[doc = "< solution was found by a heuristic"]
pub const SCIP_SolType_SCIP_SOLTYPE_HEUR: SCIP_SolType = 1;
#[doc = "< solution was found by a relaxation"]
pub const SCIP_SolType_SCIP_SOLTYPE_RELAX: SCIP_SolType = 2;
#[doc = "< solution was found by the LP relaxation"]
pub const SCIP_SolType_SCIP_SOLTYPE_LPRELAX: SCIP_SolType = 3;
#[doc = "< solution was found during strong branching"]
pub const SCIP_SolType_SCIP_SOLTYPE_STRONGBRANCH: SCIP_SolType = 4;
#[doc = "< solution originates from a pseudo solution"]
pub const SCIP_SolType_SCIP_SOLTYPE_PSEUDO: SCIP_SolType = 5;
#[doc = " type of solution: heuristic or (LP) relaxation solution, or unspecified origin"]
pub type SCIP_SolType = ::std::os::raw::c_uint;
#[doc = " type of solution: heuristic or (LP) relaxation solution, or unspecified origin"]
pub use self::SCIP_SolType as SCIP_SOLTYPE;
pub type SCIP_DIVETYPE = ::std::os::raw::c_uint;
#[doc = "< all contexts combined"]
pub const SCIP_DiveContext_SCIP_DIVECONTEXT_TOTAL: SCIP_DiveContext = 0;
#[doc = "< single heuristic context"]
pub const SCIP_DiveContext_SCIP_DIVECONTEXT_SINGLE: SCIP_DiveContext = 1;
#[doc = "< within adaptive diving"]
pub const SCIP_DiveContext_SCIP_DIVECONTEXT_ADAPTIVE: SCIP_DiveContext = 2;
#[doc = "< within the scheduler heuristic"]
pub const SCIP_DiveContext_SCIP_DIVECONTEXT_SCHEDULER: SCIP_DiveContext = 3;
#[doc = " context for diving statistics"]
pub type SCIP_DiveContext = ::std::os::raw::c_uint;
#[doc = " context for diving statistics"]
pub use self::SCIP_DiveContext as SCIP_DIVECONTEXT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_Heur {
    _unused: [u8; 0],
}
pub type SCIP_HEUR = SCIP_Heur;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_HeurData {
    _unused: [u8; 0],
}
pub type SCIP_HEURDATA = SCIP_HeurData;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_Diveset {
    _unused: [u8; 0],
}
pub type SCIP_DIVESET = SCIP_Diveset;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_VGraph {
    _unused: [u8; 0],
}
pub type SCIP_VGRAPH = SCIP_VGraph;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_Conshdlr {
    _unused: [u8; 0],
}
pub type SCIP_CONSHDLR = SCIP_Conshdlr;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_Cons {
    _unused: [u8; 0],
}
pub type SCIP_CONS = SCIP_Cons;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_ConshdlrData {
    _unused: [u8; 0],
}
pub type SCIP_CONSHDLRDATA = SCIP_ConshdlrData;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_ConsData {
    _unused: [u8; 0],
}
pub type SCIP_CONSDATA = SCIP_ConsData;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_ConsSetChg {
    _unused: [u8; 0],
}
pub type SCIP_CONSSETCHG = SCIP_ConsSetChg;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_LinConsStats {
    _unused: [u8; 0],
}
pub type SCIP_LINCONSSTATS = SCIP_LinConsStats;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SYM_Graph {
    _unused: [u8; 0],
}
pub type SYM_GRAPH = SYM_Graph;
#[doc = "< linear constraints with no variables"]
pub const SCIP_LinConstype_SCIP_LINCONSTYPE_EMPTY: SCIP_LinConstype = 0;
#[doc = "< linear constraints with no finite side"]
pub const SCIP_LinConstype_SCIP_LINCONSTYPE_FREE: SCIP_LinConstype = 1;
#[doc = "< linear constraints with a single variable"]
pub const SCIP_LinConstype_SCIP_LINCONSTYPE_SINGLETON: SCIP_LinConstype = 2;
#[doc = "< linear constraints of the type \\f$ ax + by = c\\f$"]
pub const SCIP_LinConstype_SCIP_LINCONSTYPE_AGGREGATION: SCIP_LinConstype = 3;
#[doc = "< linear constraints of the type \\f$ a x - a y \\leq b\\f$ where \\f$x\\f$ and \\f$y\\f$ must have the same type"]
pub const SCIP_LinConstype_SCIP_LINCONSTYPE_PRECEDENCE: SCIP_LinConstype = 4;
#[doc = "< linear constraints of the form \\f$ ax + by \\leq c \\, x \\in \\{0,1\\} \\f$"]
pub const SCIP_LinConstype_SCIP_LINCONSTYPE_VARBOUND: SCIP_LinConstype = 5;
#[doc = "< linear constraints of the form \\f$ \\sum x_i = 1\\, x_i \\in \\{0,1\\} \\forall i \\f$"]
pub const SCIP_LinConstype_SCIP_LINCONSTYPE_SETPARTITION: SCIP_LinConstype = 6;
#[doc = "< linear constraints of the form \\f$ \\sum x_i \\leq 1\\, x_i \\in \\{0,1\\} \\forall i \\f$"]
pub const SCIP_LinConstype_SCIP_LINCONSTYPE_SETPACKING: SCIP_LinConstype = 7;
#[doc = "< linear constraints of the form \\f$ \\sum x_i \\geq 1\\, x_i \\in \\{0,1\\} \\forall i \\f$"]
pub const SCIP_LinConstype_SCIP_LINCONSTYPE_SETCOVERING: SCIP_LinConstype = 8;
#[doc = "< linear constraints of the form \\f$ \\sum x_i = k\\, x_i \\in \\{0,1\\} \\forall i, \\, k\\geq 2 \\f$"]
pub const SCIP_LinConstype_SCIP_LINCONSTYPE_CARDINALITY: SCIP_LinConstype = 9;
#[doc = "< linear constraints of the form \\f$ \\sum x_i \\leq b\\, x_i \\in \\{0,1\\} \\forall i, \\, b\\in \\mathbb{n} \\geq 2 \\f$"]
pub const SCIP_LinConstype_SCIP_LINCONSTYPE_INVKNAPSACK: SCIP_LinConstype = 10;
#[doc = "< linear constraints of the form \\f$ \\sum a_i x_i = b\\, x_i \\in \\{0,1\\} \\forall i, \\, b\\in \\mathbb{n} \\geq 2 \\f$"]
pub const SCIP_LinConstype_SCIP_LINCONSTYPE_EQKNAPSACK: SCIP_LinConstype = 11;
#[doc = "< linear constraints of the form \\f$ \\sum a_i x_i + a x \\leq a\\, x, x_i \\in \\{0,1\\} \\forall i, \\, a\\in \\mathbb{n} \\geq 2 \\f$"]
pub const SCIP_LinConstype_SCIP_LINCONSTYPE_BINPACKING: SCIP_LinConstype = 12;
#[doc = "< linear constraints of the form \\f$ \\sum a_k x_k \\leq b\\, x_i \\in \\{0,1\\} \\forall i, \\, b\\in \\mathbb{n} \\geq 2 \\f$"]
pub const SCIP_LinConstype_SCIP_LINCONSTYPE_KNAPSACK: SCIP_LinConstype = 13;
#[doc = "< linear constraints of the form \\f$ \\sum a_k x_k \\leq b\\, x_i \\in \\mathbb{Z} \\forall i, \\, b\\in \\mathbb{n} \\f$"]
pub const SCIP_LinConstype_SCIP_LINCONSTYPE_INTKNAPSACK: SCIP_LinConstype = 14;
#[doc = "< linear constraints of the form \\f$ \\sum a_k x_k + \\sum p_j s_j \\leq/= b\\, x_i \\in \\{0,1\\} \\forall i, s_j \\in \\text{ cont. } \\forall j\\f$"]
pub const SCIP_LinConstype_SCIP_LINCONSTYPE_MIXEDBINARY: SCIP_LinConstype = 15;
#[doc = "< general linear constraints with no special structure"]
pub const SCIP_LinConstype_SCIP_LINCONSTYPE_GENERAL: SCIP_LinConstype = 16;
#[doc = " linear constraint types recognizable"]
pub type SCIP_LinConstype = ::std::os::raw::c_uint;
#[doc = " linear constraint types recognizable"]
pub use self::SCIP_LinConstype as SCIP_LINCONSTYPE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_Dialog {
    _unused: [u8; 0],
}
pub type SCIP_DIALOG = SCIP_Dialog;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_DialogData {
    _unused: [u8; 0],
}
pub type SCIP_DIALOGDATA = SCIP_DialogData;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_Dialoghdlr {
    _unused: [u8; 0],
}
pub type SCIP_DIALOGHDLR = SCIP_Dialoghdlr;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_Linelist {
    _unused: [u8; 0],
}
pub type SCIP_LINELIST = SCIP_Linelist;
#[doc = "< display column is not displayed"]
pub const SCIP_DispStatus_SCIP_DISPSTATUS_OFF: SCIP_DispStatus = 0;
#[doc = "< display column is switched on and off automatically"]
pub const SCIP_DispStatus_SCIP_DISPSTATUS_AUTO: SCIP_DispStatus = 1;
#[doc = "< display column is displayed"]
pub const SCIP_DispStatus_SCIP_DISPSTATUS_ON: SCIP_DispStatus = 2;
#[doc = " display activation status of display column"]
pub type SCIP_DispStatus = ::std::os::raw::c_uint;
#[doc = " display activation status of display column"]
pub use self::SCIP_DispStatus as SCIP_DISPSTATUS;
#[doc = "< display column is displayed only in sequential mode"]
pub const SCIP_DispMode_SCIP_DISPMODE_DEFAULT: SCIP_DispMode = 1;
#[doc = "< display column is displayed only in concurrent mode"]
pub const SCIP_DispMode_SCIP_DISPMODE_CONCURRENT: SCIP_DispMode = 2;
#[doc = "< display column is displayed in concurrent and sequential mode"]
pub const SCIP_DispMode_SCIP_DISPMODE_ALL: SCIP_DispMode = 3;
#[doc = " display activation status of display column"]
pub type SCIP_DispMode = ::std::os::raw::c_uint;
#[doc = " display activation status of display column"]
pub use self::SCIP_DispMode as SCIP_DISPMODE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_Disp {
    _unused: [u8; 0],
}
pub type SCIP_DISP = SCIP_Disp;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_DispData {
    _unused: [u8; 0],
}
pub type SCIP_DISPDATA = SCIP_DispData;
#[doc = " interval given by infimum and supremum"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_Interval {
    #[doc = "< infimum (lower bound) of interval"]
    pub inf: f64,
    #[doc = "< supremum (upper bound) of interval"]
    pub sup: f64,
}
#[test]
fn bindgen_test_layout_SCIP_Interval() {
    const UNINIT: ::std::mem::MaybeUninit<SCIP_Interval> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<SCIP_Interval>(),
        16usize,
        concat!("Size of: ", stringify!(SCIP_Interval))
    );
    assert_eq!(
        ::std::mem::align_of::<SCIP_Interval>(),
        8usize,
        concat!("Alignment of ", stringify!(SCIP_Interval))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).inf) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SCIP_Interval),
            "::",
            stringify!(inf)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sup) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SCIP_Interval),
            "::",
            stringify!(sup)
        )
    );
}
#[doc = " interval given by infimum and supremum"]
pub type SCIP_INTERVAL = SCIP_Interval;
#[doc = " rounding mode of floating point operations (upwards, downwards, nearest, ...)\n\n exact values depend on machine and compiler"]
pub type SCIP_ROUNDMODE = ::std::os::raw::c_int;
extern "C" {
    #[doc = " returns whether rounding mode control is available"]
    pub fn SCIPintervalHasRoundingControl() -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " sets rounding mode of floating point operations"]
    pub fn SCIPintervalSetRoundingMode(roundmode: SCIP_ROUNDMODE);
}
extern "C" {
    #[doc = " gets current rounding mode of floating point operations"]
    pub fn SCIPintervalGetRoundingMode() -> SCIP_ROUNDMODE;
}
extern "C" {
    #[doc = " sets rounding mode of floating point operations to downwards rounding"]
    pub fn SCIPintervalSetRoundingModeDownwards();
}
extern "C" {
    #[doc = " sets rounding mode of floating point operations to upwards rounding"]
    pub fn SCIPintervalSetRoundingModeUpwards();
}
extern "C" {
    #[doc = " sets rounding mode of floating point operations to nearest rounding"]
    pub fn SCIPintervalSetRoundingModeToNearest();
}
extern "C" {
    #[doc = " sets rounding mode of floating point operations to towards zero rounding"]
    pub fn SCIPintervalSetRoundingModeTowardsZero();
}
extern "C" {
    #[doc = " negates a number in a way that the compiler does not optimize it away"]
    pub fn SCIPintervalNegateReal(x: f64) -> f64;
}
extern "C" {
    #[doc = " returns infimum of interval"]
    pub fn SCIPintervalGetInf(interval: SCIP_INTERVAL) -> f64;
}
extern "C" {
    #[doc = " returns supremum of interval"]
    pub fn SCIPintervalGetSup(interval: SCIP_INTERVAL) -> f64;
}
extern "C" {
    #[doc = " stores given value as interval"]
    pub fn SCIPintervalSet(resultant: *mut SCIP_INTERVAL, value: f64);
}
extern "C" {
    #[doc = " stores given infimum and supremum as interval"]
    pub fn SCIPintervalSetBounds(resultant: *mut SCIP_INTERVAL, inf: f64, sup: f64);
}
extern "C" {
    #[doc = " sets interval to empty interval, which will be [1.0, -1.0]"]
    pub fn SCIPintervalSetEmpty(resultant: *mut SCIP_INTERVAL);
}
extern "C" {
    #[doc = " indicates whether interval is empty, i.e., whether inf > sup"]
    pub fn SCIPintervalIsEmpty(infinity: f64, operand: SCIP_INTERVAL) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " sets interval to entire [-infinity, +infinity]"]
    pub fn SCIPintervalSetEntire(infinity: f64, resultant: *mut SCIP_INTERVAL);
}
extern "C" {
    #[doc = " indicates whether interval is entire, i.e., whether inf &le; -infinity and sup &ge; infinity"]
    pub fn SCIPintervalIsEntire(infinity: f64, operand: SCIP_INTERVAL) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " indicates whether interval is positive infinity, i.e., [infinity, infinity]"]
    pub fn SCIPintervalIsPositiveInfinity(
        infinity: f64,
        operand: SCIP_INTERVAL,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " indicates whether interval is negative infinity, i.e., [-infinity, -infinity]"]
    pub fn SCIPintervalIsNegativeInfinity(
        infinity: f64,
        operand: SCIP_INTERVAL,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " indicates whether operand1 is contained in operand2"]
    pub fn SCIPintervalIsSubsetEQ(
        infinity: f64,
        operand1: SCIP_INTERVAL,
        operand2: SCIP_INTERVAL,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " indicates whether operand1 and operand2 are disjoint"]
    pub fn SCIPintervalAreDisjoint(
        operand1: SCIP_INTERVAL,
        operand2: SCIP_INTERVAL,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " indicates whether operand1 and operand2 are disjoint with epsilon tolerance\n\n Returns whether minimal (relative) distance of intervals is larger than epsilon.\n Same as `SCIPintervalIsEmpty(SCIPintervalIntersectEps(operand1, operand2))`."]
    pub fn SCIPintervalAreDisjointEps(
        eps: f64,
        operand1: SCIP_INTERVAL,
        operand2: SCIP_INTERVAL,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " intersection of two intervals"]
    pub fn SCIPintervalIntersect(
        resultant: *mut SCIP_INTERVAL,
        operand1: SCIP_INTERVAL,
        operand2: SCIP_INTERVAL,
    );
}
extern "C" {
    #[doc = " intersection of two intervals with epsilon tolerance\n\n If intersection of operand1 and operand2 is empty, but minimal (relative) distance of intervals\n is at most epsilon, then set resultant to singleton containing the point in operand1\n that is closest to operand2, i.e.,\n - `resultant = { operand1.sup }`, if `operand1.sup` < `operand2.inf` and `reldiff(operand2.inf,operand1.sup)` &le; eps\n - `resultant = { operand1.inf }`, if `operand1.inf` > `operand2.sup` and `reldiff(operand1.inf,operand2.sup)` &le; eps\n - `resultant` = intersection of `operand1` and `operand2`, otherwise"]
    pub fn SCIPintervalIntersectEps(
        resultant: *mut SCIP_INTERVAL,
        eps: f64,
        operand1: SCIP_INTERVAL,
        operand2: SCIP_INTERVAL,
    );
}
extern "C" {
    #[doc = " interval enclosure of the union of two intervals"]
    pub fn SCIPintervalUnify(
        resultant: *mut SCIP_INTERVAL,
        operand1: SCIP_INTERVAL,
        operand2: SCIP_INTERVAL,
    );
}
extern "C" {
    #[doc = " adds operand1 and operand2 and stores infimum of result in infimum of resultant"]
    pub fn SCIPintervalAddInf(
        infinity: f64,
        resultant: *mut SCIP_INTERVAL,
        operand1: SCIP_INTERVAL,
        operand2: SCIP_INTERVAL,
    );
}
extern "C" {
    #[doc = " adds operand1 and operand2 and stores supremum of result in supremum of resultant"]
    pub fn SCIPintervalAddSup(
        infinity: f64,
        resultant: *mut SCIP_INTERVAL,
        operand1: SCIP_INTERVAL,
        operand2: SCIP_INTERVAL,
    );
}
extern "C" {
    #[doc = " adds operand1 and operand2 and stores result in resultant"]
    pub fn SCIPintervalAdd(
        infinity: f64,
        resultant: *mut SCIP_INTERVAL,
        operand1: SCIP_INTERVAL,
        operand2: SCIP_INTERVAL,
    );
}
extern "C" {
    #[doc = " adds operand1 and scalar operand2 and stores result in resultant"]
    pub fn SCIPintervalAddScalar(
        infinity: f64,
        resultant: *mut SCIP_INTERVAL,
        operand1: SCIP_INTERVAL,
        operand2: f64,
    );
}
extern "C" {
    #[doc = " adds vector operand1 and vector operand2 and stores result in vector resultant"]
    pub fn SCIPintervalAddVectors(
        infinity: f64,
        resultant: *mut SCIP_INTERVAL,
        length: ::std::os::raw::c_int,
        operand1: *mut SCIP_INTERVAL,
        operand2: *mut SCIP_INTERVAL,
    );
}
extern "C" {
    #[doc = " subtracts operand2 from operand1 and stores result in resultant"]
    pub fn SCIPintervalSub(
        infinity: f64,
        resultant: *mut SCIP_INTERVAL,
        operand1: SCIP_INTERVAL,
        operand2: SCIP_INTERVAL,
    );
}
extern "C" {
    #[doc = " subtracts scalar operand2 from operand1 and stores result in resultant"]
    pub fn SCIPintervalSubScalar(
        infinity: f64,
        resultant: *mut SCIP_INTERVAL,
        operand1: SCIP_INTERVAL,
        operand2: f64,
    );
}
extern "C" {
    #[doc = " multiplies operand1 with operand2 and stores infimum of result in infimum of resultant"]
    pub fn SCIPintervalMulInf(
        infinity: f64,
        resultant: *mut SCIP_INTERVAL,
        operand1: SCIP_INTERVAL,
        operand2: SCIP_INTERVAL,
    );
}
extern "C" {
    #[doc = " multiplies operand1 with operand2 and stores supremum of result in supremum of resultant"]
    pub fn SCIPintervalMulSup(
        infinity: f64,
        resultant: *mut SCIP_INTERVAL,
        operand1: SCIP_INTERVAL,
        operand2: SCIP_INTERVAL,
    );
}
extern "C" {
    #[doc = " multiplies operand1 with operand2 and stores result in resultant"]
    pub fn SCIPintervalMul(
        infinity: f64,
        resultant: *mut SCIP_INTERVAL,
        operand1: SCIP_INTERVAL,
        operand2: SCIP_INTERVAL,
    );
}
extern "C" {
    #[doc = " multiplies operand1 with scalar operand2 and stores infimum of result in infimum of resultant"]
    pub fn SCIPintervalMulScalarInf(
        infinity: f64,
        resultant: *mut SCIP_INTERVAL,
        operand1: SCIP_INTERVAL,
        operand2: f64,
    );
}
extern "C" {
    #[doc = " multiplies operand1 with scalar operand2 and stores supremum of result in supremum of resultant"]
    pub fn SCIPintervalMulScalarSup(
        infinity: f64,
        resultant: *mut SCIP_INTERVAL,
        operand1: SCIP_INTERVAL,
        operand2: f64,
    );
}
extern "C" {
    #[doc = " multiplies operand1 with scalar operand2 and stores result in resultant"]
    pub fn SCIPintervalMulScalar(
        infinity: f64,
        resultant: *mut SCIP_INTERVAL,
        operand1: SCIP_INTERVAL,
        operand2: f64,
    );
}
extern "C" {
    #[doc = " divides operand1 by operand2 and stores result in resultant"]
    pub fn SCIPintervalDiv(
        infinity: f64,
        resultant: *mut SCIP_INTERVAL,
        operand1: SCIP_INTERVAL,
        operand2: SCIP_INTERVAL,
    );
}
extern "C" {
    #[doc = " divides operand1 by scalar operand2 and stores result in resultant"]
    pub fn SCIPintervalDivScalar(
        infinity: f64,
        resultant: *mut SCIP_INTERVAL,
        operand1: SCIP_INTERVAL,
        operand2: f64,
    );
}
extern "C" {
    #[doc = " computes the scalar product of two vectors of intervals and stores result in resultant"]
    pub fn SCIPintervalScalprod(
        infinity: f64,
        resultant: *mut SCIP_INTERVAL,
        length: ::std::os::raw::c_int,
        operand1: *mut SCIP_INTERVAL,
        operand2: *mut SCIP_INTERVAL,
    );
}
extern "C" {
    #[doc = " computes the scalar product of a vector of intervals and a vector of scalars and stores infimum of result in infimum of resultant"]
    pub fn SCIPintervalScalprodScalarsInf(
        infinity: f64,
        resultant: *mut SCIP_INTERVAL,
        length: ::std::os::raw::c_int,
        operand1: *mut SCIP_INTERVAL,
        operand2: *mut f64,
    );
}
extern "C" {
    #[doc = " computes the scalar product of a vector of intervals and a vector of scalars and stores supremum of result in supremum of resultant"]
    pub fn SCIPintervalScalprodScalarsSup(
        infinity: f64,
        resultant: *mut SCIP_INTERVAL,
        length: ::std::os::raw::c_int,
        operand1: *mut SCIP_INTERVAL,
        operand2: *mut f64,
    );
}
extern "C" {
    #[doc = " computes the scalar product of a vector of intervals and a vector of scalars and stores result in resultant"]
    pub fn SCIPintervalScalprodScalars(
        infinity: f64,
        resultant: *mut SCIP_INTERVAL,
        length: ::std::os::raw::c_int,
        operand1: *mut SCIP_INTERVAL,
        operand2: *mut f64,
    );
}
extern "C" {
    #[doc = " squares operand and stores result in resultant"]
    pub fn SCIPintervalSquare(infinity: f64, resultant: *mut SCIP_INTERVAL, operand: SCIP_INTERVAL);
}
extern "C" {
    #[doc = " stores (positive part of) square root of operand in resultant\n @attention we assume a correctly rounded sqrt(double) function when rounding is to nearest"]
    pub fn SCIPintervalSquareRoot(
        infinity: f64,
        resultant: *mut SCIP_INTERVAL,
        operand: SCIP_INTERVAL,
    );
}
extern "C" {
    #[doc = " stores operand1 to the power of operand2 in resultant\n\n uses SCIPintervalPowerScalar if operand2 is a scalar, otherwise computes exp(op2*log(op1))"]
    pub fn SCIPintervalPower(
        infinity: f64,
        resultant: *mut SCIP_INTERVAL,
        operand1: SCIP_INTERVAL,
        operand2: SCIP_INTERVAL,
    );
}
extern "C" {
    #[doc = " stores operand1 to the power of the scalar operand2 in resultant\n @attention we assume a correctly rounded pow(double) function when rounding is to nearest"]
    pub fn SCIPintervalPowerScalar(
        infinity: f64,
        resultant: *mut SCIP_INTERVAL,
        operand1: SCIP_INTERVAL,
        operand2: f64,
    );
}
extern "C" {
    #[doc = " stores bounds on the power of a scalar operand1 to a scalar operand2 in resultant\n\n Both operands need to be finite numbers.\n Needs to have operand1 &ge; 0 or operand2 integer and needs to have operand2 &ge; 0 if operand1 = 0.\n @attention we assume a correctly rounded pow(double) function when rounding is to nearest"]
    pub fn SCIPintervalPowerScalarScalar(
        resultant: *mut SCIP_INTERVAL,
        operand1: f64,
        operand2: f64,
    );
}
extern "C" {
    #[doc = " computes lower bound on power of a scalar operand1 to an integer operand2\n\n Both operands need to be finite numbers.\n Needs to have operand1 &ge; 0 and need to have operand2 &ge; 0 if operand1 = 0."]
    pub fn SCIPintervalPowerScalarIntegerInf(operand1: f64, operand2: ::std::os::raw::c_int)
        -> f64;
}
extern "C" {
    #[doc = " computes upper bound on power of a scalar operand1 to an integer operand2\n\n Both operands need to be finite numbers.\n Needs to have operand1 &ge; 0 and needs to have operand2 &ge; 0 if operand1 = 0."]
    pub fn SCIPintervalPowerScalarIntegerSup(operand1: f64, operand2: ::std::os::raw::c_int)
        -> f64;
}
extern "C" {
    #[doc = " computes bounds on power of a scalar operand1 to an integer operand2\n\n Both operands need to be finite numbers.\n Needs to have operand1 &ge; 0 and needs to have operand2 &ge; 0 if operand1 = 0."]
    pub fn SCIPintervalPowerScalarInteger(
        resultant: *mut SCIP_INTERVAL,
        operand1: f64,
        operand2: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " given an interval for the image of a power operation, computes an interval for the origin\n\n That is, for \\f$y = x^p\\f$ with the exponent \\f$p\\f$ a given scalar and \\f$y\\f$ = `image` a given interval,\n computes \\f$x \\subseteq \\text{basedomain}\\f$ such that \\f$y \\in x^p\\f$ and such that for all \\f$z \\in \\text{basedomain} \\setminus x: z^p \\not \\in y\\f$."]
    pub fn SCIPintervalPowerScalarInverse(
        infinity: f64,
        resultant: *mut SCIP_INTERVAL,
        basedomain: SCIP_INTERVAL,
        exponent: f64,
        image: SCIP_INTERVAL,
    );
}
extern "C" {
    #[doc = " stores operand1 to the signed power of the scalar positive operand2 in resultant\n\n The signed power of x w.r.t. an exponent n &ge; 0 is given as \\f$\\mathrm{sign}(x) |x|^n\\f$.\n\n @attention we assume correctly rounded sqrt(double) and pow(double) functions when rounding is to nearest"]
    pub fn SCIPintervalSignPowerScalar(
        infinity: f64,
        resultant: *mut SCIP_INTERVAL,
        operand1: SCIP_INTERVAL,
        operand2: f64,
    );
}
extern "C" {
    #[doc = " computes the reciprocal of an interval"]
    pub fn SCIPintervalReciprocal(
        infinity: f64,
        resultant: *mut SCIP_INTERVAL,
        operand: SCIP_INTERVAL,
    );
}
extern "C" {
    #[doc = " stores exponential of operand in resultant\n @attention we assume a correctly rounded exp(double) function when rounding is to nearest"]
    pub fn SCIPintervalExp(infinity: f64, resultant: *mut SCIP_INTERVAL, operand: SCIP_INTERVAL);
}
extern "C" {
    #[doc = " stores natural logarithm of operand in resultant\n @attention we assume a correctly rounded log(double) function when rounding is to nearest"]
    pub fn SCIPintervalLog(infinity: f64, resultant: *mut SCIP_INTERVAL, operand: SCIP_INTERVAL);
}
extern "C" {
    #[doc = " stores minimum of operands in resultant"]
    pub fn SCIPintervalMin(
        infinity: f64,
        resultant: *mut SCIP_INTERVAL,
        operand1: SCIP_INTERVAL,
        operand2: SCIP_INTERVAL,
    );
}
extern "C" {
    #[doc = " stores maximum of operands in resultant"]
    pub fn SCIPintervalMax(
        infinity: f64,
        resultant: *mut SCIP_INTERVAL,
        operand1: SCIP_INTERVAL,
        operand2: SCIP_INTERVAL,
    );
}
extern "C" {
    #[doc = " stores absolute value of operand in resultant"]
    pub fn SCIPintervalAbs(infinity: f64, resultant: *mut SCIP_INTERVAL, operand: SCIP_INTERVAL);
}
extern "C" {
    #[doc = " stores sine value of operand in resultant"]
    pub fn SCIPintervalSin(infinity: f64, resultant: *mut SCIP_INTERVAL, operand: SCIP_INTERVAL);
}
extern "C" {
    #[doc = " stores cosine value of operand in resultant"]
    pub fn SCIPintervalCos(infinity: f64, resultant: *mut SCIP_INTERVAL, operand: SCIP_INTERVAL);
}
extern "C" {
    #[doc = " stores sign of operand in resultant"]
    pub fn SCIPintervalSign(infinity: f64, resultant: *mut SCIP_INTERVAL, operand: SCIP_INTERVAL);
}
extern "C" {
    #[doc = " stores entropy of operand in resultant"]
    pub fn SCIPintervalEntropy(
        infinity: f64,
        resultant: *mut SCIP_INTERVAL,
        operand: SCIP_INTERVAL,
    );
}
extern "C" {
    #[doc = " computes exact upper bound on \\f$ a x^2 + b x \\f$ for x in [xlb, xub], b an interval, and a scalar\n\n Uses Algorithm 2.2 from Domes and Neumaier: Constraint propagation on quadratic constraints (2008)."]
    pub fn SCIPintervalQuadUpperBound(
        infinity: f64,
        a: f64,
        b_: SCIP_INTERVAL,
        x: SCIP_INTERVAL,
    ) -> f64;
}
extern "C" {
    #[doc = " stores range of quadratic term in resultant\n\n given scalar a and intervals b and x, computes interval for \\f$ a x^2 + b x \\f$"]
    pub fn SCIPintervalQuad(
        infinity: f64,
        resultant: *mut SCIP_INTERVAL,
        sqrcoeff: f64,
        lincoeff: SCIP_INTERVAL,
        xrng: SCIP_INTERVAL,
    );
}
extern "C" {
    #[doc = " computes interval with positive solutions of a quadratic equation with interval coefficients\n\n Given intervals a, b, and c, this function computes an interval that contains all positive solutions of \\f$ a x^2 + b x \\in c\\f$ within xbnds."]
    pub fn SCIPintervalSolveUnivariateQuadExpressionPositive(
        infinity: f64,
        resultant: *mut SCIP_INTERVAL,
        sqrcoeff: SCIP_INTERVAL,
        lincoeff: SCIP_INTERVAL,
        rhs: SCIP_INTERVAL,
        xbnds: SCIP_INTERVAL,
    );
}
extern "C" {
    #[doc = " computes interval with negative solutions of a quadratic equation with interval coefficients\n\n Given intervals a, b, and c, this function computes an interval that contains all negative solutions of \\f$ a x^2 + b x \\in c\\f$ within xbnds."]
    pub fn SCIPintervalSolveUnivariateQuadExpressionNegative(
        infinity: f64,
        resultant: *mut SCIP_INTERVAL,
        sqrcoeff: SCIP_INTERVAL,
        lincoeff: SCIP_INTERVAL,
        rhs: SCIP_INTERVAL,
        xbnds: SCIP_INTERVAL,
    );
}
extern "C" {
    #[doc = " computes positive solutions of a quadratic equation with scalar coefficients\n\n Givens scalar a, b, and c, this function computes an interval that contains all positive solutions of \\f$ a x^2 + b x \\geq c\\f$ within xbnds.\n Implements Algorithm 3.2 from Domes and Neumaier: Constraint propagation on quadratic constraints (2008)."]
    pub fn SCIPintervalSolveUnivariateQuadExpressionPositiveAllScalar(
        infinity: f64,
        resultant: *mut SCIP_INTERVAL,
        sqrcoeff: f64,
        lincoeff: f64,
        rhs: f64,
        xbnds: SCIP_INTERVAL,
    );
}
extern "C" {
    #[doc = " solves a quadratic equation with interval coefficients\n\n Given intervals a, b and c, this function computes an interval that contains all solutions of \\f$ a x^2 + b x \\in c\\f$ within xbnds."]
    pub fn SCIPintervalSolveUnivariateQuadExpression(
        infinity: f64,
        resultant: *mut SCIP_INTERVAL,
        sqrcoeff: SCIP_INTERVAL,
        lincoeff: SCIP_INTERVAL,
        rhs: SCIP_INTERVAL,
        xbnds: SCIP_INTERVAL,
    );
}
extern "C" {
    #[doc = " stores range of bivariate quadratic term in resultant\n\n Given scalars \\f$a_x\\f$, \\f$a_y\\f$, \\f$a_{xy}\\f$, \\f$b_x\\f$, and \\f$b_y\\f$ and intervals for \\f$x\\f$ and \\f$y\\f$,\n computes interval for \\f$ a_x x^2 + a_y y^2 + a_{xy} x y + b_x x + b_y y \\f$.\n\n \\attention The operations are not applied rounding-safe here!"]
    pub fn SCIPintervalQuadBivar(
        infinity: f64,
        resultant: *mut SCIP_INTERVAL,
        ax: f64,
        ay: f64,
        axy: f64,
        bx: f64,
        by: f64,
        xbnds: SCIP_INTERVAL,
        ybnds: SCIP_INTERVAL,
    );
}
extern "C" {
    #[doc = " solves a bivariate quadratic equation for the first variable\n\n Given scalars \\f$a_x\\f$, \\f$a_y\\f$, \\f$a_{xy}\\f$, \\f$b_x\\f$ and \\f$b_y\\f$, and intervals for \\f$x\\f$, \\f$y\\f$, and rhs,\n computes \\f$ \\{ x \\in \\mathbf{x} : \\exists y \\in \\mathbf{y} : a_x x^2 + a_y y^2 + a_{xy} x y + b_x x + b_y y \\in \\mathbf{\\mbox{rhs}} \\} \\f$.\n\n \\attention the operations are not applied rounding-safe here"]
    pub fn SCIPintervalSolveBivariateQuadExpressionAllScalar(
        infinity: f64,
        resultant: *mut SCIP_INTERVAL,
        ax: f64,
        ay: f64,
        axy: f64,
        bx: f64,
        by: f64,
        rhs: SCIP_INTERVAL,
        xbnds: SCIP_INTERVAL,
        ybnds: SCIP_INTERVAL,
    );
}
extern "C" {
    #[doc = " propagates a weighted sum of intervals in a given interval\n\n Given \\f$\\text{constant} + \\sum_i \\text{weights}_i \\text{operands}_i \\in \\text{rhs}\\f$,\n computes possibly tighter interval for each term.\n\n @attention Valid values are returned in resultants only if any tightening has been found and no empty interval, that is, function returns with non-zero and `*infeasible` = FALSE.\n\n @return Number of terms for which resulting interval is smaller than operand interval."]
    pub fn SCIPintervalPropagateWeightedSum(
        infinity: f64,
        noperands: ::std::os::raw::c_int,
        operands: *mut SCIP_INTERVAL,
        weights: *mut f64,
        constant: f64,
        rhs: SCIP_INTERVAL,
        resultants: *mut SCIP_INTERVAL,
        infeasible: *mut ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_ExprData {
    _unused: [u8; 0],
}
pub type SCIP_EXPRDATA = SCIP_ExprData;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_Expr {
    _unused: [u8; 0],
}
pub type SCIP_EXPR = SCIP_Expr;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SYM_ExprData {
    _unused: [u8; 0],
}
pub type SYM_EXPRDATA = SYM_ExprData;
#[doc = "< unknown or indefinite curvature"]
pub const SCIP_EXPRCURV_SCIP_EXPRCURV_UNKNOWN: SCIP_EXPRCURV = 0;
#[doc = "< convex"]
pub const SCIP_EXPRCURV_SCIP_EXPRCURV_CONVEX: SCIP_EXPRCURV = 1;
#[doc = "< concave"]
pub const SCIP_EXPRCURV_SCIP_EXPRCURV_CONCAVE: SCIP_EXPRCURV = 2;
#[doc = "< linear = convex and concave"]
pub const SCIP_EXPRCURV_SCIP_EXPRCURV_LINEAR: SCIP_EXPRCURV = 3;
#[doc = " curvature types"]
pub type SCIP_EXPRCURV = ::std::os::raw::c_uint;
#[doc = "< unknown or non-monotone"]
pub const SCIP_MONOTONE_SCIP_MONOTONE_UNKNOWN: SCIP_MONOTONE = 0;
#[doc = "< increasing"]
pub const SCIP_MONOTONE_SCIP_MONOTONE_INC: SCIP_MONOTONE = 1;
#[doc = "< decreasing"]
pub const SCIP_MONOTONE_SCIP_MONOTONE_DEC: SCIP_MONOTONE = 2;
#[doc = "< constant = increasing and decreasing"]
pub const SCIP_MONOTONE_SCIP_MONOTONE_CONST: SCIP_MONOTONE = 3;
#[doc = " monotonicity"]
pub type SCIP_MONOTONE = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_Expr_OwnerData {
    _unused: [u8; 0],
}
#[doc = "@name Expression Owner */\n/**@{"]
pub type SCIP_EXPR_OWNERDATA = SCIP_Expr_OwnerData;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_Exprhdlr {
    _unused: [u8; 0],
}
#[doc = "@name Expression Handler */\n/**@{"]
pub type SCIP_EXPRHDLR = SCIP_Exprhdlr;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_ExprhdlrData {
    _unused: [u8; 0],
}
pub type SCIP_EXPRHDLRDATA = SCIP_ExprhdlrData;
#[doc = " stage of DFS iterator"]
pub type SCIP_EXPRITER_STAGE = ::std::os::raw::c_uint;
#[doc = " user data storage type for expression iteration"]
#[repr(C)]
#[derive(Copy, Clone)]
pub union SCIP_EXPRITER_USERDATA {
    #[doc = "< a floating-point value"]
    pub realval: f64,
    #[doc = "< an integer value"]
    pub intval: ::std::os::raw::c_int,
    #[doc = "< two integer values"]
    pub intvals: [::std::os::raw::c_int; 2usize],
    #[doc = "< an unsigned integer value"]
    pub uintval: ::std::os::raw::c_uint,
    #[doc = "< a pointer"]
    pub ptrval: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_SCIP_EXPRITER_USERDATA() {
    const UNINIT: ::std::mem::MaybeUninit<SCIP_EXPRITER_USERDATA> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<SCIP_EXPRITER_USERDATA>(),
        8usize,
        concat!("Size of: ", stringify!(SCIP_EXPRITER_USERDATA))
    );
    assert_eq!(
        ::std::mem::align_of::<SCIP_EXPRITER_USERDATA>(),
        8usize,
        concat!("Alignment of ", stringify!(SCIP_EXPRITER_USERDATA))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).realval) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SCIP_EXPRITER_USERDATA),
            "::",
            stringify!(realval)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).intval) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SCIP_EXPRITER_USERDATA),
            "::",
            stringify!(intval)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).intvals) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SCIP_EXPRITER_USERDATA),
            "::",
            stringify!(intvals)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).uintval) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SCIP_EXPRITER_USERDATA),
            "::",
            stringify!(uintval)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ptrval) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SCIP_EXPRITER_USERDATA),
            "::",
            stringify!(ptrval)
        )
    );
}
#[doc = "< reverse topological order"]
pub const SCIP_EXPRITER_TYPE_SCIP_EXPRITER_RTOPOLOGIC: SCIP_EXPRITER_TYPE = 0;
#[doc = "< breadth-first search"]
pub const SCIP_EXPRITER_TYPE_SCIP_EXPRITER_BFS: SCIP_EXPRITER_TYPE = 1;
#[doc = "< depth-first search"]
pub const SCIP_EXPRITER_TYPE_SCIP_EXPRITER_DFS: SCIP_EXPRITER_TYPE = 2;
#[doc = " mode for expression iterator"]
pub type SCIP_EXPRITER_TYPE = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_ExprIterData {
    _unused: [u8; 0],
}
pub type SCIP_EXPRITERDATA = SCIP_ExprIterData;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_ExprIter {
    _unused: [u8; 0],
}
pub type SCIP_EXPRITER = SCIP_ExprIter;
pub type SCIP_EXPRPRINT_WHAT = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_ExprPrintData {
    _unused: [u8; 0],
}
pub type SCIP_EXPRPRINTDATA = SCIP_ExprPrintData;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_Compr {
    _unused: [u8; 0],
}
pub type SCIP_COMPR = SCIP_Compr;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_ComprData {
    _unused: [u8; 0],
}
pub type SCIP_COMPRDATA = SCIP_ComprData;
#[doc = "< downwards branching: decreasing upper bound"]
pub const SCIP_BranchDir_SCIP_BRANCHDIR_DOWNWARDS: SCIP_BranchDir = 0;
#[doc = "< upwards branching: increasing lower bound"]
pub const SCIP_BranchDir_SCIP_BRANCHDIR_UPWARDS: SCIP_BranchDir = 1;
#[doc = "< fixed branching: both bounds changed"]
pub const SCIP_BranchDir_SCIP_BRANCHDIR_FIXED: SCIP_BranchDir = 2;
#[doc = "< automatic setting for choosing bound changes"]
pub const SCIP_BranchDir_SCIP_BRANCHDIR_AUTO: SCIP_BranchDir = 3;
#[doc = " branching direction for branching on variables"]
pub type SCIP_BranchDir = ::std::os::raw::c_uint;
#[doc = " branching direction for branching on variables"]
pub use self::SCIP_BranchDir as SCIP_BRANCHDIR;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_History {
    _unused: [u8; 0],
}
pub type SCIP_HISTORY = SCIP_History;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_ValueHistory {
    _unused: [u8; 0],
}
#[doc = " Value history data structure\n\n  branching and inference history informations for single variable dependent on the domain value\n\n  - \\ref SCIP_VALUEHISTORY \"List of all available methods\""]
pub type SCIP_VALUEHISTORY = SCIP_ValueHistory;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_NodePQ {
    _unused: [u8; 0],
}
pub type SCIP_NODEPQ = SCIP_NodePQ;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_Nodesel {
    _unused: [u8; 0],
}
pub type SCIP_NODESEL = SCIP_Nodesel;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_NodeselData {
    _unused: [u8; 0],
}
pub type SCIP_NODESELDATA = SCIP_NodeselData;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_Presol {
    _unused: [u8; 0],
}
pub type SCIP_PRESOL = SCIP_Presol;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_PresolData {
    _unused: [u8; 0],
}
pub type SCIP_PRESOLDATA = SCIP_PresolData;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_Pricer {
    _unused: [u8; 0],
}
pub type SCIP_PRICER = SCIP_Pricer;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_PricerData {
    _unused: [u8; 0],
}
pub type SCIP_PRICERDATA = SCIP_PricerData;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_Reader {
    _unused: [u8; 0],
}
pub type SCIP_READER = SCIP_Reader;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_ReaderData {
    _unused: [u8; 0],
}
pub type SCIP_READERDATA = SCIP_ReaderData;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_Relax {
    _unused: [u8; 0],
}
pub type SCIP_RELAX = SCIP_Relax;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_Relaxation {
    _unused: [u8; 0],
}
pub type SCIP_RELAXATION = SCIP_Relaxation;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_RelaxData {
    _unused: [u8; 0],
}
pub type SCIP_RELAXDATA = SCIP_RelaxData;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_Reopt {
    _unused: [u8; 0],
}
pub type SCIP_REOPT = SCIP_Reopt;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_SolTree {
    _unused: [u8; 0],
}
pub type SCIP_SOLTREE = SCIP_SolTree;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_SolNode {
    _unused: [u8; 0],
}
pub type SCIP_SOLNODE = SCIP_SolNode;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_ReoptTree {
    _unused: [u8; 0],
}
pub type SCIP_REOPTTREE = SCIP_ReoptTree;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_ReoptNode {
    _unused: [u8; 0],
}
pub type SCIP_REOPTNODE = SCIP_ReoptNode;
pub type SCIP_REPRESENTATIVE = SCIP_ReoptNode;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_ReoptConsData {
    _unused: [u8; 0],
}
pub type SCIP_REOPTCONSDATA = SCIP_ReoptConsData;
#[doc = "< node is not part of the reoptimizationtree"]
pub const SCIP_ReoptType_SCIP_REOPTTYPE_NONE: SCIP_ReoptType = 0;
#[doc = "< node is only needed for reconstructing the tree"]
pub const SCIP_ReoptType_SCIP_REOPTTYPE_TRANSIT: SCIP_ReoptType = 1;
#[doc = "< node contains dual reductions which leed to LP infeasibility"]
pub const SCIP_ReoptType_SCIP_REOPTTYPE_INFSUBTREE: SCIP_ReoptType = 2;
#[doc = "< node contains dual reductions"]
pub const SCIP_ReoptType_SCIP_REOPTTYPE_STRBRANCHED: SCIP_ReoptType = 3;
#[doc = "< node contains additional constraints"]
pub const SCIP_ReoptType_SCIP_REOPTTYPE_LOGICORNODE: SCIP_ReoptType = 4;
#[doc = "< node is a leaf node"]
pub const SCIP_ReoptType_SCIP_REOPTTYPE_LEAF: SCIP_ReoptType = 5;
#[doc = "< node is a leaf node and pruned by boudning"]
pub const SCIP_ReoptType_SCIP_REOPTTYPE_PRUNED: SCIP_ReoptType = 6;
#[doc = "< node is a leaf node and has an integral optimal LP solution"]
pub const SCIP_ReoptType_SCIP_REOPTTYPE_FEASIBLE: SCIP_ReoptType = 7;
pub type SCIP_ReoptType = ::std::os::raw::c_uint;
pub use self::SCIP_ReoptType as SCIP_REOPTTYPE;
#[doc = "< constraint cutoffs an LP infeasible subtree"]
pub const Reopt_ConsType_REOPT_CONSTYPE_INFSUBTREE: Reopt_ConsType = 0;
#[doc = "< constraint reconstructs dual reductions"]
pub const Reopt_ConsType_REOPT_CONSTYPE_DUALREDS: Reopt_ConsType = 1;
#[doc = "< constraint representing a cut, e.g., to separate a solution"]
pub const Reopt_ConsType_REOPT_CONSTYPE_CUT: Reopt_ConsType = 2;
#[doc = "< constraint was added by SCIP, e.g., a (local) conflict"]
pub const Reopt_ConsType_REOPT_CONSTYPE_UNKNOWN: Reopt_ConsType = 3;
pub type Reopt_ConsType = ::std::os::raw::c_uint;
pub use self::Reopt_ConsType as REOPT_CONSTYPE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_Sepa {
    _unused: [u8; 0],
}
pub type SCIP_SEPA = SCIP_Sepa;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_SepaData {
    _unused: [u8; 0],
}
pub type SCIP_SEPADATA = SCIP_SepaData;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_Cutsel {
    _unused: [u8; 0],
}
pub type SCIP_CUTSEL = SCIP_Cutsel;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_CutselData {
    _unused: [u8; 0],
}
pub type SCIP_CUTSELDATA = SCIP_CutselData;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_Table {
    _unused: [u8; 0],
}
pub type SCIP_TABLE = SCIP_Table;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_TableData {
    _unused: [u8; 0],
}
pub type SCIP_TABLEDATA = SCIP_TableData;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_Prop {
    _unused: [u8; 0],
}
pub type SCIP_PROP = SCIP_Prop;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_PropData {
    _unused: [u8; 0],
}
pub type SCIP_PROPDATA = SCIP_PropData;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_Nlpi {
    _unused: [u8; 0],
}
pub type SCIP_NLPI = SCIP_Nlpi;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_NlpiData {
    _unused: [u8; 0],
}
pub type SCIP_NLPIDATA = SCIP_NlpiData;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_NlpiProblem {
    _unused: [u8; 0],
}
pub type SCIP_NLPIPROBLEM = SCIP_NlpiProblem;
#[doc = "< never stop if progress is still possible"]
pub const SCIP_NlpParam_FastFail_SCIP_NLPPARAM_FASTFAIL_OFF: SCIP_NlpParam_FastFail = 0;
#[doc = "< stop if it seems unlikely that an improving point can be found"]
pub const SCIP_NlpParam_FastFail_SCIP_NLPPARAM_FASTFAIL_CONSERVATIVE: SCIP_NlpParam_FastFail = 1;
#[doc = "< stop if convergence rate is low"]
pub const SCIP_NlpParam_FastFail_SCIP_NLPPARAM_FASTFAIL_AGGRESSIVE: SCIP_NlpParam_FastFail = 2;
#[doc = " NLP solver fast-fail levels"]
pub type SCIP_NlpParam_FastFail = ::std::os::raw::c_uint;
#[doc = " NLP solver fast-fail levels"]
pub use self::SCIP_NlpParam_FastFail as SCIP_NLPPARAM_FASTFAIL;
#[doc = " parameters for NLP solve"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_NlpParam {
    #[doc = "< lower objective limit (cutoff)"]
    pub lobjlimit: f64,
    #[doc = "< feasibility tolerance (maximal allowed absolute violation of constraints and variable bounds)"]
    pub feastol: f64,
    #[doc = "< optimality tolerance (maximal allowed absolute violation of optimality conditions)"]
    pub opttol: f64,
    #[doc = "< solver-specific tolerance on accuracy, e.g., maximal violation of feasibility and optimality in scaled problem (0.0: use solver default)"]
    pub solvertol: f64,
    #[doc = "< time limit in seconds: use SCIP_REAL_MAX to use remaining time available for SCIP solve (limits/time - currenttime)"]
    pub timelimit: f64,
    #[doc = "< iteration limit"]
    pub iterlimit: ::std::os::raw::c_int,
    #[doc = "< verbosity level of output of NLP solver to the screen: 0 off, 1 normal, 2 debug, > 2 more debug"]
    pub verblevel: ::std::os::raw::c_ushort,
    #[doc = "< whether the NLP solver should stop early if convergence is slow"]
    pub fastfail: SCIP_NLPPARAM_FASTFAIL,
    #[doc = "< whether to expect an infeasible problem"]
    pub expectinfeas: ::std::os::raw::c_uint,
    #[doc = "< whether to try to use solution of previous solve as starting point (if available)"]
    pub warmstart: ::std::os::raw::c_uint,
    #[doc = "< name of file from which NLP is solved (it's fine to set this to NULL)"]
    pub caller: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_SCIP_NlpParam() {
    const UNINIT: ::std::mem::MaybeUninit<SCIP_NlpParam> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<SCIP_NlpParam>(),
        72usize,
        concat!("Size of: ", stringify!(SCIP_NlpParam))
    );
    assert_eq!(
        ::std::mem::align_of::<SCIP_NlpParam>(),
        8usize,
        concat!("Alignment of ", stringify!(SCIP_NlpParam))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).lobjlimit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SCIP_NlpParam),
            "::",
            stringify!(lobjlimit)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).feastol) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SCIP_NlpParam),
            "::",
            stringify!(feastol)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).opttol) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(SCIP_NlpParam),
            "::",
            stringify!(opttol)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).solvertol) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(SCIP_NlpParam),
            "::",
            stringify!(solvertol)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).timelimit) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(SCIP_NlpParam),
            "::",
            stringify!(timelimit)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).iterlimit) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(SCIP_NlpParam),
            "::",
            stringify!(iterlimit)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).verblevel) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(SCIP_NlpParam),
            "::",
            stringify!(verblevel)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fastfail) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(SCIP_NlpParam),
            "::",
            stringify!(fastfail)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).expectinfeas) as usize - ptr as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(SCIP_NlpParam),
            "::",
            stringify!(expectinfeas)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).warmstart) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(SCIP_NlpParam),
            "::",
            stringify!(warmstart)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).caller) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(SCIP_NlpParam),
            "::",
            stringify!(caller)
        )
    );
}
#[doc = " parameters for NLP solve"]
pub type SCIP_NLPPARAM = SCIP_NlpParam;
#[doc = "< solved to global optimality"]
pub const SCIP_NlpSolStat_SCIP_NLPSOLSTAT_GLOBOPT: SCIP_NlpSolStat = 0;
#[doc = "< solved to local optimality"]
pub const SCIP_NlpSolStat_SCIP_NLPSOLSTAT_LOCOPT: SCIP_NlpSolStat = 1;
#[doc = "< feasible solution found"]
pub const SCIP_NlpSolStat_SCIP_NLPSOLSTAT_FEASIBLE: SCIP_NlpSolStat = 2;
#[doc = "< solution found is local infeasible"]
pub const SCIP_NlpSolStat_SCIP_NLPSOLSTAT_LOCINFEASIBLE: SCIP_NlpSolStat = 3;
#[doc = "< problem is proven infeasible"]
pub const SCIP_NlpSolStat_SCIP_NLPSOLSTAT_GLOBINFEASIBLE: SCIP_NlpSolStat = 4;
#[doc = "< problem is unbounded"]
pub const SCIP_NlpSolStat_SCIP_NLPSOLSTAT_UNBOUNDED: SCIP_NlpSolStat = 5;
#[doc = "< unknown solution status (e.g., problem not solved yet)"]
pub const SCIP_NlpSolStat_SCIP_NLPSOLSTAT_UNKNOWN: SCIP_NlpSolStat = 6;
#[doc = " NLP solution status"]
pub type SCIP_NlpSolStat = ::std::os::raw::c_uint;
#[doc = " NLP solution status"]
pub use self::SCIP_NlpSolStat as SCIP_NLPSOLSTAT;
#[doc = "< terminated successfully"]
pub const SCIP_NlpTermStat_SCIP_NLPTERMSTAT_OKAY: SCIP_NlpTermStat = 0;
#[doc = "< time limit exceeded"]
pub const SCIP_NlpTermStat_SCIP_NLPTERMSTAT_TIMELIMIT: SCIP_NlpTermStat = 1;
#[doc = "< iteration limit exceeded"]
pub const SCIP_NlpTermStat_SCIP_NLPTERMSTAT_ITERLIMIT: SCIP_NlpTermStat = 2;
#[doc = "< lower objective limit reached"]
pub const SCIP_NlpTermStat_SCIP_NLPTERMSTAT_LOBJLIMIT: SCIP_NlpTermStat = 3;
#[doc = "< SCIP has been asked to stop (SCIPinterruptSolve() called)"]
pub const SCIP_NlpTermStat_SCIP_NLPTERMSTAT_INTERRUPT: SCIP_NlpTermStat = 4;
#[doc = "< stopped on numerical error"]
pub const SCIP_NlpTermStat_SCIP_NLPTERMSTAT_NUMERICERROR: SCIP_NlpTermStat = 5;
#[doc = "< stopped on function evaluation error"]
pub const SCIP_NlpTermStat_SCIP_NLPTERMSTAT_EVALERROR: SCIP_NlpTermStat = 6;
#[doc = "< memory exceeded"]
pub const SCIP_NlpTermStat_SCIP_NLPTERMSTAT_OUTOFMEMORY: SCIP_NlpTermStat = 7;
#[doc = "< problems with license of NLP solver"]
pub const SCIP_NlpTermStat_SCIP_NLPTERMSTAT_LICENSEERROR: SCIP_NlpTermStat = 8;
#[doc = "< other error (= this should never happen)"]
pub const SCIP_NlpTermStat_SCIP_NLPTERMSTAT_OTHER: SCIP_NlpTermStat = 9;
#[doc = " NLP solver termination status"]
pub type SCIP_NlpTermStat = ::std::os::raw::c_uint;
#[doc = " NLP solver termination status"]
pub use self::SCIP_NlpTermStat as SCIP_NLPTERMSTAT;
#[doc = " Statistics from an NLP solve"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_NlpStatistics {
    #[doc = "< number of iterations the NLP solver spend in the last solve command"]
    pub niterations: ::std::os::raw::c_int,
    #[doc = "< total time in CPU sections the NLP solver spend in the last solve command"]
    pub totaltime: f64,
    #[doc = "< time spend in evaluation of functions and their derivatives (only measured if timing/nlpieval = TRUE)"]
    pub evaltime: f64,
    #[doc = "< maximal absolute constraint violation in current solution, or SCIP_INVALID if not available"]
    pub consviol: f64,
    #[doc = "< maximal absolute variable bound violation in current solution, or SCIP_INVALID if not available"]
    pub boundviol: f64,
}
#[test]
fn bindgen_test_layout_SCIP_NlpStatistics() {
    const UNINIT: ::std::mem::MaybeUninit<SCIP_NlpStatistics> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<SCIP_NlpStatistics>(),
        40usize,
        concat!("Size of: ", stringify!(SCIP_NlpStatistics))
    );
    assert_eq!(
        ::std::mem::align_of::<SCIP_NlpStatistics>(),
        8usize,
        concat!("Alignment of ", stringify!(SCIP_NlpStatistics))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).niterations) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SCIP_NlpStatistics),
            "::",
            stringify!(niterations)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).totaltime) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SCIP_NlpStatistics),
            "::",
            stringify!(totaltime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).evaltime) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(SCIP_NlpStatistics),
            "::",
            stringify!(evaltime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).consviol) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(SCIP_NlpStatistics),
            "::",
            stringify!(consviol)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).boundviol) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(SCIP_NlpStatistics),
            "::",
            stringify!(boundviol)
        )
    );
}
#[doc = " Statistics from an NLP solve"]
pub type SCIP_NLPSTATISTICS = SCIP_NlpStatistics;
#[doc = "< the solving status is not yet known"]
pub const SCIP_Status_SCIP_STATUS_UNKNOWN: SCIP_Status = 0;
#[doc = "< the user interrupted the solving process (by pressing CTRL-C)"]
pub const SCIP_Status_SCIP_STATUS_USERINTERRUPT: SCIP_Status = 1;
#[doc = "< the solving process was interrupted because the node limit was reached"]
pub const SCIP_Status_SCIP_STATUS_NODELIMIT: SCIP_Status = 2;
#[doc = "< the solving process was interrupted because the total node limit was\n   reached (incl. restarts)"]
pub const SCIP_Status_SCIP_STATUS_TOTALNODELIMIT: SCIP_Status = 3;
#[doc = "< the solving process was interrupted because the stalling node limit was\n   reached (no inprovement w.r.t. primal bound)"]
pub const SCIP_Status_SCIP_STATUS_STALLNODELIMIT: SCIP_Status = 4;
#[doc = "< the solving process was interrupted because the time limit was reached"]
pub const SCIP_Status_SCIP_STATUS_TIMELIMIT: SCIP_Status = 5;
#[doc = "< the solving process was interrupted because the memory limit was reached"]
pub const SCIP_Status_SCIP_STATUS_MEMLIMIT: SCIP_Status = 6;
#[doc = "< the solving process was interrupted because the gap limit was reached"]
pub const SCIP_Status_SCIP_STATUS_GAPLIMIT: SCIP_Status = 7;
#[doc = "< the solving process was interrupted because the solution limit was\n  reached"]
pub const SCIP_Status_SCIP_STATUS_SOLLIMIT: SCIP_Status = 8;
#[doc = "< the solving process was interrupted because the solution improvement limit\n   was reached"]
pub const SCIP_Status_SCIP_STATUS_BESTSOLLIMIT: SCIP_Status = 9;
#[doc = "< the solving process was interrupted because the restart limit was reached"]
pub const SCIP_Status_SCIP_STATUS_RESTARTLIMIT: SCIP_Status = 10;
#[doc = "< the problem was solved to optimality, an optimal solution is available"]
pub const SCIP_Status_SCIP_STATUS_OPTIMAL: SCIP_Status = 11;
#[doc = "< the problem was proven to be infeasible"]
pub const SCIP_Status_SCIP_STATUS_INFEASIBLE: SCIP_Status = 12;
#[doc = "< the problem was proven to be unbounded"]
pub const SCIP_Status_SCIP_STATUS_UNBOUNDED: SCIP_Status = 13;
#[doc = "< the problem was proven to be either infeasible or unbounded"]
pub const SCIP_Status_SCIP_STATUS_INFORUNBD: SCIP_Status = 14;
#[doc = "< status if the process received a SIGTERM signal"]
pub const SCIP_Status_SCIP_STATUS_TERMINATE: SCIP_Status = 15;
#[doc = " SCIP solving status"]
pub type SCIP_Status = ::std::os::raw::c_uint;
#[doc = " SCIP solving status"]
pub use self::SCIP_Status as SCIP_STATUS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_Stat {
    _unused: [u8; 0],
}
pub type SCIP_STAT = SCIP_Stat;
pub const SCIP_Parallelmode_SCIP_PARA_OPPORTUNISTIC: SCIP_Parallelmode = 0;
pub const SCIP_Parallelmode_SCIP_PARA_DETERMINISTIC: SCIP_Parallelmode = 1;
#[doc = " The parallel mode"]
pub type SCIP_Parallelmode = ::std::os::raw::c_uint;
#[doc = " The parallel mode"]
pub use self::SCIP_Parallelmode as SCIP_PARALLELMODE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_SyncStore {
    _unused: [u8; 0],
}
pub type SCIP_SYNCSTORE = SCIP_SyncStore;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_SyncData {
    _unused: [u8; 0],
}
pub type SCIP_SYNCDATA = SCIP_SyncData;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_BoundStore {
    _unused: [u8; 0],
}
pub type SCIP_BOUNDSTORE = SCIP_BoundStore;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_ConcSolverType {
    _unused: [u8; 0],
}
pub type SCIP_CONCSOLVERTYPE = SCIP_ConcSolverType;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_ConcSolverTypeData {
    _unused: [u8; 0],
}
pub type SCIP_CONCSOLVERTYPEDATA = SCIP_ConcSolverTypeData;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_ConcSolver {
    _unused: [u8; 0],
}
pub type SCIP_CONCSOLVER = SCIP_ConcSolver;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_ConcSolverData {
    _unused: [u8; 0],
}
pub type SCIP_CONCSOLVERDATA = SCIP_ConcSolverData;
#[doc = "< the Benders' subproblems are solved during the enforcement of an LP solution"]
pub const SCIP_BendersEnfoType_SCIP_BENDERSENFOTYPE_LP: SCIP_BendersEnfoType = 1;
#[doc = "< the Benders' subproblems are solved during the enforcement of a relaxation solution"]
pub const SCIP_BendersEnfoType_SCIP_BENDERSENFOTYPE_RELAX: SCIP_BendersEnfoType = 2;
#[doc = "< the Benders' subproblems are solved during the enforcement of a pseudo solution"]
pub const SCIP_BendersEnfoType_SCIP_BENDERSENFOTYPE_PSEUDO: SCIP_BendersEnfoType = 3;
#[doc = "< the Benders' subproblems are solved during the checking of a solution for feasibility"]
pub const SCIP_BendersEnfoType_SCIP_BENDERSENFOTYPE_CHECK: SCIP_BendersEnfoType = 4;
pub type SCIP_BendersEnfoType = ::std::os::raw::c_uint;
pub use self::SCIP_BendersEnfoType as SCIP_BENDERSENFOTYPE;
#[doc = "< the relaxation is solved in this iteration of the loop"]
pub const SCIP_BendersSolveLoop_SCIP_BENDERSSOLVELOOP_CONVEX: SCIP_BendersSolveLoop = 0;
#[doc = "< the CIP is solved in this iteration of the loop"]
pub const SCIP_BendersSolveLoop_SCIP_BENDERSSOLVELOOP_CIP: SCIP_BendersSolveLoop = 1;
#[doc = "< the user defined solve function is called"]
pub const SCIP_BendersSolveLoop_SCIP_BENDERSSOLVELOOP_USERCONVEX: SCIP_BendersSolveLoop = 2;
#[doc = "< the user defined solve function is called"]
pub const SCIP_BendersSolveLoop_SCIP_BENDERSSOLVELOOP_USERCIP: SCIP_BendersSolveLoop = 3;
pub type SCIP_BendersSolveLoop = ::std::os::raw::c_uint;
pub use self::SCIP_BendersSolveLoop as SCIP_BENDERSSOLVELOOP;
#[doc = "< the subsystem status is unknown"]
pub const SCIP_BendersSubStatus_SCIP_BENDERSSUBSTATUS_UNKNOWN: SCIP_BendersSubStatus = 0;
#[doc = "< the subsystem is solved to be optimal"]
pub const SCIP_BendersSubStatus_SCIP_BENDERSSUBSTATUS_OPTIMAL: SCIP_BendersSubStatus = 1;
#[doc = "< the subproblem is optimal, but the auxiliary variable is violated"]
pub const SCIP_BendersSubStatus_SCIP_BENDERSSUBSTATUS_AUXVIOL: SCIP_BendersSubStatus = 2;
#[doc = "< the subproblem is solved to be infeasible"]
pub const SCIP_BendersSubStatus_SCIP_BENDERSSUBSTATUS_INFEAS: SCIP_BendersSubStatus = 3;
pub type SCIP_BendersSubStatus = ::std::os::raw::c_uint;
pub use self::SCIP_BendersSubStatus as SCIP_BENDERSSUBSTATUS;
#[doc = "< the subproblem has convex constraints and continuous variables"]
pub const SCIP_BendersSubType_SCIP_BENDERSSUBTYPE_CONVEXCONT: SCIP_BendersSubType = 0;
#[doc = "< the subproblem has convex constraints and discrete variables"]
pub const SCIP_BendersSubType_SCIP_BENDERSSUBTYPE_CONVEXDIS: SCIP_BendersSubType = 1;
#[doc = "< the subproblem has non-convex constraints and continuous variables"]
pub const SCIP_BendersSubType_SCIP_BENDERSSUBTYPE_NONCONVEXCONT: SCIP_BendersSubType = 2;
#[doc = "< the subproblem has non-convex constraints and discrete variables"]
pub const SCIP_BendersSubType_SCIP_BENDERSSUBTYPE_NONCONVEXDIS: SCIP_BendersSubType = 3;
#[doc = "< the default type before the type is known"]
pub const SCIP_BendersSubType_SCIP_BENDERSSUBTYPE_UNKNOWN: SCIP_BendersSubType = 4;
pub type SCIP_BendersSubType = ::std::os::raw::c_uint;
pub use self::SCIP_BendersSubType as SCIP_BENDERSSUBTYPE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_Benders {
    _unused: [u8; 0],
}
pub type SCIP_BENDERS = SCIP_Benders;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_BendersData {
    _unused: [u8; 0],
}
pub type SCIP_BENDERSDATA = SCIP_BendersData;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_SubproblemSolveStat {
    _unused: [u8; 0],
}
pub type SCIP_SUBPROBLEMSOLVESTAT = SCIP_SubproblemSolveStat;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_Benderscut {
    _unused: [u8; 0],
}
pub type SCIP_BENDERSCUT = SCIP_Benderscut;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_BenderscutData {
    _unused: [u8; 0],
}
pub type SCIP_BENDERSCUTDATA = SCIP_BenderscutData;
extern "C" {
    #[doc = " create and resets an epsilon greedy bandit algorithm"]
    pub fn SCIPcreateBanditEpsgreedy(
        scip: *mut SCIP,
        epsgreedy: *mut *mut SCIP_BANDIT,
        priorities: *mut f64,
        eps: f64,
        usemodification: ::std::os::raw::c_uint,
        preferrecent: ::std::os::raw::c_uint,
        decayfactor: f64,
        avglim: ::std::os::raw::c_int,
        nactions: ::std::os::raw::c_int,
        initseed: ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " get weights array of epsilon greedy bandit algorithm"]
    pub fn SCIPgetWeightsEpsgreedy(epsgreedy: *mut SCIP_BANDIT) -> *mut f64;
}
extern "C" {
    #[doc = " set epsilon parameter of epsilon greedy bandit algorithm"]
    pub fn SCIPsetEpsilonEpsgreedy(epsgreedy: *mut SCIP_BANDIT, eps: f64);
}
extern "C" {
    #[doc = " creates and resets an Exp.3 bandit algorithm using \\p scip pointer"]
    pub fn SCIPcreateBanditExp3(
        scip: *mut SCIP,
        exp3: *mut *mut SCIP_BANDIT,
        priorities: *mut f64,
        gammaparam: f64,
        beta: f64,
        nactions: ::std::os::raw::c_int,
        initseed: ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " set gamma parameter of Exp.3 bandit algorithm to increase weight of uniform distribution"]
    pub fn SCIPsetGammaExp3(exp3: *mut SCIP_BANDIT, gammaparam: f64);
}
extern "C" {
    #[doc = " set beta parameter of Exp.3 bandit algorithm to increase gain offset for actions that were not played"]
    pub fn SCIPsetBetaExp3(exp3: *mut SCIP_BANDIT, beta: f64);
}
extern "C" {
    #[doc = " returns probability to play an action"]
    pub fn SCIPgetProbabilityExp3(exp3: *mut SCIP_BANDIT, action: ::std::os::raw::c_int) -> f64;
}
extern "C" {
    #[doc = " creates and resets an Exp.3-IX bandit algorithm using \\p scip pointer"]
    pub fn SCIPcreateBanditExp3IX(
        scip: *mut SCIP,
        exp3ix: *mut *mut SCIP_BANDIT,
        priorities: *mut f64,
        nactions: ::std::os::raw::c_int,
        initseed: ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " returns probability to play an action"]
    pub fn SCIPgetProbabilityExp3IX(exp3ix: *mut SCIP_BANDIT, action: ::std::os::raw::c_int)
        -> f64;
}
extern "C" {
    #[doc = " create and reset UCB bandit algorithm"]
    pub fn SCIPcreateBanditUcb(
        scip: *mut SCIP,
        ucb: *mut *mut SCIP_BANDIT,
        priorities: *mut f64,
        alpha: f64,
        nactions: ::std::os::raw::c_int,
        initseed: ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " returns the upper confidence bound of a selected action"]
    pub fn SCIPgetConfidenceBoundUcb(ucb: *mut SCIP_BANDIT, action: ::std::os::raw::c_int) -> f64;
}
extern "C" {
    #[doc = " return start permutation of the UCB bandit algorithm"]
    pub fn SCIPgetStartPermutationUcb(ucb: *mut SCIP_BANDIT) -> *mut ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " select the next action"]
    pub fn SCIPbanditSelect(
        bandit: *mut SCIP_BANDIT,
        action: *mut ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " update the score of the selected action"]
    pub fn SCIPbanditUpdate(
        bandit: *mut SCIP_BANDIT,
        action: ::std::os::raw::c_int,
        score: f64,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " return the name of this bandit virtual function table"]
    pub fn SCIPbanditvtableGetName(
        banditvtable: *mut SCIP_BANDITVTABLE,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " return the random number generator of a bandit algorithm"]
    pub fn SCIPbanditGetRandnumgen(bandit: *mut SCIP_BANDIT) -> *mut SCIP_RANDNUMGEN;
}
extern "C" {
    #[doc = " return number of actions of this bandit algorithm"]
    pub fn SCIPbanditGetNActions(bandit: *mut SCIP_BANDIT) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SCIPbendersComp(
        elem1: *mut ::std::os::raw::c_void,
        elem2: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SCIPbendersCompName(
        elem1: *mut ::std::os::raw::c_void,
        elem2: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " gets user data of Benders' decomposition"]
    pub fn SCIPbendersGetData(benders: *mut SCIP_BENDERS) -> *mut SCIP_BENDERSDATA;
}
extern "C" {
    #[doc = " sets user data of Benders' decomposition; user has to free old data in advance!"]
    pub fn SCIPbendersSetData(benders: *mut SCIP_BENDERS, bendersdata: *mut SCIP_BENDERSDATA);
}
extern "C" {
    #[doc = " gets name of Benders' decomposition"]
    pub fn SCIPbendersGetName(benders: *mut SCIP_BENDERS) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " gets description of Benders' decomposition"]
    pub fn SCIPbendersGetDesc(benders: *mut SCIP_BENDERS) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " gets priority of Benders' decomposition"]
    pub fn SCIPbendersGetPriority(benders: *mut SCIP_BENDERS) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " gets the number of subproblems for the Benders' decomposition"]
    pub fn SCIPbendersGetNSubproblems(benders: *mut SCIP_BENDERS) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " returns the SCIP instance for a given subproblem"]
    pub fn SCIPbendersSubproblem(
        benders: *mut SCIP_BENDERS,
        probnumber: ::std::os::raw::c_int,
    ) -> *mut SCIP;
}
extern "C" {
    #[doc = " gets the number of times, the Bender' decomposition was called and tried to find a violated second stage constraint"]
    pub fn SCIPbendersGetNCalls(benders: *mut SCIP_BENDERS) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " gets the number of optimality cuts found by the collection of Benders' decomposition subproblems"]
    pub fn SCIPbendersGetNCutsFound(benders: *mut SCIP_BENDERS) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " gets the number of cuts found from the strengthening round"]
    pub fn SCIPbendersGetNStrengthenCutsFound(benders: *mut SCIP_BENDERS) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " gets the number of calls to the strengthening round"]
    pub fn SCIPbendersGetNStrengthenCalls(benders: *mut SCIP_BENDERS) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " gets the number of calls to the strengthening round that fail"]
    pub fn SCIPbendersGetNStrengthenFails(benders: *mut SCIP_BENDERS) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " gets time in seconds used in this Benders' decomposition for setting up for next stages"]
    pub fn SCIPbendersGetSetupTime(benders: *mut SCIP_BENDERS) -> f64;
}
extern "C" {
    #[doc = " gets execution time in seconds used in this Benders' decomposition"]
    pub fn SCIPbendersGetTime(benders: *mut SCIP_BENDERS) -> f64;
}
extern "C" {
    #[doc = " Is Benders' decomposition initialized?"]
    pub fn SCIPbendersIsInitialized(benders: *mut SCIP_BENDERS) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " returns whether the given Benders' decomposition is in use in the current problem"]
    pub fn SCIPbendersIsActive(benders: *mut SCIP_BENDERS) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " Returns whether only the convex relaxations will be checked in this solve loop\n  when Benders' is used in the LNS heuristics, only the convex relaxations of the master/subproblems are checked,\n  i.e. no integer cuts are generated. In this case, then Benders' decomposition is performed under the assumption\n  that all subproblems are convex relaxations."]
    pub fn SCIPbendersOnlyCheckConvexRelax(
        benders: *mut SCIP_BENDERS,
        subscipsoff: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " returns NLP solver parameters used for solving NLP subproblems"]
    pub fn SCIPbendersGetNLPParam(benders: *mut SCIP_BENDERS) -> SCIP_NLPPARAM;
}
extern "C" {
    #[doc = " Are Benders' cuts generated from the LP solutions?"]
    pub fn SCIPbendersCutLP(benders: *mut SCIP_BENDERS) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " Are Benders' cuts generated from the pseudo solutions?"]
    pub fn SCIPbendersCutPseudo(benders: *mut SCIP_BENDERS) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " Are Benders' cuts generated from the relaxation solutions?"]
    pub fn SCIPbendersCutRelaxation(benders: *mut SCIP_BENDERS) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " Should this Benders' use the auxiliary variables from the highest priority Benders'?"]
    pub fn SCIPbendersShareAuxVars(benders: *mut SCIP_BENDERS) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " sets the subproblem setup flag"]
    pub fn SCIPbendersSetSubproblemIsSetup(
        benders: *mut SCIP_BENDERS,
        probnumber: ::std::os::raw::c_int,
        issetup: ::std::os::raw::c_uint,
    );
}
extern "C" {
    #[doc = " returns the subproblem setup flag"]
    pub fn SCIPbendersSubproblemIsSetup(
        benders: *mut SCIP_BENDERS,
        probnumber: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " returns the auxiliary variable for the given subproblem"]
    pub fn SCIPbendersGetAuxiliaryVar(
        benders: *mut SCIP_BENDERS,
        probnumber: ::std::os::raw::c_int,
    ) -> *mut SCIP_VAR;
}
extern "C" {
    #[doc = " returns all auxiliary variables"]
    pub fn SCIPbendersGetAuxiliaryVars(benders: *mut SCIP_BENDERS) -> *mut *mut SCIP_VAR;
}
extern "C" {
    #[doc = " stores the objective function value of the subproblem for use in cut generation"]
    pub fn SCIPbendersSetSubproblemObjval(
        benders: *mut SCIP_BENDERS,
        probnumber: ::std::os::raw::c_int,
        objval: f64,
    );
}
extern "C" {
    #[doc = " returns the objective function value of the subproblem for use in cut generation"]
    pub fn SCIPbendersGetSubproblemObjval(
        benders: *mut SCIP_BENDERS,
        probnumber: ::std::os::raw::c_int,
    ) -> f64;
}
extern "C" {
    #[doc = " returns the number of cuts that have been added for storage"]
    pub fn SCIPbendersGetNStoredCuts(benders: *mut SCIP_BENDERS) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " returns the data for the cuts that have been added by the Benders' cut plugin"]
    pub fn SCIPbendersGetStoredCutData(
        benders: *mut SCIP_BENDERS,
        cutidx: ::std::os::raw::c_int,
        vars: *mut *mut *mut SCIP_VAR,
        vals: *mut *mut f64,
        lhs: *mut f64,
        rhs: *mut f64,
        nvars: *mut ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " returns the original problem data for the cuts that have been added by the Benders' cut plugin. The stored\n  variables and values will populate the input vars and vals arrays. Thus, memory must be allocated for the vars and\n  vals arrays"]
    pub fn SCIPbendersGetStoredCutOrigData(
        benders: *mut SCIP_BENDERS,
        cutidx: ::std::os::raw::c_int,
        vars: *mut *mut *mut SCIP_VAR,
        vals: *mut *mut f64,
        lhs: *mut f64,
        rhs: *mut f64,
        nvars: *mut ::std::os::raw::c_int,
        varssize: ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " returns the Benders' cut of the given name, or NULL if not existing"]
    pub fn SCIPfindBenderscut(
        benders: *mut SCIP_BENDERS,
        name: *const ::std::os::raw::c_char,
    ) -> *mut SCIP_BENDERSCUT;
}
extern "C" {
    #[doc = " returns the array of currently available Benders' cuts; active Benders' decomposition are in the first slots of\n the array"]
    pub fn SCIPbendersGetBenderscuts(benders: *mut SCIP_BENDERS) -> *mut *mut SCIP_BENDERSCUT;
}
extern "C" {
    #[doc = " returns the number of currently available Benders' cuts"]
    pub fn SCIPbendersGetNBenderscuts(benders: *mut SCIP_BENDERS) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " sets the priority of a Benders' decomposition"]
    pub fn SCIPbendersSetBenderscutPriority(
        benders: *mut SCIP_BENDERS,
        benderscut: *mut SCIP_BENDERSCUT,
        priority: ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " returns whether the solution has non-zero slack variables"]
    pub fn SCIPbendersSolSlackVarsActive(
        benders: *mut SCIP_BENDERS,
        activeslack: *mut ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " sets the subproblem type\n\n The subproblem types are:\n    - Convex constraints with continuous variables\n    - Convex constraints with discrete variables\n    - Non-convex constraints with continuous variables\n    - Non-convex constraints with discrete variables"]
    pub fn SCIPbendersSetSubproblemType(
        benders: *mut SCIP_BENDERS,
        probnumber: ::std::os::raw::c_int,
        subprobtype: SCIP_BENDERSSUBTYPE,
    );
}
extern "C" {
    #[doc = " returns the type of the subproblem\n\n  This type is used to determine whether the duals of the problem can be used to generate cuts"]
    pub fn SCIPbendersGetSubproblemType(
        benders: *mut SCIP_BENDERS,
        probnumber: ::std::os::raw::c_int,
    ) -> SCIP_BENDERSSUBTYPE;
}
extern "C" {
    #[doc = " sets the flag indicating whether a subproblem is convex\n\n  It is possible that this can change during the solving process. One example is when the three-phase method is\n  employed, where the first phase solves the convex relaxation of both the master and subproblems, the second phase\n  reintroduces the integrality constraints to the master problem and the third phase then reintroduces integrality\n  constraints to the subproblems."]
    pub fn SCIPbendersSetSubproblemIsConvex(
        benders: *mut SCIP_BENDERS,
        probnumber: ::std::os::raw::c_int,
        isconvex: ::std::os::raw::c_uint,
    );
}
extern "C" {
    #[doc = " returns whether the subproblem is convex\n\n  This means that the dual solution can be used to generate cuts."]
    pub fn SCIPbendersSubproblemIsConvex(
        benders: *mut SCIP_BENDERS,
        probnumber: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " returns the number of subproblems that are convex"]
    pub fn SCIPbendersGetNConvexSubproblems(benders: *mut SCIP_BENDERS) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " sets the flag indicating whether a subproblem contains non-linear constraints"]
    pub fn SCIPbendersSetSubproblemIsNonlinear(
        benders: *mut SCIP_BENDERS,
        probnumber: ::std::os::raw::c_int,
        isnonlinear: ::std::os::raw::c_uint,
    );
}
extern "C" {
    #[doc = " returns whether the subproblem contains non-linear constraints."]
    pub fn SCIPbendersSubproblemIsNonlinear(
        benders: *mut SCIP_BENDERS,
        probnumber: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " returns the number of subproblems that contain non-linear constraints"]
    pub fn SCIPbendersGetNNonlinearSubproblems(benders: *mut SCIP_BENDERS)
        -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " sets the flag indicating whether the master problem contains non-linear constraints"]
    pub fn SCIPbendersSetMasterIsNonlinear(
        benders: *mut SCIP_BENDERS,
        isnonlinear: ::std::os::raw::c_uint,
    );
}
extern "C" {
    #[doc = " returns whether the master problem contains non-linear constraints."]
    pub fn SCIPbendersMasterIsNonlinear(benders: *mut SCIP_BENDERS) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " returns the flag indicating that Benders' decomposition is in a cut strengthening round"]
    pub fn SCIPbendersInStrengthenRound(benders: *mut SCIP_BENDERS) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " solves the LP of the Benders' decomposition subproblem\n\n  This requires that the subproblem is in probing mode."]
    pub fn SCIPbendersSolveSubproblemLP(
        scip: *mut SCIP,
        benders: *mut SCIP_BENDERS,
        probnumber: ::std::os::raw::c_int,
        solvestatus: *mut SCIP_STATUS,
        objective: *mut f64,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " solves the Benders' decomposition subproblem"]
    pub fn SCIPbendersSolveSubproblemCIP(
        scip: *mut SCIP,
        benders: *mut SCIP_BENDERS,
        probnumber: ::std::os::raw::c_int,
        solvestatus: *mut SCIP_STATUS,
        solvecip: ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " returns the number of cuts that have been transferred from sub SCIPs to the master SCIP"]
    pub fn SCIPbendersGetNTransferredCuts(benders: *mut SCIP_BENDERS) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " updates the lower bound for the subproblem. If the lower bound is not greater than the previously stored lowerbound,\n then no update occurs."]
    pub fn SCIPbendersUpdateSubproblemLowerbound(
        benders: *mut SCIP_BENDERS,
        probnumber: ::std::os::raw::c_int,
        lowerbound: f64,
    );
}
extern "C" {
    #[doc = " returns the stored lower bound for the given subproblem"]
    pub fn SCIPbendersGetSubproblemLowerbound(
        benders: *mut SCIP_BENDERS,
        probnumber: ::std::os::raw::c_int,
    ) -> f64;
}
extern "C" {
    #[doc = " sets the independent subproblem flag"]
    pub fn SCIPbendersSetSubproblemIsIndependent(
        benders: *mut SCIP_BENDERS,
        probnumber: ::std::os::raw::c_int,
        isindep: ::std::os::raw::c_uint,
    );
}
extern "C" {
    #[doc = " returns whether the subproblem is independent"]
    pub fn SCIPbendersSubproblemIsIndependent(
        benders: *mut SCIP_BENDERS,
        probnumber: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " returns whether the subproblem is enabled, i.e. the subproblem is still solved in the solving loop."]
    pub fn SCIPbendersSubproblemIsEnabled(
        benders: *mut SCIP_BENDERS,
        probnumber: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn SCIPbenderscutComp(
        elem1: *mut ::std::os::raw::c_void,
        elem2: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SCIPbenderscutCompName(
        elem1: *mut ::std::os::raw::c_void,
        elem2: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " gets user data of the Benders' decomposition cut"]
    pub fn SCIPbenderscutGetData(benderscut: *mut SCIP_BENDERSCUT) -> *mut SCIP_BENDERSCUTDATA;
}
extern "C" {
    #[doc = " sets user data of the Benders' decomposition cut; user has to free old data in advance!"]
    pub fn SCIPbenderscutSetData(
        benderscut: *mut SCIP_BENDERSCUT,
        benderscutdata: *mut SCIP_BENDERSCUTDATA,
    );
}
extern "C" {
    #[doc = " gets name of the Benders' decomposition cut"]
    pub fn SCIPbenderscutGetName(benderscut: *mut SCIP_BENDERSCUT)
        -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " gets description of the Benders' decomposition cut"]
    pub fn SCIPbenderscutGetDesc(benderscut: *mut SCIP_BENDERSCUT)
        -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " gets priority of the Benders' decomposition cut"]
    pub fn SCIPbenderscutGetPriority(benderscut: *mut SCIP_BENDERSCUT) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " gets the number of times, the Benders' decomposition cut was called and tried to find a violated cut"]
    pub fn SCIPbenderscutGetNCalls(benderscut: *mut SCIP_BENDERSCUT) -> ::std::os::raw::c_longlong;
}
extern "C" {
    #[doc = " gets the number of the cuts found by this Benders' decomposition cut"]
    pub fn SCIPbenderscutGetNFound(benderscut: *mut SCIP_BENDERSCUT) -> ::std::os::raw::c_longlong;
}
extern "C" {
    #[doc = " is the Benders' decomposition cut initialized?"]
    pub fn SCIPbenderscutIsInitialized(benderscut: *mut SCIP_BENDERSCUT) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " gets time in seconds used in this Benders' decomposition cut for setting up for next stages"]
    pub fn SCIPbenderscutGetSetupTime(benderscut: *mut SCIP_BENDERSCUT) -> f64;
}
extern "C" {
    #[doc = " gets time in seconds used in this Benders' decomposition cut"]
    pub fn SCIPbenderscutGetTime(benderscut: *mut SCIP_BENDERSCUT) -> f64;
}
extern "C" {
    #[doc = " returns whether the Benders' cut uses the LP information"]
    pub fn SCIPbenderscutIsLPCut(benderscut: *mut SCIP_BENDERSCUT) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " sets the enabled flag of the Benders' decomposition cut method"]
    pub fn SCIPbenderscutSetEnabled(
        benderscut: *mut SCIP_BENDERSCUT,
        enabled: ::std::os::raw::c_uint,
    );
}
extern "C" {
    pub fn SCIPbranchruleComp(
        elem1: *mut ::std::os::raw::c_void,
        elem2: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SCIPbranchruleCompName(
        elem1: *mut ::std::os::raw::c_void,
        elem2: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " gets user data of branching rule"]
    pub fn SCIPbranchruleGetData(branchrule: *mut SCIP_BRANCHRULE) -> *mut SCIP_BRANCHRULEDATA;
}
extern "C" {
    #[doc = " sets user data of branching rule; user has to free old data in advance!"]
    pub fn SCIPbranchruleSetData(
        branchrule: *mut SCIP_BRANCHRULE,
        branchruledata: *mut SCIP_BRANCHRULEDATA,
    );
}
extern "C" {
    #[doc = " gets name of branching rule"]
    pub fn SCIPbranchruleGetName(branchrule: *mut SCIP_BRANCHRULE)
        -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " gets description of branching rule"]
    pub fn SCIPbranchruleGetDesc(branchrule: *mut SCIP_BRANCHRULE)
        -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " gets priority of branching rule"]
    pub fn SCIPbranchruleGetPriority(branchrule: *mut SCIP_BRANCHRULE) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " gets maximal depth level, up to which this branching rule should be used (-1 for no limit)"]
    pub fn SCIPbranchruleGetMaxdepth(branchrule: *mut SCIP_BRANCHRULE) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " gets maximal relative distance from current node's dual bound to primal bound for applying branching rule"]
    pub fn SCIPbranchruleGetMaxbounddist(branchrule: *mut SCIP_BRANCHRULE) -> f64;
}
extern "C" {
    #[doc = " gets time in seconds used in this branching rule for setting up for next stages"]
    pub fn SCIPbranchruleGetSetupTime(branchrule: *mut SCIP_BRANCHRULE) -> f64;
}
extern "C" {
    #[doc = " gets time in seconds used in this branching rule"]
    pub fn SCIPbranchruleGetTime(branchrule: *mut SCIP_BRANCHRULE) -> f64;
}
extern "C" {
    #[doc = " gets the total number of times, the branching rule was called on an LP solution"]
    pub fn SCIPbranchruleGetNLPCalls(
        branchrule: *mut SCIP_BRANCHRULE,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    #[doc = " gets the total number of times, the branching rule was called on external candidates"]
    pub fn SCIPbranchruleGetNExternCalls(
        branchrule: *mut SCIP_BRANCHRULE,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    #[doc = " gets the total number of times, the branching rule was called on a pseudo solution"]
    pub fn SCIPbranchruleGetNPseudoCalls(
        branchrule: *mut SCIP_BRANCHRULE,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    #[doc = " gets the total number of times, the branching rule detected a cutoff"]
    pub fn SCIPbranchruleGetNCutoffs(
        branchrule: *mut SCIP_BRANCHRULE,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    #[doc = " gets the total number of cuts, the branching rule separated"]
    pub fn SCIPbranchruleGetNCutsFound(
        branchrule: *mut SCIP_BRANCHRULE,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    #[doc = " gets the total number of constraints, the branching rule added to the respective local nodes (not counting constraints\n  that were added to the child nodes as branching decisions)"]
    pub fn SCIPbranchruleGetNConssFound(
        branchrule: *mut SCIP_BRANCHRULE,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    #[doc = " gets the total number of domain reductions, the branching rule found"]
    pub fn SCIPbranchruleGetNDomredsFound(
        branchrule: *mut SCIP_BRANCHRULE,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    #[doc = " gets the total number of children, the branching rule created"]
    pub fn SCIPbranchruleGetNChildren(
        branchrule: *mut SCIP_BRANCHRULE,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    #[doc = " is branching rule initialized?"]
    pub fn SCIPbranchruleIsInitialized(branchrule: *mut SCIP_BRANCHRULE) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn SCIPconflicthdlrComp(
        elem1: *mut ::std::os::raw::c_void,
        elem2: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SCIPconflicthdlrCompName(
        elem1: *mut ::std::os::raw::c_void,
        elem2: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " gets user data of conflict handler"]
    pub fn SCIPconflicthdlrGetData(
        conflicthdlr: *mut SCIP_CONFLICTHDLR,
    ) -> *mut SCIP_CONFLICTHDLRDATA;
}
extern "C" {
    #[doc = " sets user data of conflict handler; user has to free old data in advance!"]
    pub fn SCIPconflicthdlrSetData(
        conflicthdlr: *mut SCIP_CONFLICTHDLR,
        conflicthdlrdata: *mut SCIP_CONFLICTHDLRDATA,
    );
}
extern "C" {
    #[doc = " gets name of conflict handler"]
    pub fn SCIPconflicthdlrGetName(
        conflicthdlr: *mut SCIP_CONFLICTHDLR,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " gets description of conflict handler"]
    pub fn SCIPconflicthdlrGetDesc(
        conflicthdlr: *mut SCIP_CONFLICTHDLR,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " gets priority of conflict handler"]
    pub fn SCIPconflicthdlrGetPriority(
        conflicthdlr: *mut SCIP_CONFLICTHDLR,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " is conflict handler initialized?"]
    pub fn SCIPconflicthdlrIsInitialized(
        conflicthdlr: *mut SCIP_CONFLICTHDLR,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " gets time in seconds used in this conflict handler for setting up for next stages"]
    pub fn SCIPconflicthdlrGetSetupTime(conflicthdlr: *mut SCIP_CONFLICTHDLR) -> f64;
}
extern "C" {
    #[doc = " gets time in seconds used in this conflict handler"]
    pub fn SCIPconflicthdlrGetTime(conflicthdlr: *mut SCIP_CONFLICTHDLR) -> f64;
}
extern "C" {
    pub fn SCIPconshdlrCompSepa(
        elem1: *mut ::std::os::raw::c_void,
        elem2: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SCIPconshdlrCompEnfo(
        elem1: *mut ::std::os::raw::c_void,
        elem2: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SCIPconshdlrCompCheck(
        elem1: *mut ::std::os::raw::c_void,
        elem2: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SCIPconsCompCheck(
        elem1: *mut ::std::os::raw::c_void,
        elem2: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " gets name of constraint handler"]
    pub fn SCIPconshdlrGetName(conshdlr: *mut SCIP_CONSHDLR) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " gets description of constraint handler"]
    pub fn SCIPconshdlrGetDesc(conshdlr: *mut SCIP_CONSHDLR) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " gets user data of constraint handler"]
    pub fn SCIPconshdlrGetData(conshdlr: *mut SCIP_CONSHDLR) -> *mut SCIP_CONSHDLRDATA;
}
extern "C" {
    #[doc = " sets user data of constraint handler; user has to free old data in advance!"]
    pub fn SCIPconshdlrSetData(conshdlr: *mut SCIP_CONSHDLR, conshdlrdata: *mut SCIP_CONSHDLRDATA);
}
extern "C" {
    #[doc = " sets all separation related callbacks of the constraint handler"]
    pub fn SCIPconshdlrSetSepa(
        conshdlr: *mut SCIP_CONSHDLR,
        conssepalp: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                conshdlr: *mut SCIP_CONSHDLR,
                conss: *mut *mut SCIP_CONS,
                nconss: ::std::os::raw::c_int,
                nusefulconss: ::std::os::raw::c_int,
                result: *mut SCIP_RESULT,
            ) -> SCIP_RETCODE,
        >,
        conssepasol: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                conshdlr: *mut SCIP_CONSHDLR,
                conss: *mut *mut SCIP_CONS,
                nconss: ::std::os::raw::c_int,
                nusefulconss: ::std::os::raw::c_int,
                sol: *mut SCIP_SOL,
                result: *mut SCIP_RESULT,
            ) -> SCIP_RETCODE,
        >,
        sepafreq: ::std::os::raw::c_int,
        sepapriority: ::std::os::raw::c_int,
        delaysepa: ::std::os::raw::c_uint,
    );
}
extern "C" {
    #[doc = " sets both the propagation callback and the propagation frequency of the constraint handler"]
    pub fn SCIPconshdlrSetProp(
        conshdlr: *mut SCIP_CONSHDLR,
        consprop: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                conshdlr: *mut SCIP_CONSHDLR,
                conss: *mut *mut SCIP_CONS,
                nconss: ::std::os::raw::c_int,
                nusefulconss: ::std::os::raw::c_int,
                nmarkedconss: ::std::os::raw::c_int,
                proptiming: SCIP_PROPTIMING,
                result: *mut SCIP_RESULT,
            ) -> SCIP_RETCODE,
        >,
        propfreq: ::std::os::raw::c_int,
        delayprop: ::std::os::raw::c_uint,
        timingmask: SCIP_PROPTIMING,
    );
}
extern "C" {
    #[doc = " sets the relaxation enforcement method of the constraint handler"]
    pub fn SCIPconshdlrSetEnforelax(
        conshdlr: *mut SCIP_CONSHDLR,
        consenforelax: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                sol: *mut SCIP_SOL,
                conshdlr: *mut SCIP_CONSHDLR,
                conss: *mut *mut SCIP_CONS,
                nconss: ::std::os::raw::c_int,
                nusefulconss: ::std::os::raw::c_int,
                solinfeasible: ::std::os::raw::c_uint,
                result: *mut SCIP_RESULT,
            ) -> SCIP_RETCODE,
        >,
    );
}
extern "C" {
    #[doc = " gets array with constraints of constraint handler; the first SCIPconshdlrGetNActiveConss() entries are the active\n  constraints, the last SCIPconshdlrGetNConss() - SCIPconshdlrGetNActiveConss() constraints are deactivated\n\n  @note A constraint is active if it is global and was not removed or it was added locally (in that case the local\n        flag is TRUE) and the current node belongs to the corresponding sub tree."]
    pub fn SCIPconshdlrGetConss(conshdlr: *mut SCIP_CONSHDLR) -> *mut *mut SCIP_CONS;
}
extern "C" {
    #[doc = " gets array with enforced constraints of constraint handler; this is local information"]
    pub fn SCIPconshdlrGetEnfoConss(conshdlr: *mut SCIP_CONSHDLR) -> *mut *mut SCIP_CONS;
}
extern "C" {
    #[doc = " gets array with checked constraints of constraint handler; this is local information"]
    pub fn SCIPconshdlrGetCheckConss(conshdlr: *mut SCIP_CONSHDLR) -> *mut *mut SCIP_CONS;
}
extern "C" {
    #[doc = " gets array with delayed update constraints\n\n @attention Usually, there should be no need to access this array. Use this only if you are absolutely sure what you are doing."]
    pub fn SCIPconshdlrGetUpdateConss(conshdlr: *mut SCIP_CONSHDLR) -> *mut *mut SCIP_CONS;
}
extern "C" {
    #[doc = " gets total number of existing transformed constraints of constraint handler"]
    pub fn SCIPconshdlrGetNConss(conshdlr: *mut SCIP_CONSHDLR) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " gets number of enforced constraints of constraint handler; this is local information"]
    pub fn SCIPconshdlrGetNEnfoConss(conshdlr: *mut SCIP_CONSHDLR) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " gets number of checked constraints of constraint handler; this is local information"]
    pub fn SCIPconshdlrGetNCheckConss(conshdlr: *mut SCIP_CONSHDLR) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " gets number of active constraints of constraint handler\n\n  @note A constraint is active if it is global and was not removed or it was added locally (in that case the local\n        flag is TRUE) and the current node belongs to the corresponding sub tree."]
    pub fn SCIPconshdlrGetNActiveConss(conshdlr: *mut SCIP_CONSHDLR) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " gets number of enabled constraints of constraint handler"]
    pub fn SCIPconshdlrGetNEnabledConss(conshdlr: *mut SCIP_CONSHDLR) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " gets number of constraints that have delayed updates"]
    pub fn SCIPconshdlrGetNUpdateConss(conshdlr: *mut SCIP_CONSHDLR) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " gets time in seconds used for setting up this constraint handler for new stages"]
    pub fn SCIPconshdlrGetSetupTime(conshdlr: *mut SCIP_CONSHDLR) -> f64;
}
extern "C" {
    #[doc = " gets time in seconds used for presolving in this constraint handler"]
    pub fn SCIPconshdlrGetPresolTime(conshdlr: *mut SCIP_CONSHDLR) -> f64;
}
extern "C" {
    #[doc = " gets time in seconds used for separation in this constraint handler"]
    pub fn SCIPconshdlrGetSepaTime(conshdlr: *mut SCIP_CONSHDLR) -> f64;
}
extern "C" {
    #[doc = " gets time in seconds used for LP enforcement in this constraint handler"]
    pub fn SCIPconshdlrGetEnfoLPTime(conshdlr: *mut SCIP_CONSHDLR) -> f64;
}
extern "C" {
    #[doc = " gets time in seconds used for pseudo enforcement in this constraint handler"]
    pub fn SCIPconshdlrGetEnfoPSTime(conshdlr: *mut SCIP_CONSHDLR) -> f64;
}
extern "C" {
    #[doc = " gets time in seconds used for relaxation enforcement in this constraint handler"]
    pub fn SCIPconshdlrGetEnfoRelaxTime(conshdlr: *mut SCIP_CONSHDLR) -> f64;
}
extern "C" {
    #[doc = " gets time in seconds used for propagation in this constraint handler"]
    pub fn SCIPconshdlrGetPropTime(conshdlr: *mut SCIP_CONSHDLR) -> f64;
}
extern "C" {
    #[doc = " gets time in seconds used for propagation in this constraint handler during strong branching"]
    pub fn SCIPconshdlrGetStrongBranchPropTime(conshdlr: *mut SCIP_CONSHDLR) -> f64;
}
extern "C" {
    #[doc = " gets time in seconds used for feasibility checking in this constraint handler"]
    pub fn SCIPconshdlrGetCheckTime(conshdlr: *mut SCIP_CONSHDLR) -> f64;
}
extern "C" {
    #[doc = " gets time in seconds used for resolving propagation in this constraint handler"]
    pub fn SCIPconshdlrGetRespropTime(conshdlr: *mut SCIP_CONSHDLR) -> f64;
}
extern "C" {
    #[doc = " gets number of calls to the constraint handler's separation method"]
    pub fn SCIPconshdlrGetNSepaCalls(conshdlr: *mut SCIP_CONSHDLR) -> ::std::os::raw::c_longlong;
}
extern "C" {
    #[doc = " gets number of calls to the constraint handler's LP enforcing method"]
    pub fn SCIPconshdlrGetNEnfoLPCalls(conshdlr: *mut SCIP_CONSHDLR) -> ::std::os::raw::c_longlong;
}
extern "C" {
    #[doc = " gets number of calls to the constraint handler's pseudo enforcing method"]
    pub fn SCIPconshdlrGetNEnfoPSCalls(conshdlr: *mut SCIP_CONSHDLR) -> ::std::os::raw::c_longlong;
}
extern "C" {
    #[doc = " gets number of calls to the constraint handler's relaxation enforcing method"]
    pub fn SCIPconshdlrGetNEnfoRelaxCalls(
        conshdlr: *mut SCIP_CONSHDLR,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    #[doc = " gets number of calls to the constraint handler's propagation method"]
    pub fn SCIPconshdlrGetNPropCalls(conshdlr: *mut SCIP_CONSHDLR) -> ::std::os::raw::c_longlong;
}
extern "C" {
    #[doc = " gets number of calls to the constraint handler's checking method"]
    pub fn SCIPconshdlrGetNCheckCalls(conshdlr: *mut SCIP_CONSHDLR) -> ::std::os::raw::c_longlong;
}
extern "C" {
    #[doc = " gets number of calls to the constraint handler's resolve propagation method"]
    pub fn SCIPconshdlrGetNRespropCalls(conshdlr: *mut SCIP_CONSHDLR)
        -> ::std::os::raw::c_longlong;
}
extern "C" {
    #[doc = " gets total number of times, this constraint handler detected a cutoff"]
    pub fn SCIPconshdlrGetNCutoffs(conshdlr: *mut SCIP_CONSHDLR) -> ::std::os::raw::c_longlong;
}
extern "C" {
    #[doc = " gets total number of cuts found by this constraint handler"]
    pub fn SCIPconshdlrGetNCutsFound(conshdlr: *mut SCIP_CONSHDLR) -> ::std::os::raw::c_longlong;
}
extern "C" {
    #[doc = " gets total number of cuts found by this constraint handler applied to lp"]
    pub fn SCIPconshdlrGetNCutsApplied(conshdlr: *mut SCIP_CONSHDLR) -> ::std::os::raw::c_longlong;
}
extern "C" {
    #[doc = " gets total number of additional constraints added by this constraint handler"]
    pub fn SCIPconshdlrGetNConssFound(conshdlr: *mut SCIP_CONSHDLR) -> ::std::os::raw::c_longlong;
}
extern "C" {
    #[doc = " gets total number of domain reductions found by this constraint handler"]
    pub fn SCIPconshdlrGetNDomredsFound(conshdlr: *mut SCIP_CONSHDLR)
        -> ::std::os::raw::c_longlong;
}
extern "C" {
    #[doc = " gets number of children created by this constraint handler"]
    pub fn SCIPconshdlrGetNChildren(conshdlr: *mut SCIP_CONSHDLR) -> ::std::os::raw::c_longlong;
}
extern "C" {
    #[doc = " gets maximum number of active constraints of constraint handler existing at the same time"]
    pub fn SCIPconshdlrGetMaxNActiveConss(conshdlr: *mut SCIP_CONSHDLR) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " gets initial number of active constraints of constraint handler"]
    pub fn SCIPconshdlrGetStartNActiveConss(conshdlr: *mut SCIP_CONSHDLR) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " gets number of variables fixed in presolving method of constraint handler"]
    pub fn SCIPconshdlrGetNFixedVars(conshdlr: *mut SCIP_CONSHDLR) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " gets number of variables aggregated in presolving method of constraint handler"]
    pub fn SCIPconshdlrGetNAggrVars(conshdlr: *mut SCIP_CONSHDLR) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " gets number of variable types changed in presolving method of constraint handler"]
    pub fn SCIPconshdlrGetNChgVarTypes(conshdlr: *mut SCIP_CONSHDLR) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " gets number of bounds changed in presolving method of constraint handler"]
    pub fn SCIPconshdlrGetNChgBds(conshdlr: *mut SCIP_CONSHDLR) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " gets number of holes added to domains of variables in presolving method of constraint handler"]
    pub fn SCIPconshdlrGetNAddHoles(conshdlr: *mut SCIP_CONSHDLR) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " gets number of constraints deleted in presolving method of constraint handler"]
    pub fn SCIPconshdlrGetNDelConss(conshdlr: *mut SCIP_CONSHDLR) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " gets number of constraints added in presolving method of constraint handler"]
    pub fn SCIPconshdlrGetNAddConss(conshdlr: *mut SCIP_CONSHDLR) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " gets number of constraints upgraded in presolving method of constraint handler"]
    pub fn SCIPconshdlrGetNUpgdConss(conshdlr: *mut SCIP_CONSHDLR) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " gets number of coefficients changed in presolving method of constraint handler"]
    pub fn SCIPconshdlrGetNChgCoefs(conshdlr: *mut SCIP_CONSHDLR) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " gets number of constraint sides changed in presolving method of constraint handler"]
    pub fn SCIPconshdlrGetNChgSides(conshdlr: *mut SCIP_CONSHDLR) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " gets number of times the presolving method of the constraint handler was called and tried to find reductions"]
    pub fn SCIPconshdlrGetNPresolCalls(conshdlr: *mut SCIP_CONSHDLR) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " gets separation priority of constraint handler"]
    pub fn SCIPconshdlrGetSepaPriority(conshdlr: *mut SCIP_CONSHDLR) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " gets enforcing priority of constraint handler"]
    pub fn SCIPconshdlrGetEnfoPriority(conshdlr: *mut SCIP_CONSHDLR) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " gets checking priority of constraint handler"]
    pub fn SCIPconshdlrGetCheckPriority(conshdlr: *mut SCIP_CONSHDLR) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " gets separation frequency of constraint handler"]
    pub fn SCIPconshdlrGetSepaFreq(conshdlr: *mut SCIP_CONSHDLR) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " gets propagation frequency of constraint handler"]
    pub fn SCIPconshdlrGetPropFreq(conshdlr: *mut SCIP_CONSHDLR) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " gets frequency of constraint handler for eager evaluations in separation, propagation and enforcement"]
    pub fn SCIPconshdlrGetEagerFreq(conshdlr: *mut SCIP_CONSHDLR) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " needs constraint handler a constraint to be called?"]
    pub fn SCIPconshdlrNeedsCons(conshdlr: *mut SCIP_CONSHDLR) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " does the constraint handler perform presolving?"]
    pub fn SCIPconshdlrDoesPresolve(conshdlr: *mut SCIP_CONSHDLR) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " should separation method be delayed, if other separators found cuts?"]
    pub fn SCIPconshdlrIsSeparationDelayed(conshdlr: *mut SCIP_CONSHDLR) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " should propagation method be delayed, if other propagators found reductions?"]
    pub fn SCIPconshdlrIsPropagationDelayed(conshdlr: *mut SCIP_CONSHDLR)
        -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " was LP separation method delayed at the last call?"]
    pub fn SCIPconshdlrWasLPSeparationDelayed(
        conshdlr: *mut SCIP_CONSHDLR,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " was primal solution separation method delayed at the last call?"]
    pub fn SCIPconshdlrWasSolSeparationDelayed(
        conshdlr: *mut SCIP_CONSHDLR,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " was propagation method delayed at the last call?"]
    pub fn SCIPconshdlrWasPropagationDelayed(
        conshdlr: *mut SCIP_CONSHDLR,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " is constraint handler initialized?"]
    pub fn SCIPconshdlrIsInitialized(conshdlr: *mut SCIP_CONSHDLR) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " does the constraint handler have a copy function?"]
    pub fn SCIPconshdlrIsClonable(conshdlr: *mut SCIP_CONSHDLR) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " returns the timing mask of the propagation method of the constraint handler"]
    pub fn SCIPconshdlrGetPropTiming(conshdlr: *mut SCIP_CONSHDLR) -> SCIP_PROPTIMING;
}
extern "C" {
    #[doc = " gets added constraints data for a constraint set change"]
    pub fn SCIPconssetchgGetAddedConsData(
        conssetchg: *mut SCIP_CONSSETCHG,
        conss: *mut *mut *mut SCIP_CONS,
        nconss: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " sets the timing mask of the propagation method of the constraint handler"]
    pub fn SCIPconshdlrSetPropTiming(conshdlr: *mut SCIP_CONSHDLR, proptiming: SCIP_PROPTIMING);
}
extern "C" {
    #[doc = " returns the timing mask of the presolving method of the constraint handler"]
    pub fn SCIPconshdlrGetPresolTiming(conshdlr: *mut SCIP_CONSHDLR) -> SCIP_PRESOLTIMING;
}
extern "C" {
    #[doc = " sets the timing mask of the presolving method of the constraint handler"]
    pub fn SCIPconshdlrSetPresolTiming(
        conshdlr: *mut SCIP_CONSHDLR,
        presoltiming: SCIP_PRESOLTIMING,
    );
}
extern "C" {
    #[doc = " returns whether conshdlr supports permutation symmetry detection"]
    pub fn SCIPconshdlrSupportsPermsymDetection(
        conshdlr: *mut SCIP_CONSHDLR,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " returns whether conshdlr supports signed permutation symmetry detection"]
    pub fn SCIPconshdlrSupportsSignedPermsymDetection(
        conshdlr: *mut SCIP_CONSHDLR,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " returns the name of the constraint\n\n  @note to change the name of a constraint, use SCIPchgConsName() from scip.h"]
    pub fn SCIPconsGetName(cons: *mut SCIP_CONS) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " returns the position of constraint in the corresponding handler's conss array"]
    pub fn SCIPconsGetPos(cons: *mut SCIP_CONS) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " returns the constraint handler of the constraint"]
    pub fn SCIPconsGetHdlr(cons: *mut SCIP_CONS) -> *mut SCIP_CONSHDLR;
}
extern "C" {
    #[doc = " returns the constraint data field of the constraint"]
    pub fn SCIPconsGetData(cons: *mut SCIP_CONS) -> *mut SCIP_CONSDATA;
}
extern "C" {
    #[doc = " gets number of times, the constraint is currently captured"]
    pub fn SCIPconsGetNUses(cons: *mut SCIP_CONS) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " for an active constraint, returns the depth in the tree at which the constraint was activated"]
    pub fn SCIPconsGetActiveDepth(cons: *mut SCIP_CONS) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " returns the depth in the tree at which the constraint is valid; returns INT_MAX, if the constraint is local\n  and currently not active"]
    pub fn SCIPconsGetValidDepth(cons: *mut SCIP_CONS) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " returns TRUE iff constraint is active in the current node"]
    pub fn SCIPconsIsActive(cons: *mut SCIP_CONS) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " returns TRUE iff constraint has to be deactivated in update phase"]
    pub fn SCIPconsIsUpdatedeactivate(cons: *mut SCIP_CONS) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " returns TRUE iff constraint is enabled in the current node"]
    pub fn SCIPconsIsEnabled(cons: *mut SCIP_CONS) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " returns TRUE iff constraint's separation is enabled in the current node"]
    pub fn SCIPconsIsSeparationEnabled(cons: *mut SCIP_CONS) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " returns TRUE iff constraint's propagation is enabled in the current node"]
    pub fn SCIPconsIsPropagationEnabled(cons: *mut SCIP_CONS) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " returns TRUE iff constraint is deleted or marked to be deleted"]
    pub fn SCIPconsIsDeleted(cons: *mut SCIP_CONS) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " returns TRUE iff constraint is marked obsolete"]
    pub fn SCIPconsIsObsolete(cons: *mut SCIP_CONS) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " returns TRUE iff constraint is marked as a conflict"]
    pub fn SCIPconsIsConflict(cons: *mut SCIP_CONS) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " gets age of constraint"]
    pub fn SCIPconsGetAge(cons: *mut SCIP_CONS) -> f64;
}
extern "C" {
    #[doc = " returns TRUE iff the LP relaxation of constraint should be in the initial LP"]
    pub fn SCIPconsIsInitial(cons: *mut SCIP_CONS) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " returns TRUE iff constraint should be separated during LP processing"]
    pub fn SCIPconsIsSeparated(cons: *mut SCIP_CONS) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " returns TRUE iff constraint should be enforced during node processing"]
    pub fn SCIPconsIsEnforced(cons: *mut SCIP_CONS) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " returns TRUE iff constraint should be checked for feasibility"]
    pub fn SCIPconsIsChecked(cons: *mut SCIP_CONS) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " returns whether the constraint is marked for propagation"]
    pub fn SCIPconsIsMarkedPropagate(cons: *mut SCIP_CONS) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " returns TRUE iff constraint should be propagated during node processing"]
    pub fn SCIPconsIsPropagated(cons: *mut SCIP_CONS) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " returns TRUE iff constraint is globally valid"]
    pub fn SCIPconsIsGlobal(cons: *mut SCIP_CONS) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " returns TRUE iff constraint is only locally valid or not added to any (sub)problem"]
    pub fn SCIPconsIsLocal(cons: *mut SCIP_CONS) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " returns TRUE iff constraint is modifiable (subject to column generation)"]
    pub fn SCIPconsIsModifiable(cons: *mut SCIP_CONS) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " returns TRUE iff constraint is subject to aging"]
    pub fn SCIPconsIsDynamic(cons: *mut SCIP_CONS) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " returns TRUE iff constraint's relaxation should be removed from the LP due to aging or cleanup"]
    pub fn SCIPconsIsRemovable(cons: *mut SCIP_CONS) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " returns TRUE iff constraint's relaxation should be removed from the LP due to aging or cleanup"]
    pub fn SCIPconsIsStickingAtNode(cons: *mut SCIP_CONS) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " returns TRUE iff constraint belongs to the global problem"]
    pub fn SCIPconsIsInProb(cons: *mut SCIP_CONS) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " returns TRUE iff constraint is belonging to original space"]
    pub fn SCIPconsIsOriginal(cons: *mut SCIP_CONS) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " returns TRUE iff constraint is belonging to transformed space"]
    pub fn SCIPconsIsTransformed(cons: *mut SCIP_CONS) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " returns TRUE iff roundings for variables in constraint are locked"]
    pub fn SCIPconsIsLockedPos(cons: *mut SCIP_CONS) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " returns TRUE iff roundings for variables in constraint's negation are locked"]
    pub fn SCIPconsIsLockedNeg(cons: *mut SCIP_CONS) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " returns TRUE iff roundings for variables in constraint or in constraint's negation are locked"]
    pub fn SCIPconsIsLocked(cons: *mut SCIP_CONS) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " get number of times the roundings for variables in constraint are locked"]
    pub fn SCIPconsGetNLocksPos(cons: *mut SCIP_CONS) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " get number of times the roundings for variables in constraint's negation are locked"]
    pub fn SCIPconsGetNLocksNeg(cons: *mut SCIP_CONS) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " returns TRUE iff roundings of the given locktype for variables in constraint are locked"]
    pub fn SCIPconsIsLockedTypePos(
        cons: *mut SCIP_CONS,
        locktype: SCIP_LOCKTYPE,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " returns TRUE iff roundings of the given locktype for variables in constraint are locked"]
    pub fn SCIPconsIsLockedTypeNeg(
        cons: *mut SCIP_CONS,
        locktype: SCIP_LOCKTYPE,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " returns TRUE iff roundings of the given locktype for variables in constraint or in constraint's negation are locked"]
    pub fn SCIPconsIsLockedType(
        cons: *mut SCIP_CONS,
        locktype: SCIP_LOCKTYPE,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " get number of times the roundings of given locktype for variables in constraint are locked"]
    pub fn SCIPconsGetNLocksTypePos(
        cons: *mut SCIP_CONS,
        locktype: SCIP_LOCKTYPE,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " get number of times the roundings of given locktype for variables in constraint's negation are locked"]
    pub fn SCIPconsGetNLocksTypeNeg(
        cons: *mut SCIP_CONS,
        locktype: SCIP_LOCKTYPE,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " returns if the constraint was already added to a SCIP instance"]
    pub fn SCIPconsIsAdded(cons: *mut SCIP_CONS) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " adds locks to (dis-)allow upgrading of constraint"]
    pub fn SCIPconsAddUpgradeLocks(cons: *mut SCIP_CONS, nlocks: ::std::os::raw::c_int);
}
extern "C" {
    #[doc = " gets number of locks against upgrading the constraint, 0 means this constraint can be upgraded"]
    pub fn SCIPconsGetNUpgradeLocks(cons: *mut SCIP_CONS) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " create linear constraint statistics"]
    pub fn SCIPlinConsStatsCreate(
        scip: *mut SCIP,
        linconsstats: *mut *mut SCIP_LINCONSSTATS,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " free linear constraint statistics"]
    pub fn SCIPlinConsStatsFree(scip: *mut SCIP, linconsstats: *mut *mut SCIP_LINCONSSTATS);
}
extern "C" {
    #[doc = " resets linear constraint statistics"]
    pub fn SCIPlinConsStatsReset(linconsstats: *mut SCIP_LINCONSSTATS);
}
extern "C" {
    #[doc = " returns the number of occurrences of a specific type of linear constraint"]
    pub fn SCIPlinConsStatsGetTypeCount(
        linconsstats: *mut SCIP_LINCONSSTATS,
        linconstype: SCIP_LINCONSTYPE,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " returns the total number of classified constraints"]
    pub fn SCIPlinConsStatsGetSum(linconsstats: *mut SCIP_LINCONSSTATS) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " increases the number of occurrences of a specific type of linear constraint"]
    pub fn SCIPlinConsStatsIncTypeCount(
        linconsstats: *mut SCIP_LINCONSSTATS,
        linconstype: SCIP_LINCONSTYPE,
        increment: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " print linear constraint classification statistics"]
    pub fn SCIPprintLinConsStats(
        scip: *mut SCIP,
        file: *mut FILE,
        linconsstats: *mut SCIP_LINCONSSTATS,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_Cutpool {
    _unused: [u8; 0],
}
pub type SCIP_CUTPOOL = SCIP_Cutpool;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_Cut {
    _unused: [u8; 0],
}
pub type SCIP_CUT = SCIP_Cut;
extern "C" {
    #[doc = " gets the row of the cut"]
    pub fn SCIPcutGetRow(cut: *mut SCIP_CUT) -> *mut SCIP_ROW;
}
extern "C" {
    #[doc = " gets the age of the cut: the number of consecutive cut pool separation rounds where the cut was neither in the LP nor violated"]
    pub fn SCIPcutGetAge(cut: *mut SCIP_CUT) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " returns the ratio of LPs where the row belonging to this cut was active in an LP solution, i.e.\n  where the age of its row has not been increased\n\n  @see SCIPcutGetAge() to get the age of a cut"]
    pub fn SCIPcutGetLPActivityQuot(cut: *mut SCIP_CUT) -> f64;
}
extern "C" {
    #[doc = " gets array of cuts in the cut pool"]
    pub fn SCIPcutpoolGetCuts(cutpool: *mut SCIP_CUTPOOL) -> *mut *mut SCIP_CUT;
}
extern "C" {
    #[doc = " get number of cuts in the cut pool"]
    pub fn SCIPcutpoolGetNCuts(cutpool: *mut SCIP_CUTPOOL) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " get maximum number of cuts that were stored in the cut pool at the same time"]
    pub fn SCIPcutpoolGetMaxNCuts(cutpool: *mut SCIP_CUTPOOL) -> ::std::os::raw::c_longlong;
}
extern "C" {
    #[doc = " gets time in seconds used for separating cuts from the pool"]
    pub fn SCIPcutpoolGetTime(cutpool: *mut SCIP_CUTPOOL) -> f64;
}
extern "C" {
    #[doc = " get number of times the cut pool was separated"]
    pub fn SCIPcutpoolGetNCalls(cutpool: *mut SCIP_CUTPOOL) -> ::std::os::raw::c_longlong;
}
extern "C" {
    #[doc = " get number of times the cut pool was separated at the root"]
    pub fn SCIPcutpoolGetNRootCalls(cutpool: *mut SCIP_CUTPOOL) -> ::std::os::raw::c_longlong;
}
extern "C" {
    #[doc = " get total number of cuts that were separated from the cut pool"]
    pub fn SCIPcutpoolGetNCutsFound(cutpool: *mut SCIP_CUTPOOL) -> ::std::os::raw::c_longlong;
}
extern "C" {
    #[doc = " get total number of cuts that were added from the cut pool to sepastore"]
    pub fn SCIPcutpoolGetNCutsAdded(cutpool: *mut SCIP_CUTPOOL) -> ::std::os::raw::c_longlong;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_Decomp {
    _unused: [u8; 0],
}
pub type SCIP_DECOMP = SCIP_Decomp;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_DecompStore {
    _unused: [u8; 0],
}
pub type SCIP_DECOMPSTORE = SCIP_DecompStore;
extern "C" {
    #[doc = " creates a decomposition"]
    pub fn SCIPdecompCreate(
        decomp: *mut *mut SCIP_DECOMP,
        blkmem: *mut BMS_BLKMEM,
        nblocks: ::std::os::raw::c_int,
        original: ::std::os::raw::c_uint,
        benderslabels: ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " frees a decomposition"]
    pub fn SCIPdecompFree(decomp: *mut *mut SCIP_DECOMP, blkmem: *mut BMS_BLKMEM);
}
extern "C" {
    #[doc = " returns TRUE if decomposition is in the original space"]
    pub fn SCIPdecompIsOriginal(decomp: *mut SCIP_DECOMP) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " sets the parameter that indicates whether the variables must be labeled for the application of Benders'\n decomposition"]
    pub fn SCIPdecompSetUseBendersLabels(
        decomp: *mut SCIP_DECOMP,
        benderslabels: ::std::os::raw::c_uint,
    );
}
extern "C" {
    #[doc = " returns TRUE if the variables must be labeled for the application of Benders' decomposition"]
    pub fn SCIPdecompUseBendersLabels(decomp: *mut SCIP_DECOMP) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " gets number of blocks of this decomposition"]
    pub fn SCIPdecompGetNBlocks(decomp: *mut SCIP_DECOMP) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " gets area score of this decomposition"]
    pub fn SCIPdecompGetAreaScore(decomp: *mut SCIP_DECOMP) -> f64;
}
extern "C" {
    #[doc = " gets modularity of this decomposition"]
    pub fn SCIPdecompGetModularity(decomp: *mut SCIP_DECOMP) -> f64;
}
extern "C" {
    #[doc = " gets variable size for each block, sorted by increasing block label\n\n To get all variable sizes, set nlabels to SCIPdecompGetNBlocks() + 1.\n The first entry corresponds to the number of border variables.\n\n @note Ensure that SCIPcomputeDecompStats() has been called before.\n       If the decomposition was read from a file, this was done automatically."]
    pub fn SCIPdecompGetVarsSize(
        decomp: *mut SCIP_DECOMP,
        varssize: *mut ::std::os::raw::c_int,
        nblocks: ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " gets constraint size for each block, sorted by increasing block label\n\n To get all constraint sizes, set nlabels to SCIPdecompGetNBlocks() + 1.\n The first entry corresponds to the number of border constraints.\n\n @note Ensure that SCIPcomputeDecompStats() has been called before.\n       If the decomposition was read from a file, this was done automatically."]
    pub fn SCIPdecompGetConssSize(
        decomp: *mut SCIP_DECOMP,
        consssize: *mut ::std::os::raw::c_int,
        nblocks: ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " gets number of border variables of this decomposition\n\n @note Ensure that SCIPcomputeDecompStats() has been called before.\n       If the decomposition was read from a file, this was done automatically."]
    pub fn SCIPdecompGetNBorderVars(decomp: *mut SCIP_DECOMP) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " gets number of border constraints of this decomposition\n\n @note Ensure that SCIPcomputeDecompStats() has been called before.\n       If the decomposition was read from a file, this was done automatically."]
    pub fn SCIPdecompGetNBorderConss(decomp: *mut SCIP_DECOMP) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " gets number of edges in the block-decomposition graph of this decomposition"]
    pub fn SCIPdecompGetNBlockGraphEdges(decomp: *mut SCIP_DECOMP) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " gets number of connected components in the block-decomposition graph of this decomposition"]
    pub fn SCIPdecompGetNBlockGraphComponents(decomp: *mut SCIP_DECOMP) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " gets number of articulation points in the block-decomposition graph of this decomposition"]
    pub fn SCIPdecompGetNBlockGraphArticulations(decomp: *mut SCIP_DECOMP)
        -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " gets the maximum degree of the block-decomposition graph of this decomposition"]
    pub fn SCIPdecompGetBlockGraphMaxDegree(decomp: *mut SCIP_DECOMP) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " gets the minimum degree of the block-decomposition graph of this decomposition"]
    pub fn SCIPdecompGetBlockGraphMinDegree(decomp: *mut SCIP_DECOMP) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " sets labels for an array of variables"]
    pub fn SCIPdecompSetVarsLabels(
        decomp: *mut SCIP_DECOMP,
        vars: *mut *mut SCIP_VAR,
        labels: *mut ::std::os::raw::c_int,
        nvars: ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " queries labels for an array of variables"]
    pub fn SCIPdecompGetVarsLabels(
        decomp: *mut SCIP_DECOMP,
        vars: *mut *mut SCIP_VAR,
        labels: *mut ::std::os::raw::c_int,
        nvars: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " sets labels for an array of constraints"]
    pub fn SCIPdecompSetConsLabels(
        decomp: *mut SCIP_DECOMP,
        conss: *mut *mut SCIP_CONS,
        labels: *mut ::std::os::raw::c_int,
        nconss: ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " queries labels for an array of constraints"]
    pub fn SCIPdecompGetConsLabels(
        decomp: *mut SCIP_DECOMP,
        conss: *mut *mut SCIP_CONS,
        labels: *mut ::std::os::raw::c_int,
        nconss: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " clears the corresponding labeling (constraints, variables, or both) of this decomposition"]
    pub fn SCIPdecompClear(
        decomp: *mut SCIP_DECOMP,
        clearvarlabels: ::std::os::raw::c_uint,
        clearconslabels: ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " prints decomposition statistics into string buffer"]
    pub fn SCIPdecompPrintStats(
        decomp: *mut SCIP_DECOMP,
        strbuf: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = "@addtogroup PublicDialogMethods\n\n @{\n/\n/** returns the root dialog of the dialog handler"]
    pub fn SCIPdialoghdlrGetRoot(dialoghdlr: *mut SCIP_DIALOGHDLR) -> *mut SCIP_DIALOG;
}
extern "C" {
    #[doc = " clears the input command buffer of the dialog handler"]
    pub fn SCIPdialoghdlrClearBuffer(dialoghdlr: *mut SCIP_DIALOGHDLR);
}
extern "C" {
    #[doc = " returns TRUE iff input command buffer is empty"]
    pub fn SCIPdialoghdlrIsBufferEmpty(dialoghdlr: *mut SCIP_DIALOGHDLR) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " returns the next line in the handler's command buffer; if the buffer is empty, displays the given prompt or the\n  current dialog's path and asks the user for further input; the user must not free or modify the returned string"]
    pub fn SCIPdialoghdlrGetLine(
        dialoghdlr: *mut SCIP_DIALOGHDLR,
        dialog: *mut SCIP_DIALOG,
        prompt: *const ::std::os::raw::c_char,
        inputline: *mut *mut ::std::os::raw::c_char,
        endoffile: *mut ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " returns the next word in the handler's command buffer; if the buffer is empty, displays the given prompt or the\n  current dialog's path and asks the user for further input; the user must not free or modify the returned string"]
    pub fn SCIPdialoghdlrGetWord(
        dialoghdlr: *mut SCIP_DIALOGHDLR,
        dialog: *mut SCIP_DIALOG,
        prompt: *const ::std::os::raw::c_char,
        inputword: *mut *mut ::std::os::raw::c_char,
        endoffile: *mut ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " adds a single line of input to the dialog handler which is treated as if the user entered the command line"]
    pub fn SCIPdialoghdlrAddInputLine(
        dialoghdlr: *mut SCIP_DIALOGHDLR,
        inputline: *const ::std::os::raw::c_char,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " adds a command to the command history of the dialog handler; if a dialog is given, the command is preceeded\n  by the dialog's command path; if no command is given, only the path to the dialog is added to the command history"]
    pub fn SCIPdialoghdlrAddHistory(
        dialoghdlr: *mut SCIP_DIALOGHDLR,
        dialog: *mut SCIP_DIALOG,
        command: *const ::std::os::raw::c_char,
        escapecommand: ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " returns TRUE iff a dialog entry matching exactly the given name is existing in the given dialog"]
    pub fn SCIPdialogHasEntry(
        dialog: *mut SCIP_DIALOG,
        entryname: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " searches the dialog for entries corresponding to the given name;\n  If a complete match is found, the entry is returned as \"subdialog\" and\n  the return value is 1.\n  If no dialog entry completely matches the given \"entryname\", the number\n  of entries with names beginning with \"entryname\" is returned. If this\n  number is 1, the single match is returned as \"subdialog\". Otherwise,\n  \"subdialog\" is set to NULL."]
    pub fn SCIPdialogFindEntry(
        dialog: *mut SCIP_DIALOG,
        entryname: *const ::std::os::raw::c_char,
        subdialog: *mut *mut SCIP_DIALOG,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " displays the dialog's menu"]
    pub fn SCIPdialogDisplayMenu(dialog: *mut SCIP_DIALOG, scip: *mut SCIP) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " displays the entry for the dialog in it's parent's menu"]
    pub fn SCIPdialogDisplayMenuEntry(dialog: *mut SCIP_DIALOG, scip: *mut SCIP) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " displays all dialog entries with names starting with the given \"entryname\""]
    pub fn SCIPdialogDisplayCompletions(
        dialog: *mut SCIP_DIALOG,
        scip: *mut SCIP,
        entryname: *const ::std::os::raw::c_char,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " gets the name of the current path in the dialog tree, separated by the given character"]
    pub fn SCIPdialogGetPath(
        dialog: *mut SCIP_DIALOG,
        sepchar: ::std::os::raw::c_char,
        path: *mut ::std::os::raw::c_char,
    );
}
extern "C" {
    #[doc = " gets the command name of the dialog"]
    pub fn SCIPdialogGetName(dialog: *mut SCIP_DIALOG) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " gets the description of the dialog"]
    pub fn SCIPdialogGetDesc(dialog: *mut SCIP_DIALOG) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " returns whether the dialog is a sub menu"]
    pub fn SCIPdialogIsSubmenu(dialog: *mut SCIP_DIALOG) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " gets the parent dialog of the given dialog"]
    pub fn SCIPdialogGetParent(dialog: *mut SCIP_DIALOG) -> *mut SCIP_DIALOG;
}
extern "C" {
    #[doc = " gets the array of sub-dialogs associated with the given dialog"]
    pub fn SCIPdialogGetSubdialogs(dialog: *mut SCIP_DIALOG) -> *mut *mut SCIP_DIALOG;
}
extern "C" {
    #[doc = " gets the number of sub-dialogs associated with the given dialog"]
    pub fn SCIPdialogGetNSubdialogs(dialog: *mut SCIP_DIALOG) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " gets the user defined data associated with the given dialog"]
    pub fn SCIPdialogGetData(dialog: *mut SCIP_DIALOG) -> *mut SCIP_DIALOGDATA;
}
extern "C" {
    #[doc = " sets user data of dialog; user has to free old data in advance!"]
    pub fn SCIPdialogSetData(dialog: *mut SCIP_DIALOG, dialogdata: *mut SCIP_DIALOGDATA);
}
extern "C" {
    #[doc = " writes command history to specified filename"]
    pub fn SCIPdialogWriteHistory(filename: *const ::std::os::raw::c_char) -> SCIP_RETCODE;
}
#[doc = "< only error and warning messages are displayed"]
pub const SCIP_VerbLevel_SCIP_VERBLEVEL_NONE: SCIP_VerbLevel = 0;
#[doc = "< only interactive dialogs, errors, and warnings are displayed"]
pub const SCIP_VerbLevel_SCIP_VERBLEVEL_DIALOG: SCIP_VerbLevel = 1;
#[doc = "< only important messages are displayed"]
pub const SCIP_VerbLevel_SCIP_VERBLEVEL_MINIMAL: SCIP_VerbLevel = 2;
#[doc = "< standard messages are displayed"]
pub const SCIP_VerbLevel_SCIP_VERBLEVEL_NORMAL: SCIP_VerbLevel = 3;
#[doc = "< a lot of information is displayed"]
pub const SCIP_VerbLevel_SCIP_VERBLEVEL_HIGH: SCIP_VerbLevel = 4;
#[doc = "< all messages are displayed"]
pub const SCIP_VerbLevel_SCIP_VERBLEVEL_FULL: SCIP_VerbLevel = 5;
#[doc = " verbosity levels of output"]
pub type SCIP_VerbLevel = ::std::os::raw::c_uint;
#[doc = " verbosity levels of output"]
pub use self::SCIP_VerbLevel as SCIP_VERBLEVEL;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_Messagehdlr {
    _unused: [u8; 0],
}
pub type SCIP_MESSAGEHDLR = SCIP_Messagehdlr;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_MessagehdlrData {
    _unused: [u8; 0],
}
pub type SCIP_MESSAGEHDLRDATA = SCIP_MessagehdlrData;
extern "C" {
    #[doc = " gets user data of display column"]
    pub fn SCIPdispGetData(disp: *mut SCIP_DISP) -> *mut SCIP_DISPDATA;
}
extern "C" {
    #[doc = " sets user data of display column; user has to free old data in advance!"]
    pub fn SCIPdispSetData(disp: *mut SCIP_DISP, dispdata: *mut SCIP_DISPDATA);
}
extern "C" {
    #[doc = " gets name of display column"]
    pub fn SCIPdispGetName(disp: *mut SCIP_DISP) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " gets description of display column"]
    pub fn SCIPdispGetDesc(disp: *mut SCIP_DISP) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " gets head line of display column"]
    pub fn SCIPdispGetHeader(disp: *mut SCIP_DISP) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " gets width of display column"]
    pub fn SCIPdispGetWidth(disp: *mut SCIP_DISP) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " gets priority of display column"]
    pub fn SCIPdispGetPriority(disp: *mut SCIP_DISP) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " gets position of display column"]
    pub fn SCIPdispGetPosition(disp: *mut SCIP_DISP) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " gets status of display column"]
    pub fn SCIPdispGetStatus(disp: *mut SCIP_DISP) -> SCIP_DISPSTATUS;
}
extern "C" {
    #[doc = " is display column initialized?"]
    pub fn SCIPdispIsInitialized(disp: *mut SCIP_DISP) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " displays a long integer in decimal form fitting in a given width"]
    pub fn SCIPdispLongint(
        messagehdlr: *mut SCIP_MESSAGEHDLR,
        file: *mut FILE,
        val: ::std::os::raw::c_longlong,
        width: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " displays an integer in decimal form fitting in a given width"]
    pub fn SCIPdispInt(
        messagehdlr: *mut SCIP_MESSAGEHDLR,
        file: *mut FILE,
        val: ::std::os::raw::c_int,
        width: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " displays a time value fitting in a given width"]
    pub fn SCIPdispTime(
        messagehdlr: *mut SCIP_MESSAGEHDLR,
        file: *mut FILE,
        val: f64,
        width: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " gets name of event handler"]
    pub fn SCIPeventhdlrGetName(eventhdlr: *mut SCIP_EVENTHDLR) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " gets user data of event handler"]
    pub fn SCIPeventhdlrGetData(eventhdlr: *mut SCIP_EVENTHDLR) -> *mut SCIP_EVENTHDLRDATA;
}
extern "C" {
    #[doc = " sets user data of event handler; user has to free old data in advance!"]
    pub fn SCIPeventhdlrSetData(
        eventhdlr: *mut SCIP_EVENTHDLR,
        eventhdlrdata: *mut SCIP_EVENTHDLRDATA,
    );
}
extern "C" {
    #[doc = " is event handler initialized?"]
    pub fn SCIPeventhdlrIsInitialized(eventhdlr: *mut SCIP_EVENTHDLR) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " gets time in seconds used in this event handler for setting up for next stages"]
    pub fn SCIPeventhdlrGetSetupTime(eventhdlr: *mut SCIP_EVENTHDLR) -> f64;
}
extern "C" {
    #[doc = " gets time in seconds used in this event handler"]
    pub fn SCIPeventhdlrGetTime(eventhdlr: *mut SCIP_EVENTHDLR) -> f64;
}
extern "C" {
    #[doc = " gets type of event"]
    pub fn SCIPeventGetType(event: *mut SCIP_EVENT) -> SCIP_EVENTTYPE;
}
extern "C" {
    #[doc = " gets variable for a variable event (var added, var deleted, var fixed,\n  objective value or domain change, domain hole added or removed)"]
    pub fn SCIPeventGetVar(event: *mut SCIP_EVENT) -> *mut SCIP_VAR;
}
extern "C" {
    #[doc = " gets old objective value for an objective value change event"]
    pub fn SCIPeventGetOldobj(event: *mut SCIP_EVENT) -> f64;
}
extern "C" {
    #[doc = " gets new objective value for an objective value change event"]
    pub fn SCIPeventGetNewobj(event: *mut SCIP_EVENT) -> f64;
}
extern "C" {
    #[doc = " gets old bound for a bound change event"]
    pub fn SCIPeventGetOldbound(event: *mut SCIP_EVENT) -> f64;
}
extern "C" {
    #[doc = " gets new bound for a bound change event"]
    pub fn SCIPeventGetNewbound(event: *mut SCIP_EVENT) -> f64;
}
extern "C" {
    #[doc = " gets old variable type for a variable type change event"]
    pub fn SCIPeventGetOldtype(event: *mut SCIP_EVENT) -> SCIP_VARTYPE;
}
extern "C" {
    #[doc = " gets new variable type for a variable type change event"]
    pub fn SCIPeventGetNewtype(event: *mut SCIP_EVENT) -> SCIP_VARTYPE;
}
extern "C" {
    #[doc = " gets node for a node or LP event"]
    pub fn SCIPeventGetNode(event: *mut SCIP_EVENT) -> *mut SCIP_NODE;
}
extern "C" {
    #[doc = " gets solution for a primal solution event"]
    pub fn SCIPeventGetSol(event: *mut SCIP_EVENT) -> *mut SCIP_SOL;
}
extern "C" {
    #[doc = " gets the left bound of open interval in the hole"]
    pub fn SCIPeventGetHoleLeft(event: *mut SCIP_EVENT) -> f64;
}
extern "C" {
    #[doc = " gets the right bound of open interval in the hole"]
    pub fn SCIPeventGetHoleRight(event: *mut SCIP_EVENT) -> f64;
}
extern "C" {
    #[doc = " gets row for a row event"]
    pub fn SCIPeventGetRow(event: *mut SCIP_EVENT) -> *mut SCIP_ROW;
}
extern "C" {
    #[doc = " gets column for a row change coefficient event"]
    pub fn SCIPeventGetRowCol(event: *mut SCIP_EVENT) -> *mut SCIP_COL;
}
extern "C" {
    #[doc = " gets old coefficient value for a row change coefficient event"]
    pub fn SCIPeventGetRowOldCoefVal(event: *mut SCIP_EVENT) -> f64;
}
extern "C" {
    #[doc = " gets new coefficient value for a row change coefficient event"]
    pub fn SCIPeventGetRowNewCoefVal(event: *mut SCIP_EVENT) -> f64;
}
extern "C" {
    #[doc = " gets old constant value for a row change constant event"]
    pub fn SCIPeventGetRowOldConstVal(event: *mut SCIP_EVENT) -> f64;
}
extern "C" {
    #[doc = " gets new constant value for a row change constant event"]
    pub fn SCIPeventGetRowNewConstVal(event: *mut SCIP_EVENT) -> f64;
}
extern "C" {
    #[doc = " gets side for a row change side event"]
    pub fn SCIPeventGetRowSide(event: *mut SCIP_EVENT) -> SCIP_SIDETYPE;
}
extern "C" {
    #[doc = " gets old side value for a row change side event"]
    pub fn SCIPeventGetRowOldSideVal(event: *mut SCIP_EVENT) -> f64;
}
extern "C" {
    #[doc = " gets new side value for a row change side event"]
    pub fn SCIPeventGetRowNewSideVal(event: *mut SCIP_EVENT) -> f64;
}
extern "C" {
    #[doc = " set the expression handler callbacks to copy and free an expression handler"]
    pub fn SCIPexprhdlrSetCopyFreeHdlr(
        exprhdlr: *mut SCIP_EXPRHDLR,
        copyhdlr: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                sourceexprhdlr: *mut SCIP_EXPRHDLR,
            ) -> SCIP_RETCODE,
        >,
        freehdlr: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                exprhdlr: *mut SCIP_EXPRHDLR,
                exprhdlrdata: *mut *mut SCIP_EXPRHDLRDATA,
            ) -> SCIP_RETCODE,
        >,
    );
}
extern "C" {
    #[doc = " set the expression handler callbacks to copy and free expression data"]
    pub fn SCIPexprhdlrSetCopyFreeData(
        exprhdlr: *mut SCIP_EXPRHDLR,
        copydata: ::std::option::Option<
            unsafe extern "C" fn(
                targetscip: *mut SCIP,
                targetexprhdlr: *mut SCIP_EXPRHDLR,
                targetexprdata: *mut *mut SCIP_EXPRDATA,
                sourcescip: *mut SCIP,
                sourceexpr: *mut SCIP_EXPR,
            ) -> SCIP_RETCODE,
        >,
        freedata: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, expr: *mut SCIP_EXPR) -> SCIP_RETCODE,
        >,
    );
}
extern "C" {
    #[doc = " set the print callback of an expression handler"]
    pub fn SCIPexprhdlrSetPrint(
        exprhdlr: *mut SCIP_EXPRHDLR,
        print: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                expr: *mut SCIP_EXPR,
                stage: SCIP_EXPRITER_STAGE,
                currentchild: ::std::os::raw::c_int,
                parentprecedence: ::std::os::raw::c_uint,
                file: *mut FILE,
            ) -> SCIP_RETCODE,
        >,
    );
}
extern "C" {
    #[doc = " set the parse callback of an expression handler"]
    pub fn SCIPexprhdlrSetParse(
        exprhdlr: *mut SCIP_EXPRHDLR,
        parse: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                exprhdlr: *mut SCIP_EXPRHDLR,
                string: *const ::std::os::raw::c_char,
                endstring: *mut *const ::std::os::raw::c_char,
                expr: *mut *mut SCIP_EXPR,
                success: *mut ::std::os::raw::c_uint,
                ownercreate: ::std::option::Option<
                    unsafe extern "C" fn(
                        scip: *mut SCIP,
                        expr: *mut SCIP_EXPR,
                        ownerdata: *mut *mut SCIP_EXPR_OWNERDATA,
                        ownerfree: *mut ::std::option::Option<
                            unsafe extern "C" fn(
                                scip: *mut SCIP,
                                expr: *mut SCIP_EXPR,
                                ownerdata: *mut *mut SCIP_EXPR_OWNERDATA,
                            ) -> SCIP_RETCODE,
                        >,
                        ownerprint: *mut ::std::option::Option<
                            unsafe extern "C" fn(
                                scip: *mut SCIP,
                                file: *mut FILE,
                                expr: *mut SCIP_EXPR,
                                ownerdata: *mut SCIP_EXPR_OWNERDATA,
                            ) -> SCIP_RETCODE,
                        >,
                        ownerevalactivity: *mut ::std::option::Option<
                            unsafe extern "C" fn(
                                scip: *mut SCIP,
                                expr: *mut SCIP_EXPR,
                                ownerdata: *mut SCIP_EXPR_OWNERDATA,
                            ) -> SCIP_RETCODE,
                        >,
                        ownercreatedata: *mut ::std::os::raw::c_void,
                    ) -> SCIP_RETCODE,
                >,
                ownercreatedata: *mut ::std::os::raw::c_void,
            ) -> SCIP_RETCODE,
        >,
    );
}
extern "C" {
    #[doc = " set the curvature detection callback of an expression handler"]
    pub fn SCIPexprhdlrSetCurvature(
        exprhdlr: *mut SCIP_EXPRHDLR,
        curvature: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                expr: *mut SCIP_EXPR,
                exprcurvature: SCIP_EXPRCURV,
                success: *mut ::std::os::raw::c_uint,
                childcurv: *mut SCIP_EXPRCURV,
            ) -> SCIP_RETCODE,
        >,
    );
}
extern "C" {
    #[doc = " set the monotonicity detection callback of an expression handler"]
    pub fn SCIPexprhdlrSetMonotonicity(
        exprhdlr: *mut SCIP_EXPRHDLR,
        monotonicity: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                expr: *mut SCIP_EXPR,
                childidx: ::std::os::raw::c_int,
                result: *mut SCIP_MONOTONE,
            ) -> SCIP_RETCODE,
        >,
    );
}
extern "C" {
    #[doc = " set the integrality detection callback of an expression handler"]
    pub fn SCIPexprhdlrSetIntegrality(
        exprhdlr: *mut SCIP_EXPRHDLR,
        integrality: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                expr: *mut SCIP_EXPR,
                isintegral: *mut ::std::os::raw::c_uint,
            ) -> SCIP_RETCODE,
        >,
    );
}
extern "C" {
    #[doc = " set the hash callback of an expression handler"]
    pub fn SCIPexprhdlrSetHash(
        exprhdlr: *mut SCIP_EXPRHDLR,
        hash: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                expr: *mut SCIP_EXPR,
                hashkey: *mut ::std::os::raw::c_uint,
                childrenhashes: *mut ::std::os::raw::c_uint,
            ) -> SCIP_RETCODE,
        >,
    );
}
extern "C" {
    #[doc = " set the compare callback of an expression handler"]
    pub fn SCIPexprhdlrSetCompare(
        exprhdlr: *mut SCIP_EXPRHDLR,
        compare: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                expr1: *mut SCIP_EXPR,
                expr2: *mut SCIP_EXPR,
            ) -> ::std::os::raw::c_int,
        >,
    );
}
extern "C" {
    #[doc = " set differentiation callbacks of an expression handler"]
    pub fn SCIPexprhdlrSetDiff(
        exprhdlr: *mut SCIP_EXPRHDLR,
        bwdiff: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                expr: *mut SCIP_EXPR,
                childidx: ::std::os::raw::c_int,
                val: *mut f64,
            ) -> SCIP_RETCODE,
        >,
        fwdiff: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                expr: *mut SCIP_EXPR,
                dot: *mut f64,
                direction: *mut SCIP_SOL,
            ) -> SCIP_RETCODE,
        >,
        bwfwdiff: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                expr: *mut SCIP_EXPR,
                childidx: ::std::os::raw::c_int,
                bardot: *mut f64,
                direction: *mut SCIP_SOL,
            ) -> SCIP_RETCODE,
        >,
    );
}
extern "C" {
    #[doc = " set the interval evaluation callback of an expression handler"]
    pub fn SCIPexprhdlrSetIntEval(
        exprhdlr: *mut SCIP_EXPRHDLR,
        inteval: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                expr: *mut SCIP_EXPR,
                interval: *mut SCIP_INTERVAL,
                intevalvar: ::std::option::Option<
                    unsafe extern "C" fn(
                        scip: *mut SCIP,
                        var: *mut SCIP_VAR,
                        intevalvardata: *mut ::std::os::raw::c_void,
                    ) -> SCIP_INTERVAL,
                >,
                intevalvardata: *mut ::std::os::raw::c_void,
            ) -> SCIP_RETCODE,
        >,
    );
}
extern "C" {
    #[doc = " set the simplify callback of an expression handler"]
    pub fn SCIPexprhdlrSetSimplify(
        exprhdlr: *mut SCIP_EXPRHDLR,
        simplify: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                expr: *mut SCIP_EXPR,
                simplifiedexpr: *mut *mut SCIP_EXPR,
                ownercreate: ::std::option::Option<
                    unsafe extern "C" fn(
                        scip: *mut SCIP,
                        expr: *mut SCIP_EXPR,
                        ownerdata: *mut *mut SCIP_EXPR_OWNERDATA,
                        ownerfree: *mut ::std::option::Option<
                            unsafe extern "C" fn(
                                scip: *mut SCIP,
                                expr: *mut SCIP_EXPR,
                                ownerdata: *mut *mut SCIP_EXPR_OWNERDATA,
                            ) -> SCIP_RETCODE,
                        >,
                        ownerprint: *mut ::std::option::Option<
                            unsafe extern "C" fn(
                                scip: *mut SCIP,
                                file: *mut FILE,
                                expr: *mut SCIP_EXPR,
                                ownerdata: *mut SCIP_EXPR_OWNERDATA,
                            ) -> SCIP_RETCODE,
                        >,
                        ownerevalactivity: *mut ::std::option::Option<
                            unsafe extern "C" fn(
                                scip: *mut SCIP,
                                expr: *mut SCIP_EXPR,
                                ownerdata: *mut SCIP_EXPR_OWNERDATA,
                            ) -> SCIP_RETCODE,
                        >,
                        ownercreatedata: *mut ::std::os::raw::c_void,
                    ) -> SCIP_RETCODE,
                >,
                ownercreatedata: *mut ::std::os::raw::c_void,
            ) -> SCIP_RETCODE,
        >,
    );
}
extern "C" {
    #[doc = " set the reverse propagation callback of an expression handler"]
    pub fn SCIPexprhdlrSetReverseProp(
        exprhdlr: *mut SCIP_EXPRHDLR,
        reverseprop: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                expr: *mut SCIP_EXPR,
                bounds: SCIP_INTERVAL,
                childrenbounds: *mut SCIP_INTERVAL,
                infeasible: *mut ::std::os::raw::c_uint,
            ) -> SCIP_RETCODE,
        >,
    );
}
extern "C" {
    #[doc = " set the estimation callbacks of an expression handler"]
    pub fn SCIPexprhdlrSetEstimate(
        exprhdlr: *mut SCIP_EXPRHDLR,
        initestimates: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                expr: *mut SCIP_EXPR,
                bounds: *mut SCIP_INTERVAL,
                overestimate: ::std::os::raw::c_uint,
                coefs: *mut *mut f64,
                constant: *mut f64,
                nreturned: *mut ::std::os::raw::c_int,
            ) -> SCIP_RETCODE,
        >,
        estimate: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                expr: *mut SCIP_EXPR,
                localbounds: *mut SCIP_INTERVAL,
                globalbounds: *mut SCIP_INTERVAL,
                refpoint: *mut f64,
                overestimate: ::std::os::raw::c_uint,
                targetvalue: f64,
                coefs: *mut f64,
                constant: *mut f64,
                islocal: *mut ::std::os::raw::c_uint,
                success: *mut ::std::os::raw::c_uint,
                branchcand: *mut ::std::os::raw::c_uint,
            ) -> SCIP_RETCODE,
        >,
    );
}
extern "C" {
    #[doc = " set the symmetry information callback of an expression handler"]
    pub fn SCIPexprhdlrSetGetSymdata(
        exprhdlr: *mut SCIP_EXPRHDLR,
        getsymdata: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                expr: *mut SCIP_EXPR,
                symdata: *mut *mut SYM_EXPRDATA,
            ) -> SCIP_RETCODE,
        >,
    );
}
extern "C" {
    #[doc = " gives the name of an expression handler"]
    pub fn SCIPexprhdlrGetName(exprhdlr: *mut SCIP_EXPRHDLR) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " gives the description of an expression handler (can be NULL)"]
    pub fn SCIPexprhdlrGetDescription(
        exprhdlr: *mut SCIP_EXPRHDLR,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " gives the precedence of an expression handler"]
    pub fn SCIPexprhdlrGetPrecedence(exprhdlr: *mut SCIP_EXPRHDLR) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " gives the data of an expression handler"]
    pub fn SCIPexprhdlrGetData(exprhdlr: *mut SCIP_EXPRHDLR) -> *mut SCIP_EXPRHDLRDATA;
}
extern "C" {
    #[doc = " returns whether expression handler implements the print callback"]
    pub fn SCIPexprhdlrHasPrint(exprhdlr: *mut SCIP_EXPRHDLR) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " returns whether expression handler implements the backward differentiation callback"]
    pub fn SCIPexprhdlrHasBwdiff(exprhdlr: *mut SCIP_EXPRHDLR) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " returns whether expression handler implements the forward differentiation callback"]
    pub fn SCIPexprhdlrHasFwdiff(exprhdlr: *mut SCIP_EXPRHDLR) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " returns whether expression handler implements the interval evaluation callback"]
    pub fn SCIPexprhdlrHasIntEval(exprhdlr: *mut SCIP_EXPRHDLR) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " returns whether expression handler implements the estimator callback"]
    pub fn SCIPexprhdlrHasEstimate(exprhdlr: *mut SCIP_EXPRHDLR) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " returns whether expression handler implements the initial estimators callback"]
    pub fn SCIPexprhdlrHasInitEstimates(exprhdlr: *mut SCIP_EXPRHDLR) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " returns whether expression handler implements the simplification callback"]
    pub fn SCIPexprhdlrHasSimplify(exprhdlr: *mut SCIP_EXPRHDLR) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " returns whether expression handler implements the curvature callback"]
    pub fn SCIPexprhdlrHasCurvature(exprhdlr: *mut SCIP_EXPRHDLR) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " returns whether expression handler implements the monotonicity callback"]
    pub fn SCIPexprhdlrHasMonotonicity(exprhdlr: *mut SCIP_EXPRHDLR) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " returns whether expression handler implements the reverse propagation callback"]
    pub fn SCIPexprhdlrHasReverseProp(exprhdlr: *mut SCIP_EXPRHDLR) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " return whether expression handler implements the symmetry data callback"]
    pub fn SCIPexprhdlrHasGetSymData(exprhdlr: *mut SCIP_EXPRHDLR) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn SCIPexprhdlrComp(
        elem1: *mut ::std::os::raw::c_void,
        elem2: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " gets number of times an expression has been created with given expression handler"]
    pub fn SCIPexprhdlrGetNCreated(exprhdlr: *mut SCIP_EXPRHDLR) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " gets number of times the interval evaluation callback was called"]
    pub fn SCIPexprhdlrGetNIntevalCalls(exprhdlr: *mut SCIP_EXPRHDLR)
        -> ::std::os::raw::c_longlong;
}
extern "C" {
    #[doc = " gets time spend in interval evaluation callback"]
    pub fn SCIPexprhdlrGetIntevalTime(exprhdlr: *mut SCIP_EXPRHDLR) -> f64;
}
extern "C" {
    #[doc = " gets number of times the reverse propagation callback was called"]
    pub fn SCIPexprhdlrGetNReversepropCalls(
        exprhdlr: *mut SCIP_EXPRHDLR,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    #[doc = " gets time spend in reverse propagation callback"]
    pub fn SCIPexprhdlrGetReversepropTime(exprhdlr: *mut SCIP_EXPRHDLR) -> f64;
}
extern "C" {
    #[doc = " gets number of times an empty interval was found in reverse propagation"]
    pub fn SCIPexprhdlrGetNCutoffs(exprhdlr: *mut SCIP_EXPRHDLR) -> ::std::os::raw::c_longlong;
}
extern "C" {
    #[doc = " gets number of times a bound reduction was found in reverse propagation (and accepted by caller)"]
    pub fn SCIPexprhdlrGetNDomainReductions(
        exprhdlr: *mut SCIP_EXPRHDLR,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    #[doc = " increments the domain reductions count of an expression handler"]
    pub fn SCIPexprhdlrIncrementNDomainReductions(
        exprhdlr: *mut SCIP_EXPRHDLR,
        nreductions: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " gets number of times the estimation callback was called"]
    pub fn SCIPexprhdlrGetNEstimateCalls(
        exprhdlr: *mut SCIP_EXPRHDLR,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    #[doc = " gets time spend in estimation callback"]
    pub fn SCIPexprhdlrGetEstimateTime(exprhdlr: *mut SCIP_EXPRHDLR) -> f64;
}
extern "C" {
    #[doc = " gets number of times branching candidates reported by of this expression handler were used to assemble branching candidates\n\n that is, how often did we consider branching on a child of this expression"]
    pub fn SCIPexprhdlrGetNBranchings(exprhdlr: *mut SCIP_EXPRHDLR) -> ::std::os::raw::c_longlong;
}
extern "C" {
    #[doc = " increments the branching candidates count of an expression handler"]
    pub fn SCIPexprhdlrIncrementNBranchings(exprhdlr: *mut SCIP_EXPRHDLR);
}
extern "C" {
    #[doc = " gets number of times the simplify callback was called"]
    pub fn SCIPexprhdlrGetNSimplifyCalls(
        exprhdlr: *mut SCIP_EXPRHDLR,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    #[doc = " gets time spend in simplify callback"]
    pub fn SCIPexprhdlrGetSimplifyTime(exprhdlr: *mut SCIP_EXPRHDLR) -> f64;
}
extern "C" {
    #[doc = " gets number of times the simplify callback found a simplification"]
    pub fn SCIPexprhdlrGetNSimplifications(
        exprhdlr: *mut SCIP_EXPRHDLR,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    #[doc = " gets the number of times the expression is currently captured"]
    pub fn SCIPexprGetNUses(expr: *mut SCIP_EXPR) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " gives the number of children of an expression"]
    pub fn SCIPexprGetNChildren(expr: *mut SCIP_EXPR) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " gives the children of an expression (can be NULL if no children)"]
    pub fn SCIPexprGetChildren(expr: *mut SCIP_EXPR) -> *mut *mut SCIP_EXPR;
}
extern "C" {
    #[doc = " gets the expression handler of an expression\n\n This identifies the type of the expression (sum, variable, ...)."]
    pub fn SCIPexprGetHdlr(expr: *mut SCIP_EXPR) -> *mut SCIP_EXPRHDLR;
}
extern "C" {
    #[doc = " gets the expression data of an expression"]
    pub fn SCIPexprGetData(expr: *mut SCIP_EXPR) -> *mut SCIP_EXPRDATA;
}
extern "C" {
    #[doc = " sets the expression data of an expression\n\n The pointer to possible old data is overwritten and the\n freedata-callback is not called before.\n This function is intended to be used by expression handler only."]
    pub fn SCIPexprSetData(expr: *mut SCIP_EXPR, exprdata: *mut SCIP_EXPRDATA);
}
extern "C" {
    #[doc = " gets the data that the owner of an expression has stored in an expression"]
    pub fn SCIPexprGetOwnerData(expr: *mut SCIP_EXPR) -> *mut SCIP_EXPR_OWNERDATA;
}
extern "C" {
    #[doc = " gives the value from the last evaluation of an expression (or SCIP_INVALID if there was an eval error)\n\n @see SCIPevalExpr to evaluate the expression at a given solution."]
    pub fn SCIPexprGetEvalValue(expr: *mut SCIP_EXPR) -> f64;
}
extern "C" {
    #[doc = " gives the evaluation tag from the last evaluation, or 0\n\n @see SCIPevalExpr"]
    pub fn SCIPexprGetEvalTag(expr: *mut SCIP_EXPR) -> ::std::os::raw::c_longlong;
}
extern "C" {
    #[doc = " returns the derivative stored in an expression (or SCIP_INVALID if there was an evaluation error)\n\n @see SCIPevalExprGradient"]
    pub fn SCIPexprGetDerivative(expr: *mut SCIP_EXPR) -> f64;
}
extern "C" {
    #[doc = " gives the value of directional derivative from the last evaluation of a directional derivative of expression\n (or SCIP_INVALID if there was an error)\n\n @see SCIPevalExprHessianDir"]
    pub fn SCIPexprGetDot(expr: *mut SCIP_EXPR) -> f64;
}
extern "C" {
    #[doc = " gives the value of directional derivative from the last evaluation of a directional derivative of derivative\n of root (or SCIP_INVALID if there was an error)\n\n @see SCIPevalExprHessianDir"]
    pub fn SCIPexprGetBardot(expr: *mut SCIP_EXPR) -> f64;
}
extern "C" {
    #[doc = " returns the difftag stored in an expression\n\n can be used to check whether partial derivative value is valid\n\n @see SCIPevalExprGradient"]
    pub fn SCIPexprGetDiffTag(expr: *mut SCIP_EXPR) -> ::std::os::raw::c_longlong;
}
extern "C" {
    #[doc = " returns the activity that is currently stored for an expression\n\n @see SCIPevalExprActivity"]
    pub fn SCIPexprGetActivity(expr: *mut SCIP_EXPR) -> SCIP_INTERVAL;
}
extern "C" {
    #[doc = " returns the tag associated with the activity of the expression\n\n It can depend on the owner of the expression how to interpret this tag.\n SCIPevalExprActivity() compares with `stat->domchgcount`.\n\n @see SCIPevalExprActivity"]
    pub fn SCIPexprGetActivityTag(expr: *mut SCIP_EXPR) -> ::std::os::raw::c_longlong;
}
extern "C" {
    #[doc = " set the activity with tag for an expression"]
    pub fn SCIPexprSetActivity(
        expr: *mut SCIP_EXPR,
        activity: SCIP_INTERVAL,
        activitytag: ::std::os::raw::c_longlong,
    );
}
extern "C" {
    #[doc = " returns the curvature of an expression\n\n  @note Call SCIPcomputeExprCurvature() before calling this function."]
    pub fn SCIPexprGetCurvature(expr: *mut SCIP_EXPR) -> SCIP_EXPRCURV;
}
extern "C" {
    #[doc = " sets the curvature of an expression"]
    pub fn SCIPexprSetCurvature(expr: *mut SCIP_EXPR, curvature: SCIP_EXPRCURV);
}
extern "C" {
    #[doc = " returns whether an expression is integral"]
    pub fn SCIPexprIsIntegral(expr: *mut SCIP_EXPR) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " sets the integrality flag of an expression"]
    pub fn SCIPexprSetIntegrality(expr: *mut SCIP_EXPR, isintegral: ::std::os::raw::c_uint);
}
extern "C" {
    #[doc = " gives the coefficients and expressions that define a quadratic expression\n\n It can return the constant part, the number, arguments, and coefficients of the purely linear part\n and the number of quadratic terms and bilinear terms.\n Note that for arguments that appear in the quadratic part, a linear coefficient is\n stored with the quadratic term.\n Use SCIPexprGetQuadraticQuadTerm() and SCIPexprGetQuadraticBilinTerm()\n to access the data for a quadratic or bilinear term.\n\n It can also return the eigenvalues and the eigenvectors of the matrix \\f$Q\\f$ when the quadratic is written\n as \\f$x^T Q x + b^T x + c^T y + d\\f$, where \\f$c^T y\\f$ defines the purely linear part.\n Note, however, that to have access to them one needs to call SCIPcomputeExprQuadraticCurvature()\n with `storeeigeninfo=TRUE`. If the eigen information was not stored or it failed to be computed,\n `eigenvalues` and `eigenvectors` will be set to NULL.\n\n This function returns pointers to internal data in linexprs and lincoefs.\n The user must not change this data.\n\n @attention SCIPcheckExprQuadratic() needs to be called first to check whether expression is quadratic and initialize the data of the quadratic representation."]
    pub fn SCIPexprGetQuadraticData(
        expr: *mut SCIP_EXPR,
        constant: *mut f64,
        nlinexprs: *mut ::std::os::raw::c_int,
        linexprs: *mut *mut *mut SCIP_EXPR,
        lincoefs: *mut *mut f64,
        nquadexprs: *mut ::std::os::raw::c_int,
        nbilinexprs: *mut ::std::os::raw::c_int,
        eigenvalues: *mut *mut f64,
        eigenvectors: *mut *mut f64,
    );
}
extern "C" {
    #[doc = " gives the data of a quadratic expression term\n\n For a term \\f$a \\cdot \\text{expr}^2 + b \\cdot \\text{expr} + \\sum_i (c_i \\cdot \\text{expr} \\cdot \\text{otherexpr}_i)\\f$, returns\n `expr`, \\f$a\\f$, \\f$b\\f$, the number of summands, and indices of bilinear terms in the quadratic expressions `bilinexprterms`.\n\n This function returns pointers to internal data in adjbilin.\n The user must not change this data."]
    pub fn SCIPexprGetQuadraticQuadTerm(
        quadexpr: *mut SCIP_EXPR,
        termidx: ::std::os::raw::c_int,
        expr: *mut *mut SCIP_EXPR,
        lincoef: *mut f64,
        sqrcoef: *mut f64,
        nadjbilin: *mut ::std::os::raw::c_int,
        adjbilin: *mut *mut ::std::os::raw::c_int,
        sqrexpr: *mut *mut SCIP_EXPR,
    );
}
extern "C" {
    #[doc = " gives the data of a bilinear expression term\n\n For a term a*expr1*expr2, returns expr1, expr2, a, and\n the position of the quadratic expression term that uses expr2 in the quadratic expressions `quadexprterms`."]
    pub fn SCIPexprGetQuadraticBilinTerm(
        expr: *mut SCIP_EXPR,
        termidx: ::std::os::raw::c_int,
        expr1: *mut *mut SCIP_EXPR,
        expr2: *mut *mut SCIP_EXPR,
        coef: *mut f64,
        pos2: *mut ::std::os::raw::c_int,
        prodexpr: *mut *mut SCIP_EXPR,
    );
}
extern "C" {
    #[doc = " returns whether all expressions that are used in a quadratic expression are variable expressions\n\n @return TRUE iff all `linexprs` and `quadexprterms[.].expr` are variable expressions"]
    pub fn SCIPexprAreQuadraticExprsVariables(expr: *mut SCIP_EXPR) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " gets the variable of a variable expression"]
    pub fn SCIPgetVarExprVar(expr: *mut SCIP_EXPR) -> *mut SCIP_VAR;
}
extern "C" {
    #[doc = " gets the value of a constant value expression"]
    pub fn SCIPgetValueExprValue(expr: *mut SCIP_EXPR) -> f64;
}
extern "C" {
    #[doc = " gets the coefficients of a summation expression"]
    pub fn SCIPgetCoefsExprSum(expr: *mut SCIP_EXPR) -> *mut f64;
}
extern "C" {
    #[doc = " gets the constant of a summation expression"]
    pub fn SCIPgetConstantExprSum(expr: *mut SCIP_EXPR) -> f64;
}
extern "C" {
    #[doc = " gets the constant coefficient of a product expression"]
    pub fn SCIPgetCoefExprProduct(expr: *mut SCIP_EXPR) -> f64;
}
extern "C" {
    #[doc = " gets the exponent of a power or signed power expression"]
    pub fn SCIPgetExponentExprPow(expr: *mut SCIP_EXPR) -> f64;
}
extern "C" {
    #[doc = " returns whether expression iterator is currently initialized"]
    pub fn SCIPexpriterIsInit(iterator: *mut SCIP_EXPRITER) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " initializes an expression iterator\n\n @note If `expr` is NULL, then iterator will be set into ended-state (SCIPexpriterIsEnd() is TRUE). Useful if following with SCIPexpriterRestartDFS().\n\n If type is DFS, then `stopstages` will be set to \\ref SCIP_EXPRITER_ENTEREXPR.\n Use `SCIPexpriterSetStagesDFS` to change this."]
    pub fn SCIPexpriterInit(
        iterator: *mut SCIP_EXPRITER,
        expr: *mut SCIP_EXPR,
        type_: SCIP_EXPRITER_TYPE,
        allowrevisit: ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " restarts an already initialized expression iterator in DFS mode\n\n The expression iterator will continue from the given expression, not revisiting expressions that\n this iterator has already been visited (if initialized with `allowrevisit=FALSE`) and giving access\n to the same iterator specified expression data that may have been set already.\n Also the stop-stages are not reset.\n\n If revisiting is forbidden and given expr has already been visited, then the iterator will behave\n as on the end of iteration (SCIPexpriterIsEnd() is TRUE).\n If the enterexpr stage is not one of the stop stages, then the iterator will be moved forward\n (SCIPexpriterGetNext() is called).\n\n @return The current expression."]
    pub fn SCIPexpriterRestartDFS(
        iterator: *mut SCIP_EXPRITER,
        expr: *mut SCIP_EXPR,
    ) -> *mut SCIP_EXPR;
}
extern "C" {
    #[doc = " specifies in which stages to stop a DFS iterator\n\n Parameter `stopstages` should be a bitwise OR of different \\ref SCIP_EXPRITER_STAGE values\n\n If the current stage is not one of the `stopstages`, then the iterator will be moved on."]
    pub fn SCIPexpriterSetStagesDFS(iterator: *mut SCIP_EXPRITER, stopstages: SCIP_EXPRITER_STAGE);
}
extern "C" {
    #[doc = " gets the current expression that the expression iterator points to"]
    pub fn SCIPexpriterGetCurrent(iterator: *mut SCIP_EXPRITER) -> *mut SCIP_EXPR;
}
extern "C" {
    #[doc = " gets the current stage that the expression iterator is in when using DFS\n\n If the iterator has finished (SCIPexpriterIsEnd() is TRUE), then the stage is undefined."]
    pub fn SCIPexpriterGetStageDFS(iterator: *mut SCIP_EXPRITER) -> SCIP_EXPRITER_STAGE;
}
extern "C" {
    #[doc = " gets the index of the child that the expression iterator considers when in DFS mode and stage \\ref SCIP_EXPRITER_VISITINGCHILD or \\ref SCIP_EXPRITER_VISITEDCHILD"]
    pub fn SCIPexpriterGetChildIdxDFS(iterator: *mut SCIP_EXPRITER) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " gets the child expression that the expression iterator considers when in DFS mode and stage \\ref SCIP_EXPRITER_VISITINGCHILD or \\ref SCIP_EXPRITER_VISITEDCHILD"]
    pub fn SCIPexpriterGetChildExprDFS(iterator: *mut SCIP_EXPRITER) -> *mut SCIP_EXPR;
}
extern "C" {
    #[doc = " gives the parent of the current expression of an expression iteration if in DFS mode\n\n @return the expression from which the current expression has been accessed"]
    pub fn SCIPexpriterGetParentDFS(iterator: *mut SCIP_EXPRITER) -> *mut SCIP_EXPR;
}
extern "C" {
    #[doc = " gives the iterator specific user data of the current expression\n\n @note The expression iterator mode must be DFS or another mode with allowrevisit=FALSE"]
    pub fn SCIPexpriterGetCurrentUserData(iterator: *mut SCIP_EXPRITER) -> SCIP_EXPRITER_USERDATA;
}
extern "C" {
    #[doc = " gives the iterator specific user data of the current expressions current child\n\n @note The expression iterator mode must be in DFS mode and stage \\ref SCIP_EXPRITER_VISITINGCHILD or \\ref SCIP_EXPRITER_VISITEDCHILD"]
    pub fn SCIPexpriterGetChildUserDataDFS(iterator: *mut SCIP_EXPRITER) -> SCIP_EXPRITER_USERDATA;
}
extern "C" {
    #[doc = " gives the iterator specific user data of a given expression\n\n @note The expression iterator mode must be DFS or another mode with allowrevisit=FALSE"]
    pub fn SCIPexpriterGetExprUserData(
        iterator: *mut SCIP_EXPRITER,
        expr: *mut SCIP_EXPR,
    ) -> SCIP_EXPRITER_USERDATA;
}
extern "C" {
    #[doc = " sets the iterator specific user data of the current expression for an expression iteration if in DFS mode\n\n @note The expression iterator mode must be DFS or another mode with allowrevisit=FALSE"]
    pub fn SCIPexpriterSetCurrentUserData(
        iterator: *mut SCIP_EXPRITER,
        userdata: SCIP_EXPRITER_USERDATA,
    );
}
extern "C" {
    #[doc = " sets the iterator specific user data of a given expression\n\n @note The expression iterator mode must be DFS or another mode with allowrevisit=FALSE"]
    pub fn SCIPexpriterSetExprUserData(
        iterator: *mut SCIP_EXPRITER,
        expr: *mut SCIP_EXPR,
        userdata: SCIP_EXPRITER_USERDATA,
    );
}
extern "C" {
    #[doc = " sets the iterator specific user data of the current expressions current child\n\n @note The expression iterator mode must be in DFS mode and stage \\ref SCIP_EXPRITER_VISITINGCHILD or \\ref SCIP_EXPRITER_VISITEDCHILD"]
    pub fn SCIPexpriterSetChildUserData(
        iterator: *mut SCIP_EXPRITER,
        userdata: SCIP_EXPRITER_USERDATA,
    );
}
extern "C" {
    #[doc = " moves the iterator to the next expression according to the mode of the expression iterator\n\n @return the next expression, if any, and NULL otherwise"]
    pub fn SCIPexpriterGetNext(iterator: *mut SCIP_EXPRITER) -> *mut SCIP_EXPR;
}
extern "C" {
    #[doc = " moves a DFS iterator to one of the next expressions\n\n - If in \\ref SCIP_EXPRITER_ENTEREXPR stage, then all children of that expression will be skipped.\n   If \\ref SCIP_EXPRITER_LEAVEEXPR is one of the `stopstages`, then it will be the next stage. Otherwise, the iterator will move further on (go to the parent, etc).\n - If in \\ref SCIP_EXPRITER_VISITINGCHILD stage, then the child that was going to be visited next will be skipped and the iterator will be moved on to the next child (if any).\n - If in \\ref SCIP_EXPRITER_VISITEDCHILD stage, then all remaining children will be skipped and we move on to the \\ref SCIP_EXPRITER_LEAVEEXPR stage (if a stop stage, otherwise further on).\n - It is not allowed to call this function when in \\ref SCIP_EXPRITER_LEAVEEXPR stage.\n\n @return the next expression, if any, and NULL otherwise"]
    pub fn SCIPexpriterSkipDFS(iterator: *mut SCIP_EXPRITER) -> *mut SCIP_EXPR;
}
extern "C" {
    #[doc = " returns whether the iterator visited all expressions already"]
    pub fn SCIPexpriterIsEnd(iterator: *mut SCIP_EXPRITER) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " gives curvature for a sum of two functions with given curvature"]
    pub fn SCIPexprcurvAdd(curv1: SCIP_EXPRCURV, curv2: SCIP_EXPRCURV) -> SCIP_EXPRCURV;
}
extern "C" {
    #[doc = " gives the curvature for the negation of a function with given curvature"]
    pub fn SCIPexprcurvNegate(curvature: SCIP_EXPRCURV) -> SCIP_EXPRCURV;
}
extern "C" {
    #[doc = " gives curvature for a functions with given curvature multiplied by a constant factor"]
    pub fn SCIPexprcurvMultiply(factor: f64, curvature: SCIP_EXPRCURV) -> SCIP_EXPRCURV;
}
extern "C" {
    #[doc = " gives curvature for base^exponent for given bounds and curvature of base-function and constant exponent"]
    pub fn SCIPexprcurvPower(
        basebounds: SCIP_INTERVAL,
        basecurv: SCIP_EXPRCURV,
        exponent: f64,
    ) -> SCIP_EXPRCURV;
}
extern "C" {
    #[doc = " gives required curvature for base so that base^exponent has given curvature under given bounds on base and constant exponent\n\n returns curvature unknown if expected curvature cannot be obtained"]
    pub fn SCIPexprcurvPowerInv(
        basebounds: SCIP_INTERVAL,
        exponent: f64,
        powercurv: SCIP_EXPRCURV,
    ) -> SCIP_EXPRCURV;
}
extern "C" {
    #[doc = " gives curvature for a monomial with given curvatures and bounds for each factor\n\n  See Maranas and Floudas, Finding All Solutions of Nonlinearly Constrained Systems of Equations, JOGO 7, 1995\n  for the categorization in the case that all factors are linear.\n\n  Exponents can also be negative or rational."]
    pub fn SCIPexprcurvMonomial(
        nfactors: ::std::os::raw::c_int,
        exponents: *mut f64,
        factoridxs: *mut ::std::os::raw::c_int,
        factorcurv: *mut SCIP_EXPRCURV,
        factorbounds: *mut SCIP_INTERVAL,
    ) -> SCIP_EXPRCURV;
}
extern "C" {
    #[doc = " for a monomial with given bounds for each factor, gives condition on the curvature of each factor, so that monomial has a requested curvature, if possible\n\n @return whether `monomialcurv` can be achieved"]
    pub fn SCIPexprcurvMonomialInv(
        monomialcurv: SCIP_EXPRCURV,
        nfactors: ::std::os::raw::c_int,
        exponents: *mut f64,
        factorbounds: *mut SCIP_INTERVAL,
        factorcurv: *mut SCIP_EXPRCURV,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " gives name as string for a curvature"]
    pub fn SCIPexprcurvGetName(curv: SCIP_EXPRCURV) -> *const ::std::os::raw::c_char;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_File {
    _unused: [u8; 0],
}
pub type SCIP_FILE = SCIP_File;
extern "C" {
    pub fn SCIPfopen(
        path: *const ::std::os::raw::c_char,
        mode: *const ::std::os::raw::c_char,
    ) -> *mut SCIP_FILE;
}
extern "C" {
    pub fn SCIPfdopen(
        fildes: ::std::os::raw::c_int,
        mode: *const ::std::os::raw::c_char,
    ) -> *mut SCIP_FILE;
}
extern "C" {
    pub fn SCIPfread(
        ptr: *mut ::std::os::raw::c_void,
        size: usize,
        nmemb: usize,
        stream: *mut SCIP_FILE,
    ) -> usize;
}
extern "C" {
    pub fn SCIPfwrite(
        ptr: *const ::std::os::raw::c_void,
        size: usize,
        nmemb: usize,
        stream: *mut SCIP_FILE,
    ) -> usize;
}
extern "C" {
    pub fn SCIPfprintf(
        stream: *mut SCIP_FILE,
        format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SCIPfputc(c: ::std::os::raw::c_int, stream: *mut SCIP_FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SCIPfputs(
        s: *const ::std::os::raw::c_char,
        stream: *mut SCIP_FILE,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SCIPfgetc(stream: *mut SCIP_FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SCIPfgets(
        s: *mut ::std::os::raw::c_char,
        size: ::std::os::raw::c_int,
        stream: *mut SCIP_FILE,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn SCIPfflush(stream: *mut SCIP_FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SCIPfseek(
        stream: *mut SCIP_FILE,
        offset: ::std::os::raw::c_long,
        whence: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SCIPrewind(stream: *mut SCIP_FILE);
}
extern "C" {
    pub fn SCIPftell(stream: *mut SCIP_FILE) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn SCIPfeof(stream: *mut SCIP_FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SCIPfclose(fp: *mut SCIP_FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SCIPheurComp(
        elem1: *mut ::std::os::raw::c_void,
        elem2: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SCIPheurCompPriority(
        elem1: *mut ::std::os::raw::c_void,
        elem2: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SCIPheurCompName(
        elem1: *mut ::std::os::raw::c_void,
        elem2: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " gets user data of primal heuristic"]
    pub fn SCIPheurGetData(heur: *mut SCIP_HEUR) -> *mut SCIP_HEURDATA;
}
extern "C" {
    #[doc = " sets user data of primal heuristic; user has to free old data in advance!"]
    pub fn SCIPheurSetData(heur: *mut SCIP_HEUR, heurdata: *mut SCIP_HEURDATA);
}
extern "C" {
    #[doc = " gets name of primal heuristic"]
    pub fn SCIPheurGetName(heur: *mut SCIP_HEUR) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " gets description of primal heuristic"]
    pub fn SCIPheurGetDesc(heur: *mut SCIP_HEUR) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " gets display character of primal heuristic"]
    pub fn SCIPheurGetDispchar(heur: *mut SCIP_HEUR) -> ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " returns the timing mask of the heuristic"]
    pub fn SCIPheurGetTimingmask(heur: *mut SCIP_HEUR) -> SCIP_HEURTIMING;
}
extern "C" {
    #[doc = " sets new timing mask for heuristic"]
    pub fn SCIPheurSetTimingmask(heur: *mut SCIP_HEUR, timingmask: SCIP_HEURTIMING);
}
extern "C" {
    #[doc = " does the heuristic use a secondary SCIP instance?"]
    pub fn SCIPheurUsesSubscip(heur: *mut SCIP_HEUR) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " gets priority of primal heuristic"]
    pub fn SCIPheurGetPriority(heur: *mut SCIP_HEUR) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " gets frequency of primal heuristic"]
    pub fn SCIPheurGetFreq(heur: *mut SCIP_HEUR) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " sets frequency of primal heuristic"]
    pub fn SCIPheurSetFreq(heur: *mut SCIP_HEUR, freq: ::std::os::raw::c_int);
}
extern "C" {
    #[doc = " gets frequency offset of primal heuristic"]
    pub fn SCIPheurGetFreqofs(heur: *mut SCIP_HEUR) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " gets maximal depth level for calling primal heuristic (returns -1, if no depth limit exists)"]
    pub fn SCIPheurGetMaxdepth(heur: *mut SCIP_HEUR) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " gets the number of times, the heuristic was called and tried to find a solution"]
    pub fn SCIPheurGetNCalls(heur: *mut SCIP_HEUR) -> ::std::os::raw::c_longlong;
}
extern "C" {
    #[doc = " gets the number of primal feasible solutions found by this heuristic"]
    pub fn SCIPheurGetNSolsFound(heur: *mut SCIP_HEUR) -> ::std::os::raw::c_longlong;
}
extern "C" {
    #[doc = " gets the number of new best primal feasible solutions found by this heuristic"]
    pub fn SCIPheurGetNBestSolsFound(heur: *mut SCIP_HEUR) -> ::std::os::raw::c_longlong;
}
extern "C" {
    #[doc = " is primal heuristic initialized?"]
    pub fn SCIPheurIsInitialized(heur: *mut SCIP_HEUR) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " gets time in seconds used in this heuristic for setting up for next stages"]
    pub fn SCIPheurGetSetupTime(heur: *mut SCIP_HEUR) -> f64;
}
extern "C" {
    #[doc = " gets time in seconds used in this heuristic"]
    pub fn SCIPheurGetTime(heur: *mut SCIP_HEUR) -> f64;
}
extern "C" {
    #[doc = " returns array of divesets of this primal heuristic, or NULL if it has no divesets"]
    pub fn SCIPheurGetDivesets(heur: *mut SCIP_HEUR) -> *mut *mut SCIP_DIVESET;
}
extern "C" {
    #[doc = " returns the number of divesets of this primal heuristic"]
    pub fn SCIPheurGetNDivesets(heur: *mut SCIP_HEUR) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " get the heuristic to which this diving setting belongs"]
    pub fn SCIPdivesetGetHeur(diveset: *mut SCIP_DIVESET) -> *mut SCIP_HEUR;
}
extern "C" {
    #[doc = " get the working solution of this dive set"]
    pub fn SCIPdivesetGetWorkSolution(diveset: *mut SCIP_DIVESET) -> *mut SCIP_SOL;
}
extern "C" {
    #[doc = " set the working solution for this dive set"]
    pub fn SCIPdivesetSetWorkSolution(diveset: *mut SCIP_DIVESET, sol: *mut SCIP_SOL);
}
extern "C" {
    #[doc = " get the name of the dive set"]
    pub fn SCIPdivesetGetName(diveset: *mut SCIP_DIVESET) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " get the minimum relative depth of the diving settings"]
    pub fn SCIPdivesetGetMinRelDepth(diveset: *mut SCIP_DIVESET) -> f64;
}
extern "C" {
    #[doc = " get the maximum relative depth of the diving settings"]
    pub fn SCIPdivesetGetMaxRelDepth(diveset: *mut SCIP_DIVESET) -> f64;
}
extern "C" {
    #[doc = " get the number of successful runs of the diving settings"]
    pub fn SCIPdivesetGetSolSuccess(
        diveset: *mut SCIP_DIVESET,
        divecontext: SCIP_DIVECONTEXT,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    #[doc = " get the number of calls to this dive set"]
    pub fn SCIPdivesetGetNCalls(
        diveset: *mut SCIP_DIVESET,
        divecontext: SCIP_DIVECONTEXT,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " get the number of calls successfully terminated at a feasible leaf node"]
    pub fn SCIPdivesetGetNSolutionCalls(
        diveset: *mut SCIP_DIVESET,
        divecontext: SCIP_DIVECONTEXT,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " get the minimum depth reached by this dive set"]
    pub fn SCIPdivesetGetMinDepth(
        diveset: *mut SCIP_DIVESET,
        divecontext: SCIP_DIVECONTEXT,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " get the maximum depth reached by this dive set"]
    pub fn SCIPdivesetGetMaxDepth(
        diveset: *mut SCIP_DIVESET,
        divecontext: SCIP_DIVECONTEXT,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " get the average depth this dive set reached during execution"]
    pub fn SCIPdivesetGetAvgDepth(diveset: *mut SCIP_DIVESET, divecontext: SCIP_DIVECONTEXT)
        -> f64;
}
extern "C" {
    #[doc = " get the minimum depth at which this dive set found a solution"]
    pub fn SCIPdivesetGetMinSolutionDepth(
        diveset: *mut SCIP_DIVESET,
        divecontext: SCIP_DIVECONTEXT,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " get the maximum depth at which this dive set found a solution"]
    pub fn SCIPdivesetGetMaxSolutionDepth(
        diveset: *mut SCIP_DIVESET,
        divecontext: SCIP_DIVECONTEXT,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " get the average depth at which this dive set found a solution"]
    pub fn SCIPdivesetGetAvgSolutionDepth(
        diveset: *mut SCIP_DIVESET,
        divecontext: SCIP_DIVECONTEXT,
    ) -> f64;
}
extern "C" {
    #[doc = " get the total number of LP iterations used by this dive set"]
    pub fn SCIPdivesetGetNLPIterations(
        diveset: *mut SCIP_DIVESET,
        divecontext: SCIP_DIVECONTEXT,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    #[doc = " get the total number of probing nodes used by this dive set"]
    pub fn SCIPdivesetGetNProbingNodes(
        diveset: *mut SCIP_DIVESET,
        divecontext: SCIP_DIVECONTEXT,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    #[doc = " get the total number of backtracks performed by this dive set"]
    pub fn SCIPdivesetGetNBacktracks(
        diveset: *mut SCIP_DIVESET,
        divecontext: SCIP_DIVECONTEXT,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    #[doc = " get the total number of conflicts found by this dive set"]
    pub fn SCIPdivesetGetNConflicts(
        diveset: *mut SCIP_DIVESET,
        divecontext: SCIP_DIVECONTEXT,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    #[doc = " get the total number of solutions (leaf and rounded solutions) found by the dive set"]
    pub fn SCIPdivesetGetNSols(
        diveset: *mut SCIP_DIVESET,
        divecontext: SCIP_DIVECONTEXT,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    #[doc = " get the maximum LP iterations quotient of the diving settings"]
    pub fn SCIPdivesetGetMaxLPIterQuot(diveset: *mut SCIP_DIVESET) -> f64;
}
extern "C" {
    #[doc = " get the maximum LP iterations offset of the diving settings"]
    pub fn SCIPdivesetGetMaxLPIterOffset(diveset: *mut SCIP_DIVESET) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " get the maximum upper bound quotient parameter of the diving settings if no solution is available"]
    pub fn SCIPdivesetGetUbQuotNoSol(diveset: *mut SCIP_DIVESET) -> f64;
}
extern "C" {
    #[doc = " get the average quotient parameter of the diving settings if no solution is available"]
    pub fn SCIPdivesetGetAvgQuotNoSol(diveset: *mut SCIP_DIVESET) -> f64;
}
extern "C" {
    #[doc = " get the maximum upper bound quotient parameter of the diving settings if an incumbent solution exists"]
    pub fn SCIPdivesetGetUbQuot(diveset: *mut SCIP_DIVESET) -> f64;
}
extern "C" {
    #[doc = " get the average upper bound quotient parameter of the diving settings if an incumbent solution exists"]
    pub fn SCIPdivesetGetAvgQuot(diveset: *mut SCIP_DIVESET) -> f64;
}
extern "C" {
    #[doc = " should backtracking be applied?"]
    pub fn SCIPdivesetUseBacktrack(diveset: *mut SCIP_DIVESET) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " returns the LP solve frequency for diving LPs (0: dynamically based on number of intermediate domain reductions)"]
    pub fn SCIPdivesetGetLPSolveFreq(diveset: *mut SCIP_DIVESET) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " returns the domain reduction quotient for triggering an immediate resolve of the diving LP (0.0: always resolve)"]
    pub fn SCIPdivesetGetLPResolveDomChgQuot(diveset: *mut SCIP_DIVESET) -> f64;
}
extern "C" {
    #[doc = " should only LP branching candidates be considered instead of the slower but\n  more general constraint handler diving variable selection?"]
    pub fn SCIPdivesetUseOnlyLPBranchcands(diveset: *mut SCIP_DIVESET) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " returns TRUE if dive set supports diving of the specified type"]
    pub fn SCIPdivesetSupportsType(
        diveset: *mut SCIP_DIVESET,
        divetype: SCIP_DIVETYPE,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " returns the random number generator of this \\p diveset for tie-breaking"]
    pub fn SCIPdivesetGetRandnumgen(diveset: *mut SCIP_DIVESET) -> *mut SCIP_RANDNUMGEN;
}
extern "C" {
    #[doc = " is this dive set publicly available (ie., can be used by other primal heuristics?)"]
    pub fn SCIPdivesetIsPublic(diveset: *mut SCIP_DIVESET) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " Perform breadth-first (BFS) search on the variable constraint graph.\n\n  The result of the algorithm is that the \\p distances array contains the correct distances for\n  every variable from the start variables. The distance of a variable can then be accessed through its\n  problem index (calling SCIPvarGetProbindex()).\n  Hence, The method assumes that the length of \\p distances is at least\n  SCIPgetNVars().\n  Variables that are not connected through constraints to the start variables have a distance of -1.\n\n  Limits can be provided to further restrict the breadth-first search. If a distance limit is given,\n  the search will be performed until the first variable at this distance is popped from the queue, i.e.,\n  all variables with a distance < maxdistance have been labeled by the search.\n  If a variable limit is given, the search stops after it completes the distance level at which\n  the limit was reached. Hence, more variables may be actually labeled.\n  The start variables are accounted for those variable limits.\n\n  If no variable variable constraint graph is provided, the method will create one and free it at the end\n  This is useful for a single use of the variable constraint graph. For several consecutive uses,\n  it is advised to create a variable constraint graph via SCIPvariableGraphCreate()."]
    pub fn SCIPvariablegraphBreadthFirst(
        scip: *mut SCIP,
        vargraph: *mut SCIP_VGRAPH,
        startvars: *mut *mut SCIP_VAR,
        nstartvars: ::std::os::raw::c_int,
        distances: *mut ::std::os::raw::c_int,
        maxdistance: ::std::os::raw::c_int,
        maxvars: ::std::os::raw::c_int,
        maxbinintvars: ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " initialization method of variable graph data structure"]
    pub fn SCIPvariableGraphCreate(
        scip: *mut SCIP,
        vargraph: *mut *mut SCIP_VGRAPH,
        relaxdenseconss: ::std::os::raw::c_uint,
        relaxdensity: f64,
        nrelaxedconstraints: *mut ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " deinitialization method of variable graph data structure"]
    pub fn SCIPvariableGraphFree(scip: *mut SCIP, vargraph: *mut *mut SCIP_VGRAPH);
}
extern "C" {
    pub fn SCIPcomprComp(
        elem1: *mut ::std::os::raw::c_void,
        elem2: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SCIPcomprCompName(
        elem1: *mut ::std::os::raw::c_void,
        elem2: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " gets user data of tree compression"]
    pub fn SCIPcomprGetData(compr: *mut SCIP_COMPR) -> *mut SCIP_COMPRDATA;
}
extern "C" {
    #[doc = " sets user data of tree compression; user has to free old data in advance!"]
    pub fn SCIPcomprSetData(compr: *mut SCIP_COMPR, comprdata: *mut SCIP_COMPRDATA);
}
extern "C" {
    #[doc = " gets name of tree compression"]
    pub fn SCIPcomprGetName(heur: *mut SCIP_COMPR) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " gets description of tree compression"]
    pub fn SCIPcomprGetDesc(compr: *mut SCIP_COMPR) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " gets priority of tree compression"]
    pub fn SCIPcomprGetPriority(compr: *mut SCIP_COMPR) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " gets minimal number of nodes for calling tree compression (returns -1, if no node threshold exists)"]
    pub fn SCIPcomprGetMinNodes(compr: *mut SCIP_COMPR) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " gets the number of times, the compression was called and tried to find a compression"]
    pub fn SCIPcomprGetNCalls(compr: *mut SCIP_COMPR) -> ::std::os::raw::c_longlong;
}
extern "C" {
    #[doc = " gets the number of tree compressions found by this compression"]
    pub fn SCIPcomprGetNFound(compr: *mut SCIP_COMPR) -> ::std::os::raw::c_longlong;
}
extern "C" {
    #[doc = " is tree compression initialized?"]
    pub fn SCIPcomprIsInitialized(compr: *mut SCIP_COMPR) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " gets time in seconds used in this compression for setting up for next stages"]
    pub fn SCIPcomprGetSetupTime(compr: *mut SCIP_COMPR) -> f64;
}
extern "C" {
    #[doc = " gets time in seconds used in this compression"]
    pub fn SCIPcomprGetTime(compr: *mut SCIP_COMPR) -> f64;
}
extern "C" {
    #[doc = " gets the conflict score of the history entry"]
    pub fn SCIPhistoryGetVSIDS(history: *mut SCIP_HISTORY, dir: SCIP_BRANCHDIR) -> f64;
}
extern "C" {
    #[doc = " gets the average conflict length of the history entry"]
    pub fn SCIPhistoryGetAvgConflictlength(history: *mut SCIP_HISTORY, dir: SCIP_BRANCHDIR) -> f64;
}
extern "C" {
    #[doc = " get number of cutoffs counter"]
    pub fn SCIPhistoryGetCutoffSum(history: *mut SCIP_HISTORY, dir: SCIP_BRANCHDIR) -> f64;
}
extern "C" {
    #[doc = " get number of inferences counter"]
    pub fn SCIPhistoryGetInferenceSum(history: *mut SCIP_HISTORY, dir: SCIP_BRANCHDIR) -> f64;
}
extern "C" {
    #[doc = " return the number of (domain) values for which a history exists"]
    pub fn SCIPvaluehistoryGetNValues(
        valuehistory: *mut SCIP_VALUEHISTORY,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " return the array containing the histories for the individual (domain) values"]
    pub fn SCIPvaluehistoryGetHistories(
        valuehistory: *mut SCIP_VALUEHISTORY,
    ) -> *mut *mut SCIP_HISTORY;
}
extern "C" {
    #[doc = " return the array containing the (domain) values for which a history exists"]
    pub fn SCIPvaluehistoryGetValues(valuehistory: *mut SCIP_VALUEHISTORY) -> *mut f64;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_VBounds {
    _unused: [u8; 0],
}
pub type SCIP_VBOUNDS = SCIP_VBounds;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_Implics {
    _unused: [u8; 0],
}
pub type SCIP_IMPLICS = SCIP_Implics;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_Clique {
    _unused: [u8; 0],
}
pub type SCIP_CLIQUE = SCIP_Clique;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_CliqueTable {
    _unused: [u8; 0],
}
pub type SCIP_CLIQUETABLE = SCIP_CliqueTable;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_CliqueList {
    _unused: [u8; 0],
}
pub type SCIP_CLIQUELIST = SCIP_CliqueList;
extern "C" {
    #[doc = " returns the position of the given variable/value pair in the clique; returns -1 if variable/value pair is not member\n  of the clique"]
    pub fn SCIPcliqueSearchVar(
        clique: *mut SCIP_CLIQUE,
        var: *mut SCIP_VAR,
        value: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " returns whether the given variable/value pair is member of the given clique"]
    pub fn SCIPcliqueHasVar(
        clique: *mut SCIP_CLIQUE,
        var: *mut SCIP_VAR,
        value: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " gets number of variables in the cliques"]
    pub fn SCIPcliqueGetNVars(clique: *mut SCIP_CLIQUE) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " gets array of active problem variables in the cliques"]
    pub fn SCIPcliqueGetVars(clique: *mut SCIP_CLIQUE) -> *mut *mut SCIP_VAR;
}
extern "C" {
    #[doc = " gets array of values of active problem variables in the cliques, i.e. whether the variable is fixed to FALSE or\n  to TRUE in the clique"]
    pub fn SCIPcliqueGetValues(clique: *mut SCIP_CLIQUE) -> *mut ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " gets unique identifier of the clique"]
    pub fn SCIPcliqueGetId(clique: *mut SCIP_CLIQUE) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " gets index of the clique in the clique table"]
    pub fn SCIPcliqueGetIndex(clique: *mut SCIP_CLIQUE) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " returns whether the given clique is cleaned up"]
    pub fn SCIPcliqueIsCleanedUp(clique: *mut SCIP_CLIQUE) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " return whether the given clique is an equation"]
    pub fn SCIPcliqueIsEquation(clique: *mut SCIP_CLIQUE) -> ::std::os::raw::c_uint;
}
#[doc = "< maximize objective function"]
pub const SCIP_ObjSen_SCIP_OBJSEN_MAXIMIZE: SCIP_ObjSen = -1;
#[doc = "< minimize objective function"]
pub const SCIP_ObjSen_SCIP_OBJSEN_MINIMIZE: SCIP_ObjSen = 1;
#[doc = " objective sense"]
pub type SCIP_ObjSen = ::std::os::raw::c_int;
#[doc = " objective sense"]
pub use self::SCIP_ObjSen as SCIP_OBJSEN;
#[doc = "< solver should start from scratch at next call?"]
pub const SCIP_LPParam_SCIP_LPPAR_FROMSCRATCH: SCIP_LPParam = 0;
#[doc = "< fast mip setting of LP solver"]
pub const SCIP_LPParam_SCIP_LPPAR_FASTMIP: SCIP_LPParam = 1;
#[doc = "< should LP solver use scaling?"]
pub const SCIP_LPParam_SCIP_LPPAR_SCALING: SCIP_LPParam = 2;
#[doc = "< should LP solver use presolving?"]
pub const SCIP_LPParam_SCIP_LPPAR_PRESOLVING: SCIP_LPParam = 3;
#[doc = "< pricing strategy"]
pub const SCIP_LPParam_SCIP_LPPAR_PRICING: SCIP_LPParam = 4;
#[doc = "< should LP solver output information to the screen?"]
pub const SCIP_LPParam_SCIP_LPPAR_LPINFO: SCIP_LPParam = 5;
#[doc = "< feasibility tolerance for primal variables and slacks, strictly positive"]
pub const SCIP_LPParam_SCIP_LPPAR_FEASTOL: SCIP_LPParam = 6;
#[doc = "< feasibility tolerance for dual variables and reduced costs, strictly positive"]
pub const SCIP_LPParam_SCIP_LPPAR_DUALFEASTOL: SCIP_LPParam = 7;
#[doc = "< convergence tolerance used in barrier algorithm"]
pub const SCIP_LPParam_SCIP_LPPAR_BARRIERCONVTOL: SCIP_LPParam = 8;
#[doc = "< objective limit (stop if objective is known be larger/smaller than limit for min/max-imization)"]
pub const SCIP_LPParam_SCIP_LPPAR_OBJLIM: SCIP_LPParam = 9;
#[doc = "< LP iteration limit, greater than or equal 0"]
pub const SCIP_LPParam_SCIP_LPPAR_LPITLIM: SCIP_LPParam = 10;
#[doc = "< LP time limit, positive"]
pub const SCIP_LPParam_SCIP_LPPAR_LPTILIM: SCIP_LPParam = 11;
#[doc = "< Markowitz tolerance"]
pub const SCIP_LPParam_SCIP_LPPAR_MARKOWITZ: SCIP_LPParam = 12;
#[doc = "< simplex algorithm shall use row representation of the basis\n   if number of rows divided by number of columns exceeds this value\n   (0 <= value or -1 = valu ; if negative, this change never occurs)"]
pub const SCIP_LPParam_SCIP_LPPAR_ROWREPSWITCH: SCIP_LPParam = 13;
#[doc = "< number of threads used to solve the LP"]
pub const SCIP_LPParam_SCIP_LPPAR_THREADS: SCIP_LPParam = 14;
#[doc = "< maximum condition number of LP basis counted as stable"]
pub const SCIP_LPParam_SCIP_LPPAR_CONDITIONLIMIT: SCIP_LPParam = 15;
#[doc = "< type of timer (1 - cpu, 2 - wallclock, 0 - off)"]
pub const SCIP_LPParam_SCIP_LPPAR_TIMING: SCIP_LPParam = 16;
#[doc = "< inital random seed, e.g. for perturbations in the simplex (0: LP default)"]
pub const SCIP_LPParam_SCIP_LPPAR_RANDOMSEED: SCIP_LPParam = 17;
#[doc = "< set solution polishing (0 - disable, 1 - enable)"]
pub const SCIP_LPParam_SCIP_LPPAR_POLISHING: SCIP_LPParam = 18;
#[doc = "< set refactorization interval (0 - automatic)"]
pub const SCIP_LPParam_SCIP_LPPAR_REFACTOR: SCIP_LPParam = 19;
#[doc = " LP solver parameters"]
pub type SCIP_LPParam = ::std::os::raw::c_uint;
#[doc = " LP solver parameters"]
pub use self::SCIP_LPParam as SCIP_LPPARAM;
#[doc = "< the SCIP/LP interface should use its preferred strategy"]
pub const SCIP_Pricing_SCIP_PRICING_LPIDEFAULT: SCIP_Pricing = 0;
#[doc = "< the LP solver should use its preferred strategy"]
pub const SCIP_Pricing_SCIP_PRICING_AUTO: SCIP_Pricing = 1;
#[doc = "< full pricing"]
pub const SCIP_Pricing_SCIP_PRICING_FULL: SCIP_Pricing = 2;
#[doc = "< partial pricing"]
pub const SCIP_Pricing_SCIP_PRICING_PARTIAL: SCIP_Pricing = 3;
#[doc = "< steepest edge pricing"]
pub const SCIP_Pricing_SCIP_PRICING_STEEP: SCIP_Pricing = 4;
#[doc = "< steepest edge pricing without initial dual norms"]
pub const SCIP_Pricing_SCIP_PRICING_STEEPQSTART: SCIP_Pricing = 5;
#[doc = "< devex pricing"]
pub const SCIP_Pricing_SCIP_PRICING_DEVEX: SCIP_Pricing = 6;
#[doc = " LP pricing strategy"]
pub type SCIP_Pricing = ::std::os::raw::c_uint;
#[doc = " LP pricing strategy"]
pub use self::SCIP_Pricing as SCIP_PRICING;
#[doc = "< (slack) variable is at its lower bound"]
pub const SCIP_BaseStat_SCIP_BASESTAT_LOWER: SCIP_BaseStat = 0;
#[doc = "< (slack) variable is basic"]
pub const SCIP_BaseStat_SCIP_BASESTAT_BASIC: SCIP_BaseStat = 1;
#[doc = "< (slack) variable is at its upper bound"]
pub const SCIP_BaseStat_SCIP_BASESTAT_UPPER: SCIP_BaseStat = 2;
#[doc = "< free variable is non-basic and set to zero"]
pub const SCIP_BaseStat_SCIP_BASESTAT_ZERO: SCIP_BaseStat = 3;
#[doc = " basis status for columns and rows"]
pub type SCIP_BaseStat = ::std::os::raw::c_uint;
#[doc = " basis status for columns and rows"]
pub use self::SCIP_BaseStat as SCIP_BASESTAT;
#[doc = "< estimated condition number of (scaled) basis matrix (SCIP_Real)"]
pub const SCIP_LPSolQuality_SCIP_LPSOLQUALITY_ESTIMCONDITION: SCIP_LPSolQuality = 0;
#[doc = "< exact condition number of (scaled) basis matrix (SCIP_Real)"]
pub const SCIP_LPSolQuality_SCIP_LPSOLQUALITY_EXACTCONDITION: SCIP_LPSolQuality = 1;
#[doc = " LP solution quality quantities"]
pub type SCIP_LPSolQuality = ::std::os::raw::c_uint;
#[doc = " LP solution quality quantities"]
pub use self::SCIP_LPSolQuality as SCIP_LPSOLQUALITY;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_LPi {
    _unused: [u8; 0],
}
pub type SCIP_LPI = SCIP_LPi;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_LPiState {
    _unused: [u8; 0],
}
pub type SCIP_LPISTATE = SCIP_LPiState;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_LPiNorms {
    _unused: [u8; 0],
}
pub type SCIP_LPINORMS = SCIP_LPiNorms;
extern "C" {
    #[doc = " sorts column entries such that LP rows precede non-LP rows and inside both parts lower row indices precede higher ones"]
    pub fn SCIPcolSort(col: *mut SCIP_COL);
}
extern "C" {
    #[doc = " gets objective value of column"]
    pub fn SCIPcolGetObj(col: *mut SCIP_COL) -> f64;
}
extern "C" {
    #[doc = " gets lower bound of column"]
    pub fn SCIPcolGetLb(col: *mut SCIP_COL) -> f64;
}
extern "C" {
    #[doc = " gets upper bound of column"]
    pub fn SCIPcolGetUb(col: *mut SCIP_COL) -> f64;
}
extern "C" {
    #[doc = " gets best bound of column with respect to the objective function"]
    pub fn SCIPcolGetBestBound(col: *mut SCIP_COL) -> f64;
}
extern "C" {
    #[doc = " gets the primal LP solution of a column"]
    pub fn SCIPcolGetPrimsol(col: *mut SCIP_COL) -> f64;
}
extern "C" {
    #[doc = " gets the minimal LP solution value, this column ever assumed"]
    pub fn SCIPcolGetMinPrimsol(col: *mut SCIP_COL) -> f64;
}
extern "C" {
    #[doc = " gets the maximal LP solution value, this column ever assumed"]
    pub fn SCIPcolGetMaxPrimsol(col: *mut SCIP_COL) -> f64;
}
extern "C" {
    #[doc = " gets the basis status of a column in the LP solution; only valid for LPs with status SCIP_LPSOLSTAT_OPTIMAL\n  and with SCIPisLPSolBasic(scip) == TRUE; returns SCIP_BASESTAT_ZERO for columns not in the current SCIP_LP"]
    pub fn SCIPcolGetBasisStatus(col: *mut SCIP_COL) -> SCIP_BASESTAT;
}
extern "C" {
    #[doc = " gets variable this column represents"]
    pub fn SCIPcolGetVar(col: *mut SCIP_COL) -> *mut SCIP_VAR;
}
extern "C" {
    #[doc = " gets unique index of col"]
    pub fn SCIPcolGetIndex(col: *mut SCIP_COL) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " gets probindex of corresponding variable"]
    pub fn SCIPcolGetVarProbindex(col: *mut SCIP_COL) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " returns whether the associated variable is of integral type (binary, integer, implicit integer)"]
    pub fn SCIPcolIsIntegral(col: *mut SCIP_COL) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " returns TRUE iff column is removable from the LP (due to aging or cleanup)"]
    pub fn SCIPcolIsRemovable(col: *mut SCIP_COL) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " gets position of column in current LP, or -1 if it is not in LP"]
    pub fn SCIPcolGetLPPos(col: *mut SCIP_COL) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " gets depth in the tree where the column entered the LP, or -1 if it is not in LP"]
    pub fn SCIPcolGetLPDepth(col: *mut SCIP_COL) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " returns TRUE iff column is member of current LP"]
    pub fn SCIPcolIsInLP(col: *mut SCIP_COL) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " get number of nonzero entries in column vector"]
    pub fn SCIPcolGetNNonz(col: *mut SCIP_COL) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " get number of nonzero entries in column vector, that correspond to rows currently in the SCIP_LP;\n\n  @warning This method is only applicable on columns, that are completely linked to their rows (e.g. a column\n  that is in the current LP and the LP was solved, or a column that was in a solved LP and didn't change afterwards"]
    pub fn SCIPcolGetNLPNonz(col: *mut SCIP_COL) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " gets array with rows of nonzero entries"]
    pub fn SCIPcolGetRows(col: *mut SCIP_COL) -> *mut *mut SCIP_ROW;
}
extern "C" {
    #[doc = " gets array with coefficients of nonzero entries"]
    pub fn SCIPcolGetVals(col: *mut SCIP_COL) -> *mut f64;
}
extern "C" {
    #[doc = " gets node number of the last node in current branch and bound run, where strong branching was used on the\n  given column, or -1 if strong branching was never applied to the column in current run"]
    pub fn SCIPcolGetStrongbranchNode(col: *mut SCIP_COL) -> ::std::os::raw::c_longlong;
}
extern "C" {
    #[doc = " gets number of times, strong branching was applied in current run on the given column"]
    pub fn SCIPcolGetNStrongbranchs(col: *mut SCIP_COL) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " gets the age of a column, i.e., the total number of successive times a column was in the LP and was 0.0 in the solution"]
    pub fn SCIPcolGetAge(col: *mut SCIP_COL) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " gets opposite bound type of given bound type"]
    pub fn SCIPboundtypeOpposite(boundtype: SCIP_BOUNDTYPE) -> SCIP_BOUNDTYPE;
}
extern "C" {
    pub fn SCIProwComp(
        elem1: *mut ::std::os::raw::c_void,
        elem2: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " locks an unmodifiable row, which forbids further changes; has no effect on modifiable rows"]
    pub fn SCIProwLock(row: *mut SCIP_ROW);
}
extern "C" {
    #[doc = " unlocks a lock of an unmodifiable row; a row with no sealed lock may be modified; has no effect on modifiable rows"]
    pub fn SCIProwUnlock(row: *mut SCIP_ROW);
}
extern "C" {
    #[doc = " returns the scalar product of the coefficient vectors of the two given rows"]
    pub fn SCIProwGetScalarProduct(row1: *mut SCIP_ROW, row2: *mut SCIP_ROW) -> f64;
}
extern "C" {
    #[doc = " returns the degree of parallelism between the hyperplanes defined by the two row vectors v, w:\n  p = |v*w|/(|v|*|w|);\n  the hyperplanes are parallel, iff p = 1, they are orthogonal, iff p = 0"]
    pub fn SCIProwGetParallelism(
        row1: *mut SCIP_ROW,
        row2: *mut SCIP_ROW,
        orthofunc: ::std::os::raw::c_char,
    ) -> f64;
}
extern "C" {
    #[doc = " returns the degree of orthogonality between the hyperplanes defined by the two row vectors v, w:\n  o = 1 - |v*w|/(|v|*|w|);\n  the hyperplanes are orthogonal, iff p = 1, they are parallel, iff p = 0"]
    pub fn SCIProwGetOrthogonality(
        row1: *mut SCIP_ROW,
        row2: *mut SCIP_ROW,
        orthofunc: ::std::os::raw::c_char,
    ) -> f64;
}
extern "C" {
    #[doc = " sorts row entries such that LP columns precede non-LP columns and inside both parts lower column indices precede\n  higher ones"]
    pub fn SCIProwSort(row: *mut SCIP_ROW);
}
extern "C" {
    #[doc = " get number of nonzero entries in row vector"]
    pub fn SCIProwGetNNonz(row: *mut SCIP_ROW) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " get number of nonzero entries in row vector, that correspond to columns currently in the SCIP_LP;\n\n  @warning This method is only applicable on rows, that are completely linked to their columns (e.g. a row\n  that is in the current LP and the LP was solved, or a row that was in a solved LP and didn't change afterwards"]
    pub fn SCIProwGetNLPNonz(row: *mut SCIP_ROW) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " gets array with columns of nonzero entries"]
    pub fn SCIProwGetCols(row: *mut SCIP_ROW) -> *mut *mut SCIP_COL;
}
extern "C" {
    #[doc = " gets array with coefficients of nonzero entries"]
    pub fn SCIProwGetVals(row: *mut SCIP_ROW) -> *mut f64;
}
extern "C" {
    #[doc = " gets constant shift of row"]
    pub fn SCIProwGetConstant(row: *mut SCIP_ROW) -> f64;
}
extern "C" {
    #[doc = " gets Euclidean norm of row vector"]
    pub fn SCIProwGetNorm(row: *mut SCIP_ROW) -> f64;
}
extern "C" {
    #[doc = " gets sum norm of row vector (sum of absolute values of coefficients)"]
    pub fn SCIProwGetSumNorm(row: *mut SCIP_ROW) -> f64;
}
extern "C" {
    #[doc = " returns the left hand side of the row"]
    pub fn SCIProwGetLhs(row: *mut SCIP_ROW) -> f64;
}
extern "C" {
    #[doc = " returns the right hand side of the row"]
    pub fn SCIProwGetRhs(row: *mut SCIP_ROW) -> f64;
}
extern "C" {
    #[doc = " gets the dual LP solution of a row"]
    pub fn SCIProwGetDualsol(row: *mut SCIP_ROW) -> f64;
}
extern "C" {
    #[doc = " gets the dual Farkas coefficient of a row in an infeasible LP"]
    pub fn SCIProwGetDualfarkas(row: *mut SCIP_ROW) -> f64;
}
extern "C" {
    #[doc = " gets the basis status of a row in the LP solution; only valid for LPs with status SCIP_LPSOLSTAT_OPTIMAL\n  and with SCIPisLPSolBasic(scip) == TRUE; returns SCIP_BASESTAT_BASIC for rows not in the current SCIP_LP"]
    pub fn SCIProwGetBasisStatus(row: *mut SCIP_ROW) -> SCIP_BASESTAT;
}
extern "C" {
    #[doc = " returns the name of the row"]
    pub fn SCIProwGetName(row: *mut SCIP_ROW) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " gets unique index of row"]
    pub fn SCIProwGetIndex(row: *mut SCIP_ROW) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " gets age of row"]
    pub fn SCIProwGetAge(row: *mut SCIP_ROW) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " gets rank of row"]
    pub fn SCIProwGetRank(row: *mut SCIP_ROW) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " returns TRUE iff the activity of the row (without the row's constant) is always integral in a feasible solution"]
    pub fn SCIProwIsIntegral(row: *mut SCIP_ROW) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " returns TRUE iff row is only valid locally"]
    pub fn SCIProwIsLocal(row: *mut SCIP_ROW) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " returns TRUE iff row is modifiable during node processing (subject to column generation)"]
    pub fn SCIProwIsModifiable(row: *mut SCIP_ROW) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " returns TRUE iff row is removable from the LP (due to aging or cleanup)"]
    pub fn SCIProwIsRemovable(row: *mut SCIP_ROW) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " returns type of origin that created the row"]
    pub fn SCIProwGetOrigintype(row: *mut SCIP_ROW) -> SCIP_ROWORIGINTYPE;
}
extern "C" {
    #[doc = " returns origin constraint handler that created the row (NULL if not available)"]
    pub fn SCIProwGetOriginConshdlr(row: *mut SCIP_ROW) -> *mut SCIP_CONSHDLR;
}
extern "C" {
    #[doc = " returns origin constraint that created the row (NULL if not available)"]
    pub fn SCIProwGetOriginCons(row: *mut SCIP_ROW) -> *mut SCIP_CONS;
}
extern "C" {
    #[doc = " returns origin separator that created the row (NULL if not available)"]
    pub fn SCIProwGetOriginSepa(row: *mut SCIP_ROW) -> *mut SCIP_SEPA;
}
extern "C" {
    #[doc = " returns TRUE iff row is member of the global cut pool"]
    pub fn SCIProwIsInGlobalCutpool(row: *mut SCIP_ROW) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " gets position of row in current LP, or -1 if it is not in LP"]
    pub fn SCIProwGetLPPos(row: *mut SCIP_ROW) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " gets depth in the tree where the row entered the LP, or -1 if it is not in LP"]
    pub fn SCIProwGetLPDepth(row: *mut SCIP_ROW) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " returns TRUE iff row is member of current LP"]
    pub fn SCIProwIsInLP(row: *mut SCIP_ROW) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " returns the number of times that this row has been sharp in an optimal LP solution"]
    pub fn SCIProwGetActiveLPCount(row: *mut SCIP_ROW) -> ::std::os::raw::c_longlong;
}
extern "C" {
    #[doc = " returns the number of LPs since this row has been created"]
    pub fn SCIProwGetNLPsAfterCreation(row: *mut SCIP_ROW) -> ::std::os::raw::c_longlong;
}
extern "C" {
    #[doc = " changes the rank of LP row"]
    pub fn SCIProwChgRank(row: *mut SCIP_ROW, rank: ::std::os::raw::c_int);
}
#[doc = "< SCIP data structures are initialized, no problem exists"]
pub const SCIP_Stage_SCIP_STAGE_INIT: SCIP_Stage = 0;
#[doc = "< the problem is being created and modified"]
pub const SCIP_Stage_SCIP_STAGE_PROBLEM: SCIP_Stage = 1;
#[doc = "< the problem is being transformed into solving data space"]
pub const SCIP_Stage_SCIP_STAGE_TRANSFORMING: SCIP_Stage = 2;
#[doc = "< the problem was transformed into solving data space"]
pub const SCIP_Stage_SCIP_STAGE_TRANSFORMED: SCIP_Stage = 3;
#[doc = "< presolving is initialized"]
pub const SCIP_Stage_SCIP_STAGE_INITPRESOLVE: SCIP_Stage = 4;
#[doc = "< the problem is being presolved"]
pub const SCIP_Stage_SCIP_STAGE_PRESOLVING: SCIP_Stage = 5;
#[doc = "< presolving is exited"]
pub const SCIP_Stage_SCIP_STAGE_EXITPRESOLVE: SCIP_Stage = 6;
#[doc = "< the problem was presolved"]
pub const SCIP_Stage_SCIP_STAGE_PRESOLVED: SCIP_Stage = 7;
#[doc = "< the solving process data is being initialized"]
pub const SCIP_Stage_SCIP_STAGE_INITSOLVE: SCIP_Stage = 8;
#[doc = "< the problem is being solved"]
pub const SCIP_Stage_SCIP_STAGE_SOLVING: SCIP_Stage = 9;
#[doc = "< the problem was solved"]
pub const SCIP_Stage_SCIP_STAGE_SOLVED: SCIP_Stage = 10;
#[doc = "< the solving process data is being freed"]
pub const SCIP_Stage_SCIP_STAGE_EXITSOLVE: SCIP_Stage = 11;
#[doc = "< the transformed problem is being freed"]
pub const SCIP_Stage_SCIP_STAGE_FREETRANS: SCIP_Stage = 12;
#[doc = "< SCIP data structures are being freed"]
pub const SCIP_Stage_SCIP_STAGE_FREE: SCIP_Stage = 13;
#[doc = " SCIP operation stage"]
pub type SCIP_Stage = ::std::os::raw::c_uint;
#[doc = " SCIP operation stage"]
pub use self::SCIP_Stage as SCIP_STAGE;
#[doc = "< undefined setting"]
pub const SCIP_Setting_SCIP_UNDEFINED: SCIP_Setting = 0;
#[doc = "< feature is disabled"]
pub const SCIP_Setting_SCIP_DISABLED: SCIP_Setting = 1;
#[doc = "< feature is set to automatic mode"]
pub const SCIP_Setting_SCIP_AUTO: SCIP_Setting = 2;
#[doc = "< feature is enabled"]
pub const SCIP_Setting_SCIP_ENABLED: SCIP_Setting = 3;
#[doc = " possible settings for enabling/disabling algorithms and other features"]
pub type SCIP_Setting = ::std::os::raw::c_uint;
#[doc = " possible settings for enabling/disabling algorithms and other features"]
pub use self::SCIP_Setting as SCIP_SETTING;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_Set {
    _unused: [u8; 0],
}
pub type SCIP_SET = SCIP_Set;
extern "C" {
    #[doc = " gets constant"]
    pub fn SCIPnlrowGetConstant(nlrow: *mut SCIP_NLROW) -> f64;
}
extern "C" {
    #[doc = " gets number of variables of linear part"]
    pub fn SCIPnlrowGetNLinearVars(nlrow: *mut SCIP_NLROW) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " gets array with variables of linear part"]
    pub fn SCIPnlrowGetLinearVars(nlrow: *mut SCIP_NLROW) -> *mut *mut SCIP_VAR;
}
extern "C" {
    #[doc = " gets array with coefficients in linear part"]
    pub fn SCIPnlrowGetLinearCoefs(nlrow: *mut SCIP_NLROW) -> *mut f64;
}
extern "C" {
    #[doc = " gets expression"]
    pub fn SCIPnlrowGetExpr(nlrow: *mut SCIP_NLROW) -> *mut SCIP_EXPR;
}
extern "C" {
    #[doc = " returns the left hand side of a nonlinear row"]
    pub fn SCIPnlrowGetLhs(nlrow: *mut SCIP_NLROW) -> f64;
}
extern "C" {
    #[doc = " returns the right hand side of a nonlinear row"]
    pub fn SCIPnlrowGetRhs(nlrow: *mut SCIP_NLROW) -> f64;
}
extern "C" {
    #[doc = " returns the curvature of a nonlinear row"]
    pub fn SCIPnlrowGetCurvature(nlrow: *mut SCIP_NLROW) -> SCIP_EXPRCURV;
}
extern "C" {
    #[doc = " returns the name of a nonlinear row"]
    pub fn SCIPnlrowGetName(nlrow: *mut SCIP_NLROW) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " gets position of a nonlinear row in current NLP, or -1 if not in NLP"]
    pub fn SCIPnlrowGetNLPPos(nlrow: *mut SCIP_NLROW) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " returns TRUE iff row is member of current NLP"]
    pub fn SCIPnlrowIsInNLP(nlrow: *mut SCIP_NLROW) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " gets the dual NLP solution of a nlrow\n\n for a ranged constraint, the dual value is positive if the right hand side is active and negative if the left hand side is active"]
    pub fn SCIPnlrowGetDualsol(nlrow: *mut SCIP_NLROW) -> f64;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_Matrix {
    _unused: [u8; 0],
}
pub type SCIP_MATRIX = SCIP_Matrix;
extern "C" {
    #[doc = " get column based start pointer of values"]
    pub fn SCIPmatrixGetColValPtr(matrix: *mut SCIP_MATRIX, col: ::std::os::raw::c_int)
        -> *mut f64;
}
extern "C" {
    #[doc = " get column based start pointer of row indices"]
    pub fn SCIPmatrixGetColIdxPtr(
        matrix: *mut SCIP_MATRIX,
        col: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " get the number of non-zero entries of this column"]
    pub fn SCIPmatrixGetColNNonzs(
        matrix: *mut SCIP_MATRIX,
        col: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " get number of columns of the matrix"]
    pub fn SCIPmatrixGetNColumns(matrix: *mut SCIP_MATRIX) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " get upper bound of column"]
    pub fn SCIPmatrixGetColUb(matrix: *mut SCIP_MATRIX, col: ::std::os::raw::c_int) -> f64;
}
extern "C" {
    #[doc = " get lower bound of column"]
    pub fn SCIPmatrixGetColLb(matrix: *mut SCIP_MATRIX, col: ::std::os::raw::c_int) -> f64;
}
extern "C" {
    #[doc = " get number of uplocks of column"]
    pub fn SCIPmatrixGetColNUplocks(
        matrix: *mut SCIP_MATRIX,
        col: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " get number of downlocks of column"]
    pub fn SCIPmatrixGetColNDownlocks(
        matrix: *mut SCIP_MATRIX,
        col: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " get variable pointer of column"]
    pub fn SCIPmatrixGetVar(matrix: *mut SCIP_MATRIX, col: ::std::os::raw::c_int) -> *mut SCIP_VAR;
}
extern "C" {
    #[doc = " get name of column/variable"]
    pub fn SCIPmatrixGetColName(
        matrix: *mut SCIP_MATRIX,
        col: ::std::os::raw::c_int,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " get row based start pointer of values"]
    pub fn SCIPmatrixGetRowValPtr(matrix: *mut SCIP_MATRIX, row: ::std::os::raw::c_int)
        -> *mut f64;
}
extern "C" {
    #[doc = " get row based start pointer of column indices"]
    pub fn SCIPmatrixGetRowIdxPtr(
        matrix: *mut SCIP_MATRIX,
        row: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " get number of non-zeros of this row"]
    pub fn SCIPmatrixGetRowNNonzs(
        matrix: *mut SCIP_MATRIX,
        row: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " get name of row"]
    pub fn SCIPmatrixGetRowName(
        matrix: *mut SCIP_MATRIX,
        row: ::std::os::raw::c_int,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " get number of rows of the matrix"]
    pub fn SCIPmatrixGetNRows(matrix: *mut SCIP_MATRIX) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " get left-hand-side of row"]
    pub fn SCIPmatrixGetRowLhs(matrix: *mut SCIP_MATRIX, row: ::std::os::raw::c_int) -> f64;
}
extern "C" {
    #[doc = " get right-hand-side of row"]
    pub fn SCIPmatrixGetRowRhs(matrix: *mut SCIP_MATRIX, row: ::std::os::raw::c_int) -> f64;
}
extern "C" {
    #[doc = " flag indicating if right-hand-side of row is infinity"]
    pub fn SCIPmatrixIsRowRhsInfinity(
        matrix: *mut SCIP_MATRIX,
        row: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " get number of non-zeros of matrix"]
    pub fn SCIPmatrixGetNNonzs(matrix: *mut SCIP_MATRIX) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " get minimal activity of row"]
    pub fn SCIPmatrixGetRowMinActivity(matrix: *mut SCIP_MATRIX, row: ::std::os::raw::c_int)
        -> f64;
}
extern "C" {
    #[doc = " get maximal activity of row"]
    pub fn SCIPmatrixGetRowMaxActivity(matrix: *mut SCIP_MATRIX, row: ::std::os::raw::c_int)
        -> f64;
}
extern "C" {
    #[doc = " get number of negative infinities present within minimal activity"]
    pub fn SCIPmatrixGetRowNMinActNegInf(
        matrix: *mut SCIP_MATRIX,
        row: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " get number of positive infinities present within minimal activity"]
    pub fn SCIPmatrixGetRowNMinActPosInf(
        matrix: *mut SCIP_MATRIX,
        row: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " get number of negative infinities present within maximal activity"]
    pub fn SCIPmatrixGetRowNMaxActNegInf(
        matrix: *mut SCIP_MATRIX,
        row: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " get number of positive infinities present within maximal activity"]
    pub fn SCIPmatrixGetRowNMaxActPosInf(
        matrix: *mut SCIP_MATRIX,
        row: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " get constraint pointer for constraint representing row"]
    pub fn SCIPmatrixGetCons(
        matrix: *mut SCIP_MATRIX,
        row: ::std::os::raw::c_int,
    ) -> *mut SCIP_CONS;
}
extern "C" {
    #[doc = " get if conflicting uplocks of variable present"]
    pub fn SCIPmatrixUplockConflict(
        matrix: *mut SCIP_MATRIX,
        col: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " get if conflicting downlocks of variable present"]
    pub fn SCIPmatrixDownlockConflict(
        matrix: *mut SCIP_MATRIX,
        col: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " initialize matrix by copying all check constraints\n\n  @note Completeness is checked by testing whether all check constraints are from a list of linear constraint handlers\n        that can be represented."]
    pub fn SCIPmatrixCreate(
        scip: *mut SCIP,
        matrixptr: *mut *mut SCIP_MATRIX,
        onlyifcomplete: ::std::os::raw::c_uint,
        initialized: *mut ::std::os::raw::c_uint,
        complete: *mut ::std::os::raw::c_uint,
        infeasible: *mut ::std::os::raw::c_uint,
        naddconss: *mut ::std::os::raw::c_int,
        ndelconss: *mut ::std::os::raw::c_int,
        nchgcoefs: *mut ::std::os::raw::c_int,
        nchgbds: *mut ::std::os::raw::c_int,
        nfixedvars: *mut ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " frees the constraint matrix"]
    pub fn SCIPmatrixFree(scip: *mut SCIP, matrix: *mut *mut SCIP_MATRIX);
}
extern "C" {
    #[doc = " print one row of the MIP matrix"]
    pub fn SCIPmatrixPrintRow(
        scip: *mut SCIP,
        matrix: *mut SCIP_MATRIX,
        row: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " detect parallel rows, rhs/lhs are ignored"]
    pub fn SCIPmatrixGetParallelRows(
        scip: *mut SCIP,
        matrix: *mut SCIP_MATRIX,
        scale: *mut f64,
        pclass: *mut ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " removes the bounds of a column and updates the activities accordingly"]
    pub fn SCIPmatrixRemoveColumnBounds(
        scip: *mut SCIP,
        matrix: *mut SCIP_MATRIX,
        col: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " detect parallel columns, obj ignored"]
    pub fn SCIPmatrixGetParallelCols(
        scip: *mut SCIP,
        matrix: *mut SCIP_MATRIX,
        scale: *mut f64,
        pclass: *mut ::std::os::raw::c_int,
        varineq: *mut ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    pub fn memcpy(
        __dest: *mut ::std::os::raw::c_void,
        __src: *const ::std::os::raw::c_void,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memmove(
        __dest: *mut ::std::os::raw::c_void,
        __src: *const ::std::os::raw::c_void,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memccpy(
        __dest: *mut ::std::os::raw::c_void,
        __src: *const ::std::os::raw::c_void,
        __c: ::std::os::raw::c_int,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memset(
        __s: *mut ::std::os::raw::c_void,
        __c: ::std::os::raw::c_int,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memcmp(
        __s1: *const ::std::os::raw::c_void,
        __s2: *const ::std::os::raw::c_void,
        __n: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __memcmpeq(
        __s1: *const ::std::os::raw::c_void,
        __s2: *const ::std::os::raw::c_void,
        __n: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn memchr(
        __s: *const ::std::os::raw::c_void,
        __c: ::std::os::raw::c_int,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn strcpy(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strncpy(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strcat(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strncat(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strcmp(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strncmp(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strcoll(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strxfrm(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_ulong;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __locale_struct {
    pub __locales: [*mut __locale_data; 13usize],
    pub __ctype_b: *const ::std::os::raw::c_ushort,
    pub __ctype_tolower: *const ::std::os::raw::c_int,
    pub __ctype_toupper: *const ::std::os::raw::c_int,
    pub __names: [*const ::std::os::raw::c_char; 13usize],
}
#[test]
fn bindgen_test_layout___locale_struct() {
    const UNINIT: ::std::mem::MaybeUninit<__locale_struct> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__locale_struct>(),
        232usize,
        concat!("Size of: ", stringify!(__locale_struct))
    );
    assert_eq!(
        ::std::mem::align_of::<__locale_struct>(),
        8usize,
        concat!("Alignment of ", stringify!(__locale_struct))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__locales) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__locale_struct),
            "::",
            stringify!(__locales)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__ctype_b) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(__locale_struct),
            "::",
            stringify!(__ctype_b)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__ctype_tolower) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(__locale_struct),
            "::",
            stringify!(__ctype_tolower)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__ctype_toupper) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(__locale_struct),
            "::",
            stringify!(__ctype_toupper)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__names) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(__locale_struct),
            "::",
            stringify!(__names)
        )
    );
}
pub type __locale_t = *mut __locale_struct;
pub type locale_t = __locale_t;
extern "C" {
    pub fn strcoll_l(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
        __l: locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strxfrm_l(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: usize,
        __l: locale_t,
    ) -> usize;
}
extern "C" {
    pub fn strdup(__s: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strndup(
        __string: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strchr(
        __s: *const ::std::os::raw::c_char,
        __c: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strrchr(
        __s: *const ::std::os::raw::c_char,
        __c: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strchrnul(
        __s: *const ::std::os::raw::c_char,
        __c: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strcspn(
        __s: *const ::std::os::raw::c_char,
        __reject: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strspn(
        __s: *const ::std::os::raw::c_char,
        __accept: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strpbrk(
        __s: *const ::std::os::raw::c_char,
        __accept: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strstr(
        __haystack: *const ::std::os::raw::c_char,
        __needle: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strtok(
        __s: *mut ::std::os::raw::c_char,
        __delim: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn __strtok_r(
        __s: *mut ::std::os::raw::c_char,
        __delim: *const ::std::os::raw::c_char,
        __save_ptr: *mut *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strtok_r(
        __s: *mut ::std::os::raw::c_char,
        __delim: *const ::std::os::raw::c_char,
        __save_ptr: *mut *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strcasestr(
        __haystack: *const ::std::os::raw::c_char,
        __needle: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn memmem(
        __haystack: *const ::std::os::raw::c_void,
        __haystacklen: usize,
        __needle: *const ::std::os::raw::c_void,
        __needlelen: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn __mempcpy(
        __dest: *mut ::std::os::raw::c_void,
        __src: *const ::std::os::raw::c_void,
        __n: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn mempcpy(
        __dest: *mut ::std::os::raw::c_void,
        __src: *const ::std::os::raw::c_void,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn strlen(__s: *const ::std::os::raw::c_char) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strnlen(__string: *const ::std::os::raw::c_char, __maxlen: usize) -> usize;
}
extern "C" {
    pub fn strerror(__errnum: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}__xpg_strerror_r"]
    pub fn strerror_r(
        __errnum: ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __buflen: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strerror_l(
        __errnum: ::std::os::raw::c_int,
        __l: locale_t,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn bcmp(
        __s1: *const ::std::os::raw::c_void,
        __s2: *const ::std::os::raw::c_void,
        __n: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bcopy(
        __src: *const ::std::os::raw::c_void,
        __dest: *mut ::std::os::raw::c_void,
        __n: usize,
    );
}
extern "C" {
    pub fn bzero(__s: *mut ::std::os::raw::c_void, __n: ::std::os::raw::c_ulong);
}
extern "C" {
    pub fn index(
        __s: *const ::std::os::raw::c_char,
        __c: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn rindex(
        __s: *const ::std::os::raw::c_char,
        __c: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ffs(__i: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ffsl(__l: ::std::os::raw::c_long) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ffsll(__ll: ::std::os::raw::c_longlong) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strcasecmp(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strncasecmp(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strcasecmp_l(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
        __loc: locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strncasecmp_l(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
        __n: usize,
        __loc: locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn explicit_bzero(__s: *mut ::std::os::raw::c_void, __n: usize);
}
extern "C" {
    pub fn strsep(
        __stringp: *mut *mut ::std::os::raw::c_char,
        __delim: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strsignal(__sig: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn __stpcpy(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn stpcpy(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn __stpncpy(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: usize,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn stpncpy(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strlcpy(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: usize,
    ) -> usize;
}
extern "C" {
    pub fn strlcat(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: usize,
    ) -> usize;
}
extern "C" {
    #[doc = " Creates and captures a message handler which deals with warning, information, and dialog (interactive shell) methods.\n\n  Use SCIPsetMessagehdlr() to make SCIP aware of the created message handler.\n  @note The message handler does not handle error messages. For that see SCIPmessageSetErrorPrinting()\n  @note Creating a message handler automatically captures it."]
    pub fn SCIPmessagehdlrCreate(
        messagehdlr: *mut *mut SCIP_MESSAGEHDLR,
        bufferedoutput: ::std::os::raw::c_uint,
        filename: *const ::std::os::raw::c_char,
        quiet: ::std::os::raw::c_uint,
        messagewarning: ::std::option::Option<
            unsafe extern "C" fn(
                messagehdlr: *mut SCIP_MESSAGEHDLR,
                file: *mut FILE,
                msg: *const ::std::os::raw::c_char,
            ),
        >,
        messagedialog: ::std::option::Option<
            unsafe extern "C" fn(
                messagehdlr: *mut SCIP_MESSAGEHDLR,
                file: *mut FILE,
                msg: *const ::std::os::raw::c_char,
            ),
        >,
        messageinfo: ::std::option::Option<
            unsafe extern "C" fn(
                messagehdlr: *mut SCIP_MESSAGEHDLR,
                file: *mut FILE,
                msg: *const ::std::os::raw::c_char,
            ),
        >,
        messagehdlrfree: ::std::option::Option<
            unsafe extern "C" fn(messagehdlr: *mut SCIP_MESSAGEHDLR) -> SCIP_RETCODE,
        >,
        messagehdlrdata: *mut SCIP_MESSAGEHDLRDATA,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " captures message handler"]
    pub fn SCIPmessagehdlrCapture(messagehdlr: *mut SCIP_MESSAGEHDLR);
}
extern "C" {
    #[doc = " releases message handler"]
    pub fn SCIPmessagehdlrRelease(messagehdlr: *mut *mut SCIP_MESSAGEHDLR) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " sets the user data of the message handler"]
    pub fn SCIPmessagehdlrSetData(
        messagehdlr: *mut SCIP_MESSAGEHDLR,
        messagehdlrdata: *mut SCIP_MESSAGEHDLRDATA,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " sets the log file name for the message handler"]
    pub fn SCIPmessagehdlrSetLogfile(
        messagehdlr: *mut SCIP_MESSAGEHDLR,
        filename: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    #[doc = " sets the messages handler to be quiet"]
    pub fn SCIPmessagehdlrSetQuiet(
        messagehdlr: *mut SCIP_MESSAGEHDLR,
        quiet: ::std::os::raw::c_uint,
    );
}
extern "C" {
    pub fn SCIPmessagePrintInfo(
        messagehdlr: *mut SCIP_MESSAGEHDLR,
        formatstr: *const ::std::os::raw::c_char,
        ...
    );
}
extern "C" {
    #[doc = " prints a message, acting like the vprintf() command"]
    pub fn SCIPmessageVPrintInfo(
        messagehdlr: *mut SCIP_MESSAGEHDLR,
        formatstr: *const ::std::os::raw::c_char,
        ap: *mut __va_list_tag,
    );
}
extern "C" {
    pub fn SCIPmessageFPrintInfo(
        messagehdlr: *mut SCIP_MESSAGEHDLR,
        file: *mut FILE,
        formatstr: *const ::std::os::raw::c_char,
        ...
    );
}
extern "C" {
    #[doc = " prints a message into a file, acting like the vfprintf() command"]
    pub fn SCIPmessageVFPrintInfo(
        messagehdlr: *mut SCIP_MESSAGEHDLR,
        file: *mut FILE,
        formatstr: *const ::std::os::raw::c_char,
        ap: *mut __va_list_tag,
    );
}
extern "C" {
    pub fn SCIPmessagePrintWarning(
        messagehdlr: *mut SCIP_MESSAGEHDLR,
        formatstr: *const ::std::os::raw::c_char,
        ...
    );
}
extern "C" {
    #[doc = " prints a warning message, acting like the vprintf() command"]
    pub fn SCIPmessageVPrintWarning(
        messagehdlr: *mut SCIP_MESSAGEHDLR,
        formatstr: *const ::std::os::raw::c_char,
        ap: *mut __va_list_tag,
    );
}
extern "C" {
    pub fn SCIPmessageFPrintWarning(
        messagehdlr: *mut SCIP_MESSAGEHDLR,
        formatstr: *const ::std::os::raw::c_char,
        ...
    );
}
extern "C" {
    #[doc = " prints a warning message into a file, acting like the vfprintf() command"]
    pub fn SCIPmessageVFPrintWarning(
        messagehdlr: *mut SCIP_MESSAGEHDLR,
        formatstr: *const ::std::os::raw::c_char,
        ap: *mut __va_list_tag,
    );
}
extern "C" {
    pub fn SCIPmessagePrintDialog(
        messagehdlr: *mut SCIP_MESSAGEHDLR,
        formatstr: *const ::std::os::raw::c_char,
        ...
    );
}
extern "C" {
    #[doc = " prints a dialog message that requests user interaction, acting like the vprintf() command"]
    pub fn SCIPmessageVPrintDialog(
        messagehdlr: *mut SCIP_MESSAGEHDLR,
        formatstr: *const ::std::os::raw::c_char,
        ap: *mut __va_list_tag,
    );
}
extern "C" {
    pub fn SCIPmessageFPrintDialog(
        messagehdlr: *mut SCIP_MESSAGEHDLR,
        file: *mut FILE,
        formatstr: *const ::std::os::raw::c_char,
        ...
    );
}
extern "C" {
    #[doc = " prints a dialog message that requests user interaction into a file, acting like the vfprintf() command"]
    pub fn SCIPmessageVFPrintDialog(
        messagehdlr: *mut SCIP_MESSAGEHDLR,
        file: *mut FILE,
        formatstr: *const ::std::os::raw::c_char,
        ap: *mut __va_list_tag,
    );
}
extern "C" {
    pub fn SCIPmessagePrintVerbInfo(
        messagehdlr: *mut SCIP_MESSAGEHDLR,
        verblevel: SCIP_VERBLEVEL,
        msgverblevel: SCIP_VERBLEVEL,
        formatstr: *const ::std::os::raw::c_char,
        ...
    );
}
extern "C" {
    #[doc = " prints a message depending on the verbosity level, acting like the vprintf() command"]
    pub fn SCIPmessageVPrintVerbInfo(
        messagehdlr: *mut SCIP_MESSAGEHDLR,
        verblevel: SCIP_VERBLEVEL,
        msgverblevel: SCIP_VERBLEVEL,
        formatstr: *const ::std::os::raw::c_char,
        ap: *mut __va_list_tag,
    );
}
extern "C" {
    pub fn SCIPmessageFPrintVerbInfo(
        messagehdlr: *mut SCIP_MESSAGEHDLR,
        verblevel: SCIP_VERBLEVEL,
        msgverblevel: SCIP_VERBLEVEL,
        file: *mut FILE,
        formatstr: *const ::std::os::raw::c_char,
        ...
    );
}
extern "C" {
    #[doc = " prints a message into a file depending on the verbosity level, acting like the vfprintf() command"]
    pub fn SCIPmessageVFPrintVerbInfo(
        messagehdlr: *mut SCIP_MESSAGEHDLR,
        verblevel: SCIP_VERBLEVEL,
        msgverblevel: SCIP_VERBLEVEL,
        file: *mut FILE,
        formatstr: *const ::std::os::raw::c_char,
        ap: *mut __va_list_tag,
    );
}
extern "C" {
    #[doc = " prints the header with source file location for an error message using the static message handler"]
    pub fn SCIPmessagePrintErrorHeader(
        sourcefile: *const ::std::os::raw::c_char,
        sourceline: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn SCIPmessagePrintError(formatstr: *const ::std::os::raw::c_char, ...);
}
extern "C" {
    #[doc = " prints an error message, acting like the vprintf() command using the static message handler"]
    pub fn SCIPmessageVPrintError(formatstr: *const ::std::os::raw::c_char, ap: *mut __va_list_tag);
}
extern "C" {
    #[doc = " Method to set the error printing method. Setting the error printing method to NULL will suspend all error methods.\n\n  @note The error printing method is a static variable. This means that all occurring errors are handled via this method."]
    pub fn SCIPmessageSetErrorPrinting(
        errorPrinting: ::std::option::Option<
            unsafe extern "C" fn(
                data: *mut ::std::os::raw::c_void,
                file: *mut FILE,
                msg: *const ::std::os::raw::c_char,
            ),
        >,
        data: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    #[doc = " Method to set the error printing method to default version prints everything the stderr.\n\n  @note The error printing method is a static variable. This means that all occurring errors are handled via this method."]
    pub fn SCIPmessageSetErrorPrintingDefault();
}
extern "C" {
    #[doc = " returns the user data of the message handler"]
    pub fn SCIPmessagehdlrGetData(messagehdlr: *mut SCIP_MESSAGEHDLR) -> *mut SCIP_MESSAGEHDLRDATA;
}
extern "C" {
    #[doc = " returns the log file or NULL for stdout"]
    pub fn SCIPmessagehdlrGetLogfile(messagehdlr: *mut SCIP_MESSAGEHDLR) -> *mut FILE;
}
extern "C" {
    #[doc = " returns TRUE if the message handler is set to be quiet"]
    pub fn SCIPmessagehdlrIsQuiet(messagehdlr: *mut SCIP_MESSAGEHDLR) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " partial sort an index array in non-decreasing order around the \\p k-th element,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectInd(
        indarray: *mut ::std::os::raw::c_int,
        indcomp: ::std::option::Option<
            unsafe extern "C" fn(
                dataptr: *mut ::std::os::raw::c_void,
                ind1: ::std::os::raw::c_int,
                ind2: ::std::os::raw::c_int,
            ) -> ::std::os::raw::c_int,
        >,
        dataptr: *mut ::std::os::raw::c_void,
        k: ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort an index array in non-decreasing order around the weighted median w.r.t. \\p weights and capacity,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectWeightedInd(
        indarray: *mut ::std::os::raw::c_int,
        indcomp: ::std::option::Option<
            unsafe extern "C" fn(
                dataptr: *mut ::std::os::raw::c_void,
                ind1: ::std::os::raw::c_int,
                ind2: ::std::os::raw::c_int,
            ) -> ::std::os::raw::c_int,
        >,
        dataptr: *mut ::std::os::raw::c_void,
        weights: *mut f64,
        capacity: f64,
        len: ::std::os::raw::c_int,
        medianpos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of an array of pointers in non-decreasing order around the \\p k-th element,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectPtr(
        ptrarray: *mut *mut ::std::os::raw::c_void,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        k: ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of an array of pointers in non-decreasing order around the weighted median w.r.t. \\p weights and capacity,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectWeightedPtr(
        ptrarray: *mut *mut ::std::os::raw::c_void,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        weights: *mut f64,
        capacity: f64,
        len: ::std::os::raw::c_int,
        medianpos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of two joint arrays of pointers/pointers, sorted by first array in non-decreasing order around the \\p k-th element,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectPtrPtr(
        ptrarray1: *mut *mut ::std::os::raw::c_void,
        ptrarray2: *mut *mut ::std::os::raw::c_void,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        k: ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of two joint arrays of pointers/pointers, sorted by first array in non-decreasing order around the weighted median w.r.t. \\p weights and capacity,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectWeightedPtrPtr(
        ptrarray1: *mut *mut ::std::os::raw::c_void,
        ptrarray2: *mut *mut ::std::os::raw::c_void,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        weights: *mut f64,
        capacity: f64,
        len: ::std::os::raw::c_int,
        medianpos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of two joint arrays of pointers/Reals, sorted by first array in non-decreasing order around the \\p k-th element,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectPtrReal(
        ptrarray: *mut *mut ::std::os::raw::c_void,
        realarray: *mut f64,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        k: ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of two joint arrays of pointers/Reals, sorted by first array in non-decreasing order around the weighted median w.r.t. \\p weights and capacity,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectWeightedPtrReal(
        ptrarray: *mut *mut ::std::os::raw::c_void,
        realarray: *mut f64,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        weights: *mut f64,
        capacity: f64,
        len: ::std::os::raw::c_int,
        medianpos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of two joint arrays of pointers/ints, sorted by first array in non-decreasing order around the \\p k-th element,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectPtrInt(
        ptrarray: *mut *mut ::std::os::raw::c_void,
        intarray: *mut ::std::os::raw::c_int,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        k: ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of two joint arrays of pointers/ints, sorted by first array in non-decreasing order around the weighted median w.r.t. \\p weights and capacity,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectWeightedPtrInt(
        ptrarray: *mut *mut ::std::os::raw::c_void,
        intarray: *mut ::std::os::raw::c_int,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        weights: *mut f64,
        capacity: f64,
        len: ::std::os::raw::c_int,
        medianpos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of two joint arrays of pointers/Bools, sorted by first array in non-decreasing order around the \\p k-th element,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectPtrBool(
        ptrarray: *mut *mut ::std::os::raw::c_void,
        boolarray: *mut ::std::os::raw::c_uint,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        k: ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of two joint arrays of pointers/Bools, sorted by first array in non-decreasing order around the weighted median w.r.t. \\p weights and capacity,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectWeightedPtrBool(
        ptrarray: *mut *mut ::std::os::raw::c_void,
        boolarray: *mut ::std::os::raw::c_uint,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        weights: *mut f64,
        capacity: f64,
        len: ::std::os::raw::c_int,
        medianpos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of three joint arrays of pointers/ints/ints, sorted by first array in non-decreasing order around the \\p k-th element,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectPtrIntInt(
        ptrarray: *mut *mut ::std::os::raw::c_void,
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        k: ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of three joint arrays of pointers/ints/ints, sorted by first array in non-decreasing order around the weighted median w.r.t. \\p weights and capacity,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectWeightedPtrIntInt(
        ptrarray: *mut *mut ::std::os::raw::c_void,
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        weights: *mut f64,
        capacity: f64,
        len: ::std::os::raw::c_int,
        medianpos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of three joint arrays of pointers/Reals/ints, sorted by first array in non-decreasing order around the \\p k-th element,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectPtrRealInt(
        ptrarray: *mut *mut ::std::os::raw::c_void,
        realarray: *mut f64,
        intarray: *mut ::std::os::raw::c_int,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        k: ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of three joint arrays of pointers/Reals/ints, sorted by first array in non-decreasing order around the weighted median w.r.t. \\p weights and capacity,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectWeightedPtrRealInt(
        ptrarray: *mut *mut ::std::os::raw::c_void,
        realarray: *mut f64,
        intarray: *mut ::std::os::raw::c_int,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        weights: *mut f64,
        capacity: f64,
        len: ::std::os::raw::c_int,
        medianpos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of four joint arrays of pointers/Reals/Reals/ints, sorted by first array in non-decreasing order around the \\p k-th element,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectPtrRealRealInt(
        ptrarray: *mut *mut ::std::os::raw::c_void,
        realarray1: *mut f64,
        realarray2: *mut f64,
        intarray: *mut ::std::os::raw::c_int,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        k: ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of four joint arrays of pointers/Reals/Reals/SCIP_Bools/SCIP_Bools, sorted by first array in non-decreasing order around the \\p k-th element,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectPtrRealRealBoolBool(
        ptrarray: *mut *mut ::std::os::raw::c_void,
        realarray1: *mut f64,
        realarray2: *mut f64,
        boolarray1: *mut ::std::os::raw::c_uint,
        boolarray2: *mut ::std::os::raw::c_uint,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        k: ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of four joint arrays of pointers/Reals/Reals/ints/SCIP_Bools, sorted by first array in non-decreasing order around the \\p k-th element,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectPtrRealRealIntBool(
        ptrarray: *mut *mut ::std::os::raw::c_void,
        realarray1: *mut f64,
        realarray2: *mut f64,
        intarray: *mut ::std::os::raw::c_int,
        boolarray: *mut ::std::os::raw::c_uint,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        k: ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of four joint arrays of pointers/Reals/Reals/ints, sorted by first array in non-decreasing order around the weighted median w.r.t. \\p weights and capacity,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectWeightedPtrRealRealInt(
        ptrarray: *mut *mut ::std::os::raw::c_void,
        realarray1: *mut f64,
        realarray2: *mut f64,
        intarray: *mut ::std::os::raw::c_int,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        weights: *mut f64,
        capacity: f64,
        len: ::std::os::raw::c_int,
        medianpos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of four joint arrays of pointers/Reals/Reals/SCIP_Bools/SCIP_Bools, sorted by first array in non-decreasing order around the weighted median w.r.t. \\p weights and capacity,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectWeightedPtrRealRealBoolBool(
        ptrarray: *mut *mut ::std::os::raw::c_void,
        realarray1: *mut f64,
        realarray2: *mut f64,
        boolarray1: *mut ::std::os::raw::c_uint,
        boolarray2: *mut ::std::os::raw::c_uint,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        weights: *mut f64,
        capacity: f64,
        len: ::std::os::raw::c_int,
        medianpos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of four joint arrays of pointers/Reals/Reals/ints/SCIP_Bools, sorted by first array in non-decreasing order around the weighted median w.r.t. \\p weights and capacity,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectWeightedPtrRealRealIntBool(
        ptrarray: *mut *mut ::std::os::raw::c_void,
        realarray1: *mut f64,
        realarray2: *mut f64,
        intarray: *mut ::std::os::raw::c_int,
        boolarray: *mut ::std::os::raw::c_uint,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        weights: *mut f64,
        capacity: f64,
        len: ::std::os::raw::c_int,
        medianpos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of three joint arrays of pointers/Reals/Bools, sorted by first array in non-decreasing order around the \\p k-th element,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectPtrRealBool(
        ptrarray: *mut *mut ::std::os::raw::c_void,
        realarray: *mut f64,
        boolarray: *mut ::std::os::raw::c_uint,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        k: ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of three joint arrays of pointers/Reals/Bools, sorted by first array in non-decreasing order around the weighted median w.r.t. \\p weights and capacity,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectWeightedPtrRealBool(
        ptrarray: *mut *mut ::std::os::raw::c_void,
        realarray: *mut f64,
        boolarray: *mut ::std::os::raw::c_uint,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        weights: *mut f64,
        capacity: f64,
        len: ::std::os::raw::c_int,
        medianpos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of three joint arrays of pointers/Reals/Reals, sorted by first array in non-decreasing order around the \\p k-th element,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectPtrRealReal(
        ptrarray: *mut *mut ::std::os::raw::c_void,
        realarray1: *mut f64,
        realarray2: *mut f64,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        k: ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of three joint arrays of pointers/Reals/Reals, sorted by first array in non-decreasing order around the weighted median w.r.t. \\p weights and capacity,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectWeightedPtrRealReal(
        ptrarray: *mut *mut ::std::os::raw::c_void,
        realarray1: *mut f64,
        realarray2: *mut f64,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        weights: *mut f64,
        capacity: f64,
        len: ::std::os::raw::c_int,
        medianpos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of three joint arrays of pointers/pointers/ints, sorted by first array in non-decreasing order around the \\p k-th element,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectPtrPtrInt(
        ptrarray1: *mut *mut ::std::os::raw::c_void,
        ptrarray2: *mut *mut ::std::os::raw::c_void,
        intarray: *mut ::std::os::raw::c_int,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        k: ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of three joint arrays of pointers/pointers/ints, sorted by first array in non-decreasing order around the weighted median w.r.t. \\p weights and capacity,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectWeightedPtrPtrInt(
        ptrarray1: *mut *mut ::std::os::raw::c_void,
        ptrarray2: *mut *mut ::std::os::raw::c_void,
        intarray: *mut ::std::os::raw::c_int,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        weights: *mut f64,
        capacity: f64,
        len: ::std::os::raw::c_int,
        medianpos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of three joint arrays of pointers/pointers/Reals, sorted by first array in non-decreasing order around the \\p k-th element,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectPtrPtrReal(
        ptrarray1: *mut *mut ::std::os::raw::c_void,
        ptrarray2: *mut *mut ::std::os::raw::c_void,
        realarray: *mut f64,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        k: ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of three joint arrays of pointers/pointers/Reals, sorted by first array in non-decreasing order around the weighted median w.r.t. \\p weights and capacity,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectWeightedPtrPtrReal(
        ptrarray1: *mut *mut ::std::os::raw::c_void,
        ptrarray2: *mut *mut ::std::os::raw::c_void,
        realarray: *mut f64,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        weights: *mut f64,
        capacity: f64,
        len: ::std::os::raw::c_int,
        medianpos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of four joint arrays of pointers/pointers/ints/ints, sorted by first array in non-decreasing order around the \\p k-th element,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectPtrPtrIntInt(
        ptrarray1: *mut *mut ::std::os::raw::c_void,
        ptrarray2: *mut *mut ::std::os::raw::c_void,
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        k: ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of four joint arrays of pointers/pointers/ints/ints, sorted by first array in non-decreasing order around the weighted median w.r.t. \\p weights and capacity,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectWeightedPtrPtrIntInt(
        ptrarray1: *mut *mut ::std::os::raw::c_void,
        ptrarray2: *mut *mut ::std::os::raw::c_void,
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        weights: *mut f64,
        capacity: f64,
        len: ::std::os::raw::c_int,
        medianpos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of four joint arrays of pointers/Reals/ints/ints, sorted by first array in non-decreasing order around the \\p k-th element,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectPtrRealIntInt(
        ptrarray: *mut *mut ::std::os::raw::c_void,
        realarray: *mut f64,
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        k: ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of four joint arrays of pointers/Reals/ints/ints, sorted by first array in non-decreasing order around the weighted median w.r.t. \\p weights and capacity,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectWeightedPtrRealIntInt(
        ptrarray: *mut *mut ::std::os::raw::c_void,
        realarray: *mut f64,
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        weights: *mut f64,
        capacity: f64,
        len: ::std::os::raw::c_int,
        medianpos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of four joint arrays of pointer/pointer/Reals/ints, sorted by first array in non-decreasing order around the \\p k-th element,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectPtrPtrRealInt(
        ptrarray1: *mut *mut ::std::os::raw::c_void,
        ptrarray2: *mut *mut ::std::os::raw::c_void,
        realarray: *mut f64,
        intarray: *mut ::std::os::raw::c_int,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        k: ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of four joint arrays of pointer/pointer/Reals/ints, sorted by first array in non-decreasing order around the weighted median w.r.t. \\p weights and capacity,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectWeightedPtrPtrRealInt(
        ptrarray1: *mut *mut ::std::os::raw::c_void,
        ptrarray2: *mut *mut ::std::os::raw::c_void,
        realarray: *mut f64,
        intarray: *mut ::std::os::raw::c_int,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        weights: *mut f64,
        capacity: f64,
        len: ::std::os::raw::c_int,
        medianpos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of four joint arrays of pointer/pointer/Reals/Bools, sorted by first array in non-decreasing order around the \\p k-th element,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectPtrPtrRealBool(
        ptrarray1: *mut *mut ::std::os::raw::c_void,
        ptrarray2: *mut *mut ::std::os::raw::c_void,
        realarray: *mut f64,
        boolarray: *mut ::std::os::raw::c_uint,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        k: ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of four joint arrays of pointer/pointer/Reals/Bools, sorted by first array in non-decreasing order around the weighted median w.r.t. \\p weights and capacity,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectWeightedPtrPtrRealBool(
        ptrarray1: *mut *mut ::std::os::raw::c_void,
        ptrarray2: *mut *mut ::std::os::raw::c_void,
        realarray: *mut f64,
        boolarray: *mut ::std::os::raw::c_uint,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        weights: *mut f64,
        capacity: f64,
        len: ::std::os::raw::c_int,
        medianpos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of four joint arrays of pointer/pointer/Longs/ints, sorted by first array in non-decreasing order around the \\p k-th element,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectPtrPtrLongInt(
        ptrarray1: *mut *mut ::std::os::raw::c_void,
        ptrarray2: *mut *mut ::std::os::raw::c_void,
        longarray: *mut ::std::os::raw::c_longlong,
        intarray: *mut ::std::os::raw::c_int,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        k: ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of four joint arrays of pointer/pointer/Longs/ints, sorted by first array in non-decreasing order around the weighted median w.r.t. \\p weights and capacity,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectWeightedPtrPtrLongInt(
        ptrarray1: *mut *mut ::std::os::raw::c_void,
        ptrarray2: *mut *mut ::std::os::raw::c_void,
        longarray: *mut ::std::os::raw::c_longlong,
        intarray: *mut ::std::os::raw::c_int,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        weights: *mut f64,
        capacity: f64,
        len: ::std::os::raw::c_int,
        medianpos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of five joint arrays of pointer/pointer/Longs/ints/ints, sorted by first array in non-decreasing order around the \\p k-th element,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectPtrPtrLongIntInt(
        ptrarray1: *mut *mut ::std::os::raw::c_void,
        ptrarray2: *mut *mut ::std::os::raw::c_void,
        longarray: *mut ::std::os::raw::c_longlong,
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        k: ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of five joint arrays of pointer/pointer/Longs/ints/ints, sorted by first array in non-decreasing order around the weighted median w.r.t. \\p weights and capacity,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectWeightedPtrPtrLongIntInt(
        ptrarray1: *mut *mut ::std::os::raw::c_void,
        ptrarray2: *mut *mut ::std::os::raw::c_void,
        longarray: *mut ::std::os::raw::c_longlong,
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        weights: *mut f64,
        capacity: f64,
        len: ::std::os::raw::c_int,
        medianpos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort an array of Reals in non-decreasing order around the \\p k-th element,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectReal(
        realarray: *mut f64,
        k: ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort an array of Reals in non-decreasing order around the weighted median w.r.t. \\p weights and capacity,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectWeightedReal(
        realarray: *mut f64,
        weights: *mut f64,
        capacity: f64,
        len: ::std::os::raw::c_int,
        medianpos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of two joint arrays of Reals/pointers, sorted by first array in non-decreasing order around the \\p k-th element,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectRealPtr(
        realarray: *mut f64,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        k: ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of two joint arrays of Reals/pointers, sorted by first array in non-decreasing order around the weighted median w.r.t. \\p weights and capacity,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectWeightedRealPtr(
        realarray: *mut f64,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        weights: *mut f64,
        capacity: f64,
        len: ::std::os::raw::c_int,
        medianpos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of two joint arrays of Reals/ints, sorted by first array in non-decreasing order around the \\p k-th element,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectRealInt(
        realarray: *mut f64,
        intarray: *mut ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of two joint arrays of Reals/ints, sorted by first array in non-decreasing order around the weighted median w.r.t. \\p weights and capacity,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectWeightedRealInt(
        realarray: *mut f64,
        intarray: *mut ::std::os::raw::c_int,
        weights: *mut f64,
        capacity: f64,
        len: ::std::os::raw::c_int,
        medianpos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of three joint arrays of Reals/ints/ints, sorted by first array in non-decreasing order around the \\p k-th element,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectRealIntInt(
        realarray: *mut f64,
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of three joint arrays of Reals/ints/ints, sorted by first array in non-decreasing order around the weighted median w.r.t. \\p weights and capacity,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectWeightedRealIntInt(
        realarray: *mut f64,
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        weights: *mut f64,
        capacity: f64,
        len: ::std::os::raw::c_int,
        medianpos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of three joint arrays of Reals/Bools/Pointer, sorted by first array in non-decreasing order around the \\p k-th element,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectRealBoolPtr(
        realarray: *mut f64,
        boolarray: *mut ::std::os::raw::c_uint,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        k: ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of three joint arrays of Reals/Bools/Pointer, sorted by first array in non-decreasing order around the weighted median w.r.t. \\p weights and capacity,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectWeightedRealBoolPtr(
        realarray: *mut f64,
        boolarray: *mut ::std::os::raw::c_uint,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        weights: *mut f64,
        capacity: f64,
        len: ::std::os::raw::c_int,
        medianpos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of three joint arrays of Reals/ints/Longs, sorted by first array in non-decreasing order around the \\p k-th element,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectRealIntLong(
        realarray: *mut f64,
        intarray: *mut ::std::os::raw::c_int,
        longarray: *mut ::std::os::raw::c_longlong,
        k: ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of three joint arrays of Reals/ints/Longs, sorted by first array in non-decreasing order around the weighted median w.r.t. \\p weights and capacity,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectWeightedRealIntLong(
        realarray: *mut f64,
        intarray: *mut ::std::os::raw::c_int,
        longarray: *mut ::std::os::raw::c_longlong,
        weights: *mut f64,
        capacity: f64,
        len: ::std::os::raw::c_int,
        medianpos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of three joint arrays of Reals/ints/Pointer, sorted by first array in non-decreasing order around the \\p k-th element,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectRealIntPtr(
        realarray: *mut f64,
        intarray: *mut ::std::os::raw::c_int,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        k: ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of three joint arrays of Reals/ints/Pointer, sorted by first array in non-decreasing order around the weighted median w.r.t. \\p weights and capacity,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectWeightedRealIntPtr(
        realarray: *mut f64,
        intarray: *mut ::std::os::raw::c_int,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        weights: *mut f64,
        capacity: f64,
        len: ::std::os::raw::c_int,
        medianpos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of three joint arrays of Reals/Reals/Pointer, sorted by first array in non-decreasing order around the \\p k-th element,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectRealRealPtr(
        realarray1: *mut f64,
        realarray2: *mut f64,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        k: ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of three joint arrays of Reals/Reals/Pointer, sorted by first array in non-decreasing order around the weighted median w.r.t. \\p weights and capacity,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectWeightedRealRealPtr(
        realarray1: *mut f64,
        realarray2: *mut f64,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        weights: *mut f64,
        capacity: f64,
        len: ::std::os::raw::c_int,
        medianpos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of four joint arrays of Reals/pointers/pointers/ints, sorted by first array in non-decreasing order around the \\p k-th element,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectRealPtrPtrInt(
        realarray: *mut f64,
        ptrarray1: *mut *mut ::std::os::raw::c_void,
        ptrarray2: *mut *mut ::std::os::raw::c_void,
        intarray: *mut ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of four joint arrays of Reals/pointers/pointers/ints, sorted by first array in non-decreasing order around the weighted median w.r.t. \\p weights and capacity,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectWeightedRealPtrPtrInt(
        realarray: *mut f64,
        ptrarray1: *mut *mut ::std::os::raw::c_void,
        ptrarray2: *mut *mut ::std::os::raw::c_void,
        intarray: *mut ::std::os::raw::c_int,
        weights: *mut f64,
        capacity: f64,
        len: ::std::os::raw::c_int,
        medianpos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of five joint arrays of Reals/pointers/pointers/ints/ints, sorted by first array in non-decreasing order around the \\p k-th element,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectRealPtrPtrIntInt(
        realarray: *mut f64,
        ptrarray1: *mut *mut ::std::os::raw::c_void,
        ptrarray2: *mut *mut ::std::os::raw::c_void,
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of five joint arrays of Reals/pointers/pointers/ints/ints, sorted by first array in non-decreasing order around the weighted median w.r.t. \\p weights and capacity,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectWeightedRealPtrPtrIntInt(
        realarray: *mut f64,
        ptrarray1: *mut *mut ::std::os::raw::c_void,
        ptrarray2: *mut *mut ::std::os::raw::c_void,
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        weights: *mut f64,
        capacity: f64,
        len: ::std::os::raw::c_int,
        medianpos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of four joint arrays of Reals/Longs/Reals/ints, sorted by first array in non-decreasing order around the \\p k-th element,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectRealLongRealInt(
        realarray1: *mut f64,
        longarray: *mut ::std::os::raw::c_longlong,
        realarray3: *mut f64,
        intarray: *mut ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of four joint arrays of Reals/Longs/Reals/ints, sorted by first array in non-decreasing order around the weighted median w.r.t. \\p weights and capacity,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectWeightedRealLongRealInt(
        realarray1: *mut f64,
        longarray: *mut ::std::os::raw::c_longlong,
        realarray3: *mut f64,
        intarray: *mut ::std::os::raw::c_int,
        weights: *mut f64,
        capacity: f64,
        len: ::std::os::raw::c_int,
        medianpos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of four joint arrays of Reals/Reals/ints/ints, sorted by first array in non-decreasing order around the \\p k-th element,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectRealRealIntInt(
        realarray1: *mut f64,
        realarray2: *mut f64,
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of four joint arrays of Reals/Reals/ints/ints, sorted by first array in non-decreasing order around the weighted median w.r.t. \\p weights and capacity,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectWeightedRealRealIntInt(
        realarray1: *mut f64,
        realarray2: *mut f64,
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        weights: *mut f64,
        capacity: f64,
        len: ::std::os::raw::c_int,
        medianpos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of four joint arrays of Reals/Reals/Reals/ints, sorted by first array in non-decreasing order around the \\p k-th element,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectRealRealRealInt(
        realarray1: *mut f64,
        realarray2: *mut f64,
        realarray3: *mut f64,
        intarray: *mut ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of four joint arrays of Reals/Reals/Reals/ints, sorted by first array in non-decreasing order around the weighted median w.r.t. \\p weights and capacity,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectWeightedRealRealRealInt(
        realarray1: *mut f64,
        realarray2: *mut f64,
        realarray3: *mut f64,
        intarray: *mut ::std::os::raw::c_int,
        weights: *mut f64,
        capacity: f64,
        len: ::std::os::raw::c_int,
        medianpos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of four joint arrays of Reals/Reals/Reals/pointers, sorted by first array in non-decreasing order around the \\p k-th element,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectRealRealRealPtr(
        realarray1: *mut f64,
        realarray2: *mut f64,
        realarray3: *mut f64,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        k: ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of four joint arrays of Reals/Reals/Reals/pointers, sorted by first array in non-decreasing order around the weighted median w.r.t. \\p weights and capacity,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectWeightedRealRealRealPtr(
        realarray1: *mut f64,
        realarray2: *mut f64,
        realarray3: *mut f64,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        weights: *mut f64,
        capacity: f64,
        len: ::std::os::raw::c_int,
        medianpos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of five joint arrays of Reals/Reals/Reals/Bools/pointers, sorted by first array in non-decreasing order around the \\p k-th element,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectRealRealRealBoolPtr(
        realarray1: *mut f64,
        realarray2: *mut f64,
        realarray3: *mut f64,
        boolarray: *mut ::std::os::raw::c_uint,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        k: ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of five joint arrays of Reals/Reals/Reals/Bools/pointers, sorted by first array in non-decreasing order around the weighted median w.r.t. \\p weights and capacity,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectWeightedRealRealRealBoolPtr(
        realarray1: *mut f64,
        realarray2: *mut f64,
        realarray3: *mut f64,
        boolarray: *mut ::std::os::raw::c_uint,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        weights: *mut f64,
        capacity: f64,
        len: ::std::os::raw::c_int,
        medianpos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of six joint arrays of Reals/Reals/Reals/Bools/Bools/pointers, sorted by first array in non-decreasing order around the \\p k-th element,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectRealRealRealBoolBoolPtr(
        realarray1: *mut f64,
        realarray2: *mut f64,
        realarray3: *mut f64,
        boolarray1: *mut ::std::os::raw::c_uint,
        boolarray2: *mut ::std::os::raw::c_uint,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        k: ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of six joint arrays of Reals/Reals/Reals/Bools/Bools/pointers, sorted by first array in non-decreasing order around the weighted median w.r.t. \\p weights and capacity,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectWeightedRealRealRealBoolBoolPtr(
        realarray1: *mut f64,
        realarray2: *mut f64,
        realarray3: *mut f64,
        boolarray1: *mut ::std::os::raw::c_uint,
        boolarray2: *mut ::std::os::raw::c_uint,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        weights: *mut f64,
        capacity: f64,
        len: ::std::os::raw::c_int,
        medianpos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort array of ints in non-decreasing order around the \\p k-th element,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectInt(
        intarray: *mut ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort array of ints in non-decreasing order around the weighted median w.r.t. \\p weights and capacity,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectWeightedInt(
        intarray: *mut ::std::os::raw::c_int,
        weights: *mut f64,
        capacity: f64,
        len: ::std::os::raw::c_int,
        medianpos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of two joint arrays of ints/ints, sorted by first array in non-decreasing order around the \\p k-th element,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectIntInt(
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of two joint arrays of ints/ints, sorted by first array in non-decreasing order around the weighted median w.r.t. \\p weights and capacity,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectWeightedIntInt(
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        weights: *mut f64,
        capacity: f64,
        len: ::std::os::raw::c_int,
        medianpos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of two joint arrays of ints/pointers, sorted by first array in non-decreasing order around the \\p k-th element,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectIntPtr(
        intarray: *mut ::std::os::raw::c_int,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        k: ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of two joint arrays of ints/pointers, sorted by first array in non-decreasing order around the weighted median w.r.t. \\p weights and capacity,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectWeightedIntPtr(
        intarray: *mut ::std::os::raw::c_int,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        weights: *mut f64,
        capacity: f64,
        len: ::std::os::raw::c_int,
        medianpos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of two joint arrays of ints/reals, sorted by first array in non-decreasing order around the \\p k-th element,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectIntReal(
        intarray: *mut ::std::os::raw::c_int,
        realarray: *mut f64,
        k: ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of two joint arrays of ints/reals, sorted by first array in non-decreasing order around the weighted median w.r.t. \\p weights and capacity,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectWeightedIntReal(
        intarray: *mut ::std::os::raw::c_int,
        realarray: *mut f64,
        weights: *mut f64,
        capacity: f64,
        len: ::std::os::raw::c_int,
        medianpos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of three joint arrays of ints/ints/ints, sorted by first array in non-decreasing order around the \\p k-th element,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectIntIntInt(
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        intarray3: *mut ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of three joint arrays of ints/ints/ints, sorted by first array in non-decreasing order around the weighted median w.r.t. \\p weights and capacity,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectWeightedIntIntInt(
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        intarray3: *mut ::std::os::raw::c_int,
        weights: *mut f64,
        capacity: f64,
        len: ::std::os::raw::c_int,
        medianpos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of three joint arrays of ints/ints/Longints, sorted by first array in non-decreasing order around the \\p k-th element,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectIntIntLong(
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        longarray: *mut ::std::os::raw::c_longlong,
        k: ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of three joint arrays of ints/ints/Longints, sorted by first array in non-decreasing order around the weighted median w.r.t. \\p weights and capacity,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectWeightedIntIntLong(
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        longarray: *mut ::std::os::raw::c_longlong,
        weights: *mut f64,
        capacity: f64,
        len: ::std::os::raw::c_int,
        medianpos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of three joint arrays of ints/ints/Longints, sorted by first array in non-decreasing order around the \\p k-th element,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectIntRealLong(
        intarray: *mut ::std::os::raw::c_int,
        realarray: *mut f64,
        longarray: *mut ::std::os::raw::c_longlong,
        k: ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of three joint arrays of ints/ints/Longints, sorted by first array in non-decreasing order around the weighted median w.r.t. \\p weights and capacity,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectWeightedIntRealLong(
        intarray: *mut ::std::os::raw::c_int,
        realarray: *mut f64,
        longarray: *mut ::std::os::raw::c_longlong,
        weights: *mut f64,
        capacity: f64,
        len: ::std::os::raw::c_int,
        medianpos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of three joint arrays of ints/ints/pointers, sorted by first array in non-decreasing order around the \\p k-th element,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectIntIntPtr(
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        k: ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of three joint arrays of ints/ints/pointers, sorted by first array in non-decreasing order around the weighted median w.r.t. \\p weights and capacity,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectWeightedIntIntPtr(
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        weights: *mut f64,
        capacity: f64,
        len: ::std::os::raw::c_int,
        medianpos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of three joint arrays of ints/ints/reals, sorted by first array in non-decreasing order around the \\p k-th element,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectIntIntReal(
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        realarray: *mut f64,
        k: ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of three joint arrays of ints/ints/reals, sorted by first array in non-decreasing order around the weighted median w.r.t. \\p weights and capacity,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectWeightedIntIntReal(
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        realarray: *mut f64,
        weights: *mut f64,
        capacity: f64,
        len: ::std::os::raw::c_int,
        medianpos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of three joint arrays of ints/pointers/reals, sorted by first array in non-decreasing order around the \\p k-th element,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectIntPtrReal(
        intarray: *mut ::std::os::raw::c_int,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        realarray: *mut f64,
        k: ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of three joint arrays of ints/pointers/reals, sorted by first array in non-decreasing order around the weighted median w.r.t. \\p weights and capacity,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectWeightedIntPtrReal(
        intarray: *mut ::std::os::raw::c_int,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        realarray: *mut f64,
        weights: *mut f64,
        capacity: f64,
        len: ::std::os::raw::c_int,
        medianpos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of four joint arrays of ints/ints/ints/pointers, sorted by first array in non-decreasing order around the \\p k-th element,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectIntIntIntPtr(
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        intarray3: *mut ::std::os::raw::c_int,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        k: ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of four joint arrays of ints/ints/ints/pointers, sorted by first array in non-decreasing order around the weighted median w.r.t. \\p weights and capacity,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectWeightedIntIntIntPtr(
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        intarray3: *mut ::std::os::raw::c_int,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        weights: *mut f64,
        capacity: f64,
        len: ::std::os::raw::c_int,
        medianpos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of four joint arrays of ints/ints/ints/reals, sorted by first array in non-decreasing order around the \\p k-th element,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectIntIntIntReal(
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        intarray3: *mut ::std::os::raw::c_int,
        realarray: *mut f64,
        k: ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of four joint arrays of ints/ints/ints/reals, sorted by first array in non-decreasing order around the weighted median w.r.t. \\p weights and capacity,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectWeightedIntIntIntReal(
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        intarray3: *mut ::std::os::raw::c_int,
        realarray: *mut f64,
        weights: *mut f64,
        capacity: f64,
        len: ::std::os::raw::c_int,
        medianpos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of four joint arrays of ints/pointers/ints/reals, sorted by first array in non-decreasing order around the \\p k-th element,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectIntPtrIntReal(
        intarray1: *mut ::std::os::raw::c_int,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        intarray2: *mut ::std::os::raw::c_int,
        realarray: *mut f64,
        k: ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of four joint arrays of ints/pointers/ints/reals, sorted by first array in non-decreasing order around the weighted median w.r.t. \\p weights and capacity,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectWeightedIntPtrIntReal(
        intarray1: *mut ::std::os::raw::c_int,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        intarray2: *mut ::std::os::raw::c_int,
        realarray: *mut f64,
        weights: *mut f64,
        capacity: f64,
        len: ::std::os::raw::c_int,
        medianpos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort an array of Longints in non-decreasing order around the \\p k-th element,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectLong(
        longarray: *mut ::std::os::raw::c_longlong,
        k: ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort an array of Longints in non-decreasing order around the weighted median w.r.t. \\p weights and capacity,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectWeightedLong(
        longarray: *mut ::std::os::raw::c_longlong,
        weights: *mut f64,
        capacity: f64,
        len: ::std::os::raw::c_int,
        medianpos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of two joint arrays of Long/pointer, sorted by the first array in non-decreasing order around the \\p k-th element,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectLongPtr(
        longarray: *mut ::std::os::raw::c_longlong,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        k: ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of two joint arrays of Long/pointer, sorted by the first array in non-decreasing order around the weighted median w.r.t. \\p weights and capacity,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectWeightedLongPtr(
        longarray: *mut ::std::os::raw::c_longlong,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        weights: *mut f64,
        capacity: f64,
        len: ::std::os::raw::c_int,
        medianpos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of three arrays of Long/pointer/ints, sorted by the first array in non-decreasing order around the \\p k-th element,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectLongPtrInt(
        longarray: *mut ::std::os::raw::c_longlong,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        intarray: *mut ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of three arrays of Long/pointer/ints, sorted by the first array in non-decreasing order around the weighted median w.r.t. \\p weights and capacity,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectWeightedLongPtrInt(
        longarray: *mut ::std::os::raw::c_longlong,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        intarray: *mut ::std::os::raw::c_int,
        weights: *mut f64,
        capacity: f64,
        len: ::std::os::raw::c_int,
        medianpos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of four arrays of Long/pointer/Real/Bool, sorted by the first array in non-decreasing order around the \\p k-th element,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectLongPtrRealBool(
        longarray: *mut ::std::os::raw::c_longlong,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        realarray: *mut f64,
        boolarray: *mut ::std::os::raw::c_uint,
        k: ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of four arrays of Long/pointer/Real/Bool, sorted by the first array in non-decreasing order around the weighted median w.r.t. \\p weights and capacity,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectWeightedLongPtrRealBool(
        longarray: *mut ::std::os::raw::c_longlong,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        realarray: *mut f64,
        boolarray: *mut ::std::os::raw::c_uint,
        weights: *mut f64,
        capacity: f64,
        len: ::std::os::raw::c_int,
        medianpos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of five arrays of Long/pointer/Real/Real/Bool, sorted by the first array in non-decreasing order around the \\p k-th element,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectLongPtrRealRealBool(
        longarray: *mut ::std::os::raw::c_longlong,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        realarray: *mut f64,
        realarray2: *mut f64,
        boolarray: *mut ::std::os::raw::c_uint,
        k: ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of five arrays of Long/pointer/Real/Real/Bool, sorted by the first array in non-decreasing order around the weighted median w.r.t. \\p weights and capacity,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectWeightedLongPtrRealRealBool(
        longarray: *mut ::std::os::raw::c_longlong,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        realarray: *mut f64,
        realarray2: *mut f64,
        boolarray: *mut ::std::os::raw::c_uint,
        weights: *mut f64,
        capacity: f64,
        len: ::std::os::raw::c_int,
        medianpos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of six arrays of Long/pointer/Real/Real/int/Bool, sorted by the first array in non-decreasing order around the \\p k-th element,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectLongPtrRealRealIntBool(
        longarray: *mut ::std::os::raw::c_longlong,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        realarray: *mut f64,
        realarray2: *mut f64,
        intarray: *mut ::std::os::raw::c_int,
        boolarray: *mut ::std::os::raw::c_uint,
        k: ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of six arrays of Long/pointer/Real/Real/int/Bool, sorted by the first array in non-decreasing order around the weighted median w.r.t. \\p weights and capacity,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectWeightedLongPtrRealRealIntBool(
        longarray: *mut ::std::os::raw::c_longlong,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        realarray: *mut f64,
        realarray2: *mut f64,
        intarray: *mut ::std::os::raw::c_int,
        boolarray: *mut ::std::os::raw::c_uint,
        weights: *mut f64,
        capacity: f64,
        len: ::std::os::raw::c_int,
        medianpos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of four joint arrays of Long/pointer/pointer/ints, sorted by first array in non-decreasing order around the \\p k-th element,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectLongPtrPtrInt(
        longarray: *mut ::std::os::raw::c_longlong,
        ptrarray1: *mut *mut ::std::os::raw::c_void,
        ptrarray2: *mut *mut ::std::os::raw::c_void,
        intarray: *mut ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of four joint arrays of Long/pointer/pointer/ints, sorted by first array in non-decreasing order around the weighted median w.r.t. \\p weights and capacity,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectWeightedLongPtrPtrInt(
        longarray: *mut ::std::os::raw::c_longlong,
        ptrarray1: *mut *mut ::std::os::raw::c_void,
        ptrarray2: *mut *mut ::std::os::raw::c_void,
        intarray: *mut ::std::os::raw::c_int,
        weights: *mut f64,
        capacity: f64,
        len: ::std::os::raw::c_int,
        medianpos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of five joint arrays of Long/pointer/pointer/ints/ints, sorted by first array in non-decreasing order around the \\p k-th element,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectLongPtrPtrIntInt(
        longarray: *mut ::std::os::raw::c_longlong,
        ptrarray1: *mut *mut ::std::os::raw::c_void,
        ptrarray2: *mut *mut ::std::os::raw::c_void,
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of five joint arrays of Long/pointer/pointer/ints/ints, sorted by first array in non-decreasing order around the weighted median w.r.t. \\p weights and capacity,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectWeightedLongPtrPtrIntInt(
        longarray: *mut ::std::os::raw::c_longlong,
        ptrarray1: *mut *mut ::std::os::raw::c_void,
        ptrarray2: *mut *mut ::std::os::raw::c_void,
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        weights: *mut f64,
        capacity: f64,
        len: ::std::os::raw::c_int,
        medianpos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of five joint arrays of Long/pointer/pointer/Bool/ints, sorted by first array in non-decreasing order around the \\p k-th element,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectLongPtrPtrBoolInt(
        longarray: *mut ::std::os::raw::c_longlong,
        ptrarray1: *mut *mut ::std::os::raw::c_void,
        ptrarray2: *mut *mut ::std::os::raw::c_void,
        boolarray: *mut ::std::os::raw::c_uint,
        intarray: *mut ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of five joint arrays of Long/pointer/pointer/Bool/ints, sorted by first array in non-decreasing order around the weighted median w.r.t. \\p weights and capacity,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectWeightedLongPtrPtrBoolInt(
        longarray: *mut ::std::os::raw::c_longlong,
        ptrarray1: *mut *mut ::std::os::raw::c_void,
        ptrarray2: *mut *mut ::std::os::raw::c_void,
        boolarray: *mut ::std::os::raw::c_uint,
        intarray: *mut ::std::os::raw::c_int,
        weights: *mut f64,
        capacity: f64,
        len: ::std::os::raw::c_int,
        medianpos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of five joint arrays of pointer/ints/ints/Bool/Bool, sorted by first array in non-decreasing order around the \\p k-th element,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectPtrIntIntBoolBool(
        ptrarray: *mut *mut ::std::os::raw::c_void,
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        boolarray1: *mut ::std::os::raw::c_uint,
        boolarray2: *mut ::std::os::raw::c_uint,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        k: ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of five joint arrays of pointer/ints/ints/Bool/Bool, sorted by first array in non-decreasing order around the weighted median w.r.t. \\p weights and capacity,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectWeightedPtrIntIntBoolBool(
        ptrarray: *mut *mut ::std::os::raw::c_void,
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        boolarray1: *mut ::std::os::raw::c_uint,
        boolarray2: *mut ::std::os::raw::c_uint,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        weights: *mut f64,
        capacity: f64,
        len: ::std::os::raw::c_int,
        medianpos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of six joint arrays of ints/pointer/ints/ints/Bool/Bool, sorted by first array in non-decreasing order around the \\p k-th element,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectIntPtrIntIntBoolBool(
        intarray1: *mut ::std::os::raw::c_int,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        intarray2: *mut ::std::os::raw::c_int,
        intarray3: *mut ::std::os::raw::c_int,
        boolarray1: *mut ::std::os::raw::c_uint,
        boolarray2: *mut ::std::os::raw::c_uint,
        k: ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of six joint arrays of ints/pointer/ints/ints/Bool/Bool, sorted by first array in non-decreasing order around the weighted median w.r.t. \\p weights and capacity,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectWeightedIntPtrIntIntBoolBool(
        intarray1: *mut ::std::os::raw::c_int,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        intarray2: *mut ::std::os::raw::c_int,
        intarray3: *mut ::std::os::raw::c_int,
        boolarray1: *mut ::std::os::raw::c_uint,
        boolarray2: *mut ::std::os::raw::c_uint,
        weights: *mut f64,
        capacity: f64,
        len: ::std::os::raw::c_int,
        medianpos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort an index array in non-increasing order around the \\p k-th element,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectDownInd(
        indarray: *mut ::std::os::raw::c_int,
        indcomp: ::std::option::Option<
            unsafe extern "C" fn(
                dataptr: *mut ::std::os::raw::c_void,
                ind1: ::std::os::raw::c_int,
                ind2: ::std::os::raw::c_int,
            ) -> ::std::os::raw::c_int,
        >,
        dataptr: *mut ::std::os::raw::c_void,
        k: ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort an index array in non-increasing order around the weighted median w.r.t. \\p weights and capacity,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectWeightedDownInd(
        indarray: *mut ::std::os::raw::c_int,
        indcomp: ::std::option::Option<
            unsafe extern "C" fn(
                dataptr: *mut ::std::os::raw::c_void,
                ind1: ::std::os::raw::c_int,
                ind2: ::std::os::raw::c_int,
            ) -> ::std::os::raw::c_int,
        >,
        dataptr: *mut ::std::os::raw::c_void,
        weights: *mut f64,
        capacity: f64,
        len: ::std::os::raw::c_int,
        medianpos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of an array of pointers in non-increasing order around the \\p k-th element,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectDownPtr(
        ptrarray: *mut *mut ::std::os::raw::c_void,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        k: ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of an array of pointers in non-increasing order around the weighted median w.r.t. \\p weights and capacity,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectWeightedDownPtr(
        ptrarray: *mut *mut ::std::os::raw::c_void,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        weights: *mut f64,
        capacity: f64,
        len: ::std::os::raw::c_int,
        medianpos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of two joint arrays of pointers/pointers, sorted by first array in non-increasing order around the \\p k-th element,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectDownPtrPtr(
        ptrarray1: *mut *mut ::std::os::raw::c_void,
        ptrarray2: *mut *mut ::std::os::raw::c_void,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        k: ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of two joint arrays of pointers/pointers, sorted by first array in non-increasing order around the weighted median w.r.t. \\p weights and capacity,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectWeightedDownPtrPtr(
        ptrarray1: *mut *mut ::std::os::raw::c_void,
        ptrarray2: *mut *mut ::std::os::raw::c_void,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        weights: *mut f64,
        capacity: f64,
        len: ::std::os::raw::c_int,
        medianpos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of two joint arrays of pointers/Reals, sorted by first array in non-increasing order around the \\p k-th element,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectDownPtrReal(
        ptrarray: *mut *mut ::std::os::raw::c_void,
        realarray: *mut f64,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        k: ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of two joint arrays of pointers/Reals, sorted by first array in non-increasing order around the weighted median w.r.t. \\p weights and capacity,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectWeightedDownPtrReal(
        ptrarray: *mut *mut ::std::os::raw::c_void,
        realarray: *mut f64,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        weights: *mut f64,
        capacity: f64,
        len: ::std::os::raw::c_int,
        medianpos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of two joint arrays of pointers/ints, sorted by first array in non-increasing order around the \\p k-th element,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectDownPtrInt(
        ptrarray: *mut *mut ::std::os::raw::c_void,
        intarray: *mut ::std::os::raw::c_int,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        k: ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of two joint arrays of pointers/ints, sorted by first array in non-increasing order around the weighted median w.r.t. \\p weights and capacity,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectWeightedDownPtrInt(
        ptrarray: *mut *mut ::std::os::raw::c_void,
        intarray: *mut ::std::os::raw::c_int,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        weights: *mut f64,
        capacity: f64,
        len: ::std::os::raw::c_int,
        medianpos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of two joint arrays of pointers/Bools, sorted by first array in non-increasing order around the \\p k-th element,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectDownPtrBool(
        ptrarray: *mut *mut ::std::os::raw::c_void,
        boolarray: *mut ::std::os::raw::c_uint,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        k: ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of two joint arrays of pointers/Bools, sorted by first array in non-increasing order around the weighted median w.r.t. \\p weights and capacity,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectWeightedDownPtrBool(
        ptrarray: *mut *mut ::std::os::raw::c_void,
        boolarray: *mut ::std::os::raw::c_uint,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        weights: *mut f64,
        capacity: f64,
        len: ::std::os::raw::c_int,
        medianpos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of three joint arrays of pointers/ints/ints, sorted by first array in non-increasing order around the \\p k-th element,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectDownPtrIntInt(
        ptrarray: *mut *mut ::std::os::raw::c_void,
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        k: ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of three joint arrays of pointers/ints/ints, sorted by first array in non-increasing order around the weighted median w.r.t. \\p weights and capacity,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectWeightedDownPtrIntInt(
        ptrarray: *mut *mut ::std::os::raw::c_void,
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        weights: *mut f64,
        capacity: f64,
        len: ::std::os::raw::c_int,
        medianpos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of three joint arrays of pointers/Reals/ints, sorted by first array in non-increasing order around the \\p k-th element,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectDownPtrRealInt(
        ptrarray: *mut *mut ::std::os::raw::c_void,
        realarray: *mut f64,
        intarray: *mut ::std::os::raw::c_int,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        k: ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of three joint arrays of pointers/Reals/ints, sorted by first array in non-increasing order around the weighted median w.r.t. \\p weights and capacity,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectWeightedDownPtrRealInt(
        ptrarray: *mut *mut ::std::os::raw::c_void,
        realarray: *mut f64,
        intarray: *mut ::std::os::raw::c_int,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        weights: *mut f64,
        capacity: f64,
        len: ::std::os::raw::c_int,
        medianpos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of three joint arrays of pointers/Reals/Bools, sorted by first array in non-increasing order around the \\p k-th element,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectDownPtrRealBool(
        ptrarray: *mut *mut ::std::os::raw::c_void,
        realarray: *mut f64,
        boolarray: *mut ::std::os::raw::c_uint,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        k: ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of three joint arrays of pointers/Reals/Bools, sorted by first array in non-increasing order around the weighted median w.r.t. \\p weights and capacity,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectWeightedDownPtrRealBool(
        ptrarray: *mut *mut ::std::os::raw::c_void,
        realarray: *mut f64,
        boolarray: *mut ::std::os::raw::c_uint,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        weights: *mut f64,
        capacity: f64,
        len: ::std::os::raw::c_int,
        medianpos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of three joint arrays of pointers/pointers/ints, sorted by first array in non-increasing order around the \\p k-th element,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectDownPtrPtrInt(
        ptrarray1: *mut *mut ::std::os::raw::c_void,
        ptrarray2: *mut *mut ::std::os::raw::c_void,
        intarray: *mut ::std::os::raw::c_int,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        k: ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of three joint arrays of pointers/pointers/ints, sorted by first array in non-increasing order around the weighted median w.r.t. \\p weights and capacity,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectWeightedDownPtrPtrInt(
        ptrarray1: *mut *mut ::std::os::raw::c_void,
        ptrarray2: *mut *mut ::std::os::raw::c_void,
        intarray: *mut ::std::os::raw::c_int,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        weights: *mut f64,
        capacity: f64,
        len: ::std::os::raw::c_int,
        medianpos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of three joint arrays of pointers/pointers/Reals, sorted by first array in non-increasing order around the \\p k-th element,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectDownPtrPtrReal(
        ptrarray1: *mut *mut ::std::os::raw::c_void,
        ptrarray2: *mut *mut ::std::os::raw::c_void,
        realarray: *mut f64,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        k: ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of three joint arrays of pointers/pointers/Reals, sorted by first array in non-increasing order around the weighted median w.r.t. \\p weights and capacity,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectWeightedDownPtrPtrReal(
        ptrarray1: *mut *mut ::std::os::raw::c_void,
        ptrarray2: *mut *mut ::std::os::raw::c_void,
        realarray: *mut f64,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        weights: *mut f64,
        capacity: f64,
        len: ::std::os::raw::c_int,
        medianpos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of four joint arrays of pointers/pointers/ints/ints, sorted by first array in non-increasing order around the \\p k-th element,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectDownPtrPtrIntInt(
        ptrarray1: *mut *mut ::std::os::raw::c_void,
        ptrarray2: *mut *mut ::std::os::raw::c_void,
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        k: ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of four joint arrays of pointers/pointers/ints/ints, sorted by first array in non-increasing order around the weighted median w.r.t. \\p weights and capacity,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectWeightedDownPtrPtrIntInt(
        ptrarray1: *mut *mut ::std::os::raw::c_void,
        ptrarray2: *mut *mut ::std::os::raw::c_void,
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        weights: *mut f64,
        capacity: f64,
        len: ::std::os::raw::c_int,
        medianpos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of four joint arrays of pointers/Reals/ints/ints, sorted by first array in non-increasing order around the \\p k-th element,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectDownPtrRealIntInt(
        ptrarray: *mut *mut ::std::os::raw::c_void,
        realarray: *mut f64,
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        k: ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of four joint arrays of pointers/Reals/ints/ints, sorted by first array in non-increasing order around the weighted median w.r.t. \\p weights and capacity,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectWeightedDownPtrRealIntInt(
        ptrarray: *mut *mut ::std::os::raw::c_void,
        realarray: *mut f64,
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        weights: *mut f64,
        capacity: f64,
        len: ::std::os::raw::c_int,
        medianpos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of four joint arrays of pointer/pointer/Reals/ints, sorted by first array in non-increasing order around the \\p k-th element,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectDownPtrPtrRealInt(
        ptrarray1: *mut *mut ::std::os::raw::c_void,
        ptrarray2: *mut *mut ::std::os::raw::c_void,
        realarray: *mut f64,
        intarray: *mut ::std::os::raw::c_int,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        k: ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of four joint arrays of pointer/pointer/Reals/ints, sorted by first array in non-increasing order around the weighted median w.r.t. \\p weights and capacity,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectWeightedDownPtrPtrRealInt(
        ptrarray1: *mut *mut ::std::os::raw::c_void,
        ptrarray2: *mut *mut ::std::os::raw::c_void,
        realarray: *mut f64,
        intarray: *mut ::std::os::raw::c_int,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        weights: *mut f64,
        capacity: f64,
        len: ::std::os::raw::c_int,
        medianpos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of four joint arrays of pointer/pointer/Reals/bools, sorted by first array in non-increasing order around the \\p k-th element,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectDownPtrPtrRealBool(
        ptrarray1: *mut *mut ::std::os::raw::c_void,
        ptrarray2: *mut *mut ::std::os::raw::c_void,
        realarray: *mut f64,
        boolarray: *mut ::std::os::raw::c_uint,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        k: ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of four joint arrays of pointer/pointer/Reals/bools, sorted by first array in non-increasing order around the weighted median w.r.t. \\p weights and capacity,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectWeightedDownPtrPtrRealBool(
        ptrarray1: *mut *mut ::std::os::raw::c_void,
        ptrarray2: *mut *mut ::std::os::raw::c_void,
        realarray: *mut f64,
        boolarray: *mut ::std::os::raw::c_uint,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        weights: *mut f64,
        capacity: f64,
        len: ::std::os::raw::c_int,
        medianpos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of four joint arrays of pointer/pointer/Longs/ints, sorted by first array in non-increasing order around the \\p k-th element,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectDownPtrPtrLongInt(
        ptrarray1: *mut *mut ::std::os::raw::c_void,
        ptrarray2: *mut *mut ::std::os::raw::c_void,
        longarray: *mut ::std::os::raw::c_longlong,
        intarray: *mut ::std::os::raw::c_int,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        k: ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of four joint arrays of pointer/pointer/Longs/ints, sorted by first array in non-increasing order around the weighted median w.r.t. \\p weights and capacity,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectWeightedDownPtrPtrLongInt(
        ptrarray1: *mut *mut ::std::os::raw::c_void,
        ptrarray2: *mut *mut ::std::os::raw::c_void,
        longarray: *mut ::std::os::raw::c_longlong,
        intarray: *mut ::std::os::raw::c_int,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        weights: *mut f64,
        capacity: f64,
        len: ::std::os::raw::c_int,
        medianpos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of five joint arrays of pointer/pointer/Longs/ints/ints, sorted by first array in non-increasing order around the \\p k-th element,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectDownPtrPtrLongIntInt(
        ptrarray1: *mut *mut ::std::os::raw::c_void,
        ptrarray2: *mut *mut ::std::os::raw::c_void,
        longarray: *mut ::std::os::raw::c_longlong,
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        k: ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of five joint arrays of pointer/pointer/Longs/ints/ints, sorted by first array in non-increasing order around the weighted median w.r.t. \\p weights and capacity,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectWeightedDownPtrPtrLongIntInt(
        ptrarray1: *mut *mut ::std::os::raw::c_void,
        ptrarray2: *mut *mut ::std::os::raw::c_void,
        longarray: *mut ::std::os::raw::c_longlong,
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        weights: *mut f64,
        capacity: f64,
        len: ::std::os::raw::c_int,
        medianpos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort an array of Reals in non-increasing order around the \\p k-th element,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectDownReal(
        realarray: *mut f64,
        k: ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort an array of Reals in non-increasing order around the weighted median w.r.t. \\p weights and capacity,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectWeightedDownReal(
        realarray: *mut f64,
        weights: *mut f64,
        capacity: f64,
        len: ::std::os::raw::c_int,
        medianpos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of two joint arrays of Reals/pointers, sorted by first array in non-increasing order around the \\p k-th element,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectDownRealPtr(
        realarray: *mut f64,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        k: ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of two joint arrays of Reals/pointers, sorted by first array in non-increasing order around the weighted median w.r.t. \\p weights and capacity,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectWeightedDownRealPtr(
        realarray: *mut f64,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        weights: *mut f64,
        capacity: f64,
        len: ::std::os::raw::c_int,
        medianpos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of two joint arrays of Reals/ints, sorted by first array in non-increasing order around the \\p k-th element,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectDownRealInt(
        realarray: *mut f64,
        intarray: *mut ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of three joint arrays of Reals/ints/ints, sorted by first array in non-increasing order around the \\p k-th element,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectDownRealIntInt(
        realarray: *mut f64,
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of two joint arrays of Reals/ints, sorted by first array in non-increasing order around the weighted median w.r.t. \\p weights and capacity,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectWeightedDownRealInt(
        realarray: *mut f64,
        intarray: *mut ::std::os::raw::c_int,
        weights: *mut f64,
        capacity: f64,
        len: ::std::os::raw::c_int,
        medianpos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of three joint arrays of Reals/ints/ints, sorted by first array in non-increasing order around the weighted median w.r.t. \\p weights and capacity,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectWeightedDownRealIntInt(
        realarray: *mut f64,
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        weights: *mut f64,
        capacity: f64,
        len: ::std::os::raw::c_int,
        medianpos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of three joint arrays of Reals/Bools/Pointer, sorted by first array in non-increasing order around the \\p k-th element,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectDownRealBoolPtr(
        realarray: *mut f64,
        boolarray: *mut ::std::os::raw::c_uint,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        k: ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of three joint arrays of Reals/Bools/Pointer, sorted by first array in non-increasing order around the weighted median w.r.t. \\p weights and capacity,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectWeightedDownRealBoolPtr(
        realarray: *mut f64,
        boolarray: *mut ::std::os::raw::c_uint,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        weights: *mut f64,
        capacity: f64,
        len: ::std::os::raw::c_int,
        medianpos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of three joint arrays of Reals/ints/Longs, sorted by first array in non-increasing order around the \\p k-th element,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectDownRealIntLong(
        realarray: *mut f64,
        intarray: *mut ::std::os::raw::c_int,
        longarray: *mut ::std::os::raw::c_longlong,
        k: ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of three joint arrays of Reals/ints/Longs, sorted by first array in non-increasing order around the weighted median w.r.t. \\p weights and capacity,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectWeightedDownRealIntLong(
        realarray: *mut f64,
        intarray: *mut ::std::os::raw::c_int,
        longarray: *mut ::std::os::raw::c_longlong,
        weights: *mut f64,
        capacity: f64,
        len: ::std::os::raw::c_int,
        medianpos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of three joint arrays of Reals/ints/Pointer, sorted by first array in non-increasing order around the \\p k-th element,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectDownRealIntPtr(
        realarray: *mut f64,
        intarray: *mut ::std::os::raw::c_int,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        k: ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of three joint arrays of Reals/ints/Pointer, sorted by first array in non-increasing order around the weighted median w.r.t. \\p weights and capacity,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectWeightedDownRealIntPtr(
        realarray: *mut f64,
        intarray: *mut ::std::os::raw::c_int,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        weights: *mut f64,
        capacity: f64,
        len: ::std::os::raw::c_int,
        medianpos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of three joint arrays of Reals/Reals/ints, sorted by first array in non-increasing order around the \\p k-th element,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectDownRealRealInt(
        realarray1: *mut f64,
        realarray2: *mut f64,
        intarray: *mut ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of three joint arrays of Reals/Reals/ints, sorted by first array in non-increasing order around the weighted median w.r.t. \\p weights and capacity,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectWeightedDownRealRealInt(
        realarray1: *mut f64,
        realarray2: *mut f64,
        intarray: *mut ::std::os::raw::c_int,
        weights: *mut f64,
        capacity: f64,
        len: ::std::os::raw::c_int,
        medianpos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of three joint arrays of Reals/Reals/Pointer, sorted by first array in non-increasing order around the \\p k-th element,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectDownRealRealPtr(
        realarray1: *mut f64,
        realarray2: *mut f64,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        k: ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of three joint arrays of Reals/Reals/Pointer, sorted by first array in non-increasing order around the weighted median w.r.t. \\p weights and capacity,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectWeightedDownRealRealPtr(
        realarray1: *mut f64,
        realarray2: *mut f64,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        weights: *mut f64,
        capacity: f64,
        len: ::std::os::raw::c_int,
        medianpos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of three joint arrays of Reals/Reals/Pointer/Pointer, sorted by first array in non-increasing order around the \\p k-th element"]
    pub fn SCIPselectDownRealRealPtrPtr(
        realarray1: *mut f64,
        realarray2: *mut f64,
        ptrarray1: *mut *mut ::std::os::raw::c_void,
        ptrarray2: *mut *mut ::std::os::raw::c_void,
        k: ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of three joint arrays of Reals/Reals/Pointer/Pointer, sorted by first array in non-increasing order around the weighted median w.r.t. \\p weights and capacity"]
    pub fn SCIPselectWeightedDownRealRealPtrPtr(
        realarray1: *mut f64,
        realarray2: *mut f64,
        ptrarray1: *mut *mut ::std::os::raw::c_void,
        ptrarray2: *mut *mut ::std::os::raw::c_void,
        weights: *mut f64,
        capacity: f64,
        len: ::std::os::raw::c_int,
        medianpos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of four joint arrays of Reals/pointers/pointers/ints, sorted by first array in non-increasing order around the \\p k-th element,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectDownRealPtrPtrInt(
        realarray: *mut f64,
        ptrarray1: *mut *mut ::std::os::raw::c_void,
        ptrarray2: *mut *mut ::std::os::raw::c_void,
        intarray: *mut ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of four joint arrays of Reals/pointers/pointers/ints, sorted by first array in non-increasing order around the weighted median w.r.t. \\p weights and capacity,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectWeightedDownRealPtrPtrInt(
        realarray: *mut f64,
        ptrarray1: *mut *mut ::std::os::raw::c_void,
        ptrarray2: *mut *mut ::std::os::raw::c_void,
        intarray: *mut ::std::os::raw::c_int,
        weights: *mut f64,
        capacity: f64,
        len: ::std::os::raw::c_int,
        medianpos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of five joint arrays of Reals/pointers/pointers/ints/ints, sorted by first array in non-increasing order around the \\p k-th element,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectDownRealPtrPtrIntInt(
        realarray: *mut f64,
        ptrarray1: *mut *mut ::std::os::raw::c_void,
        ptrarray2: *mut *mut ::std::os::raw::c_void,
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of five joint arrays of Reals/pointers/pointers/ints/ints, sorted by first array in non-increasing order around the weighted median w.r.t. \\p weights and capacity,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectWeightedDownRealPtrPtrIntInt(
        realarray: *mut f64,
        ptrarray1: *mut *mut ::std::os::raw::c_void,
        ptrarray2: *mut *mut ::std::os::raw::c_void,
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        weights: *mut f64,
        capacity: f64,
        len: ::std::os::raw::c_int,
        medianpos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of four joint arrays of Reals/Longs/Reals/ints, sorted by first array in non-increasing order around the \\p k-th element,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectDownRealLongRealInt(
        realarray1: *mut f64,
        longarray: *mut ::std::os::raw::c_longlong,
        realarray3: *mut f64,
        intarray: *mut ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of four joint arrays of Reals/Longs/Reals/ints, sorted by first array in non-increasing order around the weighted median w.r.t. \\p weights and capacity,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectWeightedDownRealLongRealInt(
        realarray1: *mut f64,
        longarray: *mut ::std::os::raw::c_longlong,
        realarray3: *mut f64,
        intarray: *mut ::std::os::raw::c_int,
        weights: *mut f64,
        capacity: f64,
        len: ::std::os::raw::c_int,
        medianpos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of four joint arrays of Reals/Reals/ints/ints, sorted by first array in non-increasing order around the \\p k-th element,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectDownRealRealIntInt(
        realarray1: *mut f64,
        realarray2: *mut f64,
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of four joint arrays of Reals/Reals/ints/ints, sorted by first array in non-increasing order around the weighted median w.r.t. \\p weights and capacity,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectWeightedDownRealRealIntInt(
        realarray1: *mut f64,
        realarray2: *mut f64,
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        weights: *mut f64,
        capacity: f64,
        len: ::std::os::raw::c_int,
        medianpos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of four joint arrays of Reals/Reals/Reals/ints, sorted by first array in non-increasing order around the \\p k-th element,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectDownRealRealRealInt(
        realarray1: *mut f64,
        realarray2: *mut f64,
        realarray3: *mut f64,
        intarray: *mut ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of four joint arrays of Reals/Reals/Reals/ints, sorted by first array in non-increasing order around the weighted median w.r.t. \\p weights and capacity,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectWeightedDownRealRealRealInt(
        realarray1: *mut f64,
        realarray2: *mut f64,
        realarray3: *mut f64,
        intarray: *mut ::std::os::raw::c_int,
        weights: *mut f64,
        capacity: f64,
        len: ::std::os::raw::c_int,
        medianpos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of four joint arrays of Reals/Reals/Reals/pointers, sorted by first array in non-increasing order around the \\p k-th element,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectDownRealRealRealPtr(
        realarray1: *mut f64,
        realarray2: *mut f64,
        realarray3: *mut f64,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        k: ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of four joint arrays of Reals/Reals/Reals/pointers, sorted by first array in non-increasing order around the weighted median w.r.t. \\p weights and capacity,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectWeightedDownRealRealRealPtr(
        realarray1: *mut f64,
        realarray2: *mut f64,
        realarray3: *mut f64,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        weights: *mut f64,
        capacity: f64,
        len: ::std::os::raw::c_int,
        medianpos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of three joint arrays of Reals/pointers, sorted by first array in non-decreasing order around the \\p k-th element,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectDownRealPtrPtr(
        realarray: *mut f64,
        ptrarray1: *mut *mut ::std::os::raw::c_void,
        ptrarray2: *mut *mut ::std::os::raw::c_void,
        k: ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of three joint arrays of Reals/pointers, sorted by first array in non-decreasing order around the weighted median w.r.t. \\p weights and capacity,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectWeightedDownRealPtrPtr(
        realarray: *mut f64,
        ptrarray1: *mut *mut ::std::os::raw::c_void,
        ptrarray2: *mut *mut ::std::os::raw::c_void,
        weights: *mut f64,
        capacity: f64,
        len: ::std::os::raw::c_int,
        medianpos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of five joint arrays of Reals/Reals/Reals/Bools/pointers, sorted by first array in non-increasing order around the \\p k-th element,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectDownRealRealRealBoolPtr(
        realarray1: *mut f64,
        realarray2: *mut f64,
        realarray3: *mut f64,
        boolarray: *mut ::std::os::raw::c_uint,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        k: ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of five joint arrays of Reals/Reals/Reals/Bools/pointers, sorted by first array in non-increasing order around the weighted median w.r.t. \\p weights and capacity,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectWeightedDownRealRealRealBoolPtr(
        realarray1: *mut f64,
        realarray2: *mut f64,
        realarray3: *mut f64,
        boolarray: *mut ::std::os::raw::c_uint,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        weights: *mut f64,
        capacity: f64,
        len: ::std::os::raw::c_int,
        medianpos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of six joint arrays of Reals/Reals/Reals/Bools/Bools/pointers, sorted by first array in non-increasing order around the \\p k-th element,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectDownRealRealRealBoolBoolPtr(
        realarray1: *mut f64,
        realarray2: *mut f64,
        realarray3: *mut f64,
        boolarray1: *mut ::std::os::raw::c_uint,
        boolarray2: *mut ::std::os::raw::c_uint,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        k: ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of six joint arrays of Reals/Reals/Reals/Bools/Bools/pointers, sorted by first array in non-increasing order around the weighted median w.r.t. \\p weights and capacity,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectWeightedDownRealRealRealBoolBoolPtr(
        realarray1: *mut f64,
        realarray2: *mut f64,
        realarray3: *mut f64,
        boolarray1: *mut ::std::os::raw::c_uint,
        boolarray2: *mut ::std::os::raw::c_uint,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        weights: *mut f64,
        capacity: f64,
        len: ::std::os::raw::c_int,
        medianpos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort array of ints in non-increasing order around the \\p k-th element,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectDownInt(
        intarray: *mut ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort array of ints in non-increasing order around the weighted median w.r.t. \\p weights and capacity,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectWeightedDownInt(
        intarray: *mut ::std::os::raw::c_int,
        weights: *mut f64,
        capacity: f64,
        len: ::std::os::raw::c_int,
        medianpos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of two joint arrays of ints/ints, sorted by first array in non-increasing order around the \\p k-th element,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectDownIntInt(
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of two joint arrays of ints/ints, sorted by first array in non-increasing order around the weighted median w.r.t. \\p weights and capacity,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectWeightedDownIntInt(
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        weights: *mut f64,
        capacity: f64,
        len: ::std::os::raw::c_int,
        medianpos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of two joint arrays of ints/pointers, sorted by first array in non-increasing order around the \\p k-th element,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectDownIntPtr(
        intarray: *mut ::std::os::raw::c_int,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        k: ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of two joint arrays of ints/pointers, sorted by first array in non-increasing order around the weighted median w.r.t. \\p weights and capacity,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectWeightedDownIntPtr(
        intarray: *mut ::std::os::raw::c_int,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        weights: *mut f64,
        capacity: f64,
        len: ::std::os::raw::c_int,
        medianpos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of two joint arrays of ints/reals, sorted by first array in non-increasing order around the \\p k-th element,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectDownIntReal(
        intarray: *mut ::std::os::raw::c_int,
        realarray: *mut f64,
        k: ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of two joint arrays of ints/reals, sorted by first array in non-increasing order around the weighted median w.r.t. \\p weights and capacity,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectWeightedDownIntReal(
        intarray: *mut ::std::os::raw::c_int,
        realarray: *mut f64,
        weights: *mut f64,
        capacity: f64,
        len: ::std::os::raw::c_int,
        medianpos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of three joint arrays of ints/ints/ints, sorted by first array in non-increasing order around the \\p k-th element,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectDownIntIntInt(
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        intarray3: *mut ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of three joint arrays of ints/ints/ints, sorted by first array in non-increasing order around the weighted median w.r.t. \\p weights and capacity,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectWeightedDownIntIntInt(
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        intarray3: *mut ::std::os::raw::c_int,
        weights: *mut f64,
        capacity: f64,
        len: ::std::os::raw::c_int,
        medianpos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of three joint arrays of ints/ints/SCIP_Longint, sorted by first array in non-increasing order around the \\p k-th element,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectDownIntIntLong(
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        longarray: *mut ::std::os::raw::c_longlong,
        k: ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of three joint arrays of ints/ints/SCIP_Longint, sorted by first array in non-increasing order around the weighted median w.r.t. \\p weights and capacity,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectWeightedDownIntIntLong(
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        longarray: *mut ::std::os::raw::c_longlong,
        weights: *mut f64,
        capacity: f64,
        len: ::std::os::raw::c_int,
        medianpos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of three joint arrays of ints/ints/pointers, sorted by first array in non-increasing order around the \\p k-th element,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectDownIntIntPtr(
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        k: ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of three joint arrays of ints/ints/pointers, sorted by first array in non-increasing order around the weighted median w.r.t. \\p weights and capacity,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectWeightedDownIntIntPtr(
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        weights: *mut f64,
        capacity: f64,
        len: ::std::os::raw::c_int,
        medianpos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of three joint arrays of ints/ints/Reals, sorted by first array in non-increasing order around the \\p k-th element,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectDownIntIntReal(
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        realarray: *mut f64,
        k: ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of three joint arrays of ints/ints/Reals, sorted by first array in non-increasing order around the weighted median w.r.t. \\p weights and capacity,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectWeightedDownIntIntReal(
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        realarray: *mut f64,
        weights: *mut f64,
        capacity: f64,
        len: ::std::os::raw::c_int,
        medianpos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of four joint arrays of ints/ints/ints/pointers, sorted by first array in non-increasing order around the \\p k-th element,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectDownIntIntIntPtr(
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        intarray3: *mut ::std::os::raw::c_int,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        k: ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of four joint arrays of ints/ints/ints/pointers, sorted by first array in non-increasing order around the weighted median w.r.t. \\p weights and capacity,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectWeightedDownIntIntIntPtr(
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        intarray3: *mut ::std::os::raw::c_int,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        weights: *mut f64,
        capacity: f64,
        len: ::std::os::raw::c_int,
        medianpos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of four joint arrays of ints/ints/ints/reals, sorted by first array in non-increasing order around the \\p k-th element,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectDownIntIntIntReal(
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        intarray3: *mut ::std::os::raw::c_int,
        realarray: *mut f64,
        k: ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of four joint arrays of ints/ints/ints/reals, sorted by first array in non-increasing order around the weighted median w.r.t. \\p weights and capacity,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectWeightedDownIntIntIntReal(
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        intarray3: *mut ::std::os::raw::c_int,
        realarray: *mut f64,
        weights: *mut f64,
        capacity: f64,
        len: ::std::os::raw::c_int,
        medianpos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of four joint arrays of ints/pointers/ints/Reals, sorted by first array in non-increasing order around the \\p k-th element,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectDownIntPtrIntReal(
        intarray1: *mut ::std::os::raw::c_int,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        intarray2: *mut ::std::os::raw::c_int,
        realarray: *mut f64,
        k: ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of four joint arrays of ints/pointers/ints/Reals, sorted by first array in non-increasing order around the weighted median w.r.t. \\p weights and capacity,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectWeightedDownIntPtrIntReal(
        intarray1: *mut ::std::os::raw::c_int,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        intarray2: *mut ::std::os::raw::c_int,
        realarray: *mut f64,
        weights: *mut f64,
        capacity: f64,
        len: ::std::os::raw::c_int,
        medianpos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort an array of Longints in non-increasing order around the \\p k-th element,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectDownLong(
        longarray: *mut ::std::os::raw::c_longlong,
        k: ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort an array of Longints in non-increasing order around the weighted median w.r.t. \\p weights and capacity,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectWeightedDownLong(
        longarray: *mut ::std::os::raw::c_longlong,
        weights: *mut f64,
        capacity: f64,
        len: ::std::os::raw::c_int,
        medianpos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of two joint arrays of Long/pointer, sorted by the first array in non-increasing order around the \\p k-th element,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectDownLongPtr(
        longarray: *mut ::std::os::raw::c_longlong,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        k: ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of two joint arrays of Long/pointer, sorted by the first array in non-increasing order around the weighted median w.r.t. \\p weights and capacity,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectWeightedDownLongPtr(
        longarray: *mut ::std::os::raw::c_longlong,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        weights: *mut f64,
        capacity: f64,
        len: ::std::os::raw::c_int,
        medianpos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of three arrays of Long/pointer/ints, sorted by the first array in non-increasing order around the \\p k-th element,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectDownLongPtrInt(
        longarray: *mut ::std::os::raw::c_longlong,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        intarray: *mut ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of three arrays of Long/pointer/ints, sorted by the first array in non-increasing order around the weighted median w.r.t. \\p weights and capacity,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectWeightedDownLongPtrInt(
        longarray: *mut ::std::os::raw::c_longlong,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        intarray: *mut ::std::os::raw::c_int,
        weights: *mut f64,
        capacity: f64,
        len: ::std::os::raw::c_int,
        medianpos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of four arrays of Long/pointer/Real/Bool, sorted by the first array in non-increasing order around the \\p k-th element,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectDownLongPtrRealBool(
        longarray: *mut ::std::os::raw::c_longlong,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        realarray: *mut f64,
        boolarray: *mut ::std::os::raw::c_uint,
        k: ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of four arrays of Long/pointer/Real/Bool, sorted by the first array in non-increasing order around the weighted median w.r.t. \\p weights and capacity,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectWeightedDownLongPtrRealBool(
        longarray: *mut ::std::os::raw::c_longlong,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        realarray: *mut f64,
        boolarray: *mut ::std::os::raw::c_uint,
        weights: *mut f64,
        capacity: f64,
        len: ::std::os::raw::c_int,
        medianpos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of five arrays of Long/pointer/Real/Real/Bool, sorted by the first array in non-increasing order around the \\p k-th element,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectDownLongPtrRealRealBool(
        longarray: *mut ::std::os::raw::c_longlong,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        realarray: *mut f64,
        realarray2: *mut f64,
        boolarray: *mut ::std::os::raw::c_uint,
        k: ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of five arrays of Long/pointer/Real/Real/Bool, sorted by the first array in non-increasing order around the weighted median w.r.t. \\p weights and capacity,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectWeightedDownLongPtrRealRealBool(
        longarray: *mut ::std::os::raw::c_longlong,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        realarray: *mut f64,
        realarray2: *mut f64,
        boolarray: *mut ::std::os::raw::c_uint,
        weights: *mut f64,
        capacity: f64,
        len: ::std::os::raw::c_int,
        medianpos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of six arrays of Long/pointer/Real/Real/int/Bool, sorted by the first array in non-increasing order around the \\p k-th element,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectDownLongPtrRealRealIntBool(
        longarray: *mut ::std::os::raw::c_longlong,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        realarray: *mut f64,
        realarray2: *mut f64,
        intarray: *mut ::std::os::raw::c_int,
        boolarray: *mut ::std::os::raw::c_uint,
        k: ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of six arrays of Long/pointer/Real/Real/int/Bool, sorted by the first array in non-increasing order around the weighted median w.r.t. \\p weights and capacity,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectWeightedDownLongPtrRealRealIntBool(
        longarray: *mut ::std::os::raw::c_longlong,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        realarray: *mut f64,
        realarray2: *mut f64,
        intarray: *mut ::std::os::raw::c_int,
        boolarray: *mut ::std::os::raw::c_uint,
        weights: *mut f64,
        capacity: f64,
        len: ::std::os::raw::c_int,
        medianpos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of four joint arrays of Long/pointer/pointer/ints, sorted by first array in non-increasing order around the \\p k-th element,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectDownLongPtrPtrInt(
        longarray: *mut ::std::os::raw::c_longlong,
        ptrarray1: *mut *mut ::std::os::raw::c_void,
        ptrarray2: *mut *mut ::std::os::raw::c_void,
        intarray: *mut ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of four joint arrays of Long/pointer/pointer/ints, sorted by first array in non-increasing order around the weighted median w.r.t. \\p weights and capacity,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectWeightedDownLongPtrPtrInt(
        longarray: *mut ::std::os::raw::c_longlong,
        ptrarray1: *mut *mut ::std::os::raw::c_void,
        ptrarray2: *mut *mut ::std::os::raw::c_void,
        intarray: *mut ::std::os::raw::c_int,
        weights: *mut f64,
        capacity: f64,
        len: ::std::os::raw::c_int,
        medianpos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of five joint arrays of Long/pointer/pointer/ints/ints, sorted by first array in non-increasing order around the \\p k-th element,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectDownLongPtrPtrIntInt(
        longarray: *mut ::std::os::raw::c_longlong,
        ptrarray1: *mut *mut ::std::os::raw::c_void,
        ptrarray2: *mut *mut ::std::os::raw::c_void,
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of five joint arrays of Long/pointer/pointer/ints/ints, sorted by first array in non-increasing order around the weighted median w.r.t. \\p weights and capacity,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectWeightedDownLongPtrPtrIntInt(
        longarray: *mut ::std::os::raw::c_longlong,
        ptrarray1: *mut *mut ::std::os::raw::c_void,
        ptrarray2: *mut *mut ::std::os::raw::c_void,
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        weights: *mut f64,
        capacity: f64,
        len: ::std::os::raw::c_int,
        medianpos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of five joint arrays of Long/pointer/pointer/Bool/ints, sorted by first array in non-increasing order around the \\p k-th element,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectDownLongPtrPtrBoolInt(
        longarray: *mut ::std::os::raw::c_longlong,
        ptrarray1: *mut *mut ::std::os::raw::c_void,
        ptrarray2: *mut *mut ::std::os::raw::c_void,
        boolarray: *mut ::std::os::raw::c_uint,
        intarray: *mut ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of five joint arrays of Long/pointer/pointer/Bool/ints, sorted by first array in non-increasing order around the weighted median w.r.t. \\p weights and capacity,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectWeightedDownLongPtrPtrBoolInt(
        longarray: *mut ::std::os::raw::c_longlong,
        ptrarray1: *mut *mut ::std::os::raw::c_void,
        ptrarray2: *mut *mut ::std::os::raw::c_void,
        boolarray: *mut ::std::os::raw::c_uint,
        intarray: *mut ::std::os::raw::c_int,
        weights: *mut f64,
        capacity: f64,
        len: ::std::os::raw::c_int,
        medianpos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of five joint arrays of pointer/ints/ints/Bool/Bool, sorted by first array in non-increasing order around the \\p k-th element,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectDownPtrIntIntBoolBool(
        ptrarray: *mut *mut ::std::os::raw::c_void,
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        boolarray1: *mut ::std::os::raw::c_uint,
        boolarray2: *mut ::std::os::raw::c_uint,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        k: ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of five joint arrays of pointer/ints/ints/Bool/Bool, sorted by first array in non-increasing order around the weighted median w.r.t. \\p weights and capacity,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectWeightedDownPtrIntIntBoolBool(
        ptrarray: *mut *mut ::std::os::raw::c_void,
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        boolarray1: *mut ::std::os::raw::c_uint,
        boolarray2: *mut ::std::os::raw::c_uint,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        weights: *mut f64,
        capacity: f64,
        len: ::std::os::raw::c_int,
        medianpos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of six joint arrays of ints/pointer/ints/ints/Bool/Bool, sorted by first array in non-increasing order around the \\p k-th element,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectDownIntPtrIntIntBoolBool(
        intarray1: *mut ::std::os::raw::c_int,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        intarray2: *mut ::std::os::raw::c_int,
        intarray3: *mut ::std::os::raw::c_int,
        boolarray1: *mut ::std::os::raw::c_uint,
        boolarray2: *mut ::std::os::raw::c_uint,
        k: ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of six joint arrays of ints/pointer/ints/ints/Bool/Bool, sorted by first array in non-increasing order around the weighted median w.r.t. \\p weights and capacity,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectWeightedDownIntPtrIntIntBoolBool(
        intarray1: *mut ::std::os::raw::c_int,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        intarray2: *mut ::std::os::raw::c_int,
        intarray3: *mut ::std::os::raw::c_int,
        boolarray1: *mut ::std::os::raw::c_uint,
        boolarray2: *mut ::std::os::raw::c_uint,
        weights: *mut f64,
        capacity: f64,
        len: ::std::os::raw::c_int,
        medianpos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn SCIPsortCompInt(
        elem1: *mut ::std::os::raw::c_void,
        elem2: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SCIPsortArgsortInt(
        dataptr: *mut ::std::os::raw::c_void,
        ind1: ::std::os::raw::c_int,
        ind2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SCIPsortArgsortPtr(
        dataptr: *mut ::std::os::raw::c_void,
        ind1: ::std::os::raw::c_int,
        ind2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " sort an indexed element set in non-decreasing order, resulting in a permutation index array"]
    pub fn SCIPsort(
        perm: *mut ::std::os::raw::c_int,
        indcomp: ::std::option::Option<
            unsafe extern "C" fn(
                dataptr: *mut ::std::os::raw::c_void,
                ind1: ::std::os::raw::c_int,
                ind2: ::std::os::raw::c_int,
            ) -> ::std::os::raw::c_int,
        >,
        dataptr: *mut ::std::os::raw::c_void,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " sort an index array in non-decreasing order"]
    pub fn SCIPsortInd(
        indarray: *mut ::std::os::raw::c_int,
        indcomp: ::std::option::Option<
            unsafe extern "C" fn(
                dataptr: *mut ::std::os::raw::c_void,
                ind1: ::std::os::raw::c_int,
                ind2: ::std::os::raw::c_int,
            ) -> ::std::os::raw::c_int,
        >,
        dataptr: *mut ::std::os::raw::c_void,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " sort of an array of pointers in non-decreasing order"]
    pub fn SCIPsortPtr(
        ptrarray: *mut *mut ::std::os::raw::c_void,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " sort of two joint arrays of pointers/pointers, sorted by first array in non-decreasing order"]
    pub fn SCIPsortPtrPtr(
        ptrarray1: *mut *mut ::std::os::raw::c_void,
        ptrarray2: *mut *mut ::std::os::raw::c_void,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " sort of two joint arrays of pointers/Reals, sorted by first array in non-decreasing order"]
    pub fn SCIPsortPtrReal(
        ptrarray: *mut *mut ::std::os::raw::c_void,
        realarray: *mut f64,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " sort of two joint arrays of pointers/ints, sorted by first array in non-decreasing order"]
    pub fn SCIPsortPtrInt(
        ptrarray: *mut *mut ::std::os::raw::c_void,
        intarray: *mut ::std::os::raw::c_int,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " sort of two joint arrays of pointers/Bools, sorted by first array in non-decreasing order"]
    pub fn SCIPsortPtrBool(
        ptrarray: *mut *mut ::std::os::raw::c_void,
        boolarray: *mut ::std::os::raw::c_uint,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " sort of three joint arrays of pointers/ints/ints, sorted by first array in non-decreasing order"]
    pub fn SCIPsortPtrIntInt(
        ptrarray: *mut *mut ::std::os::raw::c_void,
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " sort of three joint arrays of pointers/Reals/ints, sorted by first array in non-decreasing order"]
    pub fn SCIPsortPtrRealInt(
        ptrarray: *mut *mut ::std::os::raw::c_void,
        realarray: *mut f64,
        intarray: *mut ::std::os::raw::c_int,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " sort of four joint arrays of pointers/Reals/Reals/ints, sorted by first array in non-decreasing order"]
    pub fn SCIPsortPtrRealRealInt(
        ptrarray: *mut *mut ::std::os::raw::c_void,
        realarray1: *mut f64,
        realarray2: *mut f64,
        intarray: *mut ::std::os::raw::c_int,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " sort of four joint arrays of pointers/Reals/Reals/SCIP_Bools/SCIP_Bools, sorted by first array in non-decreasing order"]
    pub fn SCIPsortPtrRealRealBoolBool(
        ptrarray: *mut *mut ::std::os::raw::c_void,
        realarray1: *mut f64,
        realarray2: *mut f64,
        boolarray1: *mut ::std::os::raw::c_uint,
        boolarray2: *mut ::std::os::raw::c_uint,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " sort of four joint arrays of pointers/Reals/Reals/ints/SCIP_Bools, sorted by first array in non-decreasing order"]
    pub fn SCIPsortPtrRealRealIntBool(
        ptrarray: *mut *mut ::std::os::raw::c_void,
        realarray1: *mut f64,
        realarray2: *mut f64,
        intarray: *mut ::std::os::raw::c_int,
        boolarray: *mut ::std::os::raw::c_uint,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " sort of three joint arrays of pointers/Reals/Bools, sorted by first array in non-decreasing order"]
    pub fn SCIPsortPtrRealBool(
        ptrarray: *mut *mut ::std::os::raw::c_void,
        realarray: *mut f64,
        boolarray: *mut ::std::os::raw::c_uint,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " sort of three joint arrays of pointers/Reals/Reals, sorted by first array in non-decreasing order"]
    pub fn SCIPsortPtrRealReal(
        ptrarray: *mut *mut ::std::os::raw::c_void,
        realarray1: *mut f64,
        realarray2: *mut f64,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " sort of three joint arrays of pointers/pointers/ints, sorted by first array in non-decreasing order"]
    pub fn SCIPsortPtrPtrInt(
        ptrarray1: *mut *mut ::std::os::raw::c_void,
        ptrarray2: *mut *mut ::std::os::raw::c_void,
        intarray: *mut ::std::os::raw::c_int,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " sort of three joint arrays of pointers/pointers/Reals, sorted by first array in non-decreasing order"]
    pub fn SCIPsortPtrPtrReal(
        ptrarray1: *mut *mut ::std::os::raw::c_void,
        ptrarray2: *mut *mut ::std::os::raw::c_void,
        realarray: *mut f64,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " sort of four joint arrays of pointers/pointers/ints/ints, sorted by first array in non-decreasing order"]
    pub fn SCIPsortPtrPtrIntInt(
        ptrarray1: *mut *mut ::std::os::raw::c_void,
        ptrarray2: *mut *mut ::std::os::raw::c_void,
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " sort of four joint arrays of pointers/Reals/ints/ints, sorted by first array in non-decreasing order"]
    pub fn SCIPsortPtrRealIntInt(
        ptrarray: *mut *mut ::std::os::raw::c_void,
        realarray: *mut f64,
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " sort of four joint arrays of pointer/pointer/Reals/ints, sorted by first array in non-decreasing order"]
    pub fn SCIPsortPtrPtrRealInt(
        ptrarray1: *mut *mut ::std::os::raw::c_void,
        ptrarray2: *mut *mut ::std::os::raw::c_void,
        realarray: *mut f64,
        intarray: *mut ::std::os::raw::c_int,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " sort of four joint arrays of pointer/pointer/Reals/Bools, sorted by first array in non-decreasing order"]
    pub fn SCIPsortPtrPtrRealBool(
        ptrarray1: *mut *mut ::std::os::raw::c_void,
        ptrarray2: *mut *mut ::std::os::raw::c_void,
        realarray: *mut f64,
        boolarray: *mut ::std::os::raw::c_uint,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " sort of four joint arrays of pointer/pointer/Longs/ints, sorted by first array in non-decreasing order"]
    pub fn SCIPsortPtrPtrLongInt(
        ptrarray1: *mut *mut ::std::os::raw::c_void,
        ptrarray2: *mut *mut ::std::os::raw::c_void,
        longarray: *mut ::std::os::raw::c_longlong,
        intarray: *mut ::std::os::raw::c_int,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " sort of five joint arrays of pointer/pointer/Longs/ints/ints, sorted by first array in non-decreasing order"]
    pub fn SCIPsortPtrPtrLongIntInt(
        ptrarray1: *mut *mut ::std::os::raw::c_void,
        ptrarray2: *mut *mut ::std::os::raw::c_void,
        longarray: *mut ::std::os::raw::c_longlong,
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " sort an array of Reals in non-decreasing order"]
    pub fn SCIPsortReal(realarray: *mut f64, len: ::std::os::raw::c_int);
}
extern "C" {
    #[doc = " sort of two joint arrays of Reals/pointers, sorted by first array in non-decreasing order"]
    pub fn SCIPsortRealPtr(
        realarray: *mut f64,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " sort of two joint arrays of Reals/ints, sorted by first array in non-decreasing order"]
    pub fn SCIPsortRealInt(
        realarray: *mut f64,
        intarray: *mut ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " sort of three joint arrays of Reals/ints/ints, sorted by first array in non-decreasing order"]
    pub fn SCIPsortRealIntInt(
        realarray: *mut f64,
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " sort of three joint arrays of Reals/Bools/Pointer, sorted by first array in non-decreasing order"]
    pub fn SCIPsortRealBoolPtr(
        realarray: *mut f64,
        boolarray: *mut ::std::os::raw::c_uint,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " sort of three joint arrays of Reals/ints/Longs, sorted by first array in non-decreasing order"]
    pub fn SCIPsortRealIntLong(
        realarray: *mut f64,
        intarray: *mut ::std::os::raw::c_int,
        longarray: *mut ::std::os::raw::c_longlong,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " sort of three joint arrays of Reals/ints/Pointer, sorted by first array in non-decreasing order"]
    pub fn SCIPsortRealIntPtr(
        realarray: *mut f64,
        intarray: *mut ::std::os::raw::c_int,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " sort of three joint arrays of Reals/Reals/Pointer, sorted by first array in non-decreasing order"]
    pub fn SCIPsortRealRealPtr(
        realarray1: *mut f64,
        realarray2: *mut f64,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " sort of four joint arrays of Reals/pointers/pointers/ints, sorted by first array in non-decreasing order"]
    pub fn SCIPsortRealPtrPtrInt(
        realarray: *mut f64,
        ptrarray1: *mut *mut ::std::os::raw::c_void,
        ptrarray2: *mut *mut ::std::os::raw::c_void,
        intarray: *mut ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " sort of five joint arrays of Reals/pointers/pointers/ints/ints, sorted by first array in non-decreasing order"]
    pub fn SCIPsortRealPtrPtrIntInt(
        realarray: *mut f64,
        ptrarray1: *mut *mut ::std::os::raw::c_void,
        ptrarray2: *mut *mut ::std::os::raw::c_void,
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " sort of four joint arrays of Reals/Longs/Reals/ints, sorted by first array in non-decreasing order"]
    pub fn SCIPsortRealLongRealInt(
        realarray1: *mut f64,
        longarray: *mut ::std::os::raw::c_longlong,
        realarray3: *mut f64,
        intarray: *mut ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " sort of four joint arrays of Reals/Reals/ints/ints, sorted by first array in non-decreasing order"]
    pub fn SCIPsortRealRealIntInt(
        realarray1: *mut f64,
        realarray2: *mut f64,
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " sort of four joint arrays of Reals/Reals/Reals/ints, sorted by first array in non-decreasing order"]
    pub fn SCIPsortRealRealRealInt(
        realarray1: *mut f64,
        realarray2: *mut f64,
        realarray3: *mut f64,
        intarray: *mut ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " sort of four joint arrays of Reals/Reals/Reals/pointers, sorted by first array in non-decreasing order"]
    pub fn SCIPsortRealRealRealPtr(
        realarray1: *mut f64,
        realarray2: *mut f64,
        realarray3: *mut f64,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " sort of five joint arrays of Reals/Reals/Reals/Bools/pointers, sorted by first array in non-decreasing order"]
    pub fn SCIPsortRealRealRealBoolPtr(
        realarray1: *mut f64,
        realarray2: *mut f64,
        realarray3: *mut f64,
        boolarray: *mut ::std::os::raw::c_uint,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " sort of six joint arrays of Reals/Reals/Reals/Bools/Bools/pointers, sorted by first array in non-decreasing order"]
    pub fn SCIPsortRealRealRealBoolBoolPtr(
        realarray1: *mut f64,
        realarray2: *mut f64,
        realarray3: *mut f64,
        boolarray1: *mut ::std::os::raw::c_uint,
        boolarray2: *mut ::std::os::raw::c_uint,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " sort array of ints in non-decreasing order"]
    pub fn SCIPsortInt(intarray: *mut ::std::os::raw::c_int, len: ::std::os::raw::c_int);
}
extern "C" {
    #[doc = " sort of two joint arrays of ints/ints, sorted by first array in non-decreasing order"]
    pub fn SCIPsortIntInt(
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " sort of two joint arrays of ints/pointers, sorted by first array in non-decreasing order"]
    pub fn SCIPsortIntPtr(
        intarray: *mut ::std::os::raw::c_int,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " sort of two joint arrays of ints/reals, sorted by first array in non-decreasing order"]
    pub fn SCIPsortIntReal(
        intarray: *mut ::std::os::raw::c_int,
        realarray: *mut f64,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " sort of three joint arrays of ints/ints/ints, sorted by first array in non-decreasing order"]
    pub fn SCIPsortIntIntInt(
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        intarray3: *mut ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " sort of three joint arrays of ints/ints/Longints, sorted by first array in non-decreasing order"]
    pub fn SCIPsortIntIntLong(
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        longarray: *mut ::std::os::raw::c_longlong,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " sort of three joint arrays of ints/ints/Longints, sorted by first array in non-decreasing order"]
    pub fn SCIPsortIntRealLong(
        intarray: *mut ::std::os::raw::c_int,
        realarray: *mut f64,
        longarray: *mut ::std::os::raw::c_longlong,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " sort of three joint arrays of ints/ints/pointers, sorted by first array in non-decreasing order"]
    pub fn SCIPsortIntIntPtr(
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " sort of three joint arrays of ints/ints/reals, sorted by first array in non-decreasing order"]
    pub fn SCIPsortIntIntReal(
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        realarray: *mut f64,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " sort of three joint arrays of ints/pointers/reals, sorted by first array in non-decreasing order"]
    pub fn SCIPsortIntPtrReal(
        intarray: *mut ::std::os::raw::c_int,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        realarray: *mut f64,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " sort of four joint arrays of ints/ints/ints/pointers, sorted by first array in non-decreasing order"]
    pub fn SCIPsortIntIntIntPtr(
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        intarray3: *mut ::std::os::raw::c_int,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " sort of four joint arrays of ints/ints/ints/reals, sorted by first array in non-decreasing order"]
    pub fn SCIPsortIntIntIntReal(
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        intarray3: *mut ::std::os::raw::c_int,
        realarray: *mut f64,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " sort of four joint arrays of ints/pointers/ints/reals, sorted by first array in non-decreasing order"]
    pub fn SCIPsortIntPtrIntReal(
        intarray1: *mut ::std::os::raw::c_int,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        intarray2: *mut ::std::os::raw::c_int,
        realarray: *mut f64,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " sort an array of Longints in non-decreasing order"]
    pub fn SCIPsortLong(longarray: *mut ::std::os::raw::c_longlong, len: ::std::os::raw::c_int);
}
extern "C" {
    #[doc = " sort of two joint arrays of Long/pointer, sorted by the first array in non-decreasing order"]
    pub fn SCIPsortLongPtr(
        longarray: *mut ::std::os::raw::c_longlong,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " sort of three arrays of Long/pointer/ints, sorted by the first array in non-decreasing order"]
    pub fn SCIPsortLongPtrInt(
        longarray: *mut ::std::os::raw::c_longlong,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        intarray: *mut ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " sort of four arrays of Long/pointer/Real/Bool, sorted by the first array in non-decreasing order"]
    pub fn SCIPsortLongPtrRealBool(
        longarray: *mut ::std::os::raw::c_longlong,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        realarray: *mut f64,
        boolarray: *mut ::std::os::raw::c_uint,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " sort of five arrays of Long/pointer/Real/Real/Bool, sorted by the first array in non-decreasing order"]
    pub fn SCIPsortLongPtrRealRealBool(
        longarray: *mut ::std::os::raw::c_longlong,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        realarray: *mut f64,
        realarray2: *mut f64,
        boolarray: *mut ::std::os::raw::c_uint,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " sort of six arrays of Long/pointer/Real/Real/int/Bool, sorted by the first array in non-decreasing order"]
    pub fn SCIPsortLongPtrRealRealIntBool(
        longarray: *mut ::std::os::raw::c_longlong,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        realarray: *mut f64,
        realarray2: *mut f64,
        intarray: *mut ::std::os::raw::c_int,
        boolarray: *mut ::std::os::raw::c_uint,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " sort of four joint arrays of Long/pointer/pointer/ints, sorted by first array in non-decreasing order"]
    pub fn SCIPsortLongPtrPtrInt(
        longarray: *mut ::std::os::raw::c_longlong,
        ptrarray1: *mut *mut ::std::os::raw::c_void,
        ptrarray2: *mut *mut ::std::os::raw::c_void,
        intarray: *mut ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " sort of five joint arrays of Long/pointer/pointer/ints/ints, sorted by first array in non-decreasing order"]
    pub fn SCIPsortLongPtrPtrIntInt(
        longarray: *mut ::std::os::raw::c_longlong,
        ptrarray1: *mut *mut ::std::os::raw::c_void,
        ptrarray2: *mut *mut ::std::os::raw::c_void,
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " sort of five joint arrays of Long/pointer/pointer/Bool/ints, sorted by first array in non-decreasing order"]
    pub fn SCIPsortLongPtrPtrBoolInt(
        longarray: *mut ::std::os::raw::c_longlong,
        ptrarray1: *mut *mut ::std::os::raw::c_void,
        ptrarray2: *mut *mut ::std::os::raw::c_void,
        boolarray: *mut ::std::os::raw::c_uint,
        intarray: *mut ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " sort of five joint arrays of pointer/ints/ints/Bool/Bool, sorted by first array in non-decreasing order"]
    pub fn SCIPsortPtrIntIntBoolBool(
        ptrarray: *mut *mut ::std::os::raw::c_void,
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        boolarray1: *mut ::std::os::raw::c_uint,
        boolarray2: *mut ::std::os::raw::c_uint,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " sort of six joint arrays of ints/pointer/ints/ints/Bool/Bool, sorted by first array in non-decreasing order"]
    pub fn SCIPsortIntPtrIntIntBoolBool(
        intarray1: *mut ::std::os::raw::c_int,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        intarray2: *mut ::std::os::raw::c_int,
        intarray3: *mut ::std::os::raw::c_int,
        boolarray1: *mut ::std::os::raw::c_uint,
        boolarray2: *mut ::std::os::raw::c_uint,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " sort an indexed element set in non-increasing order, resulting in a permutation index array"]
    pub fn SCIPsortDown(
        perm: *mut ::std::os::raw::c_int,
        indcomp: ::std::option::Option<
            unsafe extern "C" fn(
                dataptr: *mut ::std::os::raw::c_void,
                ind1: ::std::os::raw::c_int,
                ind2: ::std::os::raw::c_int,
            ) -> ::std::os::raw::c_int,
        >,
        dataptr: *mut ::std::os::raw::c_void,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " sort an index array in non-increasing order"]
    pub fn SCIPsortDownInd(
        indarray: *mut ::std::os::raw::c_int,
        indcomp: ::std::option::Option<
            unsafe extern "C" fn(
                dataptr: *mut ::std::os::raw::c_void,
                ind1: ::std::os::raw::c_int,
                ind2: ::std::os::raw::c_int,
            ) -> ::std::os::raw::c_int,
        >,
        dataptr: *mut ::std::os::raw::c_void,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " sort of an array of pointers in non-increasing order"]
    pub fn SCIPsortDownPtr(
        ptrarray: *mut *mut ::std::os::raw::c_void,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " sort of two joint arrays of pointers/pointers, sorted by first array in non-increasing order"]
    pub fn SCIPsortDownPtrPtr(
        ptrarray1: *mut *mut ::std::os::raw::c_void,
        ptrarray2: *mut *mut ::std::os::raw::c_void,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " sort of two joint arrays of pointers/Reals, sorted by first array in non-increasing order"]
    pub fn SCIPsortDownPtrReal(
        ptrarray: *mut *mut ::std::os::raw::c_void,
        realarray: *mut f64,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " sort of two joint arrays of pointers/ints, sorted by first array in non-increasing order"]
    pub fn SCIPsortDownPtrInt(
        ptrarray: *mut *mut ::std::os::raw::c_void,
        intarray: *mut ::std::os::raw::c_int,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " sort of two joint arrays of pointers/Bools, sorted by first array in non-increasing order"]
    pub fn SCIPsortDownPtrBool(
        ptrarray: *mut *mut ::std::os::raw::c_void,
        boolarray: *mut ::std::os::raw::c_uint,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " sort of three joint arrays of pointers/ints/ints, sorted by first array in non-increasing order"]
    pub fn SCIPsortDownPtrIntInt(
        ptrarray: *mut *mut ::std::os::raw::c_void,
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " sort of three joint arrays of pointers/Reals/ints, sorted by first array in non-increasing order"]
    pub fn SCIPsortDownPtrRealInt(
        ptrarray: *mut *mut ::std::os::raw::c_void,
        realarray: *mut f64,
        intarray: *mut ::std::os::raw::c_int,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " sort of three joint arrays of pointers/Reals/Bools, sorted by first array in non-increasing order"]
    pub fn SCIPsortDownPtrRealBool(
        ptrarray: *mut *mut ::std::os::raw::c_void,
        realarray: *mut f64,
        boolarray: *mut ::std::os::raw::c_uint,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " sort of three joint arrays of pointers/pointers/ints, sorted by first array in non-increasing order"]
    pub fn SCIPsortDownPtrPtrInt(
        ptrarray1: *mut *mut ::std::os::raw::c_void,
        ptrarray2: *mut *mut ::std::os::raw::c_void,
        intarray: *mut ::std::os::raw::c_int,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " sort of three joint arrays of pointers/pointers/Reals, sorted by first array in non-increasing order"]
    pub fn SCIPsortDownPtrPtrReal(
        ptrarray1: *mut *mut ::std::os::raw::c_void,
        ptrarray2: *mut *mut ::std::os::raw::c_void,
        realarray: *mut f64,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " sort of four joint arrays of pointers/pointers/ints/ints, sorted by first array in non-increasing order"]
    pub fn SCIPsortDownPtrPtrIntInt(
        ptrarray1: *mut *mut ::std::os::raw::c_void,
        ptrarray2: *mut *mut ::std::os::raw::c_void,
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " sort of four joint arrays of pointers/Reals/ints/ints, sorted by first array in non-increasing order"]
    pub fn SCIPsortDownPtrRealIntInt(
        ptrarray: *mut *mut ::std::os::raw::c_void,
        realarray: *mut f64,
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " sort of four joint arrays of pointer/pointer/Reals/ints, sorted by first array in non-increasing order"]
    pub fn SCIPsortDownPtrPtrRealInt(
        ptrarray1: *mut *mut ::std::os::raw::c_void,
        ptrarray2: *mut *mut ::std::os::raw::c_void,
        realarray: *mut f64,
        intarray: *mut ::std::os::raw::c_int,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " sort of four joint arrays of pointer/pointer/Reals/bools, sorted by first array in non-increasing order"]
    pub fn SCIPsortDownPtrPtrRealBool(
        ptrarray1: *mut *mut ::std::os::raw::c_void,
        ptrarray2: *mut *mut ::std::os::raw::c_void,
        realarray: *mut f64,
        boolarray: *mut ::std::os::raw::c_uint,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " sort of four joint arrays of pointer/pointer/Longs/ints, sorted by first array in non-increasing order"]
    pub fn SCIPsortDownPtrPtrLongInt(
        ptrarray1: *mut *mut ::std::os::raw::c_void,
        ptrarray2: *mut *mut ::std::os::raw::c_void,
        longarray: *mut ::std::os::raw::c_longlong,
        intarray: *mut ::std::os::raw::c_int,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " sort of five joint arrays of pointer/pointer/Longs/ints/ints, sorted by first array in non-increasing order"]
    pub fn SCIPsortDownPtrPtrLongIntInt(
        ptrarray1: *mut *mut ::std::os::raw::c_void,
        ptrarray2: *mut *mut ::std::os::raw::c_void,
        longarray: *mut ::std::os::raw::c_longlong,
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " sort an array of Reals in non-increasing order"]
    pub fn SCIPsortDownReal(realarray: *mut f64, len: ::std::os::raw::c_int);
}
extern "C" {
    #[doc = " sort of two joint arrays of Reals/pointers, sorted by first array in non-increasing order"]
    pub fn SCIPsortDownRealPtr(
        realarray: *mut f64,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " sort of two joint arrays of Reals/ints, sorted by first array in non-increasing order"]
    pub fn SCIPsortDownRealInt(
        realarray: *mut f64,
        intarray: *mut ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " sort of three joint arrays of Reals/ints/ints, sorted by first array in non-increasing order"]
    pub fn SCIPsortDownRealIntInt(
        realarray: *mut f64,
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " sort of three joint arrays of Reals/Bools/Pointer, sorted by first array in non-increasing order"]
    pub fn SCIPsortDownRealBoolPtr(
        realarray: *mut f64,
        boolarray: *mut ::std::os::raw::c_uint,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " sort of three joint arrays of Reals/ints/Longs, sorted by first array in non-increasing order"]
    pub fn SCIPsortDownRealIntLong(
        realarray: *mut f64,
        intarray: *mut ::std::os::raw::c_int,
        longarray: *mut ::std::os::raw::c_longlong,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " sort of three joint arrays of Reals/ints/Pointer, sorted by first array in non-increasing order"]
    pub fn SCIPsortDownRealIntPtr(
        realarray: *mut f64,
        intarray: *mut ::std::os::raw::c_int,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " sort of three joint arrays of Reals/Reals/ints, sorted by first array in non-increasing order"]
    pub fn SCIPsortDownRealRealInt(
        realarray1: *mut f64,
        realarray2: *mut f64,
        intarray: *mut ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " sort of three joint arrays of Reals/Reals/Pointer, sorted by first array in non-increasing order"]
    pub fn SCIPsortDownRealRealPtr(
        realarray1: *mut f64,
        realarray2: *mut f64,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " sort of three joint arrays of Reals/Reals/Pointer, sorted by first array in non-increasing order"]
    pub fn SCIPsortDownRealRealPtrPtr(
        realarray1: *mut f64,
        realarray2: *mut f64,
        ptrarray1: *mut *mut ::std::os::raw::c_void,
        ptrarray2: *mut *mut ::std::os::raw::c_void,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " sort of four joint arrays of Reals/pointers/pointers/ints, sorted by first array in non-increasing order"]
    pub fn SCIPsortDownRealPtrPtrInt(
        realarray: *mut f64,
        ptrarray1: *mut *mut ::std::os::raw::c_void,
        ptrarray2: *mut *mut ::std::os::raw::c_void,
        intarray: *mut ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " sort of five joint arrays of Reals/pointers/pointers/ints/ints, sorted by first array in non-increasing order"]
    pub fn SCIPsortDownRealPtrPtrIntInt(
        realarray: *mut f64,
        ptrarray1: *mut *mut ::std::os::raw::c_void,
        ptrarray2: *mut *mut ::std::os::raw::c_void,
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " sort of four joint arrays of Reals/Longs/Reals/ints, sorted by first array in non-increasing order"]
    pub fn SCIPsortDownRealLongRealInt(
        realarray1: *mut f64,
        longarray: *mut ::std::os::raw::c_longlong,
        realarray3: *mut f64,
        intarray: *mut ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " sort of four joint arrays of Reals/Reals/ints/ints, sorted by first array in non-increasing order"]
    pub fn SCIPsortDownRealRealIntInt(
        realarray1: *mut f64,
        realarray2: *mut f64,
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " sort of four joint arrays of Reals/Reals/Reals/ints, sorted by first array in non-increasing order"]
    pub fn SCIPsortDownRealRealRealInt(
        realarray1: *mut f64,
        realarray2: *mut f64,
        realarray3: *mut f64,
        intarray: *mut ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " sort of four joint arrays of Reals/Reals/Reals/pointers, sorted by first array in non-increasing order"]
    pub fn SCIPsortDownRealRealRealPtr(
        realarray1: *mut f64,
        realarray2: *mut f64,
        realarray3: *mut f64,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " sort of three joint arrays of Reals/pointers, sorted by first array in non-decreasing order"]
    pub fn SCIPsortDownRealPtrPtr(
        realarray: *mut f64,
        ptrarray1: *mut *mut ::std::os::raw::c_void,
        ptrarray2: *mut *mut ::std::os::raw::c_void,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " sort of five joint arrays of Reals/Reals/Reals/Bools/pointers, sorted by first array in non-increasing order"]
    pub fn SCIPsortDownRealRealRealBoolPtr(
        realarray1: *mut f64,
        realarray2: *mut f64,
        realarray3: *mut f64,
        boolarray: *mut ::std::os::raw::c_uint,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " sort of six joint arrays of Reals/Reals/Reals/Bools/Bools/pointers, sorted by first array in non-increasing order"]
    pub fn SCIPsortDownRealRealRealBoolBoolPtr(
        realarray1: *mut f64,
        realarray2: *mut f64,
        realarray3: *mut f64,
        boolarray1: *mut ::std::os::raw::c_uint,
        boolarray2: *mut ::std::os::raw::c_uint,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " sort array of ints in non-increasing order"]
    pub fn SCIPsortDownInt(intarray: *mut ::std::os::raw::c_int, len: ::std::os::raw::c_int);
}
extern "C" {
    #[doc = " sort of two joint arrays of ints/ints, sorted by first array in non-increasing order"]
    pub fn SCIPsortDownIntInt(
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " sort of two joint arrays of ints/pointers, sorted by first array in non-increasing order"]
    pub fn SCIPsortDownIntPtr(
        intarray: *mut ::std::os::raw::c_int,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " sort of two joint arrays of ints/reals, sorted by first array in non-increasing order"]
    pub fn SCIPsortDownIntReal(
        intarray: *mut ::std::os::raw::c_int,
        realarray: *mut f64,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " sort of three joint arrays of ints/ints/ints, sorted by first array in non-increasing order"]
    pub fn SCIPsortDownIntIntInt(
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        intarray3: *mut ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " sort of three joint arrays of ints/ints/SCIP_Longint, sorted by first array in non-increasing order"]
    pub fn SCIPsortDownIntIntLong(
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        longarray: *mut ::std::os::raw::c_longlong,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " sort of three joint arrays of ints/ints/pointers, sorted by first array in non-increasing order"]
    pub fn SCIPsortDownIntIntPtr(
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " sort of three joint arrays of ints/ints/Reals, sorted by first array in non-increasing order"]
    pub fn SCIPsortDownIntIntReal(
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        realarray: *mut f64,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " sort of four joint arrays of ints/ints/ints/pointers, sorted by first array in non-increasing order"]
    pub fn SCIPsortDownIntIntIntPtr(
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        intarray3: *mut ::std::os::raw::c_int,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " sort of four joint arrays of ints/ints/ints/reals, sorted by first array in non-increasing order"]
    pub fn SCIPsortDownIntIntIntReal(
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        intarray3: *mut ::std::os::raw::c_int,
        realarray: *mut f64,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " sort of four joint arrays of ints/pointers/ints/Reals, sorted by first array in non-increasing order"]
    pub fn SCIPsortDownIntPtrIntReal(
        intarray1: *mut ::std::os::raw::c_int,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        intarray2: *mut ::std::os::raw::c_int,
        realarray: *mut f64,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " sort an array of Longints in non-increasing order"]
    pub fn SCIPsortDownLong(longarray: *mut ::std::os::raw::c_longlong, len: ::std::os::raw::c_int);
}
extern "C" {
    #[doc = " sort of two joint arrays of Long/pointer, sorted by the first array in non-increasing order"]
    pub fn SCIPsortDownLongPtr(
        longarray: *mut ::std::os::raw::c_longlong,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " sort of three arrays of Long/pointer/ints, sorted by the first array in non-increasing order"]
    pub fn SCIPsortDownLongPtrInt(
        longarray: *mut ::std::os::raw::c_longlong,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        intarray: *mut ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " sort of four arrays of Long/pointer/Real/Bool, sorted by the first array in non-increasing order"]
    pub fn SCIPsortDownLongPtrRealBool(
        longarray: *mut ::std::os::raw::c_longlong,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        realarray: *mut f64,
        boolarray: *mut ::std::os::raw::c_uint,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " sort of five arrays of Long/pointer/Real/Real/Bool, sorted by the first array in non-increasing order"]
    pub fn SCIPsortDownLongPtrRealRealBool(
        longarray: *mut ::std::os::raw::c_longlong,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        realarray: *mut f64,
        realarray2: *mut f64,
        boolarray: *mut ::std::os::raw::c_uint,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " sort of six arrays of Long/pointer/Real/Real/int/Bool, sorted by the first array in non-increasing order"]
    pub fn SCIPsortDownLongPtrRealRealIntBool(
        longarray: *mut ::std::os::raw::c_longlong,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        realarray: *mut f64,
        realarray2: *mut f64,
        intarray: *mut ::std::os::raw::c_int,
        boolarray: *mut ::std::os::raw::c_uint,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " sort of four joint arrays of Long/pointer/pointer/ints, sorted by first array in non-increasing order"]
    pub fn SCIPsortDownLongPtrPtrInt(
        longarray: *mut ::std::os::raw::c_longlong,
        ptrarray1: *mut *mut ::std::os::raw::c_void,
        ptrarray2: *mut *mut ::std::os::raw::c_void,
        intarray: *mut ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " sort of five joint arrays of Long/pointer/pointer/ints/ints, sorted by first array in non-increasing order"]
    pub fn SCIPsortDownLongPtrPtrIntInt(
        longarray: *mut ::std::os::raw::c_longlong,
        ptrarray1: *mut *mut ::std::os::raw::c_void,
        ptrarray2: *mut *mut ::std::os::raw::c_void,
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " sort of five joint arrays of Long/pointer/pointer/Bool/ints, sorted by first array in non-increasing order"]
    pub fn SCIPsortDownLongPtrPtrBoolInt(
        longarray: *mut ::std::os::raw::c_longlong,
        ptrarray1: *mut *mut ::std::os::raw::c_void,
        ptrarray2: *mut *mut ::std::os::raw::c_void,
        boolarray: *mut ::std::os::raw::c_uint,
        intarray: *mut ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " sort of five joint arrays of pointer/ints/ints/Bool/Bool, sorted by first array in non-increasing order"]
    pub fn SCIPsortDownPtrIntIntBoolBool(
        ptrarray: *mut *mut ::std::os::raw::c_void,
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        boolarray1: *mut ::std::os::raw::c_uint,
        boolarray2: *mut ::std::os::raw::c_uint,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " sort of six joint arrays of ints/pointer/ints/ints/Bool/Bool, sorted by first array in non-increasing order"]
    pub fn SCIPsortDownIntPtrIntIntBoolBool(
        intarray1: *mut ::std::os::raw::c_int,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        intarray2: *mut ::std::os::raw::c_int,
        intarray3: *mut ::std::os::raw::c_int,
        boolarray1: *mut ::std::os::raw::c_uint,
        boolarray2: *mut ::std::os::raw::c_uint,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " insert a new element into an index array in non-decreasing order"]
    pub fn SCIPsortedvecInsertInd(
        indarray: *mut ::std::os::raw::c_int,
        indcomp: ::std::option::Option<
            unsafe extern "C" fn(
                dataptr: *mut ::std::os::raw::c_void,
                ind1: ::std::os::raw::c_int,
                ind2: ::std::os::raw::c_int,
            ) -> ::std::os::raw::c_int,
        >,
        dataptr: *mut ::std::os::raw::c_void,
        keyval: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
        pos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " insert a new element into an array of pointers in non-decreasing order"]
    pub fn SCIPsortedvecInsertPtr(
        ptrarray: *mut *mut ::std::os::raw::c_void,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        keyval: *mut ::std::os::raw::c_void,
        len: *mut ::std::os::raw::c_int,
        pos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " insert a new element into two joint arrays of pointers/pointers sorted by first array in non-decreasing order"]
    pub fn SCIPsortedvecInsertPtrPtr(
        ptrarray1: *mut *mut ::std::os::raw::c_void,
        ptrarray2: *mut *mut ::std::os::raw::c_void,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        keyval: *mut ::std::os::raw::c_void,
        field1val: *mut ::std::os::raw::c_void,
        len: *mut ::std::os::raw::c_int,
        pos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " insert a new element into two joint arrays of pointers/Reals, sorted by first array in non-decreasing order"]
    pub fn SCIPsortedvecInsertPtrReal(
        ptrarray: *mut *mut ::std::os::raw::c_void,
        realarray: *mut f64,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        keyval: *mut ::std::os::raw::c_void,
        field1val: f64,
        len: *mut ::std::os::raw::c_int,
        pos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " insert a new element into two joint arrays of pointers/ints, sorted by first array in non-decreasing order"]
    pub fn SCIPsortedvecInsertPtrInt(
        ptrarray: *mut *mut ::std::os::raw::c_void,
        intarray: *mut ::std::os::raw::c_int,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        keyval: *mut ::std::os::raw::c_void,
        field1val: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
        pos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " insert a new element into two joint arrays of pointers/Bools, sorted by first array in non-decreasing order"]
    pub fn SCIPsortedvecInsertPtrBool(
        ptrarray: *mut *mut ::std::os::raw::c_void,
        boolarray: *mut ::std::os::raw::c_uint,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        keyval: *mut ::std::os::raw::c_void,
        field1val: ::std::os::raw::c_uint,
        len: *mut ::std::os::raw::c_int,
        pos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " insert a new element into three joint arrays of pointers/ints/ints, sorted by first array in non-decreasing order"]
    pub fn SCIPsortedvecInsertPtrIntInt(
        ptrarray: *mut *mut ::std::os::raw::c_void,
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        keyval: *mut ::std::os::raw::c_void,
        field1val: ::std::os::raw::c_int,
        field2val: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
        pos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " insert a new element into three joint arrays of pointers/Reals/ints, sorted by first array in non-decreasing order"]
    pub fn SCIPsortedvecInsertPtrRealInt(
        ptrarray: *mut *mut ::std::os::raw::c_void,
        realarray: *mut f64,
        intarray: *mut ::std::os::raw::c_int,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        keyval: *mut ::std::os::raw::c_void,
        field1val: f64,
        field2val: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
        pos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " insert a new element into four joint arrays of pointers/Reals/Reals/ints, sorted by first array in non-decreasing order"]
    pub fn SCIPsortedvecInsertPtrRealRealInt(
        ptrarray: *mut *mut ::std::os::raw::c_void,
        realarray1: *mut f64,
        realarray2: *mut f64,
        intarray: *mut ::std::os::raw::c_int,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        keyval: *mut ::std::os::raw::c_void,
        field1val: f64,
        field2val: f64,
        field3val: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
        pos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " insert a new element into four joint arrays of pointers/Reals/Reals/SCIP_Bools/SCIP_Bools, sorted by first array in non-decreasing order"]
    pub fn SCIPsortedvecInsertPtrRealRealBoolBool(
        ptrarray: *mut *mut ::std::os::raw::c_void,
        realarray1: *mut f64,
        realarray2: *mut f64,
        boolarray1: *mut ::std::os::raw::c_uint,
        boolarray2: *mut ::std::os::raw::c_uint,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        keyval: *mut ::std::os::raw::c_void,
        field1val: f64,
        field2val: f64,
        field3val: ::std::os::raw::c_uint,
        field4val: ::std::os::raw::c_uint,
        len: *mut ::std::os::raw::c_int,
        pos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " insert a new element into four joint arrays of pointers/Reals/Reals/ints/SCIP_Bools, sorted by first array in non-decreasing order"]
    pub fn SCIPsortedvecInsertPtrRealRealIntBool(
        ptrarray: *mut *mut ::std::os::raw::c_void,
        realarray1: *mut f64,
        realarray2: *mut f64,
        intarray: *mut ::std::os::raw::c_int,
        boolarray: *mut ::std::os::raw::c_uint,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        keyval: *mut ::std::os::raw::c_void,
        field1val: f64,
        field2val: f64,
        field3val: ::std::os::raw::c_int,
        field4val: ::std::os::raw::c_uint,
        len: *mut ::std::os::raw::c_int,
        pos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " insert a new element into three joint arrays of pointers/Reals/Bools, sorted by first array in non-decreasing order"]
    pub fn SCIPsortedvecInsertPtrRealBool(
        ptrarray: *mut *mut ::std::os::raw::c_void,
        realarray: *mut f64,
        boolarray: *mut ::std::os::raw::c_uint,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        keyval: *mut ::std::os::raw::c_void,
        field1val: f64,
        field2val: ::std::os::raw::c_uint,
        len: *mut ::std::os::raw::c_int,
        pos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " insert a new element into three joint arrays of pointers/pointers/Ints, sorted by first array in non-decreasing order"]
    pub fn SCIPsortedvecInsertPtrPtrInt(
        ptrarray1: *mut *mut ::std::os::raw::c_void,
        ptrarray2: *mut *mut ::std::os::raw::c_void,
        intarray: *mut ::std::os::raw::c_int,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        keyval: *mut ::std::os::raw::c_void,
        field1val: *mut ::std::os::raw::c_void,
        field2val: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
        pos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " insert a new element into three joint arrays of pointers/pointers/Reals, sorted by first array in non-decreasing order"]
    pub fn SCIPsortedvecInsertPtrPtrReal(
        ptrarray1: *mut *mut ::std::os::raw::c_void,
        ptrarray2: *mut *mut ::std::os::raw::c_void,
        realarray: *mut f64,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        keyval: *mut ::std::os::raw::c_void,
        field1val: *mut ::std::os::raw::c_void,
        field2val: f64,
        len: *mut ::std::os::raw::c_int,
        pos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " insert a new element into four joint arrays of pointers/pointers/ints/ints, sorted by first array in non-decreasing order"]
    pub fn SCIPsortedvecInsertPtrPtrIntInt(
        ptrarray1: *mut *mut ::std::os::raw::c_void,
        ptrarray2: *mut *mut ::std::os::raw::c_void,
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        keyval: *mut ::std::os::raw::c_void,
        field1val: *mut ::std::os::raw::c_void,
        field2val: ::std::os::raw::c_int,
        field3val: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
        pos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " insert a new element into four joint arrays of pointers/Reals/ints/ints, sorted by first array in non-decreasing order"]
    pub fn SCIPsortedvecInsertPtrRealIntInt(
        ptrarray: *mut *mut ::std::os::raw::c_void,
        realarray: *mut f64,
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        keyval: *mut ::std::os::raw::c_void,
        field1val: f64,
        field2val: ::std::os::raw::c_int,
        field3val: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
        pos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " insert a new element into four joint arrays of pointer/pointer/Reals/ints, sorted by first array in non-decreasing order"]
    pub fn SCIPsortedvecInsertPtrPtrRealInt(
        ptrarray1: *mut *mut ::std::os::raw::c_void,
        ptrarray2: *mut *mut ::std::os::raw::c_void,
        realarray: *mut f64,
        intarray: *mut ::std::os::raw::c_int,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        keyval: *mut ::std::os::raw::c_void,
        field1val: *mut ::std::os::raw::c_void,
        field2val: f64,
        field3val: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
        pos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " insert a new element into four joint arrays of pointer/pointer/Reals/bools, sorted by first array in non-decreasing order"]
    pub fn SCIPsortedvecInsertPtrPtrRealBool(
        ptrarray1: *mut *mut ::std::os::raw::c_void,
        ptrarray2: *mut *mut ::std::os::raw::c_void,
        realarray: *mut f64,
        boolarray: *mut ::std::os::raw::c_uint,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        keyval: *mut ::std::os::raw::c_void,
        field1val: *mut ::std::os::raw::c_void,
        field2val: f64,
        field3val: ::std::os::raw::c_uint,
        len: *mut ::std::os::raw::c_int,
        pos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " insert a new element into four joint arrays of pointer/pointer/Longs/ints, sorted by first array in non-decreasing order"]
    pub fn SCIPsortedvecInsertPtrPtrLongInt(
        ptrarray1: *mut *mut ::std::os::raw::c_void,
        ptrarray2: *mut *mut ::std::os::raw::c_void,
        longarray: *mut ::std::os::raw::c_longlong,
        intarray: *mut ::std::os::raw::c_int,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        keyval: *mut ::std::os::raw::c_void,
        field1val: *mut ::std::os::raw::c_void,
        field2val: ::std::os::raw::c_longlong,
        field3val: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
        pos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " insert a new element into five joint arrays of pointer/pointer/Longs/ints/ints, sorted by first array in non-decreasing order"]
    pub fn SCIPsortedvecInsertPtrPtrLongIntInt(
        ptrarray1: *mut *mut ::std::os::raw::c_void,
        ptrarray2: *mut *mut ::std::os::raw::c_void,
        longarray: *mut ::std::os::raw::c_longlong,
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        keyval: *mut ::std::os::raw::c_void,
        field1val: *mut ::std::os::raw::c_void,
        field2val: ::std::os::raw::c_longlong,
        field3val: ::std::os::raw::c_int,
        field4val: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
        pos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " insert a new element into three joint arrays of Reals/ints/ints, sorted by first array in non-decreasing order"]
    pub fn SCIPsortedvecInsertRealIntInt(
        realarray: *mut f64,
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        keyval: f64,
        field2val: ::std::os::raw::c_int,
        field3val: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
        pos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " insert a new element into three joint arrays of Reals/Bools/pointers, sorted by first array in non-decreasing order"]
    pub fn SCIPsortedvecInsertRealBoolPtr(
        realarray: *mut f64,
        boolarray: *mut ::std::os::raw::c_uint,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        keyval: f64,
        field1val: ::std::os::raw::c_uint,
        field2val: *mut ::std::os::raw::c_void,
        len: *mut ::std::os::raw::c_int,
        pos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " insert a new element into two joint arrays of Reals/pointers, sorted by first array in non-decreasing order"]
    pub fn SCIPsortedvecInsertRealPtr(
        realarray: *mut f64,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        keyval: f64,
        field1val: *mut ::std::os::raw::c_void,
        len: *mut ::std::os::raw::c_int,
        pos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " insert a new element into an arrays of Reals, sorted in non-decreasing order"]
    pub fn SCIPsortedvecInsertReal(
        realarray: *mut f64,
        keyval: f64,
        len: *mut ::std::os::raw::c_int,
        pos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " insert a new element into two joint arrays of Reals/ints, sorted by first array in non-decreasing order"]
    pub fn SCIPsortedvecInsertRealInt(
        realarray: *mut f64,
        intarray: *mut ::std::os::raw::c_int,
        keyval: f64,
        field1val: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
        pos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " insert a new element into three joint arrays of Reals/ints/Longs, sorted by first array in non-decreasing order"]
    pub fn SCIPsortedvecInsertRealIntLong(
        realarray: *mut f64,
        intarray: *mut ::std::os::raw::c_int,
        longarray: *mut ::std::os::raw::c_longlong,
        keyval: f64,
        field1val: ::std::os::raw::c_int,
        field2val: ::std::os::raw::c_longlong,
        len: *mut ::std::os::raw::c_int,
        pos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " insert a new element into three joint arrays of Reals/ints/Pointer, sorted by first array in non-decreasing order"]
    pub fn SCIPsortedvecInsertRealIntPtr(
        realarray: *mut f64,
        intarray: *mut ::std::os::raw::c_int,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        keyval: f64,
        field1val: ::std::os::raw::c_int,
        field2val: *mut ::std::os::raw::c_void,
        len: *mut ::std::os::raw::c_int,
        pos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " insert a new element into three joint arrays of Reals/Reals/Pointer, sorted by first array in non-decreasing order"]
    pub fn SCIPsortedvecInsertRealRealPtr(
        realarray1: *mut f64,
        realarray2: *mut f64,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        keyval: f64,
        field1val: f64,
        field2val: *mut ::std::os::raw::c_void,
        len: *mut ::std::os::raw::c_int,
        pos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " insert a new element into four joint arrays of Reals/pointers/pointers/ints, sorted by first array in non-decreasing order"]
    pub fn SCIPsortedvecInsertRealPtrPtrInt(
        realarray: *mut f64,
        ptrarray1: *mut *mut ::std::os::raw::c_void,
        ptrarray2: *mut *mut ::std::os::raw::c_void,
        intarray: *mut ::std::os::raw::c_int,
        keyval: f64,
        field1val: *mut ::std::os::raw::c_void,
        field2val: *mut ::std::os::raw::c_void,
        intval: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
        pos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " insert a new element into five joint arrays of Reals/pointers/pointers/ints/ints, sorted by first array in non-decreasing order"]
    pub fn SCIPsortedvecInsertRealPtrPtrIntInt(
        realarray: *mut f64,
        ptrarray1: *mut *mut ::std::os::raw::c_void,
        ptrarray2: *mut *mut ::std::os::raw::c_void,
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        keyval: f64,
        field1val: *mut ::std::os::raw::c_void,
        field2val: *mut ::std::os::raw::c_void,
        intval1: ::std::os::raw::c_int,
        intval2: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
        pos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " insert a new element into four joint arrays of Reals/Long/Reals/ints, sorted by first array in non-decreasing order"]
    pub fn SCIPsortedvecInsertRealLongRealInt(
        realarray1: *mut f64,
        longarray: *mut ::std::os::raw::c_longlong,
        realarray3: *mut f64,
        intarray: *mut ::std::os::raw::c_int,
        keyval: f64,
        field1val: ::std::os::raw::c_longlong,
        field2val: f64,
        field3val: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
        pos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " insert a new element into four joint arrays of Reals/Reals/ints/ints, sorted by first array in non-decreasing order"]
    pub fn SCIPsortedvecInsertRealRealIntInt(
        realarray1: *mut f64,
        realarray2: *mut f64,
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        keyval: f64,
        field1val: f64,
        field2val: ::std::os::raw::c_int,
        field3val: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
        pos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " insert a new element into four joint arrays of Reals/Reals/Reals/ints, sorted by first array in non-decreasing order"]
    pub fn SCIPsortedvecInsertRealRealRealInt(
        realarray1: *mut f64,
        realarray2: *mut f64,
        realarray3: *mut f64,
        intarray: *mut ::std::os::raw::c_int,
        keyval: f64,
        field1val: f64,
        field2val: f64,
        field3val: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
        pos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " insert a new element into four joint arrays of Reals/Reals/Reals/pointers, sorted by first array in non-decreasing order"]
    pub fn SCIPsortedvecInsertRealRealRealPtr(
        realarray1: *mut f64,
        realarray2: *mut f64,
        realarray3: *mut f64,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        keyval: f64,
        field1val: f64,
        field2val: f64,
        field3val: *mut ::std::os::raw::c_void,
        len: *mut ::std::os::raw::c_int,
        pos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " insert a new element into five joint arrays of Reals/Reals/Reals/Bools/pointers, sorted by first array in non-decreasing order"]
    pub fn SCIPsortedvecInsertRealRealRealBoolPtr(
        realarray1: *mut f64,
        realarray2: *mut f64,
        realarray3: *mut f64,
        boolarray: *mut ::std::os::raw::c_uint,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        keyval: f64,
        field1val: f64,
        field2val: f64,
        field3val: ::std::os::raw::c_uint,
        field4val: *mut ::std::os::raw::c_void,
        len: *mut ::std::os::raw::c_int,
        pos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " insert a new element into six joint arrays of Reals/Reals/Reals/Bools/Bools/pointers, sorted by first array in non-decreasing order"]
    pub fn SCIPsortedvecInsertRealRealRealBoolBoolPtr(
        realarray1: *mut f64,
        realarray2: *mut f64,
        realarray3: *mut f64,
        boolarray1: *mut ::std::os::raw::c_uint,
        boolarray2: *mut ::std::os::raw::c_uint,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        keyval: f64,
        field1val: f64,
        field2val: f64,
        field3val: ::std::os::raw::c_uint,
        field4val: ::std::os::raw::c_uint,
        field5val: *mut ::std::os::raw::c_void,
        len: *mut ::std::os::raw::c_int,
        pos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " insert a new element into an array of ints in non-decreasing order"]
    pub fn SCIPsortedvecInsertInt(
        intarray: *mut ::std::os::raw::c_int,
        keyval: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
        pos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " insert a new element into two joint arrays of ints/ints, sorted by first array in non-decreasing order"]
    pub fn SCIPsortedvecInsertIntInt(
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        keyval: ::std::os::raw::c_int,
        field1val: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
        pos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " insert a new element into two joint arrays of ints/pointers, sorted by first array in non-decreasing order"]
    pub fn SCIPsortedvecInsertIntPtr(
        intarray: *mut ::std::os::raw::c_int,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        keyval: ::std::os::raw::c_int,
        field1val: *mut ::std::os::raw::c_void,
        len: *mut ::std::os::raw::c_int,
        pos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " insert a new element into two joint arrays of ints/reals, sorted by first array in non-decreasing order"]
    pub fn SCIPsortedvecInsertIntReal(
        intarray: *mut ::std::os::raw::c_int,
        realarray: *mut f64,
        keyval: ::std::os::raw::c_int,
        field1val: f64,
        len: *mut ::std::os::raw::c_int,
        pos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " insert a new element into three joint arrays of ints/ints/ints, sorted by first array in non-decreasing order"]
    pub fn SCIPsortedvecInsertIntIntInt(
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        intarray3: *mut ::std::os::raw::c_int,
        keyval: ::std::os::raw::c_int,
        field1val: ::std::os::raw::c_int,
        field2val: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
        pos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " insert a new element into three joint arrays of ints/ints/SCIP_Longint, sorted by first array in non-decreasing order"]
    pub fn SCIPsortedvecInsertIntIntLong(
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        longarray: *mut ::std::os::raw::c_longlong,
        keyval: ::std::os::raw::c_int,
        field1val: ::std::os::raw::c_int,
        field2val: ::std::os::raw::c_longlong,
        len: *mut ::std::os::raw::c_int,
        pos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " insert a new element into three joint arrays of ints/SCIP_Real/SCIP_Longint, sorted by first array in non-decreasing order"]
    pub fn SCIPsortedvecInsertIntRealLong(
        intarray: *mut ::std::os::raw::c_int,
        realarray: *mut f64,
        longarray: *mut ::std::os::raw::c_longlong,
        keyval: ::std::os::raw::c_int,
        field1val: f64,
        field2val: ::std::os::raw::c_longlong,
        len: *mut ::std::os::raw::c_int,
        pos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " insert a new element into three joint arrays of ints/ints/pointers, sorted by first array in non-decreasing order"]
    pub fn SCIPsortedvecInsertIntIntPtr(
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        keyval: ::std::os::raw::c_int,
        field1val: ::std::os::raw::c_int,
        field2val: *mut ::std::os::raw::c_void,
        len: *mut ::std::os::raw::c_int,
        pos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " insert a new element into three joint arrays of ints/ints/Reals, sorted by first array in non-decreasing order"]
    pub fn SCIPsortedvecInsertIntIntReal(
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        realarray: *mut f64,
        keyval: ::std::os::raw::c_int,
        field1val: ::std::os::raw::c_int,
        field2val: f64,
        len: *mut ::std::os::raw::c_int,
        pos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " insert a new element into three joint arrays of ints/pointers/Reals, sorted by first array in non-decreasing order"]
    pub fn SCIPsortedvecInsertIntPtrReal(
        intarray: *mut ::std::os::raw::c_int,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        realarray: *mut f64,
        keyval: ::std::os::raw::c_int,
        field1val: *mut ::std::os::raw::c_void,
        field2val: f64,
        len: *mut ::std::os::raw::c_int,
        pos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " insert a new element into four joint arrays of ints/ints/ints/pointers, sorted by first array in non-decreasing order"]
    pub fn SCIPsortedvecInsertIntIntIntPtr(
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        intarray3: *mut ::std::os::raw::c_int,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        keyval: ::std::os::raw::c_int,
        field1val: ::std::os::raw::c_int,
        field2val: ::std::os::raw::c_int,
        field3val: *mut ::std::os::raw::c_void,
        len: *mut ::std::os::raw::c_int,
        pos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " insert a new element into four joint arrays of ints/ints/ints/reals, sorted by first array in non-decreasing order"]
    pub fn SCIPsortedvecInsertIntIntIntReal(
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        intarray3: *mut ::std::os::raw::c_int,
        realarray: *mut f64,
        keyval: ::std::os::raw::c_int,
        field1val: ::std::os::raw::c_int,
        field2val: ::std::os::raw::c_int,
        field3val: f64,
        len: *mut ::std::os::raw::c_int,
        pos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " insert a new element into four joint arrays of ints/pointers/ints/reals, sorted by first array in non-decreasing order"]
    pub fn SCIPsortedvecInsertIntPtrIntReal(
        intarray1: *mut ::std::os::raw::c_int,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        intarray2: *mut ::std::os::raw::c_int,
        realarray: *mut f64,
        keyval: ::std::os::raw::c_int,
        field1val: *mut ::std::os::raw::c_void,
        field2val: ::std::os::raw::c_int,
        field3val: f64,
        len: *mut ::std::os::raw::c_int,
        pos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " insert a new element into an array of Longints, sorted in non-decreasing order"]
    pub fn SCIPsortedvecInsertLong(
        longarray: *mut ::std::os::raw::c_longlong,
        keyval: ::std::os::raw::c_longlong,
        len: *mut ::std::os::raw::c_int,
        pos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " insert a new element into two joint arrays of Long/pointer, sorted by the first array in non-decreasing order"]
    pub fn SCIPsortedvecInsertLongPtr(
        longarray: *mut ::std::os::raw::c_longlong,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        keyval: ::std::os::raw::c_longlong,
        field1val: *mut ::std::os::raw::c_void,
        len: *mut ::std::os::raw::c_int,
        pos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " insert a new element into three joint arrays of Long/pointer/ints, sorted by the first array in non-decreasing order"]
    pub fn SCIPsortedvecInsertLongPtrInt(
        longarray: *mut ::std::os::raw::c_longlong,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        intarray: *mut ::std::os::raw::c_int,
        keyval: ::std::os::raw::c_longlong,
        field1val: *mut ::std::os::raw::c_void,
        field2val: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
        pos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " insert a new element into four joint arrays of Long/pointer/Real/Bool, sorted by the first array in non-decreasing order"]
    pub fn SCIPsortedvecInsertLongPtrRealBool(
        longarray: *mut ::std::os::raw::c_longlong,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        realarray: *mut f64,
        boolarray: *mut ::std::os::raw::c_uint,
        keyval: ::std::os::raw::c_longlong,
        field1val: *mut ::std::os::raw::c_void,
        field2val: f64,
        field3val: ::std::os::raw::c_uint,
        len: *mut ::std::os::raw::c_int,
        pos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " insert a new element into five joint arrays of Long/pointer/Real/Real/Bool, sorted by the first array in non-decreasing order"]
    pub fn SCIPsortedvecInsertLongPtrRealRealBool(
        longarray: *mut ::std::os::raw::c_longlong,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        realarray: *mut f64,
        realarray2: *mut f64,
        boolarray: *mut ::std::os::raw::c_uint,
        keyval: ::std::os::raw::c_longlong,
        field1val: *mut ::std::os::raw::c_void,
        field2val: f64,
        field3val: f64,
        field4val: ::std::os::raw::c_uint,
        len: *mut ::std::os::raw::c_int,
        pos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " insert a new element into six joint arrays of Long/pointer/Real/Real/int/Bool, sorted by the first array in non-decreasing order"]
    pub fn SCIPsortedvecInsertLongPtrRealRealIntBool(
        longarray: *mut ::std::os::raw::c_longlong,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        realarray: *mut f64,
        realarray2: *mut f64,
        intarray: *mut ::std::os::raw::c_int,
        boolarray: *mut ::std::os::raw::c_uint,
        keyval: ::std::os::raw::c_longlong,
        field1val: *mut ::std::os::raw::c_void,
        field2val: f64,
        field3val: f64,
        field4val: ::std::os::raw::c_int,
        field5val: ::std::os::raw::c_uint,
        len: *mut ::std::os::raw::c_int,
        pos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " insert a new element into four joint arrays of Long/pointer/pointer/ints, sorted by first array in non-decreasing order"]
    pub fn SCIPsortedvecInsertLongPtrPtrInt(
        longarray: *mut ::std::os::raw::c_longlong,
        ptrarray1: *mut *mut ::std::os::raw::c_void,
        ptrarray2: *mut *mut ::std::os::raw::c_void,
        intarray: *mut ::std::os::raw::c_int,
        keyval: ::std::os::raw::c_longlong,
        field1val: *mut ::std::os::raw::c_void,
        field2val: *mut ::std::os::raw::c_void,
        field3val: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
        pos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " insert a new element into five joint arrays of Long/pointer/pointer/ints/ints, sorted by first array in non-decreasing order"]
    pub fn SCIPsortedvecInsertLongPtrPtrIntInt(
        longarray: *mut ::std::os::raw::c_longlong,
        ptrarray1: *mut *mut ::std::os::raw::c_void,
        ptrarray2: *mut *mut ::std::os::raw::c_void,
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        keyval: ::std::os::raw::c_longlong,
        field1val: *mut ::std::os::raw::c_void,
        field2val: *mut ::std::os::raw::c_void,
        field3val: ::std::os::raw::c_int,
        field4val: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
        pos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " insert a new element into five joint arrays of Long/pointer/pointer/Bool/ints, sorted by first array in non-decreasing order"]
    pub fn SCIPsortedvecInsertLongPtrPtrBoolInt(
        longarray: *mut ::std::os::raw::c_longlong,
        ptrarray1: *mut *mut ::std::os::raw::c_void,
        ptrarray2: *mut *mut ::std::os::raw::c_void,
        boolarray: *mut ::std::os::raw::c_uint,
        intarray: *mut ::std::os::raw::c_int,
        keyval: ::std::os::raw::c_longlong,
        field1val: *mut ::std::os::raw::c_void,
        field2val: *mut ::std::os::raw::c_void,
        field3val: ::std::os::raw::c_uint,
        field4val: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
        pos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " insert a new element into five joint arrays of pointer/ints/ints/Bool/Bool, sorted by first array in non-decreasing order"]
    pub fn SCIPsortedvecInsertPtrIntIntBoolBool(
        ptrarray: *mut *mut ::std::os::raw::c_void,
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        boolarray1: *mut ::std::os::raw::c_uint,
        boolarray2: *mut ::std::os::raw::c_uint,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        keyval: *mut ::std::os::raw::c_void,
        field1val: ::std::os::raw::c_int,
        field2val: ::std::os::raw::c_int,
        field3val: ::std::os::raw::c_uint,
        field4val: ::std::os::raw::c_uint,
        len: *mut ::std::os::raw::c_int,
        pos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " insert a new element into six joint arrays of ints/pointer/ints/ints/Bool/Bool, sorted by first array in non-decreasing order"]
    pub fn SCIPsortedvecInsertIntPtrIntIntBoolBool(
        intarray1: *mut ::std::os::raw::c_int,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        intarray2: *mut ::std::os::raw::c_int,
        intarray3: *mut ::std::os::raw::c_int,
        boolarray1: *mut ::std::os::raw::c_uint,
        boolarray2: *mut ::std::os::raw::c_uint,
        keyval: ::std::os::raw::c_int,
        field1val: *mut ::std::os::raw::c_void,
        field2val: ::std::os::raw::c_int,
        field3val: ::std::os::raw::c_int,
        field4val: ::std::os::raw::c_uint,
        field5val: ::std::os::raw::c_uint,
        len: *mut ::std::os::raw::c_int,
        pos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " insert a new element into an index array in non-increasing order"]
    pub fn SCIPsortedvecInsertDownInd(
        indarray: *mut ::std::os::raw::c_int,
        indcomp: ::std::option::Option<
            unsafe extern "C" fn(
                dataptr: *mut ::std::os::raw::c_void,
                ind1: ::std::os::raw::c_int,
                ind2: ::std::os::raw::c_int,
            ) -> ::std::os::raw::c_int,
        >,
        dataptr: *mut ::std::os::raw::c_void,
        keyval: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
        pos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " insert a new element into an array of pointers in non-increasing order"]
    pub fn SCIPsortedvecInsertDownPtr(
        ptrarray: *mut *mut ::std::os::raw::c_void,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        keyval: *mut ::std::os::raw::c_void,
        len: *mut ::std::os::raw::c_int,
        pos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " insert a new element into two joint arrays of pointers/pointers, sorted by first array in non-increasing order"]
    pub fn SCIPsortedvecInsertDownPtrPtr(
        ptrarray1: *mut *mut ::std::os::raw::c_void,
        ptrarray2: *mut *mut ::std::os::raw::c_void,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        keyval: *mut ::std::os::raw::c_void,
        field1val: *mut ::std::os::raw::c_void,
        len: *mut ::std::os::raw::c_int,
        pos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " insert a new element into two joint arrays of pointers/Reals, sorted by first array in non-increasing order"]
    pub fn SCIPsortedvecInsertDownPtrReal(
        ptrarray: *mut *mut ::std::os::raw::c_void,
        realarray: *mut f64,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        keyval: *mut ::std::os::raw::c_void,
        field1val: f64,
        len: *mut ::std::os::raw::c_int,
        pos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " insert a new element into two joint arrays of pointers/ints, sorted by first array in non-increasing order"]
    pub fn SCIPsortedvecInsertDownPtrInt(
        ptrarray: *mut *mut ::std::os::raw::c_void,
        intarray: *mut ::std::os::raw::c_int,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        keyval: *mut ::std::os::raw::c_void,
        field1val: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
        pos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " insert a new element into two joint arrays of pointers/Bools, sorted by first array in non-increasing order"]
    pub fn SCIPsortedvecInsertDownPtrBool(
        ptrarray: *mut *mut ::std::os::raw::c_void,
        boolarray: *mut ::std::os::raw::c_uint,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        keyval: *mut ::std::os::raw::c_void,
        field1val: ::std::os::raw::c_uint,
        len: *mut ::std::os::raw::c_int,
        pos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " insert a new element into three joint arrays of pointers/ints/ints, sorted by first array in non-increasing order"]
    pub fn SCIPsortedvecInsertDownPtrIntInt(
        ptrarray: *mut *mut ::std::os::raw::c_void,
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        keyval: *mut ::std::os::raw::c_void,
        field1val: ::std::os::raw::c_int,
        field2val: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
        pos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " insert a new element into three joint arrays of pointers/Reals/ints, sorted by first array in non-increasing order"]
    pub fn SCIPsortedvecInsertDownPtrRealInt(
        ptrarray: *mut *mut ::std::os::raw::c_void,
        realarray: *mut f64,
        intarray: *mut ::std::os::raw::c_int,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        keyval: *mut ::std::os::raw::c_void,
        field1val: f64,
        field2val: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
        pos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " insert a new element into three joint arrays of pointers/Reals/Bools, sorted by first array in non-increasing order"]
    pub fn SCIPsortedvecInsertDownPtrRealBool(
        ptrarray: *mut *mut ::std::os::raw::c_void,
        realarray: *mut f64,
        boolarray: *mut ::std::os::raw::c_uint,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        keyval: *mut ::std::os::raw::c_void,
        field1val: f64,
        field2val: ::std::os::raw::c_uint,
        len: *mut ::std::os::raw::c_int,
        pos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " insert a new element into three joint arrays of pointers/pointers/Ints, sorted by first array in non-increasing order"]
    pub fn SCIPsortedvecInsertDownPtrPtrInt(
        ptrarray1: *mut *mut ::std::os::raw::c_void,
        ptrarray2: *mut *mut ::std::os::raw::c_void,
        intarray: *mut ::std::os::raw::c_int,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        keyval: *mut ::std::os::raw::c_void,
        field1val: *mut ::std::os::raw::c_void,
        field2val: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
        pos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " insert a new element into three joint arrays of pointers/pointers/Reals, sorted by first array in non-increasing order"]
    pub fn SCIPsortedvecInsertDownPtrPtrReal(
        ptrarray1: *mut *mut ::std::os::raw::c_void,
        ptrarray2: *mut *mut ::std::os::raw::c_void,
        realarray: *mut f64,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        keyval: *mut ::std::os::raw::c_void,
        field1val: *mut ::std::os::raw::c_void,
        field2val: f64,
        len: *mut ::std::os::raw::c_int,
        pos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " insert a new element into four joint arrays of pointers/pointers/ints/ints, sorted by first array in non-increasing order"]
    pub fn SCIPsortedvecInsertDownPtrPtrIntInt(
        ptrarray1: *mut *mut ::std::os::raw::c_void,
        ptrarray2: *mut *mut ::std::os::raw::c_void,
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        keyval: *mut ::std::os::raw::c_void,
        field1val: *mut ::std::os::raw::c_void,
        field2val: ::std::os::raw::c_int,
        field3val: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
        pos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " insert a new element into four joint arrays of pointers/Reals/ints/ints, sorted by first array in non-increasing order"]
    pub fn SCIPsortedvecInsertDownPtrRealIntInt(
        ptrarray: *mut *mut ::std::os::raw::c_void,
        realarray: *mut f64,
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        keyval: *mut ::std::os::raw::c_void,
        field1val: f64,
        field2val: ::std::os::raw::c_int,
        field3val: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
        pos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " insert a new element into four joint arrays of pointer/pointer/Reals/ints, sorted by first array in non-increasing order"]
    pub fn SCIPsortedvecInsertDownPtrPtrRealInt(
        ptrarray1: *mut *mut ::std::os::raw::c_void,
        ptrarray2: *mut *mut ::std::os::raw::c_void,
        realarray: *mut f64,
        intarray: *mut ::std::os::raw::c_int,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        keyval: *mut ::std::os::raw::c_void,
        field1val: *mut ::std::os::raw::c_void,
        field2val: f64,
        field3val: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
        pos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " insert a new element into four joint arrays of pointer/pointer/Reals/bools, sorted by first array in non-increasing order"]
    pub fn SCIPsortedvecInsertDownPtrPtrRealBool(
        ptrarray1: *mut *mut ::std::os::raw::c_void,
        ptrarray2: *mut *mut ::std::os::raw::c_void,
        realarray: *mut f64,
        boolarray: *mut ::std::os::raw::c_uint,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        keyval: *mut ::std::os::raw::c_void,
        field1val: *mut ::std::os::raw::c_void,
        field2val: f64,
        field3val: ::std::os::raw::c_uint,
        len: *mut ::std::os::raw::c_int,
        pos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " insert a new element into four joint arrays of pointer/pointer/Longs/ints, sorted by first array in non-increasing order"]
    pub fn SCIPsortedvecInsertDownPtrPtrLongInt(
        ptrarray1: *mut *mut ::std::os::raw::c_void,
        ptrarray2: *mut *mut ::std::os::raw::c_void,
        longarray: *mut ::std::os::raw::c_longlong,
        intarray: *mut ::std::os::raw::c_int,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        keyval: *mut ::std::os::raw::c_void,
        field1val: *mut ::std::os::raw::c_void,
        field2val: ::std::os::raw::c_longlong,
        field3val: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
        pos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " insert a new element into five joint arrays of pointer/pointer/Longs/ints/ints, sorted by first array in non-increasing order"]
    pub fn SCIPsortedvecInsertDownPtrPtrLongIntInt(
        ptrarray1: *mut *mut ::std::os::raw::c_void,
        ptrarray2: *mut *mut ::std::os::raw::c_void,
        longarray: *mut ::std::os::raw::c_longlong,
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        keyval: *mut ::std::os::raw::c_void,
        field1val: *mut ::std::os::raw::c_void,
        field2val: ::std::os::raw::c_longlong,
        field3val: ::std::os::raw::c_int,
        field4val: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
        pos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " insert a new element into an array of Reals, sorted in non-increasing order"]
    pub fn SCIPsortedvecInsertDownReal(
        realarray: *mut f64,
        keyval: f64,
        len: *mut ::std::os::raw::c_int,
        pos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " insert a new element into three joint arrays of Reals/Bools/pointers, sorted by first array in non-increasing order"]
    pub fn SCIPsortedvecInsertDownRealBoolPtr(
        realarray: *mut f64,
        boolarray: *mut ::std::os::raw::c_uint,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        keyval: f64,
        field1val: ::std::os::raw::c_uint,
        field2val: *mut ::std::os::raw::c_void,
        len: *mut ::std::os::raw::c_int,
        pos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " insert a new element into two joint arrays of Reals/pointers, sorted by first array in non-increasing order"]
    pub fn SCIPsortedvecInsertDownRealPtr(
        realarray: *mut f64,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        keyval: f64,
        field1val: *mut ::std::os::raw::c_void,
        len: *mut ::std::os::raw::c_int,
        pos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " insert a new element into three joint arrays of Reals/pointers, sorted by first array in non-increasing order"]
    pub fn SCIPsortedvecInsertDownRealPtrPtr(
        realarray: *mut f64,
        ptrarray1: *mut *mut ::std::os::raw::c_void,
        ptrarray2: *mut *mut ::std::os::raw::c_void,
        keyval: f64,
        field1val: *mut ::std::os::raw::c_void,
        field2val: *mut ::std::os::raw::c_void,
        len: *mut ::std::os::raw::c_int,
        pos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " insert a new element into two joint arrays of Reals/ints, sorted by first array in non-increasing order"]
    pub fn SCIPsortedvecInsertDownRealInt(
        realarray: *mut f64,
        intarray: *mut ::std::os::raw::c_int,
        keyval: f64,
        field1val: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
        pos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " insert a new element into three joint arrays of Reals/ints/ints, sorted by first array in non-increasing order"]
    pub fn SCIPsortedvecInsertDownRealIntInt(
        realarray: *mut f64,
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        keyval: f64,
        field1val: ::std::os::raw::c_int,
        field2val: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
        pos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " insert a new element into three joint arrays of Reals/Reals/ints, sorted by first array in non-increasing order"]
    pub fn SCIPsortedvecInsertDownRealRealInt(
        realarray: *mut f64,
        realarray2: *mut f64,
        intarray: *mut ::std::os::raw::c_int,
        keyval: f64,
        field1val: f64,
        field2val: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
        pos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " insert a new element into three joint arrays of Reals/ints/Longs, sorted by first array in non-increasing order"]
    pub fn SCIPsortedvecInsertDownRealIntLong(
        realarray: *mut f64,
        intarray: *mut ::std::os::raw::c_int,
        longarray: *mut ::std::os::raw::c_longlong,
        keyval: f64,
        field1val: ::std::os::raw::c_int,
        field2val: ::std::os::raw::c_longlong,
        len: *mut ::std::os::raw::c_int,
        pos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " insert a new element into three joint arrays of Reals/ints/Pointer, sorted by first array in non-increasing order"]
    pub fn SCIPsortedvecInsertDownRealIntPtr(
        realarray: *mut f64,
        intarray: *mut ::std::os::raw::c_int,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        keyval: f64,
        field1val: ::std::os::raw::c_int,
        field2val: *mut ::std::os::raw::c_void,
        len: *mut ::std::os::raw::c_int,
        pos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " insert a new element into three joint arrays of Reals/Reals/Pointer, sorted by first array in non-increasing order"]
    pub fn SCIPsortedvecInsertDownRealRealPtr(
        realarray1: *mut f64,
        realarray2: *mut f64,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        keyval: f64,
        field1val: f64,
        field2val: *mut ::std::os::raw::c_void,
        len: *mut ::std::os::raw::c_int,
        pos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " insert a new element into three joint arrays of Reals/Reals/Pointer/Pointer, sorted by first array in non-increasing order"]
    pub fn SCIPsortedvecInsertDownRealRealPtrPtr(
        realarray1: *mut f64,
        realarray2: *mut f64,
        ptrarray1: *mut *mut ::std::os::raw::c_void,
        ptrarray2: *mut *mut ::std::os::raw::c_void,
        keyval: f64,
        field1val: f64,
        field2val: *mut ::std::os::raw::c_void,
        field3val: *mut ::std::os::raw::c_void,
        len: *mut ::std::os::raw::c_int,
        pos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " insert a new element into four joint arrays of Reals/pointers/pointers/ints, sorted by first array in non-increasing order"]
    pub fn SCIPsortedvecInsertDownRealPtrPtrInt(
        realarray: *mut f64,
        ptrarray1: *mut *mut ::std::os::raw::c_void,
        ptrarray2: *mut *mut ::std::os::raw::c_void,
        intarray: *mut ::std::os::raw::c_int,
        keyval: f64,
        field1val: *mut ::std::os::raw::c_void,
        field2val: *mut ::std::os::raw::c_void,
        intval: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
        pos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " insert a new element into five joint arrays of Reals/pointers/pointers/ints/ints, sorted by first array in non-increasing order"]
    pub fn SCIPsortedvecInsertDownRealPtrPtrIntInt(
        realarray: *mut f64,
        ptrarray1: *mut *mut ::std::os::raw::c_void,
        ptrarray2: *mut *mut ::std::os::raw::c_void,
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        keyval: f64,
        field1val: *mut ::std::os::raw::c_void,
        field2val: *mut ::std::os::raw::c_void,
        intval1: ::std::os::raw::c_int,
        intval2: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
        pos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " insert a new element into four joint arrays of Reals/Longs/Reals/ints, sorted by first array in non-increasing order"]
    pub fn SCIPsortedvecInsertDownRealLongRealInt(
        realarray1: *mut f64,
        longarray: *mut ::std::os::raw::c_longlong,
        realarray3: *mut f64,
        intarray: *mut ::std::os::raw::c_int,
        keyval: f64,
        field1val: ::std::os::raw::c_longlong,
        field2val: f64,
        field3val: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
        pos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " insert a new element into four joint arrays of Reals/Reals/ints/ints, sorted by first array in non-increasing order"]
    pub fn SCIPsortedvecInsertDownRealRealIntInt(
        realarray1: *mut f64,
        realarray2: *mut f64,
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        keyval: f64,
        field1val: f64,
        field2val: ::std::os::raw::c_int,
        field3val: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
        pos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " insert a new element into four joint arrays of Reals/Reals/Reals/ints, sorted by first array in non-increasing order"]
    pub fn SCIPsortedvecInsertDownRealRealRealInt(
        realarray1: *mut f64,
        realarray2: *mut f64,
        realarray3: *mut f64,
        intarray: *mut ::std::os::raw::c_int,
        keyval: f64,
        field1val: f64,
        field2val: f64,
        field3val: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
        pos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " insert a new element into four joint arrays of Reals/Reals/Reals/pointers, sorted by first array in non-increasing order"]
    pub fn SCIPsortedvecInsertDownRealRealRealPtr(
        realarray1: *mut f64,
        realarray2: *mut f64,
        realarray3: *mut f64,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        keyval: f64,
        field1val: f64,
        field2val: f64,
        field3val: *mut ::std::os::raw::c_void,
        len: *mut ::std::os::raw::c_int,
        pos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " insert a new element into five joint arrays of Reals/Reals/Reals/Bools/pointers, sorted by first array in non-increasing order"]
    pub fn SCIPsortedvecInsertDownRealRealRealBoolPtr(
        realarray1: *mut f64,
        realarray2: *mut f64,
        realarray3: *mut f64,
        boolarray: *mut ::std::os::raw::c_uint,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        keyval: f64,
        field1val: f64,
        field2val: f64,
        field3val: ::std::os::raw::c_uint,
        field4val: *mut ::std::os::raw::c_void,
        len: *mut ::std::os::raw::c_int,
        pos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " insert a new element into six joint arrays of Reals/Reals/Reals/Bools/Bools/pointers, sorted by first array in non-increasing order"]
    pub fn SCIPsortedvecInsertDownRealRealRealBoolBoolPtr(
        realarray1: *mut f64,
        realarray2: *mut f64,
        realarray3: *mut f64,
        boolarray1: *mut ::std::os::raw::c_uint,
        boolarray2: *mut ::std::os::raw::c_uint,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        keyval: f64,
        field1val: f64,
        field2val: f64,
        field3val: ::std::os::raw::c_uint,
        field4val: ::std::os::raw::c_uint,
        field5val: *mut ::std::os::raw::c_void,
        len: *mut ::std::os::raw::c_int,
        pos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " insert a new element into an array of ints in non-increasing order"]
    pub fn SCIPsortedvecInsertDownInt(
        intarray: *mut ::std::os::raw::c_int,
        keyval: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
        pos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " insert a new element into two joint arrays of ints/ints, sorted by first array in non-increasing order"]
    pub fn SCIPsortedvecInsertDownIntInt(
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        keyval: ::std::os::raw::c_int,
        field1val: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
        pos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " insert a new element into two joint arrays of ints/reals, sorted by first array in non-increasing order"]
    pub fn SCIPsortedvecInsertDownIntReal(
        intarray: *mut ::std::os::raw::c_int,
        realarray: *mut f64,
        keyval: ::std::os::raw::c_int,
        field1val: f64,
        len: *mut ::std::os::raw::c_int,
        pos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " insert a new element into three joint arrays of ints/ints/ints, sorted by first array in non-increasing order"]
    pub fn SCIPsortedvecInsertDownIntIntInt(
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        intarray3: *mut ::std::os::raw::c_int,
        keyval: ::std::os::raw::c_int,
        field1val: ::std::os::raw::c_int,
        field2val: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
        pos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " insert a new element into three joint arrays of ints/ints/SCIP_Longint, sorted by first array in non-increasing order"]
    pub fn SCIPsortedvecInsertDownIntIntLong(
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        longarray: *mut ::std::os::raw::c_longlong,
        keyval: ::std::os::raw::c_int,
        field1val: ::std::os::raw::c_int,
        field2val: ::std::os::raw::c_longlong,
        len: *mut ::std::os::raw::c_int,
        pos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " insert a new element into three joint arrays of ints/ints/pointers, sorted by first array in non-increasing order"]
    pub fn SCIPsortedvecInsertDownIntIntPtr(
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        keyval: ::std::os::raw::c_int,
        field1val: ::std::os::raw::c_int,
        field2val: *mut ::std::os::raw::c_void,
        len: *mut ::std::os::raw::c_int,
        pos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " insert a new element into three joint arrays of ints/ints/Reals, sorted by first array in non-increasing order"]
    pub fn SCIPsortedvecInsertDownIntIntReal(
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        realarray: *mut f64,
        keyval: ::std::os::raw::c_int,
        field1val: ::std::os::raw::c_int,
        field2val: f64,
        len: *mut ::std::os::raw::c_int,
        pos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " insert a new element into two joint arrays of ints/pointers, sorted by first array in non-increasing order"]
    pub fn SCIPsortedvecInsertDownIntPtr(
        intarray: *mut ::std::os::raw::c_int,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        keyval: ::std::os::raw::c_int,
        field1val: *mut ::std::os::raw::c_void,
        len: *mut ::std::os::raw::c_int,
        pos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " insert a new element into four joint arrays of ints/pointers/ints/Reals, sorted by first array in non-increasing order"]
    pub fn SCIPsortedvecInsertDownIntIntIntPtr(
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        intarray3: *mut ::std::os::raw::c_int,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        keyval: ::std::os::raw::c_int,
        field1val: ::std::os::raw::c_int,
        field2val: ::std::os::raw::c_int,
        field3val: *mut ::std::os::raw::c_void,
        len: *mut ::std::os::raw::c_int,
        pos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " insert a new element into four joint arrays of ints/int/ints/reals, sorted by first array in non-increasing order"]
    pub fn SCIPsortedvecInsertDownIntIntIntReal(
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        intarray3: *mut ::std::os::raw::c_int,
        realarray: *mut f64,
        keyval: ::std::os::raw::c_int,
        field1val: ::std::os::raw::c_int,
        field2val: ::std::os::raw::c_int,
        field3val: f64,
        len: *mut ::std::os::raw::c_int,
        pos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " insert a new element into four joint arrays of ints/pointers/ints/reals, sorted by first array in non-increasing order"]
    pub fn SCIPsortedvecInsertDownIntPtrIntReal(
        intarray1: *mut ::std::os::raw::c_int,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        intarray2: *mut ::std::os::raw::c_int,
        realarray: *mut f64,
        keyval: ::std::os::raw::c_int,
        field1val: *mut ::std::os::raw::c_void,
        field2val: ::std::os::raw::c_int,
        field3val: f64,
        len: *mut ::std::os::raw::c_int,
        pos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " insert a new element into an array of Longints, sorted in non-increasing order"]
    pub fn SCIPsortedvecInsertDownLong(
        longarray: *mut ::std::os::raw::c_longlong,
        keyval: ::std::os::raw::c_longlong,
        len: *mut ::std::os::raw::c_int,
        pos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " insert a new element into two joint arrays of Long/pointer, sorted by the first array in non-increasing order"]
    pub fn SCIPsortedvecInsertDownLongPtr(
        longarray: *mut ::std::os::raw::c_longlong,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        keyval: ::std::os::raw::c_longlong,
        field1val: *mut ::std::os::raw::c_void,
        len: *mut ::std::os::raw::c_int,
        pos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " insert a new element into three joint arrays of Long/pointer/ints, sorted by the first array in non-increasing order"]
    pub fn SCIPsortedvecInsertDownLongPtrInt(
        longarray: *mut ::std::os::raw::c_longlong,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        intarray: *mut ::std::os::raw::c_int,
        keyval: ::std::os::raw::c_longlong,
        field1val: *mut ::std::os::raw::c_void,
        field2val: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
        pos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " insert a new element into four joint arrays of Long/pointer/Real/Bool, sorted by the first array in non-increasing order"]
    pub fn SCIPsortedvecInsertDownLongPtrRealBool(
        longarray: *mut ::std::os::raw::c_longlong,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        realarray: *mut f64,
        boolarray: *mut ::std::os::raw::c_uint,
        keyval: ::std::os::raw::c_longlong,
        field1val: *mut ::std::os::raw::c_void,
        field2val: f64,
        field3val: ::std::os::raw::c_uint,
        len: *mut ::std::os::raw::c_int,
        pos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " insert a new element into five joint arrays of Long/pointer/Real/Real/Bool, sorted by the first array in non-increasing order"]
    pub fn SCIPsortedvecInsertDownLongPtrRealRealBool(
        longarray: *mut ::std::os::raw::c_longlong,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        realarray: *mut f64,
        realarray2: *mut f64,
        boolarray: *mut ::std::os::raw::c_uint,
        keyval: ::std::os::raw::c_longlong,
        field1val: *mut ::std::os::raw::c_void,
        field2val: f64,
        field3val: f64,
        field4val: ::std::os::raw::c_uint,
        len: *mut ::std::os::raw::c_int,
        pos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " insert a new element into six joint arrays of Long/pointer/Real/Real/int/Bool, sorted by the first array in non-increasing order"]
    pub fn SCIPsortedvecInsertDownLongPtrRealRealIntBool(
        longarray: *mut ::std::os::raw::c_longlong,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        realarray: *mut f64,
        realarray2: *mut f64,
        intarray: *mut ::std::os::raw::c_int,
        boolarray: *mut ::std::os::raw::c_uint,
        keyval: ::std::os::raw::c_longlong,
        field1val: *mut ::std::os::raw::c_void,
        field2val: f64,
        field3val: f64,
        field4val: ::std::os::raw::c_int,
        field5val: ::std::os::raw::c_uint,
        len: *mut ::std::os::raw::c_int,
        pos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " insert a new element into four joint arrays of Long/pointer/pointer/ints, sorted by first array in non-increasing order"]
    pub fn SCIPsortedvecInsertDownLongPtrPtrInt(
        longarray: *mut ::std::os::raw::c_longlong,
        ptrarray1: *mut *mut ::std::os::raw::c_void,
        ptrarray2: *mut *mut ::std::os::raw::c_void,
        intarray: *mut ::std::os::raw::c_int,
        keyval: ::std::os::raw::c_longlong,
        field1val: *mut ::std::os::raw::c_void,
        field2val: *mut ::std::os::raw::c_void,
        field3val: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
        pos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " insert a new element into five joint arrays of Long/pointer/pointer/ints/ints, sorted by first array in non-increasing order"]
    pub fn SCIPsortedvecInsertDownLongPtrPtrIntInt(
        longarray: *mut ::std::os::raw::c_longlong,
        ptrarray1: *mut *mut ::std::os::raw::c_void,
        ptrarray2: *mut *mut ::std::os::raw::c_void,
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        keyval: ::std::os::raw::c_longlong,
        field1val: *mut ::std::os::raw::c_void,
        field2val: *mut ::std::os::raw::c_void,
        field3val: ::std::os::raw::c_int,
        field4val: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
        pos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " insert a new element into five joint arrays of Long/pointer/pointer/Bool/ints, sorted by first array in non-increasing order"]
    pub fn SCIPsortedvecInsertDownLongPtrPtrBoolInt(
        longarray: *mut ::std::os::raw::c_longlong,
        ptrarray1: *mut *mut ::std::os::raw::c_void,
        ptrarray2: *mut *mut ::std::os::raw::c_void,
        boolarray: *mut ::std::os::raw::c_uint,
        intarray: *mut ::std::os::raw::c_int,
        keyval: ::std::os::raw::c_longlong,
        field1val: *mut ::std::os::raw::c_void,
        field2val: *mut ::std::os::raw::c_void,
        field3val: ::std::os::raw::c_uint,
        field4val: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
        pos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " insert a new element into five joint arrays of pointer/ints/ints/Bool/Bool, sorted by first array in non-increasing order"]
    pub fn SCIPsortedvecInsertDownPtrIntIntBoolBool(
        ptrarray: *mut *mut ::std::os::raw::c_void,
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        boolarray1: *mut ::std::os::raw::c_uint,
        boolarray2: *mut ::std::os::raw::c_uint,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        keyval: *mut ::std::os::raw::c_void,
        field1val: ::std::os::raw::c_int,
        field2val: ::std::os::raw::c_int,
        field3val: ::std::os::raw::c_uint,
        field4val: ::std::os::raw::c_uint,
        len: *mut ::std::os::raw::c_int,
        pos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " insert a new element into six joint arrays of ints/pointer/ints/ints/Bool/Bool, sorted by first array in non-increased order"]
    pub fn SCIPsortedvecInsertDownIntPtrIntIntBoolBool(
        intarray1: *mut ::std::os::raw::c_int,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        intarray2: *mut ::std::os::raw::c_int,
        intarray3: *mut ::std::os::raw::c_int,
        boolarray1: *mut ::std::os::raw::c_uint,
        boolarray2: *mut ::std::os::raw::c_uint,
        keyval: ::std::os::raw::c_int,
        field1val: *mut ::std::os::raw::c_void,
        field2val: ::std::os::raw::c_int,
        field3val: ::std::os::raw::c_int,
        field4val: ::std::os::raw::c_uint,
        field5val: ::std::os::raw::c_uint,
        len: *mut ::std::os::raw::c_int,
        pos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " delete the element at the given position from an index array in non-decreasing order"]
    pub fn SCIPsortedvecDelPosInd(
        indarray: *mut ::std::os::raw::c_int,
        indcomp: ::std::option::Option<
            unsafe extern "C" fn(
                dataptr: *mut ::std::os::raw::c_void,
                ind1: ::std::os::raw::c_int,
                ind2: ::std::os::raw::c_int,
            ) -> ::std::os::raw::c_int,
        >,
        dataptr: *mut ::std::os::raw::c_void,
        pos: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " delete the element at the given position from an array of pointers in non-decreasing order"]
    pub fn SCIPsortedvecDelPosPtr(
        ptrarray: *mut *mut ::std::os::raw::c_void,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        pos: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " delete the element at the given position from two joint arrays of pointers/pointers, sorted by first array in non-decreasing order"]
    pub fn SCIPsortedvecDelPosPtrPtr(
        ptrarray1: *mut *mut ::std::os::raw::c_void,
        ptrarray2: *mut *mut ::std::os::raw::c_void,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        pos: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " delete the element at the given position from two joint arrays of pointers/Reals, sorted by first array in non-decreasing order"]
    pub fn SCIPsortedvecDelPosPtrReal(
        ptrarray: *mut *mut ::std::os::raw::c_void,
        realarray: *mut f64,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        pos: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " delete the element at the given position from two joint arrays of pointers/ints, sorted by first array in non-decreasing order"]
    pub fn SCIPsortedvecDelPosPtrInt(
        ptrarray: *mut *mut ::std::os::raw::c_void,
        intarray: *mut ::std::os::raw::c_int,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        pos: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " delete the element at the given position from two joint arrays of pointers/Bools, sorted by first array in non-decreasing order"]
    pub fn SCIPsortedvecDelPosPtrBool(
        ptrarray: *mut *mut ::std::os::raw::c_void,
        boolarray: *mut ::std::os::raw::c_uint,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        pos: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " delete the element at the given position from three joint arrays of pointers/ints/ints, sorted by first array in non-decreasing order"]
    pub fn SCIPsortedvecDelPosPtrIntInt(
        ptrarray: *mut *mut ::std::os::raw::c_void,
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        pos: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " delete the element at the given position from three joint arrays of pointers/Reals/ints, sorted by first array in non-decreasing order"]
    pub fn SCIPsortedvecDelPosPtrRealInt(
        ptrarray: *mut *mut ::std::os::raw::c_void,
        realarray: *mut f64,
        intarray: *mut ::std::os::raw::c_int,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        pos: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " delete the element at the given position from four joint arrays of pointers/RealsReals//ints, sorted by first array in non-decreasing order"]
    pub fn SCIPsortedvecDelPosPtrRealRealInt(
        ptrarray: *mut *mut ::std::os::raw::c_void,
        realarray1: *mut f64,
        realarray2: *mut f64,
        intarray: *mut ::std::os::raw::c_int,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        pos: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " delete the element at the given position from four joint arrays of pointers/RealsReals/SCIP_Bools/SCIP_Bools, sorted by first array in non-decreasing order"]
    pub fn SCIPsortedvecDelPosPtrRealRealBoolBool(
        ptrarray: *mut *mut ::std::os::raw::c_void,
        realarray1: *mut f64,
        realarray2: *mut f64,
        boolarray1: *mut ::std::os::raw::c_uint,
        boolarray2: *mut ::std::os::raw::c_uint,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        pos: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " delete the element at the given position from four joint arrays of pointers/RealsReals/ints/SCIP_Bools, sorted by first array in non-decreasing order"]
    pub fn SCIPsortedvecDelPosPtrRealRealIntBool(
        ptrarray: *mut *mut ::std::os::raw::c_void,
        realarray1: *mut f64,
        realarray2: *mut f64,
        intarray: *mut ::std::os::raw::c_int,
        boolarray: *mut ::std::os::raw::c_uint,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        pos: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " delete the element at the given position from three joint arrays of pointers/Reals/Bools, sorted by first array in non-decreasing order"]
    pub fn SCIPsortedvecDelPosPtrRealBool(
        ptrarray: *mut *mut ::std::os::raw::c_void,
        realarray: *mut f64,
        boolarray: *mut ::std::os::raw::c_uint,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        pos: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " delete the element at the given position from three joint arrays of pointers/pointers/Ints, sorted by first array in non-decreasing order"]
    pub fn SCIPsortedvecDelPosPtrPtrInt(
        ptrarray1: *mut *mut ::std::os::raw::c_void,
        ptrarray2: *mut *mut ::std::os::raw::c_void,
        intarray: *mut ::std::os::raw::c_int,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        pos: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " delete the element at the given position from three joint arrays of pointers/pointers/Reals, sorted by first array in non-decreasing order"]
    pub fn SCIPsortedvecDelPosPtrPtrReal(
        ptrarray1: *mut *mut ::std::os::raw::c_void,
        ptrarray2: *mut *mut ::std::os::raw::c_void,
        realarray: *mut f64,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        pos: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " delete the element at the given position from four joint arrays of pointers/pointers/ints/ints, sorted by first array in non-decreasing order"]
    pub fn SCIPsortedvecDelPosPtrPtrIntInt(
        ptrarray1: *mut *mut ::std::os::raw::c_void,
        ptrarray2: *mut *mut ::std::os::raw::c_void,
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        pos: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " delete the element at the given position from four joint arrays of pointers/Reals/ints/ints, sorted by first array in non-decreasing order"]
    pub fn SCIPsortedvecDelPosPtrRealIntInt(
        ptrarray: *mut *mut ::std::os::raw::c_void,
        realarray: *mut f64,
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        pos: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " deletes the element at the given position from four joint arrays of pointer/pointer/Reals/ints, sorted by first array in non-decreasing order"]
    pub fn SCIPsortedvecDelPosPtrPtrRealInt(
        ptrarray1: *mut *mut ::std::os::raw::c_void,
        ptrarray2: *mut *mut ::std::os::raw::c_void,
        realarray: *mut f64,
        intarray: *mut ::std::os::raw::c_int,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        pos: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " deletes the element at the given position from four joint arrays of pointer/pointer/Reals/bools, sorted by first array in non-decreasing order"]
    pub fn SCIPsortedvecDelPosPtrPtrRealBool(
        ptrarray1: *mut *mut ::std::os::raw::c_void,
        ptrarray2: *mut *mut ::std::os::raw::c_void,
        realarray: *mut f64,
        boolarray: *mut ::std::os::raw::c_uint,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        pos: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " deletes the element at the given position from four joint arrays of pointer/pointer/Longs/ints, sorted by first array in non-decreasing order"]
    pub fn SCIPsortedvecDelPosPtrPtrLongInt(
        ptrarray1: *mut *mut ::std::os::raw::c_void,
        ptrarray2: *mut *mut ::std::os::raw::c_void,
        longarray: *mut ::std::os::raw::c_longlong,
        intarray: *mut ::std::os::raw::c_int,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        pos: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " deletes the element at the given position from five joint arrays of pointer/pointer/Longs/ints/ints, sorted by first array in non-decreasing order"]
    pub fn SCIPsortedvecDelPosPtrPtrLongIntInt(
        ptrarray1: *mut *mut ::std::os::raw::c_void,
        ptrarray2: *mut *mut ::std::os::raw::c_void,
        longarray: *mut ::std::os::raw::c_longlong,
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        pos: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " delete the element at the given position from three joint arrays of Reals/Bools/pointers, sorted by first array in non-decreasing order"]
    pub fn SCIPsortedvecDelPosRealBoolPtr(
        realarray: *mut f64,
        boolarray: *mut ::std::os::raw::c_uint,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        pos: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " delete the element at the given position from two joint arrays of Reals/pointers, sorted by first array in non-decreasing order"]
    pub fn SCIPsortedvecDelPosRealPtr(
        realarray: *mut f64,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        pos: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " delete the element at the given position from an arrays of Reals, sorted in non-decreasing order"]
    pub fn SCIPsortedvecDelPosReal(
        realarray: *mut f64,
        pos: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " delete the element at the given position from two joint arrays of Reals/ints, sorted by first array in non-decreasing order"]
    pub fn SCIPsortedvecDelPosRealInt(
        realarray: *mut f64,
        intarray: *mut ::std::os::raw::c_int,
        pos: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " delete the element at the given position from two joint arrays of Reals/ints, sorted by first array in non-decreasing order"]
    pub fn SCIPsortedvecDelPosRealIntInt(
        realarray: *mut f64,
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        pos: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " delete the element at the given position from three joint arrays of Reals/ints/Longs, sorted by first array in non-decreasing order"]
    pub fn SCIPsortedvecDelPosRealIntLong(
        realarray: *mut f64,
        intarray: *mut ::std::os::raw::c_int,
        longarray: *mut ::std::os::raw::c_longlong,
        pos: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " delete the element at the given position from three joint arrays of Reals/ints/Pointer, sorted by first array in non-decreasing order"]
    pub fn SCIPsortedvecDelPosRealIntPtr(
        realarray: *mut f64,
        intarray: *mut ::std::os::raw::c_int,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        pos: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " delete the element at the given position from three joint arrays of Reals/Reals/Pointer, sorted by first array in non-decreasing order"]
    pub fn SCIPsortedvecDelPosRealRealPtr(
        realarray1: *mut f64,
        realarray2: *mut f64,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        pos: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " delete the element at the given position from four joint arrays of Reals/pointers/pointers/ints, sorted by first array in non-decreasing order"]
    pub fn SCIPsortedvecDelPosRealPtrPtrInt(
        realarray: *mut f64,
        ptrarray1: *mut *mut ::std::os::raw::c_void,
        ptrarray2: *mut *mut ::std::os::raw::c_void,
        intarray: *mut ::std::os::raw::c_int,
        pos: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " delete the element at the given position from five joint arrays of Reals/pointers/pointers/ints/ints, sorted by first array in non-decreasing order"]
    pub fn SCIPsortedvecDelPosRealPtrPtrIntInt(
        realarray: *mut f64,
        ptrarray1: *mut *mut ::std::os::raw::c_void,
        ptrarray2: *mut *mut ::std::os::raw::c_void,
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        pos: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " delete the element at the given position from four joint arrays of Reals/Long/Reals/ints, sorted by first array in non-decreasing order"]
    pub fn SCIPsortedvecDelPosRealLongRealInt(
        realarray1: *mut f64,
        longarray: *mut ::std::os::raw::c_longlong,
        realarray3: *mut f64,
        intarray: *mut ::std::os::raw::c_int,
        pos: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " delete the element at the given position from four joint arrays of Reals/Reals/ints/ints, sorted by first array in non-decreasing order"]
    pub fn SCIPsortedvecDelPosRealRealIntInt(
        realarray1: *mut f64,
        realarray2: *mut f64,
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        pos: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " delete the element at the given position from four joint arrays of Reals/Reals/Reals/ints, sorted by first array in non-decreasing order"]
    pub fn SCIPsortedvecDelPosRealRealRealInt(
        realarray1: *mut f64,
        realarray2: *mut f64,
        realarray3: *mut f64,
        intarray: *mut ::std::os::raw::c_int,
        pos: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " delete the element at the given position from four joint arrays of Reals/Reals/Reals/pointers, sorted by first array in non-decreasing order"]
    pub fn SCIPsortedvecDelPosRealRealRealPtr(
        realarray1: *mut f64,
        realarray2: *mut f64,
        realarray3: *mut f64,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        pos: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " delete the element at the given position from five joint arrays of Reals/Reals/Reals/Bools/pointers, sorted by first array in non-decreasing order"]
    pub fn SCIPsortedvecDelPosRealRealRealBoolPtr(
        realarray1: *mut f64,
        realarray2: *mut f64,
        realarray3: *mut f64,
        boolarray: *mut ::std::os::raw::c_uint,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        pos: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " delete the element at the given position from six joint arrays of Reals/Reals/Reals/Bools/Bools/pointers, sorted by first array in non-decreasing order"]
    pub fn SCIPsortedvecDelPosRealRealRealBoolBoolPtr(
        realarray1: *mut f64,
        realarray2: *mut f64,
        realarray3: *mut f64,
        boolarray1: *mut ::std::os::raw::c_uint,
        boolarray2: *mut ::std::os::raw::c_uint,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        pos: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " delete the element at the given position from an array of ints in non-decreasing order"]
    pub fn SCIPsortedvecDelPosInt(
        intarray: *mut ::std::os::raw::c_int,
        pos: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " delete the element at the given position from two joint arrays of ints/ints, sorted by first array in non-decreasing order"]
    pub fn SCIPsortedvecDelPosIntInt(
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        pos: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " delete the element at the given position from two joint arrays of ints/reals, sorted by first array in non-decreasing order"]
    pub fn SCIPsortedvecDelPosIntReal(
        intarray: *mut ::std::os::raw::c_int,
        realarray: *mut f64,
        pos: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " delete the element at the given position from three joint arrays of ints/ints/ints, sorted by first array in non-decreasing order"]
    pub fn SCIPsortedvecDelPosIntIntInt(
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        intarray3: *mut ::std::os::raw::c_int,
        pos: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " delete the element at the given position from three joint arrays of ints/ints/SCIP_Longint, sorted by first array in non-decreasing order"]
    pub fn SCIPsortedvecDelPosIntIntLong(
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        longarray: *mut ::std::os::raw::c_longlong,
        pos: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " delete the element at the given position from three joint arrays of ints/SCIP_Real/SCIP_Longint, sorted by first array in non-decreasing order"]
    pub fn SCIPsortedvecDelPosIntRealLong(
        intarray: *mut ::std::os::raw::c_int,
        realarray: *mut f64,
        longarray: *mut ::std::os::raw::c_longlong,
        pos: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " delete the element at the given position from three joint arrays of ints/ints/pointers, sorted by first array in non-decreasing order"]
    pub fn SCIPsortedvecDelPosIntIntPtr(
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        pos: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " delete the element at the given position from three joint arrays of ints/ints/Reals, sorted by first array in non-decreasing order"]
    pub fn SCIPsortedvecDelPosIntIntReal(
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        realarray: *mut f64,
        pos: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " delete the element at the given position from two joint arrays of ints/pointers, sorted by first array in non-decreasing order"]
    pub fn SCIPsortedvecDelPosIntPtr(
        intarray: *mut ::std::os::raw::c_int,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        pos: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " delete the element at the given position from three joint arrays of ints/pointers/Reals, sorted by first array in non-decreasing order"]
    pub fn SCIPsortedvecDelPosIntPtrReal(
        intarray: *mut ::std::os::raw::c_int,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        realarray: *mut f64,
        pos: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " delete the element at the given position from four joint arrays of ints/ints/ints/pointers, sorted by first array in non-decreasing order"]
    pub fn SCIPsortedvecDelPosIntIntIntPtr(
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        intarray3: *mut ::std::os::raw::c_int,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        pos: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " delete the element at the given position from four joint arrays of ints/ints/ints/reals, sorted by first array in non-decreasing order"]
    pub fn SCIPsortedvecDelPosIntIntIntReal(
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        intarray3: *mut ::std::os::raw::c_int,
        realarray: *mut f64,
        pos: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " delete the element at the given position from four joint arrays of ints/pointers/ints/Reals, sorted by first array in non-decreasing order"]
    pub fn SCIPsortedvecDelPosIntPtrIntReal(
        intarray1: *mut ::std::os::raw::c_int,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        intarray2: *mut ::std::os::raw::c_int,
        realarray: *mut f64,
        pos: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " delete the element at the given position from an array of Longints, sorted by in non-decreasing order"]
    pub fn SCIPsortedvecDelPosLong(
        longarray: *mut ::std::os::raw::c_longlong,
        pos: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " delete the element at the given position from two joint arrays of Long/pointer, sorted by the first array in non-decreasing order"]
    pub fn SCIPsortedvecDelPosLongPtr(
        longarray: *mut ::std::os::raw::c_longlong,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        pos: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " delete the element at the given position from three joint arrays of Long/pointer/int, sorted by the first array in non-decreasing order"]
    pub fn SCIPsortedvecDelPosLongPtrInt(
        longarray: *mut ::std::os::raw::c_longlong,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        intarray: *mut ::std::os::raw::c_int,
        pos: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " delete the element at the given position from four joint arrays of Long/pointer/Real/Bool, sorted by the first array in non-decreasing order"]
    pub fn SCIPsortedvecDelPosLongPtrRealBool(
        longarray: *mut ::std::os::raw::c_longlong,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        realarray: *mut f64,
        boolarray: *mut ::std::os::raw::c_uint,
        pos: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " delete the element at the given position from five joint arrays of Long/pointer/Real/Real/Bool, sorted by the first array in non-decreasing order"]
    pub fn SCIPsortedvecDelPosLongPtrRealRealBool(
        longarray: *mut ::std::os::raw::c_longlong,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        realarray: *mut f64,
        realarray2: *mut f64,
        boolarray: *mut ::std::os::raw::c_uint,
        pos: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " delete the element at the given position from six joint arrays of Long/pointer/Real/Real/int/Bool, sorted by the first array in non-decreasing order"]
    pub fn SCIPsortedvecDelPosLongPtrRealRealIntBool(
        longarray: *mut ::std::os::raw::c_longlong,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        realarray: *mut f64,
        realarray2: *mut f64,
        intarray: *mut ::std::os::raw::c_int,
        boolarray: *mut ::std::os::raw::c_uint,
        pos: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " delete the element at the given position from four joint arrays of Long/pointer/pointer/ints, sorted by first array in non-decreasing order"]
    pub fn SCIPsortedvecDelPosLongPtrPtrInt(
        longarray: *mut ::std::os::raw::c_longlong,
        ptrarray1: *mut *mut ::std::os::raw::c_void,
        ptrarray2: *mut *mut ::std::os::raw::c_void,
        intarray: *mut ::std::os::raw::c_int,
        pos: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " delete the element at the given position from five joint arrays of Long/pointer/pointer/ints/ints, sorted by first array in non-decreasing order"]
    pub fn SCIPsortedvecDelPosLongPtrPtrIntInt(
        longarray: *mut ::std::os::raw::c_longlong,
        ptrarray1: *mut *mut ::std::os::raw::c_void,
        ptrarray2: *mut *mut ::std::os::raw::c_void,
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        pos: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " delete the element at the given position from five joint arrays of Long/pointer/pointer/Bool/ints, sorted by first array in non-decreasing order"]
    pub fn SCIPsortedvecDelPosLongPtrPtrBoolInt(
        longarray: *mut ::std::os::raw::c_longlong,
        ptrarray1: *mut *mut ::std::os::raw::c_void,
        ptrarray2: *mut *mut ::std::os::raw::c_void,
        boolarray: *mut ::std::os::raw::c_uint,
        intarray: *mut ::std::os::raw::c_int,
        pos: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " delete the element at the given position from five joint arrays of pointer/ints/ints/Bool/Bool, sorted by first array in non-decreasing order"]
    pub fn SCIPsortedvecDelPosPtrIntIntBoolBool(
        ptrarray: *mut *mut ::std::os::raw::c_void,
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        boolarray1: *mut ::std::os::raw::c_uint,
        boolarray2: *mut ::std::os::raw::c_uint,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        pos: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " delete the element at the given position from six joint arrays of ints/pointer/ints/ints/Bool/Bool, sorted by first array in non-decreasing order"]
    pub fn SCIPsortedvecDelPosIntPtrIntIntBoolBool(
        intarray1: *mut ::std::os::raw::c_int,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        intarray2: *mut ::std::os::raw::c_int,
        intarray3: *mut ::std::os::raw::c_int,
        boolarray1: *mut ::std::os::raw::c_uint,
        boolarray2: *mut ::std::os::raw::c_uint,
        pos: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " delete the element at the given position from an index array in non-increasing order"]
    pub fn SCIPsortedvecDelPosDownInd(
        indarray: *mut ::std::os::raw::c_int,
        indcomp: ::std::option::Option<
            unsafe extern "C" fn(
                dataptr: *mut ::std::os::raw::c_void,
                ind1: ::std::os::raw::c_int,
                ind2: ::std::os::raw::c_int,
            ) -> ::std::os::raw::c_int,
        >,
        dataptr: *mut ::std::os::raw::c_void,
        pos: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " delete the element at the given position from an array of pointers in non-increasing order"]
    pub fn SCIPsortedvecDelPosDownPtr(
        ptrarray: *mut *mut ::std::os::raw::c_void,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        pos: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " delete the element at the given position from two joint arrays of pointers/pointers, sorted by first array in non-increasing order"]
    pub fn SCIPsortedvecDelPosDownPtrPtr(
        ptrarray1: *mut *mut ::std::os::raw::c_void,
        ptrarray2: *mut *mut ::std::os::raw::c_void,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        pos: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " delete the element at the given position from two joint arrays of pointers/Reals, sorted by first array in non-increasing order"]
    pub fn SCIPsortedvecDelPosDownPtrReal(
        ptrarray: *mut *mut ::std::os::raw::c_void,
        realarray: *mut f64,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        pos: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " delete the element at the given position from two joint arrays of pointers/ints, sorted by first array in non-increasing order"]
    pub fn SCIPsortedvecDelPosDownPtrInt(
        ptrarray: *mut *mut ::std::os::raw::c_void,
        intarray: *mut ::std::os::raw::c_int,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        pos: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " delete the element at the given position from two joint arrays of pointers/Bools, sorted by first array in non-increasing order"]
    pub fn SCIPsortedvecDelPosDownPtrBool(
        ptrarray: *mut *mut ::std::os::raw::c_void,
        boolarray: *mut ::std::os::raw::c_uint,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        pos: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " delete the element at the given position from three joint arrays of pointers/ints/ints, sorted by first array in non-increasing order"]
    pub fn SCIPsortedvecDelPosDownPtrIntInt(
        ptrarray: *mut *mut ::std::os::raw::c_void,
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        pos: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " delete the element at the given position from three joint arrays of pointers/Reals/ints, sorted by first array in non-increasing order"]
    pub fn SCIPsortedvecDelPosDownPtrRealInt(
        ptrarray: *mut *mut ::std::os::raw::c_void,
        realarray: *mut f64,
        intarray: *mut ::std::os::raw::c_int,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        pos: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " delete the element at the given position from three joint arrays of pointers/Reals/Bools, sorted by first array in non-increasing order"]
    pub fn SCIPsortedvecDelPosDownPtrRealBool(
        ptrarray: *mut *mut ::std::os::raw::c_void,
        realarray: *mut f64,
        boolarray: *mut ::std::os::raw::c_uint,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        pos: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " delete the element at the given position from three joint arrays of pointers/pointers/Ints, sorted by first array in non-increasing order"]
    pub fn SCIPsortedvecDelPosDownPtrPtrInt(
        ptrarray1: *mut *mut ::std::os::raw::c_void,
        ptrarray2: *mut *mut ::std::os::raw::c_void,
        intarray: *mut ::std::os::raw::c_int,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        pos: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " delete the element at the given position from three joint arrays of pointers/pointers/Reals, sorted by first array in non-increasing order"]
    pub fn SCIPsortedvecDelPosDownPtrPtrReal(
        ptrarray1: *mut *mut ::std::os::raw::c_void,
        ptrarray2: *mut *mut ::std::os::raw::c_void,
        realarray: *mut f64,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        pos: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " delete the element at the given position from four joint arrays of pointers/pointers/ints/ints, sorted by first array in non-increasing order"]
    pub fn SCIPsortedvecDelPosDownPtrPtrIntInt(
        ptrarray1: *mut *mut ::std::os::raw::c_void,
        ptrarray2: *mut *mut ::std::os::raw::c_void,
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        pos: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " delete the element at the given position from four joint arrays of pointers/Reals/ints/ints, sorted by first array in non-increasing order"]
    pub fn SCIPsortedvecDelPosDownPtrRealIntInt(
        ptrarray: *mut *mut ::std::os::raw::c_void,
        realarray: *mut f64,
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        pos: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " deletes the element at the given position from four joint arrays of pointer/pointer/Reals/ints, sorted by first array in non-increasing order"]
    pub fn SCIPsortedvecDelPosDownPtrPtrRealInt(
        ptrarray1: *mut *mut ::std::os::raw::c_void,
        ptrarray2: *mut *mut ::std::os::raw::c_void,
        realarray: *mut f64,
        intarray: *mut ::std::os::raw::c_int,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        pos: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " deletes the element at the given position from four joint arrays of pointer/pointer/Reals/bools, sorted by first array in non-increasing order"]
    pub fn SCIPsortedvecDelPosDownPtrPtrRealBool(
        ptrarray1: *mut *mut ::std::os::raw::c_void,
        ptrarray2: *mut *mut ::std::os::raw::c_void,
        realarray: *mut f64,
        boolarray: *mut ::std::os::raw::c_uint,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        pos: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " deletes the element at the given position from four joint arrays of pointer/pointer/Longs/ints, sorted by first array in non-increasing order"]
    pub fn SCIPsortedvecDelPosDownPtrPtrLongInt(
        ptrarray1: *mut *mut ::std::os::raw::c_void,
        ptrarray2: *mut *mut ::std::os::raw::c_void,
        longarray: *mut ::std::os::raw::c_longlong,
        intarray: *mut ::std::os::raw::c_int,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        pos: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " deletes the element at the given position from five joint arrays of pointer/pointer/Longs/ints/ints, sorted by first array in non-increasing order"]
    pub fn SCIPsortedvecDelPosDownPtrPtrLongIntInt(
        ptrarray1: *mut *mut ::std::os::raw::c_void,
        ptrarray2: *mut *mut ::std::os::raw::c_void,
        longarray: *mut ::std::os::raw::c_longlong,
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        pos: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " delete the element at the given position from an array of Reals, sorted in non-increasing order"]
    pub fn SCIPsortedvecDelPosDownReal(
        realarray: *mut f64,
        pos: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " delete the element at the given position from three joint arrays of Reals/Bools/pointers, sorted by first array in non-increasing order"]
    pub fn SCIPsortedvecDelPosDownRealBoolPtr(
        realarray: *mut f64,
        boolarray: *mut ::std::os::raw::c_uint,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        pos: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " delete the element at the given position from two joint arrays of Reals/pointers, sorted by first array in non-increasing order"]
    pub fn SCIPsortedvecDelPosDownRealPtr(
        realarray: *mut f64,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        pos: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " delete the element at the given position from two joint arrays of Reals/ints, sorted by first array in non-increasing order"]
    pub fn SCIPsortedvecDelPosDownRealInt(
        realarray: *mut f64,
        intarray: *mut ::std::os::raw::c_int,
        pos: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " delete the element at the given position from two joint arrays of Reals/ints, sorted by first array in non-increasing order"]
    pub fn SCIPsortedvecDelPosDownRealIntInt(
        realarray: *mut f64,
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        pos: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " delete the element at the given position from three joint arrays of Reals/ints/Longs, sorted by first array in non-increasing order"]
    pub fn SCIPsortedvecDelPosDownRealIntLong(
        realarray: *mut f64,
        intarray: *mut ::std::os::raw::c_int,
        longarray: *mut ::std::os::raw::c_longlong,
        pos: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " delete the element at the given position from three joint arrays of Reals/ints/Pointer, sorted by first array in non-increasing order"]
    pub fn SCIPsortedvecDelPosDownRealIntPtr(
        realarray: *mut f64,
        intarray: *mut ::std::os::raw::c_int,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        pos: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " delete the element at the given position from three joint arrays of Reals/Reals/ints, sorted by first array in non-increasing order"]
    pub fn SCIPsortedvecDelPosDownRealRealInt(
        realarray1: *mut f64,
        realarray2: *mut f64,
        intarray: *mut ::std::os::raw::c_int,
        pos: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " delete the element at the given position from three joint arrays of Reals/Reals/Pointer, sorted by first array in non-increasing order"]
    pub fn SCIPsortedvecDelPosDownRealRealPtr(
        realarray1: *mut f64,
        realarray2: *mut f64,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        pos: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " delete the element at the given position from three joint arrays of Reals/Reals/Pointer/Pointer, sorted by first array in non-increasing order"]
    pub fn SCIPsortedvecDelPosDownRealRealPtrPtr(
        realarray1: *mut f64,
        realarray2: *mut f64,
        ptrarray1: *mut *mut ::std::os::raw::c_void,
        ptrarray2: *mut *mut ::std::os::raw::c_void,
        pos: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " delete the element at the given position from three joint arrays of Reals/Reals/Pointer, sorted by first array in non-increasing order"]
    pub fn SCIPsortedvecDelPosDownRealPtrPtr(
        realarray: *mut f64,
        ptrarray1: *mut *mut ::std::os::raw::c_void,
        ptrarray2: *mut *mut ::std::os::raw::c_void,
        pos: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " delete the element at the given position from four joint arrays of Reals/pointers/pointers/ints, sorted by first array in non-increasing order"]
    pub fn SCIPsortedvecDelPosDownRealPtrPtrInt(
        realarray: *mut f64,
        ptrarray1: *mut *mut ::std::os::raw::c_void,
        ptrarray2: *mut *mut ::std::os::raw::c_void,
        intarray: *mut ::std::os::raw::c_int,
        pos: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " delete the element at the given position from five joint arrays of Reals/pointers/pointers/ints/ints, sorted by first array in non-increasing order"]
    pub fn SCIPsortedvecDelPosDownRealPtrPtrIntInt(
        realarray: *mut f64,
        ptrarray1: *mut *mut ::std::os::raw::c_void,
        ptrarray2: *mut *mut ::std::os::raw::c_void,
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        pos: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " delete the element at the given position from four joint arrays of Reals/Long/Reals/ints, sorted by first array in non-increasing order"]
    pub fn SCIPsortedvecDelPosDownRealLongRealInt(
        realarray1: *mut f64,
        longarray: *mut ::std::os::raw::c_longlong,
        realarray3: *mut f64,
        intarray: *mut ::std::os::raw::c_int,
        pos: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " delete the element at the given position from four joint arrays of Reals/Reals/ints/ints, sorted by first array in non-increasing order"]
    pub fn SCIPsortedvecDelPosDownRealRealIntInt(
        realarray1: *mut f64,
        realarray2: *mut f64,
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        pos: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " delete the element at the given position from four joint arrays of Reals/Reals/Reals/ints, sorted by first array in non-increasing order"]
    pub fn SCIPsortedvecDelPosDownRealRealRealInt(
        realarray1: *mut f64,
        realarray2: *mut f64,
        realarray3: *mut f64,
        intarray: *mut ::std::os::raw::c_int,
        pos: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " delete the element at the given position from four joint arrays of Reals/Reals/Reals/pointers, sorted by first array in non-increasing order"]
    pub fn SCIPsortedvecDelPosDownRealRealRealPtr(
        realarray1: *mut f64,
        realarray2: *mut f64,
        realarray3: *mut f64,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        pos: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " delete the element at the given position from five joint arrays of Reals/Reals/Reals/Bools/pointers, sorted by first array in non-increasing order"]
    pub fn SCIPsortedvecDelPosDownRealRealRealBoolPtr(
        realarray1: *mut f64,
        realarray2: *mut f64,
        realarray3: *mut f64,
        boolarray: *mut ::std::os::raw::c_uint,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        pos: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " delete the element at the given position from six joint arrays of Reals/Reals/Reals/Bools/Bools/pointers, sorted by first array in non-increasing order"]
    pub fn SCIPsortedvecDelPosDownRealRealRealBoolBoolPtr(
        realarray1: *mut f64,
        realarray2: *mut f64,
        realarray3: *mut f64,
        boolarray1: *mut ::std::os::raw::c_uint,
        boolarray2: *mut ::std::os::raw::c_uint,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        pos: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " delete the element at the given position from an array of ints in non-increasing order"]
    pub fn SCIPsortedvecDelPosDownInt(
        intarray: *mut ::std::os::raw::c_int,
        pos: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " delete the element at the given position from two joint arrays of ints/ints, sorted by first array in non-increasing order"]
    pub fn SCIPsortedvecDelPosDownIntInt(
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        pos: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " delete the element at the given position from two joint arrays of ints/reals, sorted by first array in non-increasing order"]
    pub fn SCIPsortedvecDelPosDownIntReal(
        intarray: *mut ::std::os::raw::c_int,
        realarray: *mut f64,
        pos: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " delete the element at the given position from three joint arrays of ints/ints/ints, sorted by first array in non-increasing order"]
    pub fn SCIPsortedvecDelPosDownIntIntInt(
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        intarray3: *mut ::std::os::raw::c_int,
        pos: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " delete the element at the given position from three joint arrays of ints/ints/SCIP_Longint, sorted by first array in non-increasing order"]
    pub fn SCIPsortedvecDelPosDownIntIntLong(
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        longarray: *mut ::std::os::raw::c_longlong,
        pos: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " delete the element at the given position from three joint arrays of ints/ints/pointers, sorted by first array in non-increasing order"]
    pub fn SCIPsortedvecDelPosDownIntIntPtr(
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        pos: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " delete the element at the given position from three joint arrays of ints/ints/Reals, sorted by first array in non-increasing order"]
    pub fn SCIPsortedvecDelPosDownIntIntReal(
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        realarray: *mut f64,
        pos: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " delete the element at the given position from two joint arrays of ints/pointers, sorted by first array in non-increasing order"]
    pub fn SCIPsortedvecDelPosDownIntPtr(
        intarray: *mut ::std::os::raw::c_int,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        pos: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " delete the element at the given position from four joint arrays of ints/ints/ints/pointers, sorted by first array in non-decreasing order"]
    pub fn SCIPsortedvecDelPosDownIntIntIntPtr(
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        intarray3: *mut ::std::os::raw::c_int,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        pos: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " delete the element at the given position from four joint arrays of ints/ints/ints/reals, sorted by first array in non-decreasing order"]
    pub fn SCIPsortedvecDelPosDownIntIntIntReal(
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        intarray3: *mut ::std::os::raw::c_int,
        realarray: *mut f64,
        pos: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " delete the element at the given position from four joint arrays of ints/pointers/ints/reals, sorted by first array in non-decreasing order"]
    pub fn SCIPsortedvecDelPosDownIntPtrIntReal(
        intarray1: *mut ::std::os::raw::c_int,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        intarray2: *mut ::std::os::raw::c_int,
        realarray: *mut f64,
        pos: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " delete the element at the given position from an array of Longints, sorted in non-increasing order"]
    pub fn SCIPsortedvecDelPosDownLong(
        longarray: *mut ::std::os::raw::c_longlong,
        pos: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " delete the element at the given position from two arrays of Long/pointer, sorted by the first array in non-increasing order"]
    pub fn SCIPsortedvecDelPosDownLongPtr(
        longarray: *mut ::std::os::raw::c_longlong,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        pos: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " delete the element at the given position from three joint arrays of Long/pointer/int, sorted by the first array in non-increasing order"]
    pub fn SCIPsortedvecDelPosDownLongPtrInt(
        longarray: *mut ::std::os::raw::c_longlong,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        intarray: *mut ::std::os::raw::c_int,
        pos: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " delete the element at the given position from three joint arrays of Long/pointer/Real/Bool, sorted by the first array in non-increasing order"]
    pub fn SCIPsortedvecDelPosDownLongPtrRealBool(
        longarray: *mut ::std::os::raw::c_longlong,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        realarray: *mut f64,
        boolarray: *mut ::std::os::raw::c_uint,
        pos: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " delete the element at the given position from five joint arrays of Long/pointer/Real/Real/Bool, sorted by the first array in non-increasing order"]
    pub fn SCIPsortedvecDelPosDownLongPtrRealRealBool(
        longarray: *mut ::std::os::raw::c_longlong,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        realarray: *mut f64,
        realarray2: *mut f64,
        boolarray: *mut ::std::os::raw::c_uint,
        pos: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " delete the element at the given position from six joint arrays of Long/pointer/Real/Real/int/Bool, sorted by the first array in non-increasing order"]
    pub fn SCIPsortedvecDelPosDownLongPtrRealRealIntBool(
        longarray: *mut ::std::os::raw::c_longlong,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        realarray: *mut f64,
        realarray2: *mut f64,
        intarray: *mut ::std::os::raw::c_int,
        boolarray: *mut ::std::os::raw::c_uint,
        pos: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " delete the element at the given position from four joint arrays of Long/pointer/pointer/ints, sorted by first array in non-increasing order"]
    pub fn SCIPsortedvecDelPosDownLongPtrPtrInt(
        longarray: *mut ::std::os::raw::c_longlong,
        ptrarray1: *mut *mut ::std::os::raw::c_void,
        ptrarray2: *mut *mut ::std::os::raw::c_void,
        intarray: *mut ::std::os::raw::c_int,
        pos: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " delete the element at the given position from five joint arrays of Long/pointer/pointer/ints/ints, sorted by first array in non-increasing order"]
    pub fn SCIPsortedvecDelPosDownLongPtrPtrIntInt(
        longarray: *mut ::std::os::raw::c_longlong,
        ptrarray1: *mut *mut ::std::os::raw::c_void,
        ptrarray2: *mut *mut ::std::os::raw::c_void,
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        pos: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " delete the element at the given position from five joint arrays of Long/pointer/pointer/Bool/ints, sorted by first array in non-increasing order"]
    pub fn SCIPsortedvecDelPosDownLongPtrPtrBoolInt(
        longarray: *mut ::std::os::raw::c_longlong,
        ptrarray1: *mut *mut ::std::os::raw::c_void,
        ptrarray2: *mut *mut ::std::os::raw::c_void,
        boolarray: *mut ::std::os::raw::c_uint,
        intarray: *mut ::std::os::raw::c_int,
        pos: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " delete the element at the given position from five joint arrays of pointer/ints/ints/Bool/Bool, sorted by first array in non-increasing order"]
    pub fn SCIPsortedvecDelPosDownPtrIntIntBoolBool(
        ptrarray: *mut *mut ::std::os::raw::c_void,
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        boolarray1: *mut ::std::os::raw::c_uint,
        boolarray2: *mut ::std::os::raw::c_uint,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        pos: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " delete the element at the given position from six joint arrays of ints/pointer/ints/ints/Bool/Bool, sorted by first array in non-increasing order"]
    pub fn SCIPsortedvecDelPosDownIntPtrIntIntBoolBool(
        intarray1: *mut ::std::os::raw::c_int,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        intarray2: *mut ::std::os::raw::c_int,
        intarray3: *mut ::std::os::raw::c_int,
        boolarray1: *mut ::std::os::raw::c_uint,
        boolarray2: *mut ::std::os::raw::c_uint,
        pos: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " Finds the position at which 'val' is located in the sorted vector by binary search.\n  If the element exists, the method returns TRUE and stores the position of the element in '*pos'.\n  If the element does not exist, the method returns FALSE and stores the position of the element that follows\n  'val' in the ordering in '*pos', i.e., '*pos' is the position at which 'val' would be inserted.\n  Note that if the element is not found, '*pos' may be equal to len if all existing elements are smaller than 'val'."]
    pub fn SCIPsortedvecFindInd(
        indarray: *mut ::std::os::raw::c_int,
        indcomp: ::std::option::Option<
            unsafe extern "C" fn(
                dataptr: *mut ::std::os::raw::c_void,
                ind1: ::std::os::raw::c_int,
                ind2: ::std::os::raw::c_int,
            ) -> ::std::os::raw::c_int,
        >,
        dataptr: *mut ::std::os::raw::c_void,
        val: ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
        pos: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " Finds the position at which 'val' is located in the sorted vector by binary search.\n  If the element exists, the method returns TRUE and stores the position of the element in '*pos'.\n  If the element does not exist, the method returns FALSE and stores the position of the element that follows\n  'val' in the ordering in '*pos', i.e., '*pos' is the position at which 'val' would be inserted.\n  Note that if the element is not found, '*pos' may be equal to len if all existing elements are smaller than 'val'."]
    pub fn SCIPsortedvecFindPtr(
        ptrarray: *mut *mut ::std::os::raw::c_void,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        val: *mut ::std::os::raw::c_void,
        len: ::std::os::raw::c_int,
        pos: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " Finds the position at which 'val' is located in the sorted vector by binary search.\n  If the element exists, the method returns TRUE and stores the position of the element in '*pos'.\n  If the element does not exist, the method returns FALSE and stores the position of the element that follows\n  'val' in the ordering in '*pos', i.e., '*pos' is the position at which 'val' would be inserted.\n  Note that if the element is not found, '*pos' may be equal to len if all existing elements are smaller than 'val'."]
    pub fn SCIPsortedvecFindReal(
        realarray: *mut f64,
        val: f64,
        len: ::std::os::raw::c_int,
        pos: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " Finds the position at which 'val' is located in the sorted vector by binary search.\n  If the element exists, the method returns TRUE and stores the position of the element in '*pos'.\n  If the element does not exist, the method returns FALSE and stores the position of the element that follows\n  'val' in the ordering in '*pos', i.e., '*pos' is the position at which 'val' would be inserted.\n  Note that if the element is not found, '*pos' may be equal to len if all existing elements are smaller than 'val'."]
    pub fn SCIPsortedvecFindInt(
        intarray: *mut ::std::os::raw::c_int,
        val: ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
        pos: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " Finds the position at which 'val' is located in the sorted vector by binary search.\n  If the element exists, the method returns TRUE and stores the position of the element in '*pos'.\n  If the element does not exist, the method returns FALSE and stores the position of the element that follows\n  'val' in the ordering in '*pos', i.e., '*pos' is the position at which 'val' would be inserted.\n  Note that if the element is not found, '*pos' may be equal to len if all existing elements are smaller than 'val'."]
    pub fn SCIPsortedvecFindLong(
        longarray: *mut ::std::os::raw::c_longlong,
        val: ::std::os::raw::c_longlong,
        len: ::std::os::raw::c_int,
        pos: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " Finds the position at which 'val' is located in the sorted vector by binary search.\n  If the element exists, the method returns TRUE and stores the position of the element in '*pos'.\n  If the element does not exist, the method returns FALSE and stores the position of the element that follows\n  'val' in the ordering in '*pos', i.e., '*pos' is the position at which 'val' would be inserted.\n  Note that if the element is not found, '*pos' may be equal to len if all existing elements are smaller than 'val'."]
    pub fn SCIPsortedvecFindDownInd(
        indarray: *mut ::std::os::raw::c_int,
        indcomp: ::std::option::Option<
            unsafe extern "C" fn(
                dataptr: *mut ::std::os::raw::c_void,
                ind1: ::std::os::raw::c_int,
                ind2: ::std::os::raw::c_int,
            ) -> ::std::os::raw::c_int,
        >,
        dataptr: *mut ::std::os::raw::c_void,
        val: ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
        pos: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " Finds the position at which 'val' is located in the sorted vector by binary search.\n  If the element exists, the method returns TRUE and stores the position of the element in '*pos'.\n  If the element does not exist, the method returns FALSE and stores the position of the element that follows\n  'val' in the ordering in '*pos', i.e., '*pos' is the position at which 'val' would be inserted.\n  Note that if the element is not found, '*pos' may be equal to len if all existing elements are smaller than 'val'."]
    pub fn SCIPsortedvecFindDownPtr(
        ptrarray: *mut *mut ::std::os::raw::c_void,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        val: *mut ::std::os::raw::c_void,
        len: ::std::os::raw::c_int,
        pos: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " Finds the position at which 'val' is located in the sorted vector by binary search.\n  If the element exists, the method returns TRUE and stores the position of the element in '*pos'.\n  If the element does not exist, the method returns FALSE and stores the position of the element that follows\n  'val' in the ordering in '*pos', i.e., '*pos' is the position at which 'val' would be inserted.\n  Note that if the element is not found, '*pos' may be equal to len if all existing elements are smaller than 'val'."]
    pub fn SCIPsortedvecFindDownReal(
        realarray: *mut f64,
        val: f64,
        len: ::std::os::raw::c_int,
        pos: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " Finds the position at which 'val' is located in the sorted vector by binary search.\n  If the element exists, the method returns TRUE and stores the position of the element in '*pos'.\n  If the element does not exist, the method returns FALSE and stores the position of the element that follows\n  'val' in the ordering in '*pos', i.e., '*pos' is the position at which 'val' would be inserted.\n  Note that if the element is not found, '*pos' may be equal to len if all existing elements are smaller than 'val'."]
    pub fn SCIPsortedvecFindDownInt(
        intarray: *mut ::std::os::raw::c_int,
        val: ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
        pos: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " Finds the position at which 'val' is located in the sorted vector by binary search.\n  If the element exists, the method returns TRUE and stores the position of the element in '*pos'.\n  If the element does not exist, the method returns FALSE and stores the position of the element that follows\n  'val' in the ordering in '*pos', i.e., '*pos' is the position at which 'val' would be inserted.\n  Note that if the element is not found, '*pos' may be equal to len if all existing elements are smaller than 'val'."]
    pub fn SCIPsortedvecFindDownLong(
        longarray: *mut ::std::os::raw::c_longlong,
        val: ::std::os::raw::c_longlong,
        len: ::std::os::raw::c_int,
        pos: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " returns the right-hand side of an arbitrary SCIP constraint that can be represented as a single linear constraint\n\n  @note The success pointer indicates if the individual contraint handler was able to return the involved values"]
    pub fn SCIPconsGetRhs(
        scip: *mut SCIP,
        cons: *mut SCIP_CONS,
        success: *mut ::std::os::raw::c_uint,
    ) -> f64;
}
extern "C" {
    #[doc = " returns the left-hand side of an arbitrary SCIP constraint that can be represented as a single linear constraint\n\n  @note The success pointer indicates if the individual contraint handler was able to return the involved values"]
    pub fn SCIPconsGetLhs(
        scip: *mut SCIP,
        cons: *mut SCIP_CONS,
        success: *mut ::std::os::raw::c_uint,
    ) -> f64;
}
extern "C" {
    #[doc = " returns the value array of an arbitrary SCIP constraint that can be represented as a single linear constraint\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @note The success pointer indicates if the individual contraint handler was able to return the involved values"]
    pub fn SCIPgetConsVals(
        scip: *mut SCIP,
        cons: *mut SCIP_CONS,
        vals: *mut f64,
        varssize: ::std::os::raw::c_int,
        success: *mut ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " returns the dual farkas solution of an arbitrary SCIP constraint that can be represented as a single linear constraint\n\n  @note The success pointer indicates if the individual contraint handler was able to return the dual farkas solution"]
    pub fn SCIPconsGetDualfarkas(
        scip: *mut SCIP,
        cons: *mut SCIP_CONS,
        dualfarkas: *mut f64,
        success: *mut ::std::os::raw::c_uint,
    );
}
extern "C" {
    #[doc = " returns the dual solution of an arbitrary SCIP constraint that can be represented as a single linear constraint\n\n  @note The success pointer indicates if the individual contraint handler was able to return the dual solution"]
    pub fn SCIPconsGetDualsol(
        scip: *mut SCIP,
        cons: *mut SCIP_CONS,
        dualsol: *mut f64,
        success: *mut ::std::os::raw::c_uint,
    );
}
extern "C" {
    #[doc = " returns the row of an arbitrary SCIP constraint that can be represented as a single linear constraint\n  or NULL of no row is available"]
    pub fn SCIPconsGetRow(scip: *mut SCIP, cons: *mut SCIP_CONS) -> *mut SCIP_ROW;
}
extern "C" {
    #[doc = " adds the given variable to the input constraint.\n  If the constraint is setppc or logicor the value is ignored. If the constraint is knapsack, then the value is\n  converted to an int. A warning is passed if the SCIP_Real is not an integer.\n  TODO: Allow val to be a pointer."]
    pub fn SCIPconsAddCoef(
        scip: *mut SCIP,
        cons: *mut SCIP_CONS,
        var: *mut SCIP_VAR,
        val: f64,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " creates a SCIP_ROWPREP datastructure\n\n Initial row represents 0 &le; 0."]
    pub fn SCIPcreateRowprep(
        scip: *mut SCIP,
        rowprep: *mut *mut SCIP_ROWPREP,
        sidetype: SCIP_SIDETYPE,
        local: ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " frees a SCIP_ROWPREP datastructure"]
    pub fn SCIPfreeRowprep(scip: *mut SCIP, rowprep: *mut *mut SCIP_ROWPREP);
}
extern "C" {
    #[doc = " creates a copy of a SCIP_ROWPREP datastructure"]
    pub fn SCIPcopyRowprep(
        scip: *mut SCIP,
        target: *mut *mut SCIP_ROWPREP,
        source: *mut SCIP_ROWPREP,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " gives number of terms in rowprep"]
    pub fn SCIProwprepGetNVars(rowprep: *mut SCIP_ROWPREP) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " gives variables of rowprep (feel free to modify)"]
    pub fn SCIProwprepGetVars(rowprep: *mut SCIP_ROWPREP) -> *mut *mut SCIP_VAR;
}
extern "C" {
    #[doc = " gives coefficients of rowprep (feel free to modify)"]
    pub fn SCIProwprepGetCoefs(rowprep: *mut SCIP_ROWPREP) -> *mut f64;
}
extern "C" {
    #[doc = " gives side of rowprep"]
    pub fn SCIProwprepGetSide(rowprep: *mut SCIP_ROWPREP) -> f64;
}
extern "C" {
    #[doc = " gives kind of inequality of rowprep"]
    pub fn SCIProwprepGetSidetype(rowprep: *mut SCIP_ROWPREP) -> SCIP_SIDETYPE;
}
extern "C" {
    #[doc = " returns whether rowprep is locally valid only"]
    pub fn SCIProwprepIsLocal(rowprep: *mut SCIP_ROWPREP) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " returns name of rowprep (feel free to modify)"]
    pub fn SCIProwprepGetName(rowprep: *mut SCIP_ROWPREP) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " returns number of variables which coefficients were modified in cleanup"]
    pub fn SCIProwprepGetNModifiedVars(rowprep: *mut SCIP_ROWPREP) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " returns variables which coefficients were modified in cleanup"]
    pub fn SCIProwprepGetModifiedVars(rowprep: *mut SCIP_ROWPREP) -> *mut *mut SCIP_VAR;
}
extern "C" {
    #[doc = " resets rowprep to have 0 terms and side 0.0"]
    pub fn SCIProwprepReset(rowprep: *mut SCIP_ROWPREP);
}
extern "C" {
    #[doc = " sets coefficient idx of rowprep"]
    pub fn SCIProwprepSetCoef(rowprep: *mut SCIP_ROWPREP, idx: ::std::os::raw::c_int, newcoef: f64);
}
extern "C" {
    #[doc = " adds constant value to side of rowprep"]
    pub fn SCIProwprepAddSide(rowprep: *mut SCIP_ROWPREP, side: f64);
}
extern "C" {
    #[doc = " adds constant term to rowprep\n\n Substracts constant from side."]
    pub fn SCIProwprepAddConstant(rowprep: *mut SCIP_ROWPREP, constant: f64);
}
extern "C" {
    #[doc = " sets side type of rowprep"]
    pub fn SCIProwprepSetSidetype(rowprep: *mut SCIP_ROWPREP, sidetype: SCIP_SIDETYPE);
}
extern "C" {
    #[doc = " sets whether rowprep is local"]
    pub fn SCIProwprepSetLocal(rowprep: *mut SCIP_ROWPREP, islocal: ::std::os::raw::c_uint);
}
extern "C" {
    #[doc = " enables recording for where modifications were done in cleanup"]
    pub fn SCIProwprepRecordModifications(rowprep: *mut SCIP_ROWPREP);
}
extern "C" {
    #[doc = " prints a rowprep"]
    pub fn SCIPprintRowprep(scip: *mut SCIP, rowprep: *mut SCIP_ROWPREP, file: *mut FILE);
}
extern "C" {
    #[doc = " prints a rowprep and values in solution"]
    pub fn SCIPprintRowprepSol(
        scip: *mut SCIP,
        rowprep: *mut SCIP_ROWPREP,
        sol: *mut SCIP_SOL,
        file: *mut FILE,
    );
}
extern "C" {
    #[doc = " ensures that rowprep has space for at least given number of additional terms\n\n Useful when knowing in advance how many terms will be added."]
    pub fn SCIPensureRowprepSize(
        scip: *mut SCIP,
        rowprep: *mut SCIP_ROWPREP,
        size: ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " adds a term coef*var to a rowprep"]
    pub fn SCIPaddRowprepTerm(
        scip: *mut SCIP,
        rowprep: *mut SCIP_ROWPREP,
        var: *mut SCIP_VAR,
        coef: f64,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " adds several terms coef*var to a rowprep"]
    pub fn SCIPaddRowprepTerms(
        scip: *mut SCIP,
        rowprep: *mut SCIP_ROWPREP,
        nvars: ::std::os::raw::c_int,
        vars: *mut *mut SCIP_VAR,
        coefs: *mut f64,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " computes violation of rowprep in a given solution\n\n Can return whether the violation value is reliable from a floating-point accuracy point of view.\n The value will not be deemed reliable when its calculation involved the subtraction of large numbers.\n To be precise, the violation of an inequality \\f$ \\sum_i a_ix_i \\leq b \\f$ in a solution \\f$x^*\\f$ is deemed\n reliable if \\f$ |\\sum_i a_ix^*_i - b| \\geq 2^{-50} \\max (|b|, \\max_i |a_ix^*_i|) \\f$."]
    pub fn SCIPgetRowprepViolation(
        scip: *mut SCIP,
        rowprep: *mut SCIP_ROWPREP,
        sol: *mut SCIP_SOL,
        reliable: *mut ::std::os::raw::c_uint,
    ) -> f64;
}
extern "C" {
    #[doc = " computes violation of rowprep in a given solution and reports whether that value seem numerically reliable\n\n @see SCIPgetRowprepViolation()"]
    pub fn SCIPisRowprepViolationReliable(
        scip: *mut SCIP,
        rowprep: *mut SCIP_ROWPREP,
        sol: *mut SCIP_SOL,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " Merge terms that use same variable and eliminate zero coefficients.\n\n Removes a variable if its bounds have a relative difference of below epsilon.\n Local bounds are checked for local rows, otherwise global bounds are used.\n If the bounds are not absolute equal, the bound that relaxes the row is used.\n\n Terms are sorted by variable (see SCIPvarComp()) after return."]
    pub fn SCIPmergeRowprepTerms(scip: *mut SCIP, rowprep: *mut SCIP_ROWPREP);
}
extern "C" {
    #[doc = " Cleans up and attempts to improve rowprep\n\n Drops small or large coefficients if their ratio is beyond separating/maxcoefratiofacrowprep / numerics/feastol,\n if this can be done by relaxing the row.\n Scales coefficients up to reach minimal violation, if possible.\n Scaling is omitted if violation is very small (\\ref ROWPREP_SCALEUP_VIOLNONZERO) or\n maximal coefficient would become huge (\\ref ROWPREP_SCALEUP_MAXMAXCOEF).\n Scales coefficients and side down if they are large and if the minimal violation is still reached.\n Rounds coefficients close to integral values to integrals, if this can be done by relaxing the row.\n Rounds side within epsilon of 0 to 0.0 or +/-1.1*epsilon, whichever relaxes the row least.\n\n After return, the terms in the rowprep will be sorted by absolute value of coefficient, in decreasing order.\n Thus, the coefratio can be obtained via `REALABS(rowprep->coefs[0]) / REALABS(rowprep->coefs[rowprep->nvars-1])` (if nvars>0).\n\n `success` is set to TRUE if and only if the rowprep satisfies the following:\n - the coefratio is below separating/maxcoefratiofacrowprep / numerics/feastol\n - the violation is at least `minviol`\n - the violation is reliable or `minviol` = 0\n - the absolute value of coefficients are below SCIPinfinity()\n - the absolute value of the side is below SCIPinfinity()"]
    pub fn SCIPcleanupRowprep(
        scip: *mut SCIP,
        rowprep: *mut SCIP_ROWPREP,
        sol: *mut SCIP_SOL,
        minviol: f64,
        viol: *mut f64,
        success: *mut ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " Cleans up and attempts to improve rowprep without regard for violation\n\n Drops small or large coefficients if their ratio is beyond separating/maxcoefratiofacrowprep / numerics/feastol,\n if this can be done by relaxing the row.\n Scales coefficients and side to have maximal coefficient in `[1/maxcoefbound,maxcoefbound]`.\n Rounds coefficients close to integral values to integrals, if this can be done by relaxing the row.\n Rounds side within epsilon of 0 to 0.0 or +/-1.1*epsilon, whichever relaxes the row least.\n\n After return, the terms in the rowprep will be sorted by absolute value of coefficient, in decreasing order.\n Thus, the coefratio can be obtained via `REALABS(rowprep->coefs[0]) / REALABS(rowprep->coefs[rowprep->nvars-1])` (if nvars>0).\n\n `success` is set to TRUE if and only if the rowprep satisfies the following:\n - the coefratio is below separating/maxcoefratiofacrowprep / numerics/feastol\n - the absolute value of coefficients are below SCIPinfinity()\n - the absolute value of the side is below SCIPinfinity()\n\n In difference to SCIPcleanupRowprep(), this function does not scale up the row to increase the absolute violation."]
    pub fn SCIPcleanupRowprep2(
        scip: *mut SCIP,
        rowprep: *mut SCIP_ROWPREP,
        sol: *mut SCIP_SOL,
        maxcoefbound: f64,
        success: *mut ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " Scales up a rowprep to increase coefficients/sides that are within epsilon to an integer value, if possible.\n\n Computes the minimal fractionality of all fractional coefficients and the side of the rowprep.\n If this fractionality is below epsilon, the rowprep is scaled up such that the fractionality exceeds epsilon,\n if this will not put any coefficient or side above SCIPhugeValue().\n\n This function does not relax the rowprep.\n\n `success` is set to TRUE if the resulting rowprep can be turned into a SCIP_ROW, that is,\n all coefs and the side is below SCIPinfinity() and fractionalities are above epsilon.\n If `success` is set to FALSE, then the rowprep will not have been modified.\n\n @return The applied scaling factor, if `success` is set to TRUE."]
    pub fn SCIPscaleupRowprep(
        scip: *mut SCIP,
        rowprep: *mut SCIP_ROWPREP,
        minscaleup: f64,
        success: *mut ::std::os::raw::c_uint,
    ) -> f64;
}
extern "C" {
    #[doc = " scales a rowprep by given factor (after some rounding)\n\n @return Exponent of actually applied scaling factor, if written as \\f$2^x\\f$."]
    pub fn SCIPscaleRowprep(rowprep: *mut SCIP_ROWPREP, factor: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " generates a SCIP_ROW from a rowprep, setting its origin to given constraint handler"]
    pub fn SCIPgetRowprepRowConshdlr(
        scip: *mut SCIP,
        row: *mut *mut SCIP_ROW,
        rowprep: *mut SCIP_ROWPREP,
        conshdlr: *mut SCIP_CONSHDLR,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " generates a SCIP_ROW from a rowprep, setting its origin to given constraint"]
    pub fn SCIPgetRowprepRowCons(
        scip: *mut SCIP,
        row: *mut *mut SCIP_ROW,
        rowprep: *mut SCIP_ROWPREP,
        cons: *mut SCIP_CONS,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " generates a SCIP_ROW from a rowprep, setting its origin to given separator"]
    pub fn SCIPgetRowprepRowSepa(
        scip: *mut SCIP,
        row: *mut *mut SCIP_ROW,
        rowprep: *mut SCIP_ROWPREP,
        sepa: *mut SCIP_SEPA,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " get critical value of a Student-T distribution for a given number of degrees of freedom at a confidence level"]
    pub fn SCIPstudentTGetCriticalValue(
        clevel: SCIP_CONFIDENCELEVEL,
        df: ::std::os::raw::c_int,
    ) -> f64;
}
extern "C" {
    #[doc = " compute a t-value for the hypothesis that x and y are from the same population; Assuming that\n  x and y represent normally distributed random samples with equal variance, the returned value\n  comes from a Student-T distribution with countx + county - 2 degrees of freedom; this\n  value can be compared with a critical value (see also SCIPstudentTGetCriticalValue()) at\n  a predefined confidence level for checking if x and y significantly differ in location"]
    pub fn SCIPcomputeTwoSampleTTestValue(
        meanx: f64,
        meany: f64,
        variancex: f64,
        variancey: f64,
        countx: f64,
        county: f64,
    ) -> f64;
}
extern "C" {
    #[doc = " returns the value of the Gauss error function evaluated at a given point"]
    pub fn SCIPerf(x: f64) -> f64;
}
extern "C" {
    #[doc = " get critical value of a standard normal distribution  at a given confidence level"]
    pub fn SCIPnormalGetCriticalValue(clevel: SCIP_CONFIDENCELEVEL) -> f64;
}
extern "C" {
    #[doc = " calculates the cumulative distribution P(-infinity <= x <= value) that a normally distributed\n  random variable x takes a value between -infinity and parameter \\p value.\n\n  The distribution is given by the respective mean and deviation. This implementation\n  uses the error function erf()."]
    pub fn SCIPnormalCDF(mean: f64, variance: f64, value: f64) -> f64;
}
extern "C" {
    #[doc = " returns the number of observations of this regression"]
    pub fn SCIPregressionGetNObservations(
        regression: *mut SCIP_REGRESSION,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " return the current slope of the regression"]
    pub fn SCIPregressionGetSlope(regression: *mut SCIP_REGRESSION) -> f64;
}
extern "C" {
    #[doc = " get the current y-intercept of the regression"]
    pub fn SCIPregressionGetIntercept(regression: *mut SCIP_REGRESSION) -> f64;
}
extern "C" {
    #[doc = " removes an observation (x,y) from the regression"]
    pub fn SCIPregressionRemoveObservation(regression: *mut SCIP_REGRESSION, x: f64, y: f64);
}
extern "C" {
    #[doc = " update regression by a new observation (x,y)"]
    pub fn SCIPregressionAddObservation(regression: *mut SCIP_REGRESSION, x: f64, y: f64);
}
extern "C" {
    #[doc = " reset regression data structure"]
    pub fn SCIPregressionReset(regression: *mut SCIP_REGRESSION);
}
extern "C" {
    #[doc = " creates and resets a regression"]
    pub fn SCIPregressionCreate(regression: *mut *mut SCIP_REGRESSION) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " frees a regression"]
    pub fn SCIPregressionFree(regression: *mut *mut SCIP_REGRESSION);
}
extern "C" {
    #[doc = " writes a node section to the given graph file"]
    pub fn SCIPgmlWriteNode(
        file: *mut FILE,
        id: ::std::os::raw::c_uint,
        label: *const ::std::os::raw::c_char,
        nodetype: *const ::std::os::raw::c_char,
        fillcolor: *const ::std::os::raw::c_char,
        bordercolor: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    #[doc = " writes a node section including weight to the given graph file"]
    pub fn SCIPgmlWriteNodeWeight(
        file: *mut FILE,
        id: ::std::os::raw::c_uint,
        label: *const ::std::os::raw::c_char,
        nodetype: *const ::std::os::raw::c_char,
        fillcolor: *const ::std::os::raw::c_char,
        bordercolor: *const ::std::os::raw::c_char,
        weight: f64,
    );
}
extern "C" {
    #[doc = " writes an edge section to the given graph file"]
    pub fn SCIPgmlWriteEdge(
        file: *mut FILE,
        source: ::std::os::raw::c_uint,
        target: ::std::os::raw::c_uint,
        label: *const ::std::os::raw::c_char,
        color: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    #[doc = " writes an arc section to the given graph file"]
    pub fn SCIPgmlWriteArc(
        file: *mut FILE,
        source: ::std::os::raw::c_uint,
        target: ::std::os::raw::c_uint,
        label: *const ::std::os::raw::c_char,
        color: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    #[doc = " writes the starting line to a GML graph file, does not open a file"]
    pub fn SCIPgmlWriteOpening(file: *mut FILE, directed: ::std::os::raw::c_uint);
}
extern "C" {
    #[doc = " writes the ending lines to a GML graph file, does not close a file"]
    pub fn SCIPgmlWriteClosing(file: *mut FILE);
}
extern "C" {
    #[doc = " writes the opening line to a dot graph file, does not open a file"]
    pub fn SCIPdotWriteOpening(file: *mut FILE);
}
extern "C" {
    #[doc = " adds a node to the dot graph"]
    pub fn SCIPdotWriteNode(
        file: *mut FILE,
        node: ::std::os::raw::c_int,
        label: *const ::std::os::raw::c_char,
        nodetype: *const ::std::os::raw::c_char,
        fillcolor: *const ::std::os::raw::c_char,
        bordercolor: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    #[doc = " adds an arc (edge) between two nodes in the dot graph"]
    pub fn SCIPdotWriteArc(
        file: *mut FILE,
        source: ::std::os::raw::c_int,
        target: ::std::os::raw::c_int,
        color: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    #[doc = " writes the closing line to a dot graph file, does not close a file"]
    pub fn SCIPdotWriteClosing(file: *mut FILE);
}
extern "C" {
    #[doc = " creates a sparse solution"]
    pub fn SCIPsparseSolCreate(
        sparsesol: *mut *mut SCIP_SPARSESOL,
        vars: *mut *mut SCIP_VAR,
        nvars: ::std::os::raw::c_int,
        cleared: ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " frees sparse solution"]
    pub fn SCIPsparseSolFree(sparsesol: *mut *mut SCIP_SPARSESOL);
}
extern "C" {
    #[doc = " returns the variables in the given sparse solution"]
    pub fn SCIPsparseSolGetVars(sparsesol: *mut SCIP_SPARSESOL) -> *mut *mut SCIP_VAR;
}
extern "C" {
    #[doc = " returns the number of variables in the given sparse solution"]
    pub fn SCIPsparseSolGetNVars(sparsesol: *mut SCIP_SPARSESOL) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " returns the the lower bound array for all variables for a given sparse solution"]
    pub fn SCIPsparseSolGetLbs(sparsesol: *mut SCIP_SPARSESOL) -> *mut ::std::os::raw::c_longlong;
}
extern "C" {
    #[doc = " returns the the upper bound array for all variables for a given sparse solution"]
    pub fn SCIPsparseSolGetUbs(sparsesol: *mut SCIP_SPARSESOL) -> *mut ::std::os::raw::c_longlong;
}
extern "C" {
    #[doc = " constructs the first solution of sparse solution (all variables are set to their lower bound value"]
    pub fn SCIPsparseSolGetFirstSol(
        sparsesol: *mut SCIP_SPARSESOL,
        sol: *mut ::std::os::raw::c_longlong,
        nvars: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " constructs the next solution of the sparse solution and return whether there was one more or not"]
    pub fn SCIPsparseSolGetNextSol(
        sparsesol: *mut SCIP_SPARSESOL,
        sol: *mut ::std::os::raw::c_longlong,
        nvars: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " creates a (circular) queue, best used if the size will be fixed or will not be increased that much"]
    pub fn SCIPqueueCreate(
        queue: *mut *mut SCIP_QUEUE,
        initsize: ::std::os::raw::c_int,
        sizefac: f64,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " frees queue, but not the data elements themselves"]
    pub fn SCIPqueueFree(queue: *mut *mut SCIP_QUEUE);
}
extern "C" {
    #[doc = " clears the queue, but doesn't free the data elements themselves"]
    pub fn SCIPqueueClear(queue: *mut SCIP_QUEUE);
}
extern "C" {
    #[doc = " inserts pointer element at the end of the queue"]
    pub fn SCIPqueueInsert(
        queue: *mut SCIP_QUEUE,
        elem: *mut ::std::os::raw::c_void,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " inserts unsigned integer element at the end of the queue"]
    pub fn SCIPqueueInsertUInt(
        queue: *mut SCIP_QUEUE,
        elem: ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " removes and returns the first element of the queue, or NULL if no element exists"]
    pub fn SCIPqueueRemove(queue: *mut SCIP_QUEUE) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " removes and returns the first unsigned integer element of the queue, or UNIT_MAX if no element exists"]
    pub fn SCIPqueueRemoveUInt(queue: *mut SCIP_QUEUE) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " returns the first element of the queue without removing it, or NULL if no element exists"]
    pub fn SCIPqueueFirst(queue: *mut SCIP_QUEUE) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " returns the first unsigned integer element of the queue without removing it, or UINT_MAX if no element exists"]
    pub fn SCIPqueueFirstUInt(queue: *mut SCIP_QUEUE) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " returns whether the queue is empty"]
    pub fn SCIPqueueIsEmpty(queue: *mut SCIP_QUEUE) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " returns the number of elements in the queue"]
    pub fn SCIPqueueNElems(queue: *mut SCIP_QUEUE) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " creates priority queue"]
    pub fn SCIPpqueueCreate(
        pqueue: *mut *mut SCIP_PQUEUE,
        initsize: ::std::os::raw::c_int,
        sizefac: f64,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        elemchgpos: ::std::option::Option<
            unsafe extern "C" fn(
                elem: *mut ::std::os::raw::c_void,
                oldpos: ::std::os::raw::c_int,
                newpos: ::std::os::raw::c_int,
            ),
        >,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " frees priority queue, but not the data elements themselves"]
    pub fn SCIPpqueueFree(pqueue: *mut *mut SCIP_PQUEUE);
}
extern "C" {
    #[doc = " clears the priority queue, but doesn't free the data elements themselves"]
    pub fn SCIPpqueueClear(pqueue: *mut SCIP_PQUEUE);
}
extern "C" {
    #[doc = " inserts element into priority queue"]
    pub fn SCIPpqueueInsert(
        pqueue: *mut SCIP_PQUEUE,
        elem: *mut ::std::os::raw::c_void,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " delete element at specified position, maintaining the heap property"]
    pub fn SCIPpqueueDelPos(pqueue: *mut SCIP_PQUEUE, pos: ::std::os::raw::c_int);
}
extern "C" {
    #[doc = " removes and returns best element from the priority queue"]
    pub fn SCIPpqueueRemove(pqueue: *mut SCIP_PQUEUE) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " returns the best element of the queue without removing it"]
    pub fn SCIPpqueueFirst(pqueue: *mut SCIP_PQUEUE) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " returns the number of elements in the queue"]
    pub fn SCIPpqueueNElems(pqueue: *mut SCIP_PQUEUE) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " returns the elements of the queue; changing the returned array may destroy the queue's ordering!"]
    pub fn SCIPpqueueElems(pqueue: *mut SCIP_PQUEUE) -> *mut *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " return the position of @p elem in the priority queue, or -1 if element is not found"]
    pub fn SCIPpqueueFind(
        pqueue: *mut SCIP_PQUEUE,
        elem: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " creates a hash table"]
    pub fn SCIPhashtableCreate(
        hashtable: *mut *mut SCIP_HASHTABLE,
        blkmem: *mut BMS_BLKMEM,
        tablesize: ::std::os::raw::c_int,
        hashgetkey: ::std::option::Option<
            unsafe extern "C" fn(
                userptr: *mut ::std::os::raw::c_void,
                elem: *mut ::std::os::raw::c_void,
            ) -> *mut ::std::os::raw::c_void,
        >,
        hashkeyeq: ::std::option::Option<
            unsafe extern "C" fn(
                userptr: *mut ::std::os::raw::c_void,
                key1: *mut ::std::os::raw::c_void,
                key2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_uint,
        >,
        hashkeyval: ::std::option::Option<
            unsafe extern "C" fn(
                userptr: *mut ::std::os::raw::c_void,
                key: *mut ::std::os::raw::c_void,
            ) -> u64,
        >,
        userptr: *mut ::std::os::raw::c_void,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " frees the hash table"]
    pub fn SCIPhashtableFree(hashtable: *mut *mut SCIP_HASHTABLE);
}
extern "C" {
    #[doc = " removes all elements of the hash table\n\n  @note From a performance point of view you should not fill and clear a hash table too often since the clearing can\n        be expensive. Clearing is done by looping over all buckets and removing the hash table lists one-by-one.\n\n  @deprecated Please use SCIPhashtableRemoveAll()"]
    pub fn SCIPhashtableClear(hashtable: *mut SCIP_HASHTABLE);
}
extern "C" {
    #[doc = " inserts element in hash table (multiple inserts of same element override the previous entry)"]
    pub fn SCIPhashtableInsert(
        hashtable: *mut SCIP_HASHTABLE,
        element: *mut ::std::os::raw::c_void,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " inserts element in hash table (multiple insertion of same element is checked and results in an error)"]
    pub fn SCIPhashtableSafeInsert(
        hashtable: *mut SCIP_HASHTABLE,
        element: *mut ::std::os::raw::c_void,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " retrieve element with key from hash table, returns NULL if not existing"]
    pub fn SCIPhashtableRetrieve(
        hashtable: *mut SCIP_HASHTABLE,
        key: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " returns whether the given element exists in the table"]
    pub fn SCIPhashtableExists(
        hashtable: *mut SCIP_HASHTABLE,
        element: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " removes element from the hash table, if it exists"]
    pub fn SCIPhashtableRemove(
        hashtable: *mut SCIP_HASHTABLE,
        element: *mut ::std::os::raw::c_void,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " removes all elements of the hash table"]
    pub fn SCIPhashtableRemoveAll(hashtable: *mut SCIP_HASHTABLE);
}
extern "C" {
    #[doc = " returns number of hash table elements"]
    pub fn SCIPhashtableGetNElements(hashtable: *mut SCIP_HASHTABLE) -> ::std::os::raw::c_longlong;
}
extern "C" {
    #[doc = " gives the number of entries in the internal arrays of a hash table"]
    pub fn SCIPhashtableGetNEntries(hashtable: *mut SCIP_HASHTABLE) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " gives the element at the given index or NULL if entry at that index has no element"]
    pub fn SCIPhashtableGetEntry(
        hashtable: *mut SCIP_HASHTABLE,
        entryidx: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " returns the load of the given hash table in percentage"]
    pub fn SCIPhashtableGetLoad(hashtable: *mut SCIP_HASHTABLE) -> f64;
}
extern "C" {
    #[doc = " prints statistics about hash table usage"]
    pub fn SCIPhashtablePrintStatistics(
        hashtable: *mut SCIP_HASHTABLE,
        messagehdlr: *mut SCIP_MESSAGEHDLR,
    );
}
extern "C" {
    #[doc = " returns a reasonable hash table size (a prime number) that is at least as large as the specified value"]
    pub fn SCIPcalcMultihashSize(minsize: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " creates a multihash table"]
    pub fn SCIPmultihashCreate(
        multihash: *mut *mut SCIP_MULTIHASH,
        blkmem: *mut BMS_BLKMEM,
        tablesize: ::std::os::raw::c_int,
        hashgetkey: ::std::option::Option<
            unsafe extern "C" fn(
                userptr: *mut ::std::os::raw::c_void,
                elem: *mut ::std::os::raw::c_void,
            ) -> *mut ::std::os::raw::c_void,
        >,
        hashkeyeq: ::std::option::Option<
            unsafe extern "C" fn(
                userptr: *mut ::std::os::raw::c_void,
                key1: *mut ::std::os::raw::c_void,
                key2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_uint,
        >,
        hashkeyval: ::std::option::Option<
            unsafe extern "C" fn(
                userptr: *mut ::std::os::raw::c_void,
                key: *mut ::std::os::raw::c_void,
            ) -> u64,
        >,
        userptr: *mut ::std::os::raw::c_void,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " frees the multihash table"]
    pub fn SCIPmultihashFree(multihash: *mut *mut SCIP_MULTIHASH);
}
extern "C" {
    #[doc = " inserts element in multihash table (multiple inserts of same element possible)\n\n  @note A pointer to a multihashlist returned by SCIPmultihashRetrieveNext() might get invalid when adding an element\n        to the hash table, due to dynamic resizing."]
    pub fn SCIPmultihashInsert(
        multihash: *mut SCIP_MULTIHASH,
        element: *mut ::std::os::raw::c_void,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " inserts element in multihash table (multiple insertion of same element is checked and results in an error)\n\n  @note A pointer to a multihashlist returned by SCIPmultihashRetrieveNext() might get invalid when adding a new\n        element to the multihash table, due to dynamic resizing."]
    pub fn SCIPmultihashSafeInsert(
        multihash: *mut SCIP_MULTIHASH,
        element: *mut ::std::os::raw::c_void,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " retrieve element with key from multihash table, returns NULL if not existing"]
    pub fn SCIPmultihashRetrieve(
        multihash: *mut SCIP_MULTIHASH,
        key: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " retrieve element with key from multihash table, returns NULL if not existing\n  can be used to retrieve all entries with the same key (one-by-one)\n\n  @note The returned multimultihashlist pointer might get invalid when adding a new element to the multihash table."]
    pub fn SCIPmultihashRetrieveNext(
        multihash: *mut SCIP_MULTIHASH,
        multihashlist: *mut *mut SCIP_MULTIHASHLIST,
        key: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " returns whether the given element exists in the multihash table"]
    pub fn SCIPmultihashExists(
        multihash: *mut SCIP_MULTIHASH,
        element: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " removes element from the multihash table, if it exists"]
    pub fn SCIPmultihashRemove(
        multihash: *mut SCIP_MULTIHASH,
        element: *mut ::std::os::raw::c_void,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " removes all elements of the multihash table\n\n  @note From a performance point of view you should not fill and clear a hash table too often since the clearing can\n        be expensive. Clearing is done by looping over all buckets and removing the hash table lists one-by-one."]
    pub fn SCIPmultihashRemoveAll(multihash: *mut SCIP_MULTIHASH);
}
extern "C" {
    #[doc = " returns number of multihash table elements"]
    pub fn SCIPmultihashGetNElements(multihash: *mut SCIP_MULTIHASH) -> ::std::os::raw::c_longlong;
}
extern "C" {
    #[doc = " returns the load of the given multihash table in percentage"]
    pub fn SCIPmultihashGetLoad(multihash: *mut SCIP_MULTIHASH) -> f64;
}
extern "C" {
    #[doc = " prints statistics about multihash table usage"]
    pub fn SCIPmultihashPrintStatistics(
        multihash: *mut SCIP_MULTIHASH,
        messagehdlr: *mut SCIP_MESSAGEHDLR,
    );
}
extern "C" {
    pub fn SCIPhashKeyEqString(
        userptr: *mut ::std::os::raw::c_void,
        key1: *mut ::std::os::raw::c_void,
        key2: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn SCIPhashKeyValString(
        userptr: *mut ::std::os::raw::c_void,
        key: *mut ::std::os::raw::c_void,
    ) -> u64;
}
extern "C" {
    pub fn SCIPhashGetKeyStandard(
        userptr: *mut ::std::os::raw::c_void,
        elem: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn SCIPhashKeyEqPtr(
        userptr: *mut ::std::os::raw::c_void,
        key1: *mut ::std::os::raw::c_void,
        key2: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn SCIPhashKeyValPtr(
        userptr: *mut ::std::os::raw::c_void,
        key: *mut ::std::os::raw::c_void,
    ) -> u64;
}
extern "C" {
    #[doc = " creates a hash map mapping pointers to pointers"]
    pub fn SCIPhashmapCreate(
        hashmap: *mut *mut SCIP_HASHMAP,
        blkmem: *mut BMS_BLKMEM,
        mapsize: ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " frees the hash map"]
    pub fn SCIPhashmapFree(hashmap: *mut *mut SCIP_HASHMAP);
}
extern "C" {
    #[doc = " inserts new origin->image pair in hash map (must not be called for already existing origins!)"]
    pub fn SCIPhashmapInsert(
        hashmap: *mut SCIP_HASHMAP,
        origin: *mut ::std::os::raw::c_void,
        image: *mut ::std::os::raw::c_void,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " inserts new origin->image pair in hash map (must not be called for already existing origins!)"]
    pub fn SCIPhashmapInsertInt(
        hashmap: *mut SCIP_HASHMAP,
        origin: *mut ::std::os::raw::c_void,
        image: ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " inserts new origin->image pair in hash map (must not be called for already existing origins!)"]
    pub fn SCIPhashmapInsertReal(
        hashmap: *mut SCIP_HASHMAP,
        origin: *mut ::std::os::raw::c_void,
        image: f64,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " retrieves image of given origin from the hash map, or NULL if no image exists"]
    pub fn SCIPhashmapGetImage(
        hashmap: *mut SCIP_HASHMAP,
        origin: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " retrieves image of given origin from the hash map, or INT_MAX if no image exists"]
    pub fn SCIPhashmapGetImageInt(
        hashmap: *mut SCIP_HASHMAP,
        origin: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " retrieves image of given origin from the hash map, or SCIP_INVALID if no image exists"]
    pub fn SCIPhashmapGetImageReal(
        hashmap: *mut SCIP_HASHMAP,
        origin: *mut ::std::os::raw::c_void,
    ) -> f64;
}
extern "C" {
    #[doc = " sets image for given origin in the hash map, either by modifying existing origin->image pair or by appending a\n  new origin->image pair"]
    pub fn SCIPhashmapSetImage(
        hashmap: *mut SCIP_HASHMAP,
        origin: *mut ::std::os::raw::c_void,
        image: *mut ::std::os::raw::c_void,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " sets image for given origin in the hash map, either by modifying existing origin->image pair or by appending a\n  new origin->image pair"]
    pub fn SCIPhashmapSetImageInt(
        hashmap: *mut SCIP_HASHMAP,
        origin: *mut ::std::os::raw::c_void,
        image: ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " sets image for given origin in the hash map, either by modifying existing origin->image pair or by appending a\n  new origin->image pair"]
    pub fn SCIPhashmapSetImageReal(
        hashmap: *mut SCIP_HASHMAP,
        origin: *mut ::std::os::raw::c_void,
        image: f64,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " checks whether an image to the given origin exists in the hash map"]
    pub fn SCIPhashmapExists(
        hashmap: *mut SCIP_HASHMAP,
        origin: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " removes origin->image pair from the hash map, if it exists"]
    pub fn SCIPhashmapRemove(
        hashmap: *mut SCIP_HASHMAP,
        origin: *mut ::std::os::raw::c_void,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " prints statistics about hash map usage"]
    pub fn SCIPhashmapPrintStatistics(
        hashmap: *mut SCIP_HASHMAP,
        messagehdlr: *mut SCIP_MESSAGEHDLR,
    );
}
extern "C" {
    #[doc = " indicates whether a hash map has no entries"]
    pub fn SCIPhashmapIsEmpty(hashmap: *mut SCIP_HASHMAP) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " gives the number of elements in a hash map"]
    pub fn SCIPhashmapGetNElements(hashmap: *mut SCIP_HASHMAP) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " gives the number of entries in the internal arrays of a hash map"]
    pub fn SCIPhashmapGetNEntries(hashmap: *mut SCIP_HASHMAP) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " gives the hashmap entry at the given index or NULL if entry has no element"]
    pub fn SCIPhashmapGetEntry(
        hashmap: *mut SCIP_HASHMAP,
        entryidx: ::std::os::raw::c_int,
    ) -> *mut SCIP_HASHMAPENTRY;
}
extern "C" {
    #[doc = " gives the origin of the hashmap entry"]
    pub fn SCIPhashmapEntryGetOrigin(entry: *mut SCIP_HASHMAPENTRY) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " gives the image of the hashmap entry"]
    pub fn SCIPhashmapEntryGetImage(entry: *mut SCIP_HASHMAPENTRY) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " gives the image of the hashmap entry"]
    pub fn SCIPhashmapEntryGetImageInt(entry: *mut SCIP_HASHMAPENTRY) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " gives the image of the hashmap entry"]
    pub fn SCIPhashmapEntryGetImageReal(entry: *mut SCIP_HASHMAPENTRY) -> f64;
}
extern "C" {
    #[doc = " sets pointer image of a hashmap entry"]
    pub fn SCIPhashmapEntrySetImage(
        entry: *mut SCIP_HASHMAPENTRY,
        image: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    #[doc = " sets integer image of a hashmap entry"]
    pub fn SCIPhashmapEntrySetImageInt(entry: *mut SCIP_HASHMAPENTRY, image: ::std::os::raw::c_int);
}
extern "C" {
    #[doc = " sets real image of a hashmap entry"]
    pub fn SCIPhashmapEntrySetImageReal(entry: *mut SCIP_HASHMAPENTRY, image: f64);
}
extern "C" {
    #[doc = " removes all entries in a hash map."]
    pub fn SCIPhashmapRemoveAll(hashmap: *mut SCIP_HASHMAP) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " creates a hash set of pointers"]
    pub fn SCIPhashsetCreate(
        hashset: *mut *mut SCIP_HASHSET,
        blkmem: *mut BMS_BLKMEM,
        size: ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " frees the hash set"]
    pub fn SCIPhashsetFree(hashset: *mut *mut SCIP_HASHSET, blkmem: *mut BMS_BLKMEM);
}
extern "C" {
    #[doc = " inserts new element into the hash set"]
    pub fn SCIPhashsetInsert(
        hashset: *mut SCIP_HASHSET,
        blkmem: *mut BMS_BLKMEM,
        element: *mut ::std::os::raw::c_void,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " checks whether an element exists in the hash set"]
    pub fn SCIPhashsetExists(
        hashset: *mut SCIP_HASHSET,
        element: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " removes an element from the hash set, if it exists"]
    pub fn SCIPhashsetRemove(
        hashset: *mut SCIP_HASHSET,
        element: *mut ::std::os::raw::c_void,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " prints statistics about hash set usage"]
    pub fn SCIPhashsetPrintStatistics(
        hashset: *mut SCIP_HASHSET,
        messagehdlr: *mut SCIP_MESSAGEHDLR,
    );
}
extern "C" {
    #[doc = " indicates whether a hash set has no entries"]
    pub fn SCIPhashsetIsEmpty(hashset: *mut SCIP_HASHSET) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " gives the number of elements in a hash set"]
    pub fn SCIPhashsetGetNElements(hashset: *mut SCIP_HASHSET) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " gives the number of slots of a hash set"]
    pub fn SCIPhashsetGetNSlots(hashset: *mut SCIP_HASHSET) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " gives the array of hash set slots; contains all elements in indetermined order and may contain NULL values"]
    pub fn SCIPhashsetGetSlots(hashset: *mut SCIP_HASHSET) -> *mut *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " removes all entries in a hash set."]
    pub fn SCIPhashsetRemoveAll(hashset: *mut SCIP_HASHSET);
}
extern "C" {
    #[doc = " create a resource activity"]
    pub fn SCIPactivityCreate(
        activity: *mut *mut SCIP_RESOURCEACTIVITY,
        var: *mut SCIP_VAR,
        duration: ::std::os::raw::c_int,
        demand: ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " frees a resource activity"]
    pub fn SCIPactivityFree(activity: *mut *mut SCIP_RESOURCEACTIVITY);
}
extern "C" {
    #[doc = " returns the start time variable of the resource activity"]
    pub fn SCIPactivityGetVar(activity: *mut SCIP_RESOURCEACTIVITY) -> *mut SCIP_VAR;
}
extern "C" {
    #[doc = " returns the duration of the resource activity"]
    pub fn SCIPactivityGetDuration(activity: *mut SCIP_RESOURCEACTIVITY) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " returns the demand of the resource activity"]
    pub fn SCIPactivityGetDemand(activity: *mut SCIP_RESOURCEACTIVITY) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " returns the energy of the resource activity"]
    pub fn SCIPactivityGetEnergy(activity: *mut SCIP_RESOURCEACTIVITY) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " creates resource profile"]
    pub fn SCIPprofileCreate(
        profile: *mut *mut SCIP_PROFILE,
        capacity: ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " frees given resource profile"]
    pub fn SCIPprofileFree(profile: *mut *mut SCIP_PROFILE);
}
extern "C" {
    #[doc = " output of the given resource profile"]
    pub fn SCIPprofilePrint(
        profile: *mut SCIP_PROFILE,
        messagehdlr: *mut SCIP_MESSAGEHDLR,
        file: *mut FILE,
    );
}
extern "C" {
    #[doc = " returns the capacity of the resource profile"]
    pub fn SCIPprofileGetCapacity(profile: *mut SCIP_PROFILE) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " returns the number time points of the resource profile"]
    pub fn SCIPprofileGetNTimepoints(profile: *mut SCIP_PROFILE) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " returns the time points of the resource profile"]
    pub fn SCIPprofileGetTimepoints(profile: *mut SCIP_PROFILE) -> *mut ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " returns the loads of the resource profile"]
    pub fn SCIPprofileGetLoads(profile: *mut SCIP_PROFILE) -> *mut ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " returns the time point for given position of the resource profile"]
    pub fn SCIPprofileGetTime(
        profile: *mut SCIP_PROFILE,
        pos: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " returns the loads of the resource profile at the given position"]
    pub fn SCIPprofileGetLoad(
        profile: *mut SCIP_PROFILE,
        pos: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " returns if the given time point exists in the resource profile and stores the position of the given time point if it\n  exists; otherwise the position of the next smaller existing time point is stored"]
    pub fn SCIPprofileFindLeft(
        profile: *mut SCIP_PROFILE,
        timepoint: ::std::os::raw::c_int,
        pos: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " insert a core into resource profile; if the core is non-empty the resource profile will be updated otherwise nothing\n  happens"]
    pub fn SCIPprofileInsertCore(
        profile: *mut SCIP_PROFILE,
        left: ::std::os::raw::c_int,
        right: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
        pos: *mut ::std::os::raw::c_int,
        infeasible: *mut ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " subtracts the height from the resource profile during core time"]
    pub fn SCIPprofileDeleteCore(
        profile: *mut SCIP_PROFILE,
        left: ::std::os::raw::c_int,
        right: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " return the earliest possible starting point within the time interval [lb,ub] for a given core (given by its height\n  and duration)"]
    pub fn SCIPprofileGetEarliestFeasibleStart(
        profile: *mut SCIP_PROFILE,
        est: ::std::os::raw::c_int,
        lst: ::std::os::raw::c_int,
        duration: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
        infeasible: *mut ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " return the latest possible starting point within the time interval [lb,ub] for a given core (given by its height and\n  duration)"]
    pub fn SCIPprofileGetLatestFeasibleStart(
        profile: *mut SCIP_PROFILE,
        lb: ::std::os::raw::c_int,
        ub: ::std::os::raw::c_int,
        duration: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
        infeasible: *mut ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " resize directed graph structure"]
    pub fn SCIPdigraphResize(
        digraph: *mut SCIP_DIGRAPH,
        nnodes: ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " sets the sizes of the successor lists for the nodes in a directed graph and allocates memory for the lists"]
    pub fn SCIPdigraphSetSizes(
        digraph: *mut SCIP_DIGRAPH,
        sizes: *mut ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " frees given directed graph structure"]
    pub fn SCIPdigraphFree(digraph: *mut *mut SCIP_DIGRAPH);
}
extern "C" {
    #[doc = " add (directed) arc and a related data to the directed graph structure\n\n  @note if the arc is already contained, it is added a second time"]
    pub fn SCIPdigraphAddArc(
        digraph: *mut SCIP_DIGRAPH,
        startnode: ::std::os::raw::c_int,
        endnode: ::std::os::raw::c_int,
        data: *mut ::std::os::raw::c_void,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " add (directed) arc to the directed graph structure, if it is not contained, yet\n\n @note if there already exists an arc from startnode to endnode, the new arc is not added,\n       even if its data is different"]
    pub fn SCIPdigraphAddArcSafe(
        digraph: *mut SCIP_DIGRAPH,
        startnode: ::std::os::raw::c_int,
        endnode: ::std::os::raw::c_int,
        data: *mut ::std::os::raw::c_void,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " sets the number of successors to a given value"]
    pub fn SCIPdigraphSetNSuccessors(
        digraph: *mut SCIP_DIGRAPH,
        node: ::std::os::raw::c_int,
        nsuccessors: ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " returns the number of nodes of the given digraph"]
    pub fn SCIPdigraphGetNNodes(digraph: *mut SCIP_DIGRAPH) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " returns the node data, or NULL if no data exist"]
    pub fn SCIPdigraphGetNodeData(
        digraph: *mut SCIP_DIGRAPH,
        node: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " sets the node data"]
    pub fn SCIPdigraphSetNodeData(
        digraph: *mut SCIP_DIGRAPH,
        dataptr: *mut ::std::os::raw::c_void,
        node: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " returns the total number of arcs in the given digraph"]
    pub fn SCIPdigraphGetNArcs(digraph: *mut SCIP_DIGRAPH) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " returns the number of successor nodes of the given node"]
    pub fn SCIPdigraphGetNSuccessors(
        digraph: *mut SCIP_DIGRAPH,
        node: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " returns the array of indices of the successor nodes; this array must not be changed from outside"]
    pub fn SCIPdigraphGetSuccessors(
        digraph: *mut SCIP_DIGRAPH,
        node: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " returns the array of data corresponding to the arcs originating at the given node, or NULL if no data exist; this\n  array must not be changed from outside"]
    pub fn SCIPdigraphGetSuccessorsData(
        digraph: *mut SCIP_DIGRAPH,
        node: ::std::os::raw::c_int,
    ) -> *mut *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " identifies the articulation points in a given directed graph\n  uses the helper recursive function findArticulationPointsUtil"]
    pub fn SCIPdigraphGetArticulationPoints(
        digraph: *mut SCIP_DIGRAPH,
        articulations: *mut *mut ::std::os::raw::c_int,
        narticulations: *mut ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " Compute undirected connected components on the given graph.\n\n  @note For each arc, its reverse is added, so the graph does not need to be the directed representation of an\n        undirected graph."]
    pub fn SCIPdigraphComputeUndirectedComponents(
        digraph: *mut SCIP_DIGRAPH,
        minsize: ::std::os::raw::c_int,
        components: *mut ::std::os::raw::c_int,
        ncomponents: *mut ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " Computes all strongly connected components of an undirected connected component with Tarjan's Algorithm.\n  The resulting strongly connected components are sorted topologically (starting from the end of the\n  strongcomponents array).\n\n  @note In general a topological sort of the strongly connected components is not unique."]
    pub fn SCIPdigraphComputeDirectedComponents(
        digraph: *mut SCIP_DIGRAPH,
        compidx: ::std::os::raw::c_int,
        strongcomponents: *mut ::std::os::raw::c_int,
        strongcompstartidx: *mut ::std::os::raw::c_int,
        nstrongcomponents: *mut ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " Performes an (almost) topological sort on the undirected components of the given directed graph. The undirected\n  components should be computed before using SCIPdigraphComputeUndirectedComponents().\n\n  @note In general a topological sort is not unique.  Note, that there might be directed cycles, that are randomly\n        broken, which is the reason for having only almost topologically sorted arrays."]
    pub fn SCIPdigraphTopoSortComponents(digraph: *mut SCIP_DIGRAPH) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " returns the number of previously computed undirected components for the given directed graph"]
    pub fn SCIPdigraphGetNComponents(digraph: *mut SCIP_DIGRAPH) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Returns the previously computed undirected component of the given number for the given directed graph.\n  If the components were sorted using SCIPdigraphTopoSortComponents(), the component is (almost) topologically sorted."]
    pub fn SCIPdigraphGetComponent(
        digraph: *mut SCIP_DIGRAPH,
        compidx: ::std::os::raw::c_int,
        nodes: *mut *mut ::std::os::raw::c_int,
        nnodes: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " frees the component information for the given directed graph"]
    pub fn SCIPdigraphFreeComponents(digraph: *mut SCIP_DIGRAPH);
}
extern "C" {
    #[doc = " output of the given directed graph via the given message handler"]
    pub fn SCIPdigraphPrint(
        digraph: *mut SCIP_DIGRAPH,
        messagehdlr: *mut SCIP_MESSAGEHDLR,
        file: *mut FILE,
    );
}
extern "C" {
    #[doc = " prints the given directed graph structure in GML format into the given file"]
    pub fn SCIPdigraphPrintGml(digraph: *mut SCIP_DIGRAPH, file: *mut FILE);
}
extern "C" {
    #[doc = " output of the given directed graph via the given message handler"]
    pub fn SCIPdigraphPrintComponents(
        digraph: *mut SCIP_DIGRAPH,
        messagehdlr: *mut SCIP_MESSAGEHDLR,
        file: *mut FILE,
    );
}
extern "C" {
    #[doc = " creates a binary tree node with sorting value and user data"]
    pub fn SCIPbtnodeCreate(
        tree: *mut SCIP_BT,
        node: *mut *mut SCIP_BTNODE,
        dataptr: *mut ::std::os::raw::c_void,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " frees the binary node including the rooted subtree\n\n  @note The user pointer (object) is not freed. If needed, it has to be done by the user."]
    pub fn SCIPbtnodeFree(tree: *mut SCIP_BT, node: *mut *mut SCIP_BTNODE);
}
extern "C" {
    #[doc = " returns the user data pointer stored in that node"]
    pub fn SCIPbtnodeGetData(node: *mut SCIP_BTNODE) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " returns the parent which can be NULL if the given node is the root"]
    pub fn SCIPbtnodeGetParent(node: *mut SCIP_BTNODE) -> *mut SCIP_BTNODE;
}
extern "C" {
    #[doc = " returns left child which can be NULL if the given node is a leaf"]
    pub fn SCIPbtnodeGetLeftchild(node: *mut SCIP_BTNODE) -> *mut SCIP_BTNODE;
}
extern "C" {
    #[doc = " returns right child which can be NULL if the given node is a leaf"]
    pub fn SCIPbtnodeGetRightchild(node: *mut SCIP_BTNODE) -> *mut SCIP_BTNODE;
}
extern "C" {
    #[doc = " returns the sibling of the node or NULL if does not exist"]
    pub fn SCIPbtnodeGetSibling(node: *mut SCIP_BTNODE) -> *mut SCIP_BTNODE;
}
extern "C" {
    #[doc = " returns whether the node is a root node"]
    pub fn SCIPbtnodeIsRoot(node: *mut SCIP_BTNODE) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " returns whether the node is a leaf"]
    pub fn SCIPbtnodeIsLeaf(node: *mut SCIP_BTNODE) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " returns TRUE if the given node is left child"]
    pub fn SCIPbtnodeIsLeftchild(node: *mut SCIP_BTNODE) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " returns TRUE if the given node is right child"]
    pub fn SCIPbtnodeIsRightchild(node: *mut SCIP_BTNODE) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " sets the give node data\n\n  @note The old user pointer is not freed."]
    pub fn SCIPbtnodeSetData(node: *mut SCIP_BTNODE, dataptr: *mut ::std::os::raw::c_void);
}
extern "C" {
    #[doc = " sets parent node\n\n  @note The old parent including the rooted subtree is not delete."]
    pub fn SCIPbtnodeSetParent(node: *mut SCIP_BTNODE, parent: *mut SCIP_BTNODE);
}
extern "C" {
    #[doc = " sets left child\n\n  @note The old left child including the rooted subtree is not delete."]
    pub fn SCIPbtnodeSetLeftchild(node: *mut SCIP_BTNODE, left: *mut SCIP_BTNODE);
}
extern "C" {
    #[doc = " sets right child\n\n  @note The old right child including the rooted subtree is not delete."]
    pub fn SCIPbtnodeSetRightchild(node: *mut SCIP_BTNODE, right: *mut SCIP_BTNODE);
}
extern "C" {
    #[doc = " creates an binary tree"]
    pub fn SCIPbtCreate(tree: *mut *mut SCIP_BT, blkmem: *mut BMS_BLKMEM) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " frees binary tree\n\n  @note The user pointers (object) of the search nodes are not freed. If needed, it has to be done by the user."]
    pub fn SCIPbtFree(tree: *mut *mut SCIP_BT);
}
extern "C" {
    #[doc = " prints the binary tree in GML format into the given file"]
    pub fn SCIPbtPrintGml(tree: *mut SCIP_BT, file: *mut FILE);
}
extern "C" {
    #[doc = " returns whether the binary tree is empty (has no nodes)"]
    pub fn SCIPbtIsEmpty(tree: *mut SCIP_BT) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " returns the root node of the binary tree or NULL if the binary tree is empty"]
    pub fn SCIPbtGetRoot(tree: *mut SCIP_BT) -> *mut SCIP_BTNODE;
}
extern "C" {
    #[doc = " sets root node\n\n  @note The old root including the rooted subtree is not delete."]
    pub fn SCIPbtSetRoot(tree: *mut SCIP_BT, root: *mut SCIP_BTNODE);
}
extern "C" {
    #[doc = " clears the disjoint set (union find) structure \\p djset"]
    pub fn SCIPdisjointsetClear(djset: *mut SCIP_DISJOINTSET);
}
extern "C" {
    #[doc = " finds and returns the component identifier of this \\p element"]
    pub fn SCIPdisjointsetFind(
        djset: *mut SCIP_DISJOINTSET,
        element: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " merges the components containing the elements \\p p and \\p q"]
    pub fn SCIPdisjointsetUnion(
        djset: *mut SCIP_DISJOINTSET,
        p: ::std::os::raw::c_int,
        q: ::std::os::raw::c_int,
        forcerepofp: ::std::os::raw::c_uint,
    );
}
extern "C" {
    #[doc = " returns the number of independent components in this disjoint set (union find) data structure"]
    pub fn SCIPdisjointsetGetComponentCount(djset: *mut SCIP_DISJOINTSET) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " returns the size (number of nodes) of this disjoint set (union find) data structure"]
    pub fn SCIPdisjointsetGetSize(djset: *mut SCIP_DISJOINTSET) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " returns the machine epsilon: the smallest number eps > 0, for which 1.0 + eps > 1.0"]
    pub fn SCIPcalcMachineEpsilon() -> f64;
}
extern "C" {
    #[doc = " returns the next representable value of from in the direction of to"]
    pub fn SCIPnextafter(from: f64, to: f64) -> f64;
}
extern "C" {
    #[doc = " calculates the greatest common divisor of the two given values"]
    pub fn SCIPcalcGreComDiv(
        val1: ::std::os::raw::c_longlong,
        val2: ::std::os::raw::c_longlong,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    #[doc = " calculates the smallest common multiple of the two given values"]
    pub fn SCIPcalcSmaComMul(
        val1: ::std::os::raw::c_longlong,
        val2: ::std::os::raw::c_longlong,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    #[doc = " calculates a binomial coefficient n over m, choose m elements out of n, maximal value will be 33 over 16 (because\n  the n=33 is the last line in the Pascal's triangle where each entry fits in a 4 byte value), an error occurs due to\n  big numbers or an negative value m (and m < n) and -1 will be returned"]
    pub fn SCIPcalcBinomCoef(
        n: ::std::os::raw::c_int,
        m: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    #[doc = " calculates hash for floating-point number by using Fibonacci hashing"]
    pub fn SCIPcalcFibHash(v: f64) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " converts a real number into a (approximate) rational representation, and returns TRUE iff the conversion was\n  successful"]
    pub fn SCIPrealToRational(
        val: f64,
        mindelta: f64,
        maxdelta: f64,
        maxdnom: ::std::os::raw::c_longlong,
        nominator: *mut ::std::os::raw::c_longlong,
        denominator: *mut ::std::os::raw::c_longlong,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " tries to find a value, such that all given values, if scaled with this value become integral in relative allowed\n  difference in between mindelta and maxdelta"]
    pub fn SCIPcalcIntegralScalar(
        vals: *mut f64,
        nvals: ::std::os::raw::c_int,
        mindelta: f64,
        maxdelta: f64,
        maxdnom: ::std::os::raw::c_longlong,
        maxscale: f64,
        intscalar: *mut f64,
        success: *mut ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " given a (usually very small) interval, tries to find a rational number with simple denominator (i.e. a small\n  number, probably multiplied with powers of 10) out of this interval; returns TRUE iff a valid rational\n  number inside the interval was found"]
    pub fn SCIPfindSimpleRational(
        lb: f64,
        ub: f64,
        maxdnom: ::std::os::raw::c_longlong,
        nominator: *mut ::std::os::raw::c_longlong,
        denominator: *mut ::std::os::raw::c_longlong,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " given a (usually very small) interval, selects a value inside this interval; it is tried to select a rational number\n  with simple denominator (i.e. a small number, probably multiplied with powers of 10);\n  if no valid rational number inside the interval was found, selects the central value of the interval"]
    pub fn SCIPselectSimpleValue(lb: f64, ub: f64, maxdnom: ::std::os::raw::c_longlong) -> f64;
}
extern "C" {
    #[doc = " Performs the Newton Procedure from a given starting point to compute a root of the given function with\n  specified precision and maximum number of iterations. If the procedure fails, SCIP_INVALID is returned."]
    pub fn SCIPcalcRootNewton(
        function: ::std::option::Option<
            unsafe extern "C" fn(
                point: f64,
                params: *mut f64,
                nparams: ::std::os::raw::c_int,
            ) -> f64,
        >,
        derivative: ::std::option::Option<
            unsafe extern "C" fn(
                point: f64,
                params: *mut f64,
                nparams: ::std::os::raw::c_int,
            ) -> f64,
        >,
        params: *mut f64,
        nparams: ::std::os::raw::c_int,
        x: f64,
        eps: f64,
        k: ::std::os::raw::c_int,
    ) -> f64;
}
extern "C" {
    #[doc = " returns the relative difference: (val1-val2)/max(|val1|,|val2|,1.0)"]
    pub fn SCIPrelDiff(val1: f64, val2: f64) -> f64;
}
extern "C" {
    #[doc = " computes the gap from the primal and the dual bound"]
    pub fn SCIPcomputeGap(eps: f64, inf: f64, primalbound: f64, dualbound: f64) -> f64;
}
extern "C" {
    #[doc = " returns a random integer between minrandval and maxrandval\n\n  @deprecated Please use SCIPrandomGetInt() to request a random integer."]
    pub fn SCIPgetRandomInt(
        minrandval: ::std::os::raw::c_int,
        maxrandval: ::std::os::raw::c_int,
        seedp: *mut ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " returns a random integer between minrandval and maxrandval"]
    pub fn SCIPrandomGetInt(
        randgen: *mut SCIP_RANDNUMGEN,
        minrandval: ::std::os::raw::c_int,
        maxrandval: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " draws a random subset of disjoint elements from a given set of disjoint elements;\n  this implementation is suited for the case that nsubelems is considerably smaller then nelems"]
    pub fn SCIPrandomGetSubset(
        randgen: *mut SCIP_RANDNUMGEN,
        set: *mut *mut ::std::os::raw::c_void,
        nelems: ::std::os::raw::c_int,
        subset: *mut *mut ::std::os::raw::c_void,
        nsubelems: ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " returns a random real between minrandval and maxrandval"]
    pub fn SCIPrandomGetReal(
        randgen: *mut SCIP_RANDNUMGEN,
        minrandval: f64,
        maxrandval: f64,
    ) -> f64;
}
extern "C" {
    #[doc = " returns a random real between minrandval and maxrandval\n\n  @deprecated Please use SCIPrandomGetReal() to request a random real."]
    pub fn SCIPgetRandomReal(
        minrandval: f64,
        maxrandval: f64,
        seedp: *mut ::std::os::raw::c_uint,
    ) -> f64;
}
extern "C" {
    #[doc = " draws a random subset of disjoint elements from a given set of disjoint elements;\n  this implementation is suited for the case that nsubelems is considerably smaller then nelems\n\n  @deprecated Please use SCIPrandomGetSubset()"]
    pub fn SCIPgetRandomSubset(
        set: *mut *mut ::std::os::raw::c_void,
        nelems: ::std::os::raw::c_int,
        subset: *mut *mut ::std::os::raw::c_void,
        nsubelems: ::std::os::raw::c_int,
        randseed: ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " swaps two ints"]
    pub fn SCIPswapInts(value1: *mut ::std::os::raw::c_int, value2: *mut ::std::os::raw::c_int);
}
extern "C" {
    #[doc = " swaps two real values"]
    pub fn SCIPswapReals(value1: *mut f64, value2: *mut f64);
}
extern "C" {
    #[doc = " swaps the addresses of two pointers"]
    pub fn SCIPswapPointers(
        pointer1: *mut *mut ::std::os::raw::c_void,
        pointer2: *mut *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    #[doc = " randomly shuffles parts of an integer array using the Fisher-Yates algorithm\n\n  @deprecated Please use SCIPrandomPermuteIntArray()"]
    pub fn SCIPpermuteIntArray(
        array: *mut ::std::os::raw::c_int,
        begin: ::std::os::raw::c_int,
        end: ::std::os::raw::c_int,
        randseed: *mut ::std::os::raw::c_uint,
    );
}
extern "C" {
    #[doc = " randomly shuffles parts of an integer array using the Fisher-Yates algorithm"]
    pub fn SCIPrandomPermuteIntArray(
        randgen: *mut SCIP_RANDNUMGEN,
        array: *mut ::std::os::raw::c_int,
        begin: ::std::os::raw::c_int,
        end: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " randomly shuffles parts of an array using the Fisher-Yates algorithm"]
    pub fn SCIPrandomPermuteArray(
        randgen: *mut SCIP_RANDNUMGEN,
        array: *mut *mut ::std::os::raw::c_void,
        begin: ::std::os::raw::c_int,
        end: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " randomly shuffles parts of an array using the Fisher-Yates algorithm\n\n  @deprecated Please use SCIPrandomPermuteArray()"]
    pub fn SCIPpermuteArray(
        array: *mut *mut ::std::os::raw::c_void,
        begin: ::std::os::raw::c_int,
        end: ::std::os::raw::c_int,
        randseed: *mut ::std::os::raw::c_uint,
    );
}
extern "C" {
    #[doc = " computes set intersection (duplicates removed) of two integer arrays that are ordered ascendingly\n\n @deprecated Switch to SCIPcomputeArraysIntersectionInt()."]
    pub fn SCIPcomputeArraysIntersection(
        array1: *mut ::std::os::raw::c_int,
        narray1: ::std::os::raw::c_int,
        array2: *mut ::std::os::raw::c_int,
        narray2: ::std::os::raw::c_int,
        intersectarray: *mut ::std::os::raw::c_int,
        nintersectarray: *mut ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " computes set intersection (duplicates removed) of two integer arrays that are ordered ascendingly"]
    pub fn SCIPcomputeArraysIntersectionInt(
        array1: *mut ::std::os::raw::c_int,
        narray1: ::std::os::raw::c_int,
        array2: *mut ::std::os::raw::c_int,
        narray2: ::std::os::raw::c_int,
        intersectarray: *mut ::std::os::raw::c_int,
        nintersectarray: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " computes set intersection (duplicates removed) of two void-pointer arrays that are ordered ascendingly"]
    pub fn SCIPcomputeArraysIntersectionPtr(
        array1: *mut *mut ::std::os::raw::c_void,
        narray1: ::std::os::raw::c_int,
        array2: *mut *mut ::std::os::raw::c_void,
        narray2: ::std::os::raw::c_int,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        intersectarray: *mut *mut ::std::os::raw::c_void,
        nintersectarray: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " computes set difference (duplicates removed) of two integer arrays that are ordered ascendingly\n\n @deprecated Switch to SCIPcomputeArraysSetminusInt()."]
    pub fn SCIPcomputeArraysSetminus(
        array1: *mut ::std::os::raw::c_int,
        narray1: ::std::os::raw::c_int,
        array2: *mut ::std::os::raw::c_int,
        narray2: ::std::os::raw::c_int,
        setminusarray: *mut ::std::os::raw::c_int,
        nsetminusarray: *mut ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " computes set difference (duplicates removed) of two integer arrays that are ordered ascendingly"]
    pub fn SCIPcomputeArraysSetminusInt(
        array1: *mut ::std::os::raw::c_int,
        narray1: ::std::os::raw::c_int,
        array2: *mut ::std::os::raw::c_int,
        narray2: ::std::os::raw::c_int,
        setminusarray: *mut ::std::os::raw::c_int,
        nsetminusarray: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " copies characters from 'src' to 'dest', copying is stopped when either the 'stop' character is reached or after\n  'cnt' characters have been copied, whichever comes first.\n\n  @note undefined behaviuor on overlapping arrays"]
    pub fn SCIPmemccpy(
        dest: *mut ::std::os::raw::c_char,
        src: *const ::std::os::raw::c_char,
        stop: ::std::os::raw::c_char,
        cnt: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " prints an error message containing of the given string followed by a string describing the current system error;\n  prefers to use the strerror_r method, which is threadsafe; on systems where this method does not exist,\n  NO_STRERROR_R should be defined (see INSTALL), in this case, srerror is used which is not guaranteed to be\n  threadsafe (on SUN-systems, it actually is)"]
    pub fn SCIPprintSysError(message: *const ::std::os::raw::c_char);
}
extern "C" {
    #[doc = " extracts tokens from strings - wrapper method for strtok_r()"]
    pub fn SCIPstrtok(
        s: *mut ::std::os::raw::c_char,
        delim: *const ::std::os::raw::c_char,
        ptrptr: *mut *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " translates the given string into a string where symbols \", ', and spaces are escaped with a \\ prefix"]
    pub fn SCIPescapeString(
        t: *mut ::std::os::raw::c_char,
        bufsize: ::std::os::raw::c_int,
        s: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    #[doc = " increases string pointer as long as it refers to a space character or an explicit space control sequence"]
    pub fn SCIPskipSpace(s: *mut *mut ::std::os::raw::c_char) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " safe version of snprintf"]
    pub fn SCIPsnprintf(
        t: *mut ::std::os::raw::c_char,
        len: ::std::os::raw::c_int,
        s: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " safe version of strncpy\n\n  Copies string in s to t using at most @a size-1 nonzero characters (strncpy copies size characters). It always adds\n  a terminating zero char. Does not pad the remaining string with zero characters (unlike strncpy). Returns the number\n  of copied nonzero characters, if the length of s is at most size - 1, and returns size otherwise. Thus, the original\n  string was truncated if the return value is size."]
    pub fn SCIPstrncpy(
        t: *mut ::std::os::raw::c_char,
        s: *const ::std::os::raw::c_char,
        size: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " extract the next token as a integer value if it is one; in case no value is parsed the endptr is set to @p str\n\n  @return Returns TRUE if a value could be extracted, otherwise FALSE"]
    pub fn SCIPstrToIntValue(
        str_: *const ::std::os::raw::c_char,
        value: *mut ::std::os::raw::c_int,
        endptr: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " extract the next token as a double value if it is one; in case a value is parsed the endptr is set to @p str\n\n  @return Returns TRUE if a value could be extracted, otherwise FALSE"]
    pub fn SCIPstrToRealValue(
        str_: *const ::std::os::raw::c_char,
        value: *mut f64,
        endptr: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " copies the first size characters between a start and end character of str into token, if no error occurred endptr\n  will point to the position after the read part, otherwise it will point to @p str"]
    pub fn SCIPstrCopySection(
        str_: *const ::std::os::raw::c_char,
        startchar: ::std::os::raw::c_char,
        endchar: ::std::os::raw::c_char,
        token: *mut ::std::os::raw::c_char,
        size: ::std::os::raw::c_int,
        endptr: *mut *mut ::std::os::raw::c_char,
    );
}
extern "C" {
    #[doc = " checks whether a given string t appears at the beginning of the string s (up to spaces at beginning)"]
    pub fn SCIPstrAtStart(
        s: *const ::std::os::raw::c_char,
        t: *const ::std::os::raw::c_char,
        tlen: usize,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " returns, whether the given file exists"]
    pub fn SCIPfileExists(filename: *const ::std::os::raw::c_char) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " splits filename into path, name, and extension"]
    pub fn SCIPsplitFilename(
        filename: *mut ::std::os::raw::c_char,
        path: *mut *mut ::std::os::raw::c_char,
        name: *mut *mut ::std::os::raw::c_char,
        extension: *mut *mut ::std::os::raw::c_char,
        compression: *mut *mut ::std::os::raw::c_char,
    );
}
extern "C" {
    #[doc = " gets name of node selector"]
    pub fn SCIPnodeselGetName(nodesel: *mut SCIP_NODESEL) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " gets description of node selector"]
    pub fn SCIPnodeselGetDesc(nodesel: *mut SCIP_NODESEL) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " gets priority of node selector in standard mode"]
    pub fn SCIPnodeselGetStdPriority(nodesel: *mut SCIP_NODESEL) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " gets priority of node selector in memory saving mode"]
    pub fn SCIPnodeselGetMemsavePriority(nodesel: *mut SCIP_NODESEL) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " gets user data of node selector"]
    pub fn SCIPnodeselGetData(nodesel: *mut SCIP_NODESEL) -> *mut SCIP_NODESELDATA;
}
extern "C" {
    #[doc = " sets user data of node selector; user has to free old data in advance!"]
    pub fn SCIPnodeselSetData(nodesel: *mut SCIP_NODESEL, nodeseldata: *mut SCIP_NODESELDATA);
}
extern "C" {
    #[doc = " is node selector initialized?"]
    pub fn SCIPnodeselIsInitialized(nodesel: *mut SCIP_NODESEL) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " gets time in seconds used in this node selector for setting up for next stages"]
    pub fn SCIPnodeselGetSetupTime(nodesel: *mut SCIP_NODESEL) -> f64;
}
extern "C" {
    #[doc = " gets time in seconds used in this node selector"]
    pub fn SCIPnodeselGetTime(nodesel: *mut SCIP_NODESEL) -> f64;
}
extern "C" {
    #[doc = " returns type of parameter"]
    pub fn SCIPparamGetType(param: *mut SCIP_PARAM) -> SCIP_PARAMTYPE;
}
extern "C" {
    #[doc = " returns name of parameter"]
    pub fn SCIPparamGetName(param: *mut SCIP_PARAM) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " returns description of parameter"]
    pub fn SCIPparamGetDesc(param: *mut SCIP_PARAM) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " returns locally defined parameter specific data"]
    pub fn SCIPparamGetData(param: *mut SCIP_PARAM) -> *mut SCIP_PARAMDATA;
}
extern "C" {
    #[doc = " returns whether parameter is advanced"]
    pub fn SCIPparamIsAdvanced(param: *mut SCIP_PARAM) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " returns whether parameter is fixed"]
    pub fn SCIPparamIsFixed(param: *mut SCIP_PARAM) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " sets fixing status of given parameter"]
    pub fn SCIPparamSetFixed(param: *mut SCIP_PARAM, fixed: ::std::os::raw::c_uint);
}
extern "C" {
    #[doc = " returns value of SCIP_Bool parameter"]
    pub fn SCIPparamGetBool(param: *mut SCIP_PARAM) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " returns default value of SCIP_Bool parameter"]
    pub fn SCIPparamGetBoolDefault(param: *mut SCIP_PARAM) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " returns value of int parameter"]
    pub fn SCIPparamGetInt(param: *mut SCIP_PARAM) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " returns minimal value of int parameter"]
    pub fn SCIPparamGetIntMin(param: *mut SCIP_PARAM) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " returns maximal value of int parameter"]
    pub fn SCIPparamGetIntMax(param: *mut SCIP_PARAM) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " returns default value of int parameter"]
    pub fn SCIPparamGetIntDefault(param: *mut SCIP_PARAM) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " returns value of SCIP_Longint parameter"]
    pub fn SCIPparamGetLongint(param: *mut SCIP_PARAM) -> ::std::os::raw::c_longlong;
}
extern "C" {
    #[doc = " returns minimal value of longint parameter"]
    pub fn SCIPparamGetLongintMin(param: *mut SCIP_PARAM) -> ::std::os::raw::c_longlong;
}
extern "C" {
    #[doc = " returns maximal value of longint parameter"]
    pub fn SCIPparamGetLongintMax(param: *mut SCIP_PARAM) -> ::std::os::raw::c_longlong;
}
extern "C" {
    #[doc = " returns default value of SCIP_Longint parameter"]
    pub fn SCIPparamGetLongintDefault(param: *mut SCIP_PARAM) -> ::std::os::raw::c_longlong;
}
extern "C" {
    #[doc = " returns value of SCIP_Real parameter"]
    pub fn SCIPparamGetReal(param: *mut SCIP_PARAM) -> f64;
}
extern "C" {
    #[doc = " returns minimal value of real parameter"]
    pub fn SCIPparamGetRealMin(param: *mut SCIP_PARAM) -> f64;
}
extern "C" {
    #[doc = " returns maximal value of real parameter"]
    pub fn SCIPparamGetRealMax(param: *mut SCIP_PARAM) -> f64;
}
extern "C" {
    #[doc = " returns default value of SCIP_Real parameter"]
    pub fn SCIPparamGetRealDefault(param: *mut SCIP_PARAM) -> f64;
}
extern "C" {
    #[doc = " returns value of char parameter"]
    pub fn SCIPparamGetChar(param: *mut SCIP_PARAM) -> ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " returns allowed values of char parameter, or NULL if everything is allowed"]
    pub fn SCIPparamGetCharAllowedValues(param: *mut SCIP_PARAM) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " returns default value of char parameter"]
    pub fn SCIPparamGetCharDefault(param: *mut SCIP_PARAM) -> ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " returns value of string parameter"]
    pub fn SCIPparamGetString(param: *mut SCIP_PARAM) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " returns default value of String parameter"]
    pub fn SCIPparamGetStringDefault(param: *mut SCIP_PARAM) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " returns whether the parameter is on its default setting"]
    pub fn SCIPparamIsDefault(param: *mut SCIP_PARAM) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn SCIPpresolComp(
        elem1: *mut ::std::os::raw::c_void,
        elem2: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SCIPpresolCompName(
        elem1: *mut ::std::os::raw::c_void,
        elem2: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " gets user data of presolver"]
    pub fn SCIPpresolGetData(presol: *mut SCIP_PRESOL) -> *mut SCIP_PRESOLDATA;
}
extern "C" {
    #[doc = " sets user data of presolver; user has to free old data in advance!"]
    pub fn SCIPpresolSetData(presol: *mut SCIP_PRESOL, presoldata: *mut SCIP_PRESOLDATA);
}
extern "C" {
    #[doc = " gets name of presolver"]
    pub fn SCIPpresolGetName(presol: *mut SCIP_PRESOL) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " gets description of presolver"]
    pub fn SCIPpresolGetDesc(presol: *mut SCIP_PRESOL) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " gets priority of presolver"]
    pub fn SCIPpresolGetPriority(presol: *mut SCIP_PRESOL) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " gets round limit of presolver"]
    pub fn SCIPpresolGetMaxrounds(presol: *mut SCIP_PRESOL) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " gets the timing mask of the presolver"]
    pub fn SCIPpresolGetTiming(presol: *mut SCIP_PRESOL) -> SCIP_PRESOLTIMING;
}
extern "C" {
    #[doc = " sets the timing mask of the presolver"]
    pub fn SCIPpresolSetTiming(presol: *mut SCIP_PRESOL, timing: SCIP_PRESOLTIMING);
}
extern "C" {
    #[doc = " is presolver initialized?"]
    pub fn SCIPpresolIsInitialized(presol: *mut SCIP_PRESOL) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " gets time in seconds used in this presolver for setting up for next stages"]
    pub fn SCIPpresolGetSetupTime(presol: *mut SCIP_PRESOL) -> f64;
}
extern "C" {
    #[doc = " gets time in seconds used in this presolver"]
    pub fn SCIPpresolGetTime(presol: *mut SCIP_PRESOL) -> f64;
}
extern "C" {
    #[doc = " gets number of variables fixed in presolver"]
    pub fn SCIPpresolGetNFixedVars(presol: *mut SCIP_PRESOL) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " gets number of variables aggregated in presolver"]
    pub fn SCIPpresolGetNAggrVars(presol: *mut SCIP_PRESOL) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " gets number of variable types changed in presolver"]
    pub fn SCIPpresolGetNChgVarTypes(presol: *mut SCIP_PRESOL) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " gets number of bounds changed in presolver"]
    pub fn SCIPpresolGetNChgBds(presol: *mut SCIP_PRESOL) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " gets number of holes added to domains of variables in presolver"]
    pub fn SCIPpresolGetNAddHoles(presol: *mut SCIP_PRESOL) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " gets number of constraints deleted in presolver"]
    pub fn SCIPpresolGetNDelConss(presol: *mut SCIP_PRESOL) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " gets number of constraints added in presolver"]
    pub fn SCIPpresolGetNAddConss(presol: *mut SCIP_PRESOL) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " gets number of constraints upgraded in presolver"]
    pub fn SCIPpresolGetNUpgdConss(presol: *mut SCIP_PRESOL) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " gets number of coefficients changed in presolver"]
    pub fn SCIPpresolGetNChgCoefs(presol: *mut SCIP_PRESOL) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " gets number of constraint sides changed in presolver"]
    pub fn SCIPpresolGetNChgSides(presol: *mut SCIP_PRESOL) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " gets number of times the presolver was called and tried to find reductions"]
    pub fn SCIPpresolGetNCalls(presol: *mut SCIP_PRESOL) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SCIPpricerComp(
        elem1: *mut ::std::os::raw::c_void,
        elem2: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SCIPpricerCompName(
        elem1: *mut ::std::os::raw::c_void,
        elem2: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " gets user data of variable pricer"]
    pub fn SCIPpricerGetData(pricer: *mut SCIP_PRICER) -> *mut SCIP_PRICERDATA;
}
extern "C" {
    #[doc = " sets user data of variable pricer; user has to free old data in advance!"]
    pub fn SCIPpricerSetData(pricer: *mut SCIP_PRICER, pricerdata: *mut SCIP_PRICERDATA);
}
extern "C" {
    #[doc = " gets name of variable pricer"]
    pub fn SCIPpricerGetName(pricer: *mut SCIP_PRICER) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " gets description of variable pricer"]
    pub fn SCIPpricerGetDesc(pricer: *mut SCIP_PRICER) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " gets priority of variable pricer"]
    pub fn SCIPpricerGetPriority(pricer: *mut SCIP_PRICER) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " gets the number of times, the pricer was called and tried to find a variable with negative reduced costs"]
    pub fn SCIPpricerGetNCalls(pricer: *mut SCIP_PRICER) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " gets the number of variables with negative reduced costs found by this pricer"]
    pub fn SCIPpricerGetNVarsFound(pricer: *mut SCIP_PRICER) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " gets time in seconds used in this pricer for setting up for next stages"]
    pub fn SCIPpricerGetSetupTime(pricer: *mut SCIP_PRICER) -> f64;
}
extern "C" {
    #[doc = " gets time in seconds used in this pricer"]
    pub fn SCIPpricerGetTime(pricer: *mut SCIP_PRICER) -> f64;
}
extern "C" {
    #[doc = " returns whether the given pricer is in use in the current problem"]
    pub fn SCIPpricerIsActive(pricer: *mut SCIP_PRICER) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " returns whether the pricer should be delayed until no other pricer finds a new variable"]
    pub fn SCIPpricerIsDelayed(pricer: *mut SCIP_PRICER) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " is variable pricer initialized?"]
    pub fn SCIPpricerIsInitialized(pricer: *mut SCIP_PRICER) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " gets user data of reader"]
    pub fn SCIPreaderGetData(reader: *mut SCIP_READER) -> *mut SCIP_READERDATA;
}
extern "C" {
    #[doc = " sets user data of reader; user has to free old data in advance!"]
    pub fn SCIPreaderSetData(reader: *mut SCIP_READER, readerdata: *mut SCIP_READERDATA);
}
extern "C" {
    #[doc = " gets name of reader"]
    pub fn SCIPreaderGetName(reader: *mut SCIP_READER) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " gets description of reader"]
    pub fn SCIPreaderGetDesc(reader: *mut SCIP_READER) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " gets file extension of reader"]
    pub fn SCIPreaderGetExtension(reader: *mut SCIP_READER) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " return whether the reader can read files"]
    pub fn SCIPreaderCanRead(reader: *mut SCIP_READER) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " return whether the reader can write files"]
    pub fn SCIPreaderCanWrite(reader: *mut SCIP_READER) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn SCIPrelaxComp(
        elem1: *mut ::std::os::raw::c_void,
        elem2: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SCIPrelaxCompName(
        elem1: *mut ::std::os::raw::c_void,
        elem2: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " gets user data of relaxation handler"]
    pub fn SCIPrelaxGetData(relax: *mut SCIP_RELAX) -> *mut SCIP_RELAXDATA;
}
extern "C" {
    #[doc = " sets user data of relaxation handler; user has to free old data in advance!"]
    pub fn SCIPrelaxSetData(relax: *mut SCIP_RELAX, relaxdata: *mut SCIP_RELAXDATA);
}
extern "C" {
    #[doc = " gets name of relaxation handler"]
    pub fn SCIPrelaxGetName(relax: *mut SCIP_RELAX) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " gets description of relaxation handler"]
    pub fn SCIPrelaxGetDesc(relax: *mut SCIP_RELAX) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " gets priority of relaxation handler"]
    pub fn SCIPrelaxGetPriority(relax: *mut SCIP_RELAX) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " gets frequency of relaxation handler"]
    pub fn SCIPrelaxGetFreq(relax: *mut SCIP_RELAX) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " gets time in seconds used in this relaxator for setting up for next stages"]
    pub fn SCIPrelaxGetSetupTime(relax: *mut SCIP_RELAX) -> f64;
}
extern "C" {
    #[doc = " gets time in seconds used in this relaxation handler"]
    pub fn SCIPrelaxGetTime(relax: *mut SCIP_RELAX) -> f64;
}
extern "C" {
    #[doc = " gets the total number of times the relaxation handler was called"]
    pub fn SCIPrelaxGetNCalls(relax: *mut SCIP_RELAX) -> ::std::os::raw::c_longlong;
}
extern "C" {
    #[doc = " gets the total number of times the relaxation handler cut off a node"]
    pub fn SCIPrelaxGetNCutoffs(relax: *mut SCIP_RELAX) -> ::std::os::raw::c_longlong;
}
extern "C" {
    #[doc = " gets the total number of times the relaxation handler improved a node's lower bound"]
    pub fn SCIPrelaxGetNImprovedLowerbound(relax: *mut SCIP_RELAX) -> ::std::os::raw::c_longlong;
}
extern "C" {
    #[doc = " gets the time in seconds spent for the execution of the relaxation handler when a node's lower bound could be improved (or a cutoff was found)"]
    pub fn SCIPrelaxGetImprovedLowerboundTime(relax: *mut SCIP_RELAX) -> f64;
}
extern "C" {
    #[doc = " gets the total number of times the relaxation handler added constraints"]
    pub fn SCIPrelaxGetNAddedConss(relax: *mut SCIP_RELAX) -> ::std::os::raw::c_longlong;
}
extern "C" {
    #[doc = " gets the total number of times the relaxation handler reduced variable domains"]
    pub fn SCIPrelaxGetNReducedDomains(relax: *mut SCIP_RELAX) -> ::std::os::raw::c_longlong;
}
extern "C" {
    #[doc = " gets the total number of times the relaxation handler separated cutting planes"]
    pub fn SCIPrelaxGetNSeparatedCuts(relax: *mut SCIP_RELAX) -> ::std::os::raw::c_longlong;
}
extern "C" {
    #[doc = " is relaxation handler initialized?"]
    pub fn SCIPrelaxIsInitialized(relax: *mut SCIP_RELAX) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " marks the current relaxation unsolved, s.t. the relaxation handler is called again in the next solving round"]
    pub fn SCIPrelaxMarkUnsolved(relax: *mut SCIP_RELAX);
}
extern "C" {
    #[doc = " returns the number of bound changes stored in the reoptnode"]
    pub fn SCIPreoptnodeGetNVars(reoptnode: *mut SCIP_REOPTNODE) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " returns the number of bound changes at the node stored at ID id"]
    pub fn SCIPreoptnodeGetNConss(reoptnode: *mut SCIP_REOPTNODE) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " returns the number of stored bound changes based on dual information in the reopttree at ID id"]
    pub fn SCIPreoptnodeGetNDualBoundChgs(reoptnode: *mut SCIP_REOPTNODE) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " returns the number of child nodes of @p reoptnode"]
    pub fn SCIPreoptnodeGetNChildren(reoptnode: *mut SCIP_REOPTNODE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SCIPreoptnodeGetLowerbound(reoptnode: *mut SCIP_REOPTNODE) -> f64;
}
extern "C" {
    #[doc = " returns the type of the @p reoptnode"]
    pub fn SCIPreoptnodeGetType(reoptnode: *mut SCIP_REOPTNODE) -> SCIP_REOPTTYPE;
}
extern "C" {
    #[doc = " create the constraint which splits the node stored at ID id on the basis of the stored dual information."]
    pub fn SCIPreoptnodeGetSplitCons(
        reoptnode: *mut SCIP_REOPTNODE,
        vars: *mut *mut SCIP_VAR,
        vals: *mut f64,
        constype: *mut REOPT_CONSTYPE,
        conssize: ::std::os::raw::c_int,
        nvars: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " returns all added constraints at ID id"]
    pub fn SCIPreoptnodeGetConss(
        reoptnode: *mut SCIP_REOPTNODE,
        vars: *mut *mut *mut SCIP_VAR,
        bounds: *mut *mut f64,
        boundtypes: *mut *mut SCIP_BOUNDTYPE,
        mem: ::std::os::raw::c_int,
        nconss: *mut ::std::os::raw::c_int,
        nvars: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " set the parent id"]
    pub fn SCIPreoptnodeSetParentID(
        reoptnode: *mut SCIP_REOPTNODE,
        parentid: ::std::os::raw::c_uint,
    );
}
extern "C" {
    #[doc = " returns the number of global restarts"]
    pub fn SCIPreoptGetNRestartsGlobal(reopt: *mut SCIP_REOPT) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " returns the number of local restarts in the current run"]
    pub fn SCIPreoptGetNRestartsLocal(reopt: *mut SCIP_REOPT) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " returns the number of local restarts over all runs"]
    pub fn SCIPreoptGetNTotalRestartsLocal(reopt: *mut SCIP_REOPT) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " returns the number of iteration with the first global restarts"]
    pub fn SCIPreoptGetFirstRestarts(reopt: *mut SCIP_REOPT) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " returns the number of iteration with the last global restarts"]
    pub fn SCIPreoptGetLastRestarts(reopt: *mut SCIP_REOPT) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " returns the number of nodes providing an improving feasible LP solution in the current run"]
    pub fn SCIPreoptGetNFeasNodes(reopt: *mut SCIP_REOPT) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " returns the number of nodes providing an improving feasible LP solution over all runs"]
    pub fn SCIPreoptGetNTotalFeasNodes(reopt: *mut SCIP_REOPT) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " returns the number of nodes that exceeded the cutoff bound in the current run"]
    pub fn SCIPreoptGetNPrunedNodes(reopt: *mut SCIP_REOPT) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " returns the number of nodes that exceeded the cutoff bound over all runs"]
    pub fn SCIPreoptGetNTotalPrunedNodes(reopt: *mut SCIP_REOPT) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " returns the number of reoptimized nodes that were cut off in the current run"]
    pub fn SCIPreoptGetNCutoffReoptnodes(reopt: *mut SCIP_REOPT) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " returns the number of reoptimized nodes that were cut off over all runs"]
    pub fn SCIPreoptGetNTotalCutoffReoptnodes(reopt: *mut SCIP_REOPT) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " returns the number of stored nodes with an infeasible LP in the current run"]
    pub fn SCIPreoptGetNInfNodes(reopt: *mut SCIP_REOPT) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " returns the number of stored nodes with an infeasible LP over all runs"]
    pub fn SCIPreoptGetNTotalInfNodes(reopt: *mut SCIP_REOPT) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SCIPsepaComp(
        elem1: *mut ::std::os::raw::c_void,
        elem2: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SCIPsepaCompName(
        elem1: *mut ::std::os::raw::c_void,
        elem2: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " gets user data of separator"]
    pub fn SCIPsepaGetData(sepa: *mut SCIP_SEPA) -> *mut SCIP_SEPADATA;
}
extern "C" {
    #[doc = " sets user data of separator; user has to free old data in advance!"]
    pub fn SCIPsepaSetData(sepa: *mut SCIP_SEPA, sepadata: *mut SCIP_SEPADATA);
}
extern "C" {
    #[doc = " gets name of separator"]
    pub fn SCIPsepaGetName(sepa: *mut SCIP_SEPA) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " gets description of separator"]
    pub fn SCIPsepaGetDesc(sepa: *mut SCIP_SEPA) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " gets priority of separator"]
    pub fn SCIPsepaGetPriority(sepa: *mut SCIP_SEPA) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " gets frequency of separator"]
    pub fn SCIPsepaGetFreq(sepa: *mut SCIP_SEPA) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " sets frequency of separator"]
    pub fn SCIPsepaSetFreq(sepa: *mut SCIP_SEPA, freq: ::std::os::raw::c_int);
}
extern "C" {
    #[doc = " get maximal bound distance at which the separator is called"]
    pub fn SCIPsepaGetMaxbounddist(sepa: *mut SCIP_SEPA) -> f64;
}
extern "C" {
    #[doc = " does the separator use a secondary SCIP instance?"]
    pub fn SCIPsepaUsesSubscip(sepa: *mut SCIP_SEPA) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " gets time in seconds used in this separator for setting up for next stages"]
    pub fn SCIPsepaGetSetupTime(sepa: *mut SCIP_SEPA) -> f64;
}
extern "C" {
    #[doc = " gets time in seconds used in this separator"]
    pub fn SCIPsepaGetTime(sepa: *mut SCIP_SEPA) -> f64;
}
extern "C" {
    #[doc = " gets the total number of times the separator was called"]
    pub fn SCIPsepaGetNCalls(sepa: *mut SCIP_SEPA) -> ::std::os::raw::c_longlong;
}
extern "C" {
    #[doc = " gets the total number of times the separator was called at the root"]
    pub fn SCIPsepaGetNRootCalls(sepa: *mut SCIP_SEPA) -> ::std::os::raw::c_longlong;
}
extern "C" {
    #[doc = " gets the number of times, the separator was called at the current node"]
    pub fn SCIPsepaGetNCallsAtNode(sepa: *mut SCIP_SEPA) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " gets total number of times, the separator detected a cutoff"]
    pub fn SCIPsepaGetNCutoffs(sepa: *mut SCIP_SEPA) -> ::std::os::raw::c_longlong;
}
extern "C" {
    #[doc = " gets the total number of cutting planes added from the separator to the cut pool\n  and to the sepastore directly"]
    pub fn SCIPsepaGetNCutsFound(sepa: *mut SCIP_SEPA) -> ::std::os::raw::c_longlong;
}
extern "C" {
    #[doc = " gets the total number of cutting planes added from the separator to the sepastore;\n  equal to the sum of added cuts directly and via the pool."]
    pub fn SCIPsepaGetNCutsAdded(sepa: *mut SCIP_SEPA) -> ::std::os::raw::c_longlong;
}
extern "C" {
    #[doc = " gets the number of cutting planes from the separator added from the cut pool"]
    pub fn SCIPsepaGetNCutsAddedViaPool(sepa: *mut SCIP_SEPA) -> ::std::os::raw::c_longlong;
}
extern "C" {
    #[doc = " gets the number of cutting planes from the separator added directly to the sepastore"]
    pub fn SCIPsepaGetNCutsAddedDirect(sepa: *mut SCIP_SEPA) -> ::std::os::raw::c_longlong;
}
extern "C" {
    #[doc = " gets the total number of cutting planes from the separator applied to the LP"]
    pub fn SCIPsepaGetNCutsApplied(sepa: *mut SCIP_SEPA) -> ::std::os::raw::c_longlong;
}
extern "C" {
    #[doc = " gets the total number of cutting planes from the separator applied to the LP from the cutpool"]
    pub fn SCIPsepaGetNCutsAppliedViaPool(sepa: *mut SCIP_SEPA) -> ::std::os::raw::c_longlong;
}
extern "C" {
    #[doc = " gets the total number of cutting planes from the separator applied directly to the LP"]
    pub fn SCIPsepaGetNCutsAppliedDirect(sepa: *mut SCIP_SEPA) -> ::std::os::raw::c_longlong;
}
extern "C" {
    #[doc = " gets the number of cutting planes found by this separator at the current node"]
    pub fn SCIPsepaGetNCutsFoundAtNode(sepa: *mut SCIP_SEPA) -> ::std::os::raw::c_longlong;
}
extern "C" {
    #[doc = " gets total number of additional constraints added by this separator"]
    pub fn SCIPsepaGetNConssFound(sepa: *mut SCIP_SEPA) -> ::std::os::raw::c_longlong;
}
extern "C" {
    #[doc = " gets total number of domain reductions found by this separator"]
    pub fn SCIPsepaGetNDomredsFound(sepa: *mut SCIP_SEPA) -> ::std::os::raw::c_longlong;
}
extern "C" {
    #[doc = " should separator be delayed, if other separators found cuts?"]
    pub fn SCIPsepaIsDelayed(sepa: *mut SCIP_SEPA) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " was separation of the LP solution delayed at the last call?"]
    pub fn SCIPsepaWasLPDelayed(sepa: *mut SCIP_SEPA) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " was separation of the primal solution delayed at the last call?"]
    pub fn SCIPsepaWasSolDelayed(sepa: *mut SCIP_SEPA) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " is separator initialized?"]
    pub fn SCIPsepaIsInitialized(sepa: *mut SCIP_SEPA) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " gets whether separator is a parent separator"]
    pub fn SCIPsepaIsParentsepa(sepa: *mut SCIP_SEPA) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " gets parent separator (or NULL)"]
    pub fn SCIPsepaGetParentsepa(sepa: *mut SCIP_SEPA) -> *mut SCIP_SEPA;
}
extern "C" {
    #[doc = " gets name of cut selector"]
    pub fn SCIPcutselGetName(cutsel: *mut SCIP_CUTSEL) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " gets user data of cut selector"]
    pub fn SCIPcutselGetData(cutsel: *mut SCIP_CUTSEL) -> *mut SCIP_CUTSELDATA;
}
extern "C" {
    #[doc = " gets description of cut selector"]
    pub fn SCIPcutselGetDesc(cutsel: *mut SCIP_CUTSEL) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " gets priority of cut selector"]
    pub fn SCIPcutselGetPriority(cutsel: *mut SCIP_CUTSEL) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " sets user data of cut selector; user has to free old data in advance!"]
    pub fn SCIPcutselSetData(cutsel: *mut SCIP_CUTSEL, cutseldata: *mut SCIP_CUTSELDATA);
}
extern "C" {
    #[doc = " is cut selector initialized?"]
    pub fn SCIPcutselIsInitialized(cutsel: *mut SCIP_CUTSEL) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " gets time in seconds used in this cut selector for setting up for next stages"]
    pub fn SCIPcutselGetSetupTime(cutsel: *mut SCIP_CUTSEL) -> f64;
}
extern "C" {
    #[doc = " gets time in seconds used in this cut selector"]
    pub fn SCIPcutselGetTime(cutsel: *mut SCIP_CUTSEL) -> f64;
}
extern "C" {
    #[doc = " get number of times the cutselector was called"]
    pub fn SCIPcutselGetNCalls(cutsel: *mut SCIP_CUTSEL) -> ::std::os::raw::c_longlong;
}
extern "C" {
    #[doc = " get number of times the cutselector was called at the root"]
    pub fn SCIPcutselGetNRootCalls(cutsel: *mut SCIP_CUTSEL) -> ::std::os::raw::c_longlong;
}
extern "C" {
    #[doc = " get total number of cuts that were selected at the root"]
    pub fn SCIPcutselGetNRootCuts(cutsel: *mut SCIP_CUTSEL) -> ::std::os::raw::c_longlong;
}
extern "C" {
    #[doc = " get total number of forced cuts that were selected at the root"]
    pub fn SCIPcutselGetNRootForcedCuts(cutsel: *mut SCIP_CUTSEL) -> ::std::os::raw::c_longlong;
}
extern "C" {
    #[doc = " get total number of root cuts that were filtered"]
    pub fn SCIPcutselGetNRootCutsFiltered(cutsel: *mut SCIP_CUTSEL) -> ::std::os::raw::c_longlong;
}
extern "C" {
    #[doc = " get total number of local cuts that were selected"]
    pub fn SCIPcutselGetNLocalCuts(cutsel: *mut SCIP_CUTSEL) -> ::std::os::raw::c_longlong;
}
extern "C" {
    #[doc = " get total number of forced local cuts that were selected"]
    pub fn SCIPcutselGetNLocalForcedCuts(cutsel: *mut SCIP_CUTSEL) -> ::std::os::raw::c_longlong;
}
extern "C" {
    #[doc = " get total number of local cuts that were filtered"]
    pub fn SCIPcutselGetNLocalCutsFiltered(cutsel: *mut SCIP_CUTSEL) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn SCIPcutselComp(
        elem1: *mut ::std::os::raw::c_void,
        elem2: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SCIPpropComp(
        elem1: *mut ::std::os::raw::c_void,
        elem2: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SCIPpropCompPresol(
        elem1: *mut ::std::os::raw::c_void,
        elem2: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SCIPpropCompName(
        elem1: *mut ::std::os::raw::c_void,
        elem2: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " gets user data of propagator"]
    pub fn SCIPpropGetData(prop: *mut SCIP_PROP) -> *mut SCIP_PROPDATA;
}
extern "C" {
    #[doc = " sets user data of propagator; user has to free old data in advance!"]
    pub fn SCIPpropSetData(prop: *mut SCIP_PROP, propdata: *mut SCIP_PROPDATA);
}
extern "C" {
    #[doc = " gets name of propagator"]
    pub fn SCIPpropGetName(prop: *mut SCIP_PROP) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " gets description of propagator"]
    pub fn SCIPpropGetDesc(prop: *mut SCIP_PROP) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " gets priority of propagator"]
    pub fn SCIPpropGetPriority(prop: *mut SCIP_PROP) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " gets presolving priority of propagator"]
    pub fn SCIPpropGetPresolPriority(prop: *mut SCIP_PROP) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " gets frequency of propagator"]
    pub fn SCIPpropGetFreq(prop: *mut SCIP_PROP) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " gets time in seconds used for setting up this propagator for new stages"]
    pub fn SCIPpropGetSetupTime(prop: *mut SCIP_PROP) -> f64;
}
extern "C" {
    #[doc = " sets frequency of propagator"]
    pub fn SCIPpropSetFreq(prop: *mut SCIP_PROP, freq: ::std::os::raw::c_int);
}
extern "C" {
    #[doc = " gets time in seconds used in this propagator"]
    pub fn SCIPpropGetTime(prop: *mut SCIP_PROP) -> f64;
}
extern "C" {
    #[doc = " gets time in seconds used in this propagator during strong branching"]
    pub fn SCIPpropGetStrongBranchPropTime(prop: *mut SCIP_PROP) -> f64;
}
extern "C" {
    #[doc = " gets time in seconds used in this propagator for resolve propagation"]
    pub fn SCIPpropGetRespropTime(prop: *mut SCIP_PROP) -> f64;
}
extern "C" {
    #[doc = " gets time in seconds used in this propagator for presolving"]
    pub fn SCIPpropGetPresolTime(prop: *mut SCIP_PROP) -> f64;
}
extern "C" {
    #[doc = " gets the total number of times, the propagator was called"]
    pub fn SCIPpropGetNCalls(prop: *mut SCIP_PROP) -> ::std::os::raw::c_longlong;
}
extern "C" {
    #[doc = " gets the total number of times, the propagator was called for resolving a propagation"]
    pub fn SCIPpropGetNRespropCalls(prop: *mut SCIP_PROP) -> ::std::os::raw::c_longlong;
}
extern "C" {
    #[doc = " gets total number of times, this propagator detected a cutoff"]
    pub fn SCIPpropGetNCutoffs(prop: *mut SCIP_PROP) -> ::std::os::raw::c_longlong;
}
extern "C" {
    #[doc = " gets total number of domain reductions found by this propagator"]
    pub fn SCIPpropGetNDomredsFound(prop: *mut SCIP_PROP) -> ::std::os::raw::c_longlong;
}
extern "C" {
    #[doc = " should propagator be delayed, if other propagators found reductions?"]
    pub fn SCIPpropIsDelayed(prop: *mut SCIP_PROP) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " was propagator delayed at the last call?"]
    pub fn SCIPpropWasDelayed(prop: *mut SCIP_PROP) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " is propagator initialized?"]
    pub fn SCIPpropIsInitialized(prop: *mut SCIP_PROP) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " gets number of variables fixed during presolving of propagator"]
    pub fn SCIPpropGetNFixedVars(prop: *mut SCIP_PROP) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " gets number of variables aggregated during presolving of propagator"]
    pub fn SCIPpropGetNAggrVars(prop: *mut SCIP_PROP) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " gets number of variable types changed during presolving of propagator"]
    pub fn SCIPpropGetNChgVarTypes(prop: *mut SCIP_PROP) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " gets number of bounds changed during presolving of propagator"]
    pub fn SCIPpropGetNChgBds(prop: *mut SCIP_PROP) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " gets number of holes added to domains of variables during presolving of propagator"]
    pub fn SCIPpropGetNAddHoles(prop: *mut SCIP_PROP) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " gets number of constraints deleted during presolving of propagator"]
    pub fn SCIPpropGetNDelConss(prop: *mut SCIP_PROP) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " gets number of constraints added during presolving of propagator"]
    pub fn SCIPpropGetNAddConss(prop: *mut SCIP_PROP) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " gets number of constraints upgraded during presolving of propagator"]
    pub fn SCIPpropGetNUpgdConss(prop: *mut SCIP_PROP) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " gets number of coefficients changed during presolving of propagator"]
    pub fn SCIPpropGetNChgCoefs(prop: *mut SCIP_PROP) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " gets number of constraint sides changed during presolving of propagator"]
    pub fn SCIPpropGetNChgSides(prop: *mut SCIP_PROP) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " gets number of times the propagator was called in presolving and tried to find reductions"]
    pub fn SCIPpropGetNPresolCalls(prop: *mut SCIP_PROP) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " returns the timing mask of the propagator"]
    pub fn SCIPpropGetTimingmask(prop: *mut SCIP_PROP) -> SCIP_PROPTIMING;
}
extern "C" {
    #[doc = " does the propagator perform presolving?"]
    pub fn SCIPpropDoesPresolve(prop: *mut SCIP_PROP) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " returns the timing mask of the presolving method of the propagator"]
    pub fn SCIPpropGetPresolTiming(prop: *mut SCIP_PROP) -> SCIP_PRESOLTIMING;
}
extern "C" {
    #[doc = " sets the timing mask of the presolving method of the propagator"]
    pub fn SCIPpropSetPresolTiming(prop: *mut SCIP_PROP, presoltiming: SCIP_PRESOLTIMING);
}
extern "C" {
    #[doc = " gets origin of solution"]
    pub fn SCIPsolGetOrigin(sol: *mut SCIP_SOL) -> SCIP_SOLORIGIN;
}
extern "C" {
    #[doc = " returns whether the given solution is defined on original variables"]
    pub fn SCIPsolIsOriginal(sol: *mut SCIP_SOL) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " returns whether the given solution is partial"]
    pub fn SCIPsolIsPartial(sol: *mut SCIP_SOL) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " gets objective value of primal CIP solution which lives in the original problem space"]
    pub fn SCIPsolGetOrigObj(sol: *mut SCIP_SOL) -> f64;
}
extern "C" {
    #[doc = " gets clock time, when this solution was found"]
    pub fn SCIPsolGetTime(sol: *mut SCIP_SOL) -> f64;
}
extern "C" {
    #[doc = " gets branch and bound run number, where this solution was found"]
    pub fn SCIPsolGetRunnum(sol: *mut SCIP_SOL) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " gets node number of the specific branch and bound run, where this solution was found"]
    pub fn SCIPsolGetNodenum(sol: *mut SCIP_SOL) -> ::std::os::raw::c_longlong;
}
extern "C" {
    #[doc = " gets node's depth, where this solution was found"]
    pub fn SCIPsolGetDepth(sol: *mut SCIP_SOL) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " gets information if solution was found by the LP, a primal heuristic, or a custom relaxator"]
    pub fn SCIPsolGetType(sol: *mut SCIP_SOL) -> SCIP_SOLTYPE;
}
extern "C" {
    #[doc = " gets heuristic that found this solution, or NULL if solution has type different than SCIP_SOLTYPE_HEUR"]
    pub fn SCIPsolGetHeur(sol: *mut SCIP_SOL) -> *mut SCIP_HEUR;
}
extern "C" {
    #[doc = " gets relaxation handler that found this solution, or NULL if solution has different type than SCIP_SOLTYPE_RELAX"]
    pub fn SCIPsolGetRelax(sol: *mut SCIP_SOL) -> *mut SCIP_RELAX;
}
extern "C" {
    #[doc = " informs the solution that it now belongs to the given primal heuristic. For convenience and backwards compatibility,\n  the method accepts NULL as input for \\p heur, in which case the solution type is set to SCIP_SOLTYPE_LPRELAX.\n\n  @note Relaxation handlers should use SCIPsolSetRelax() instead."]
    pub fn SCIPsolSetHeur(sol: *mut SCIP_SOL, heur: *mut SCIP_HEUR);
}
extern "C" {
    #[doc = " informs the solution that it now belongs to the given relaxation handler"]
    pub fn SCIPsolSetRelax(sol: *mut SCIP_SOL, relax: *mut SCIP_RELAX);
}
extern "C" {
    #[doc = " informs the solution that it is an LP relaxation solution"]
    pub fn SCIPsolSetLPRelaxation(sol: *mut SCIP_SOL);
}
extern "C" {
    #[doc = " informs the solution that it is a solution found during strong branching"]
    pub fn SCIPsolSetStrongbranching(sol: *mut SCIP_SOL);
}
extern "C" {
    #[doc = " informs the solution that it originates from a pseudo solution"]
    pub fn SCIPsolSetPseudo(sol: *mut SCIP_SOL);
}
extern "C" {
    #[doc = " returns unique index of given solution"]
    pub fn SCIPsolGetIndex(sol: *mut SCIP_SOL) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " get maximum absolute bound violation of solution"]
    pub fn SCIPsolGetAbsBoundViolation(sol: *mut SCIP_SOL) -> f64;
}
extern "C" {
    #[doc = " get maximum relative bound violation of solution"]
    pub fn SCIPsolGetRelBoundViolation(sol: *mut SCIP_SOL) -> f64;
}
extern "C" {
    #[doc = " get maximum absolute integrality violation of solution"]
    pub fn SCIPsolGetAbsIntegralityViolation(sol: *mut SCIP_SOL) -> f64;
}
extern "C" {
    #[doc = " get maximum absolute LP row violation of solution"]
    pub fn SCIPsolGetAbsLPRowViolation(sol: *mut SCIP_SOL) -> f64;
}
extern "C" {
    #[doc = " get maximum relative LP row violation of solution"]
    pub fn SCIPsolGetRelLPRowViolation(sol: *mut SCIP_SOL) -> f64;
}
extern "C" {
    #[doc = " get maximum absolute constraint violation of solution"]
    pub fn SCIPsolGetAbsConsViolation(sol: *mut SCIP_SOL) -> f64;
}
extern "C" {
    #[doc = " get maximum relative constraint violation of solution"]
    pub fn SCIPsolGetRelConsViolation(sol: *mut SCIP_SOL) -> f64;
}
extern "C" {
    #[doc = " gets user data of statistics table"]
    pub fn SCIPtableGetData(table: *mut SCIP_TABLE) -> *mut SCIP_TABLEDATA;
}
extern "C" {
    #[doc = " sets user data of statistics table; user has to free old data in advance!"]
    pub fn SCIPtableSetData(table: *mut SCIP_TABLE, tabledata: *mut SCIP_TABLEDATA);
}
extern "C" {
    #[doc = " gets name of statistics table"]
    pub fn SCIPtableGetName(table: *mut SCIP_TABLE) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " gets description of statistics table"]
    pub fn SCIPtableGetDesc(table: *mut SCIP_TABLE) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " gets position of statistics table"]
    pub fn SCIPtableGetPosition(table: *mut SCIP_TABLE) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " gets earliest stage of statistics table"]
    pub fn SCIPtableGetEarliestStage(table: *mut SCIP_TABLE) -> SCIP_STAGE;
}
extern "C" {
    #[doc = " is statistics table currently active?"]
    pub fn SCIPtableIsActive(table: *mut SCIP_TABLE) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " is statistics table initialized?"]
    pub fn SCIPtableIsInitialized(table: *mut SCIP_TABLE) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn SCIPnodeCompLowerbound(
        elem1: *mut ::std::os::raw::c_void,
        elem2: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " returns the set of variable branchings that were performed in the parent node to create this node"]
    pub fn SCIPnodeGetParentBranchings(
        node: *mut SCIP_NODE,
        branchvars: *mut *mut SCIP_VAR,
        branchbounds: *mut f64,
        boundtypes: *mut SCIP_BOUNDTYPE,
        nbranchvars: *mut ::std::os::raw::c_int,
        branchvarssize: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " returns the set of variable branchings that were performed in all ancestor nodes (nodes on the path to the root) to create this node"]
    pub fn SCIPnodeGetAncestorBranchings(
        node: *mut SCIP_NODE,
        branchvars: *mut *mut SCIP_VAR,
        branchbounds: *mut f64,
        boundtypes: *mut SCIP_BOUNDTYPE,
        nbranchvars: *mut ::std::os::raw::c_int,
        branchvarssize: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " returns the set of variable branchings that were performed between the given @p node and the given @p parent node."]
    pub fn SCIPnodeGetAncestorBranchingsPart(
        node: *mut SCIP_NODE,
        parent: *mut SCIP_NODE,
        branchvars: *mut *mut SCIP_VAR,
        branchbounds: *mut f64,
        boundtypes: *mut SCIP_BOUNDTYPE,
        nbranchvars: *mut ::std::os::raw::c_int,
        branchvarssize: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " outputs the path into given file stream in GML format"]
    pub fn SCIPnodePrintAncestorBranchings(node: *mut SCIP_NODE, file: *mut FILE) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " returns the set of variable branchings that were performed in all ancestor nodes (nodes on the path to the root) to create this node\n  sorted by the nodes, starting from the current node going up to the root"]
    pub fn SCIPnodeGetAncestorBranchingPath(
        node: *mut SCIP_NODE,
        branchvars: *mut *mut SCIP_VAR,
        branchbounds: *mut f64,
        boundtypes: *mut SCIP_BOUNDTYPE,
        nbranchvars: *mut ::std::os::raw::c_int,
        branchvarssize: ::std::os::raw::c_int,
        nodeswitches: *mut ::std::os::raw::c_int,
        nnodes: *mut ::std::os::raw::c_int,
        nodeswitchsize: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " checks for two nodes whether they share the same root path, i.e., whether one is an ancestor of the other"]
    pub fn SCIPnodesSharePath(
        node1: *mut SCIP_NODE,
        node2: *mut SCIP_NODE,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " finds the common ancestor node of two given nodes"]
    pub fn SCIPnodesGetCommonAncestor(
        node1: *mut SCIP_NODE,
        node2: *mut SCIP_NODE,
    ) -> *mut SCIP_NODE;
}
extern "C" {
    #[doc = " gets the type of the node"]
    pub fn SCIPnodeGetType(node: *mut SCIP_NODE) -> SCIP_NODETYPE;
}
extern "C" {
    #[doc = " gets successively assigned number of the node"]
    pub fn SCIPnodeGetNumber(node: *mut SCIP_NODE) -> ::std::os::raw::c_longlong;
}
extern "C" {
    #[doc = " gets the depth of the node"]
    pub fn SCIPnodeGetDepth(node: *mut SCIP_NODE) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " gets the lower bound of the node"]
    pub fn SCIPnodeGetLowerbound(node: *mut SCIP_NODE) -> f64;
}
extern "C" {
    #[doc = " gets the estimated value of the best feasible solution in subtree of the node"]
    pub fn SCIPnodeGetEstimate(node: *mut SCIP_NODE) -> f64;
}
extern "C" {
    #[doc = " gets the reoptimization type of a node"]
    pub fn SCIPnodeGetReopttype(node: *mut SCIP_NODE) -> SCIP_REOPTTYPE;
}
extern "C" {
    #[doc = " gets the unique id to identify the node during reoptimization; id is 0 if the node is the root or not part of the\n reoptimization tree"]
    pub fn SCIPnodeGetReoptID(node: *mut SCIP_NODE) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " sets the reoptimization type of the node"]
    pub fn SCIPnodeSetReopttype(node: *mut SCIP_NODE, reopttype: SCIP_REOPTTYPE);
}
extern "C" {
    #[doc = " sets a unique id to identify the node during reoptimization"]
    pub fn SCIPnodeSetReoptID(node: *mut SCIP_NODE, id: ::std::os::raw::c_uint);
}
extern "C" {
    #[doc = " counts the number of bound changes due to branching, constraint propagation, and propagation"]
    pub fn SCIPnodeGetNDomchg(
        node: *mut SCIP_NODE,
        nbranchings: *mut ::std::os::raw::c_int,
        nconsprop: *mut ::std::os::raw::c_int,
        nprop: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " gets the domain change information of the node, i.e., the information about the differences in the\n  variables domains to the parent node"]
    pub fn SCIPnodeGetDomchg(node: *mut SCIP_NODE) -> *mut SCIP_DOMCHG;
}
extern "C" {
    #[doc = " gets the parent node of a node in the branch-and-bound tree, if any"]
    pub fn SCIPnodeGetParent(node: *mut SCIP_NODE) -> *mut SCIP_NODE;
}
extern "C" {
    #[doc = " returns all constraints added to a given node"]
    pub fn SCIPnodeGetAddedConss(
        node: *mut SCIP_NODE,
        addedconss: *mut *mut SCIP_CONS,
        naddedconss: *mut ::std::os::raw::c_int,
        addedconsssize: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " returns the number of added constraints to the given node"]
    pub fn SCIPnodeGetNAddedConss(node: *mut SCIP_NODE) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " returns whether node is in the path to the current node"]
    pub fn SCIPnodeIsActive(node: *mut SCIP_NODE) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " returns whether the node is marked to be propagated again"]
    pub fn SCIPnodeIsPropagatedAgain(node: *mut SCIP_NODE) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn SCIPnodeGetConssetchg(node: *mut SCIP_NODE) -> *mut SCIP_CONSSETCHG;
}
extern "C" {
    #[doc = " gets number of locks for rounding down\n\n  @note This method will always return variable locks of type model\n\n  @note It is recommented to use SCIPvarGetNLocksDownType()"]
    pub fn SCIPvarGetNLocksDown(var: *mut SCIP_VAR) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " gets number of locks for rounding up\n\n  @note This method will always return variable locks of type model\n\n  @note It is recommented to use SCIPvarGetNLocksUpType()"]
    pub fn SCIPvarGetNLocksUp(var: *mut SCIP_VAR) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " gets number of locks for rounding up of a special type"]
    pub fn SCIPvarGetNLocksUpType(
        var: *mut SCIP_VAR,
        locktype: SCIP_LOCKTYPE,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " gets number of locks for rounding down of a special type"]
    pub fn SCIPvarGetNLocksDownType(
        var: *mut SCIP_VAR,
        locktype: SCIP_LOCKTYPE,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " is it possible, to round variable down and stay feasible?\n\n  @note This method will always check w.r.t variable locks of type model"]
    pub fn SCIPvarMayRoundDown(var: *mut SCIP_VAR) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " is it possible, to round variable up and stay feasible?\n\n  @note This method will always check w.r.t. variable locks of type model"]
    pub fn SCIPvarMayRoundUp(var: *mut SCIP_VAR) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " compares the index of two variables, only active or negated variables are allowed, if a variable\n  is negated then the index of the corresponding active variable is taken, returns -1 if first is\n  smaller than, and +1 if first is greater than second variable index; returns 0 if both indices\n  are equal, which means both variables are equal"]
    pub fn SCIPvarCompareActiveAndNegated(
        var1: *mut SCIP_VAR,
        var2: *mut SCIP_VAR,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SCIPvarCompActiveAndNegated(
        elem1: *mut ::std::os::raw::c_void,
        elem2: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " compares the index of two variables, returns -1 if first is smaller than, and +1 if first is greater than second\n  variable index; returns 0 if both indices are equal, which means both variables are equal"]
    pub fn SCIPvarCompare(var1: *mut SCIP_VAR, var2: *mut SCIP_VAR) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SCIPvarComp(
        elem1: *mut ::std::os::raw::c_void,
        elem2: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SCIPvarCompObj(
        elem1: *mut ::std::os::raw::c_void,
        elem2: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SCIPvarGetHashkey(
        userptr: *mut ::std::os::raw::c_void,
        elem: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn SCIPvarIsHashkeyEq(
        userptr: *mut ::std::os::raw::c_void,
        key1: *mut ::std::os::raw::c_void,
        key2: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn SCIPvarGetHashkeyVal(
        userptr: *mut ::std::os::raw::c_void,
        key: *mut ::std::os::raw::c_void,
    ) -> u64;
}
extern "C" {
    #[doc = " gets corresponding active, fixed, or multi-aggregated problem variables of given variables,\n  @note the content of the given array will/might change"]
    pub fn SCIPvarsGetProbvar(vars: *mut *mut SCIP_VAR, nvars: ::std::os::raw::c_int);
}
extern "C" {
    #[doc = " gets corresponding active, fixed, or multi-aggregated problem variable of a variable"]
    pub fn SCIPvarGetProbvar(var: *mut SCIP_VAR) -> *mut SCIP_VAR;
}
extern "C" {
    #[doc = " gets corresponding active, fixed, or multi-aggregated problem variables of binary variables and\n  updates the given negation status of each variable"]
    pub fn SCIPvarsGetProbvarBinary(
        vars: *mut *mut *mut SCIP_VAR,
        negatedarr: *mut *mut ::std::os::raw::c_uint,
        nvars: ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " gets corresponding active, fixed, or multi-aggregated problem variable of a binary variable and\n  updates the given negation status"]
    pub fn SCIPvarGetProbvarBinary(
        var: *mut *mut SCIP_VAR,
        negated: *mut ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " transforms given variable, boundtype and bound to the corresponding active, fixed, or multi-aggregated variable\n  values"]
    pub fn SCIPvarGetProbvarBound(
        var: *mut *mut SCIP_VAR,
        bound: *mut f64,
        boundtype: *mut SCIP_BOUNDTYPE,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " transforms given variable and domain hole to the corresponding active, fixed, or multi-aggregated variable\n  values"]
    pub fn SCIPvarGetProbvarHole(
        var: *mut *mut SCIP_VAR,
        left: *mut f64,
        right: *mut f64,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " retransforms given variable, scalar and constant to the corresponding original variable, scalar\n  and constant, if possible; if the retransformation is impossible, NULL is returned as variable"]
    pub fn SCIPvarGetOrigvarSum(
        var: *mut *mut SCIP_VAR,
        scalar: *mut f64,
        constant: *mut f64,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " returns whether the given variable is the direct counterpart of an original problem variable"]
    pub fn SCIPvarIsTransformedOrigvar(var: *mut SCIP_VAR) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " returns the number of times, a bound of the variable was changed in given direction due to branching"]
    pub fn SCIPvarGetNBranchings(
        var: *mut SCIP_VAR,
        dir: SCIP_BRANCHDIR,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    #[doc = " returns the number of times, a bound of the variable was changed in given direction due to branching\n  in the current run"]
    pub fn SCIPvarGetNBranchingsCurrentRun(
        var: *mut SCIP_VAR,
        dir: SCIP_BRANCHDIR,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    #[doc = " returns the number of inferences branching on this variable in given direction triggered"]
    pub fn SCIPvarGetInferenceSum(var: *mut SCIP_VAR, dir: SCIP_BRANCHDIR) -> f64;
}
extern "C" {
    #[doc = " returns the number of inferences branching on this variable in given direction triggered\n  in the current run"]
    pub fn SCIPvarGetInferenceSumCurrentRun(var: *mut SCIP_VAR, dir: SCIP_BRANCHDIR) -> f64;
}
extern "C" {
    #[doc = " returns the number of cutoffs branching on this variable in given direction produced"]
    pub fn SCIPvarGetCutoffSum(var: *mut SCIP_VAR, dir: SCIP_BRANCHDIR) -> f64;
}
extern "C" {
    #[doc = " returns the number of cutoffs branching on this variable in given direction produced in the current run"]
    pub fn SCIPvarGetCutoffSumCurrentRun(var: *mut SCIP_VAR, dir: SCIP_BRANCHDIR) -> f64;
}
extern "C" {
    #[doc = " returns the average depth of bound changes in given direction due to branching on the variable"]
    pub fn SCIPvarGetAvgBranchdepth(var: *mut SCIP_VAR, dir: SCIP_BRANCHDIR) -> f64;
}
extern "C" {
    #[doc = " returns the average depth of bound changes in given direction due to branching on the variable\n  in the current run"]
    pub fn SCIPvarGetAvgBranchdepthCurrentRun(var: *mut SCIP_VAR, dir: SCIP_BRANCHDIR) -> f64;
}
extern "C" {
    #[doc = " returns whether there is an implication x == varfixing -> y <= b or y >= b in the implication graph;\n  implications that are represented as cliques in the clique table are not regarded (use SCIPvarsHaveCommonClique());\n  both variables must be active, variable x must be binary"]
    pub fn SCIPvarHasImplic(
        var: *mut SCIP_VAR,
        varfixing: ::std::os::raw::c_uint,
        implvar: *mut SCIP_VAR,
        impltype: SCIP_BOUNDTYPE,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " returns whether there is an implication x == varfixing -> y == implvarfixing in the implication graph;\n  implications that are represented as cliques in the clique table are not regarded (use SCIPvarsHaveCommonClique());\n  both variables must be active binary variables"]
    pub fn SCIPvarHasBinaryImplic(
        var: *mut SCIP_VAR,
        varfixing: ::std::os::raw::c_uint,
        implvar: *mut SCIP_VAR,
        implvarfixing: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " gets the values of b in implications x == varfixing -> y <= b or y >= b in the implication graph;\n  the values are set to SCIP_INVALID if there is no implied bound"]
    pub fn SCIPvarGetImplicVarBounds(
        var: *mut SCIP_VAR,
        varfixing: ::std::os::raw::c_uint,
        implvar: *mut SCIP_VAR,
        lb: *mut f64,
        ub: *mut f64,
    );
}
extern "C" {
    #[doc = " returns whether there is a clique that contains both given variable/value pairs;\n  the variables must be active binary variables;\n  if regardimplics is FALSE, only the cliques in the clique table are looked at;\n  if regardimplics is TRUE, both the cliques and the implications of the implication graph are regarded"]
    pub fn SCIPvarsHaveCommonClique(
        var1: *mut SCIP_VAR,
        value1: ::std::os::raw::c_uint,
        var2: *mut SCIP_VAR,
        value2: ::std::os::raw::c_uint,
        regardimplics: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " gets corresponding objective value of active, fixed, or multi-aggregated problem variable of given variable\n  e.g. obj(x) = 1 this method returns for ~x the value -1"]
    pub fn SCIPvarGetAggregatedObj(var: *mut SCIP_VAR, aggrobj: *mut f64) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " sets the initial flag of a variable; only possible for original or loose variables"]
    pub fn SCIPvarSetInitial(var: *mut SCIP_VAR, initial: ::std::os::raw::c_uint) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " sets the removable flag of a variable; only possible for original or loose variables"]
    pub fn SCIPvarSetRemovable(
        var: *mut SCIP_VAR,
        removable: ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " returns the name of the variable\n\n  @note to change the name of a variable, use SCIPchgVarName() from scip.h"]
    pub fn SCIPvarGetName(var: *mut SCIP_VAR) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " gets number of times, the variable is currently captured"]
    pub fn SCIPvarGetNUses(var: *mut SCIP_VAR) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " returns the user data of the variable"]
    pub fn SCIPvarGetData(var: *mut SCIP_VAR) -> *mut SCIP_VARDATA;
}
extern "C" {
    #[doc = " sets the user data for the variable"]
    pub fn SCIPvarSetData(var: *mut SCIP_VAR, vardata: *mut SCIP_VARDATA);
}
extern "C" {
    #[doc = " sets method to free user data for the original variable"]
    pub fn SCIPvarSetDelorigData(
        var: *mut SCIP_VAR,
        vardelorig: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                var: *mut SCIP_VAR,
                vardata: *mut *mut SCIP_VARDATA,
            ) -> SCIP_RETCODE,
        >,
    );
}
extern "C" {
    #[doc = " sets method to transform user data of the variable"]
    pub fn SCIPvarSetTransData(
        var: *mut SCIP_VAR,
        vartrans: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                sourcevar: *mut SCIP_VAR,
                sourcedata: *mut SCIP_VARDATA,
                targetvar: *mut SCIP_VAR,
                targetdata: *mut *mut SCIP_VARDATA,
            ) -> SCIP_RETCODE,
        >,
    );
}
extern "C" {
    #[doc = " sets method to free transformed user data for the variable"]
    pub fn SCIPvarSetDeltransData(
        var: *mut SCIP_VAR,
        vardeltrans: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                var: *mut SCIP_VAR,
                vardata: *mut *mut SCIP_VARDATA,
            ) -> SCIP_RETCODE,
        >,
    );
}
extern "C" {
    #[doc = " sets method to copy this variable into sub-SCIPs"]
    pub fn SCIPvarSetCopyData(
        var: *mut SCIP_VAR,
        varcopy: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                sourcescip: *mut SCIP,
                sourcevar: *mut SCIP_VAR,
                sourcedata: *mut SCIP_VARDATA,
                varmap: *mut SCIP_HASHMAP,
                consmap: *mut SCIP_HASHMAP,
                targetvar: *mut SCIP_VAR,
                targetdata: *mut *mut SCIP_VARDATA,
                result: *mut SCIP_RESULT,
            ) -> SCIP_RETCODE,
        >,
    );
}
extern "C" {
    #[doc = " gets status of variable"]
    pub fn SCIPvarGetStatus(var: *mut SCIP_VAR) -> SCIP_VARSTATUS;
}
extern "C" {
    #[doc = " returns whether the variable belongs to the original problem"]
    pub fn SCIPvarIsOriginal(var: *mut SCIP_VAR) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " returns whether the variable belongs to the transformed problem"]
    pub fn SCIPvarIsTransformed(var: *mut SCIP_VAR) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " returns whether the variable was created by negation of a different variable"]
    pub fn SCIPvarIsNegated(var: *mut SCIP_VAR) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " gets type of variable"]
    pub fn SCIPvarGetType(var: *mut SCIP_VAR) -> SCIP_VARTYPE;
}
extern "C" {
    #[doc = " returns TRUE if the variable is of binary type; this is the case if:\n  (1) variable type is binary\n  (2) variable type is integer or implicit integer and\n      (i)  the global lower bound is greater than or equal to zero\n      (ii) the global upper bound is less than or equal to one"]
    pub fn SCIPvarIsBinary(var: *mut SCIP_VAR) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " returns whether variable is of integral type (binary, integer, or implicit integer)"]
    pub fn SCIPvarIsIntegral(var: *mut SCIP_VAR) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " returns whether variable's column should be present in the initial root LP"]
    pub fn SCIPvarIsInitial(var: *mut SCIP_VAR) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " returns whether variable's column is removable from the LP (due to aging or cleanup)"]
    pub fn SCIPvarIsRemovable(var: *mut SCIP_VAR) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " returns whether the variable was deleted from the problem"]
    pub fn SCIPvarIsDeleted(var: *mut SCIP_VAR) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " marks the variable to be deletable, i.e., it may be deleted completely from the problem;\n  method can only be called before the variable is added to the problem by SCIPaddVar() or SCIPaddPricedVar()"]
    pub fn SCIPvarMarkDeletable(var: *mut SCIP_VAR);
}
extern "C" {
    #[doc = " marks the variable to be not deletable from the problem"]
    pub fn SCIPvarMarkNotDeletable(var: *mut SCIP_VAR);
}
extern "C" {
    #[doc = " returns whether variable is allowed to be deleted completely from the problem"]
    pub fn SCIPvarIsDeletable(var: *mut SCIP_VAR) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " marks variable to be deleted from global structures (cliques etc.) when cleaning up\n\n  @note: this is not equivalent to marking the variable itself for deletion, this is done by using SCIPvarMarkDeletable()"]
    pub fn SCIPvarMarkDeleteGlobalStructures(var: *mut SCIP_VAR);
}
extern "C" {
    #[doc = " returns whether variable is an active (neither fixed nor aggregated) variable"]
    pub fn SCIPvarIsActive(var: *mut SCIP_VAR) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " gets unique index of variable"]
    pub fn SCIPvarGetIndex(var: *mut SCIP_VAR) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " gets position of variable in problem, or -1 if variable is not active"]
    pub fn SCIPvarGetProbindex(var: *mut SCIP_VAR) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " gets transformed variable of ORIGINAL variable"]
    pub fn SCIPvarGetTransVar(var: *mut SCIP_VAR) -> *mut SCIP_VAR;
}
extern "C" {
    #[doc = " gets column of COLUMN variable"]
    pub fn SCIPvarGetCol(var: *mut SCIP_VAR) -> *mut SCIP_COL;
}
extern "C" {
    #[doc = " returns whether the variable is a COLUMN variable that is member of the current LP"]
    pub fn SCIPvarIsInLP(var: *mut SCIP_VAR) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " gets aggregation variable y of an aggregated variable x = a*y + c"]
    pub fn SCIPvarGetAggrVar(var: *mut SCIP_VAR) -> *mut SCIP_VAR;
}
extern "C" {
    #[doc = " gets aggregation scalar a of an aggregated variable x = a*y + c"]
    pub fn SCIPvarGetAggrScalar(var: *mut SCIP_VAR) -> f64;
}
extern "C" {
    #[doc = " gets aggregation constant c of an aggregated variable x = a*y + c"]
    pub fn SCIPvarGetAggrConstant(var: *mut SCIP_VAR) -> f64;
}
extern "C" {
    #[doc = " gets number n of aggregation variables of a multi aggregated variable x = a0*y0 + ... + a(n-1)*y(n-1) + c"]
    pub fn SCIPvarGetMultaggrNVars(var: *mut SCIP_VAR) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " gets vector of aggregation variables y of a multi aggregated variable x = a0*y0 + ... + a(n-1)*y(n-1) + c"]
    pub fn SCIPvarGetMultaggrVars(var: *mut SCIP_VAR) -> *mut *mut SCIP_VAR;
}
extern "C" {
    #[doc = " gets vector of aggregation scalars a of a multi aggregated variable x = a0*y0 + ... + a(n-1)*y(n-1) + c"]
    pub fn SCIPvarGetMultaggrScalars(var: *mut SCIP_VAR) -> *mut f64;
}
extern "C" {
    #[doc = " gets aggregation constant c of a multi aggregated variable x = a0*y0 + ... + a(n-1)*y(n-1) + c"]
    pub fn SCIPvarGetMultaggrConstant(var: *mut SCIP_VAR) -> f64;
}
extern "C" {
    #[doc = " gets the negation of the given variable; may return NULL, if no negation is existing yet"]
    pub fn SCIPvarGetNegatedVar(var: *mut SCIP_VAR) -> *mut SCIP_VAR;
}
extern "C" {
    #[doc = " gets the negation variable x of a negated variable x' = offset - x"]
    pub fn SCIPvarGetNegationVar(var: *mut SCIP_VAR) -> *mut SCIP_VAR;
}
extern "C" {
    #[doc = " gets the negation offset of a negated variable x' = offset - x"]
    pub fn SCIPvarGetNegationConstant(var: *mut SCIP_VAR) -> f64;
}
extern "C" {
    #[doc = " gets objective function value of variable"]
    pub fn SCIPvarGetObj(var: *mut SCIP_VAR) -> f64;
}
extern "C" {
    #[doc = " gets the unchanged objective function value of variable (ignoring temproray changes performed in probing mode)"]
    pub fn SCIPvarGetUnchangedObj(var: *mut SCIP_VAR) -> f64;
}
extern "C" {
    #[doc = " gets original lower bound of original problem variable (i.e. the bound set in problem creation)"]
    pub fn SCIPvarGetLbOriginal(var: *mut SCIP_VAR) -> f64;
}
extern "C" {
    #[doc = " gets original upper bound of original problem variable (i.e. the bound set in problem creation)"]
    pub fn SCIPvarGetUbOriginal(var: *mut SCIP_VAR) -> f64;
}
extern "C" {
    #[doc = " gets the original hole list of an original variable"]
    pub fn SCIPvarGetHolelistOriginal(var: *mut SCIP_VAR) -> *mut SCIP_HOLELIST;
}
extern "C" {
    #[doc = " gets global lower bound of variable"]
    pub fn SCIPvarGetLbGlobal(var: *mut SCIP_VAR) -> f64;
}
extern "C" {
    #[doc = " gets global upper bound of variable"]
    pub fn SCIPvarGetUbGlobal(var: *mut SCIP_VAR) -> f64;
}
extern "C" {
    #[doc = " gets the global hole list of an active variable"]
    pub fn SCIPvarGetHolelistGlobal(var: *mut SCIP_VAR) -> *mut SCIP_HOLELIST;
}
extern "C" {
    #[doc = " gets best global bound of variable with respect to the objective function"]
    pub fn SCIPvarGetBestBoundGlobal(var: *mut SCIP_VAR) -> f64;
}
extern "C" {
    #[doc = " gets worst global bound of variable with respect to the objective function"]
    pub fn SCIPvarGetWorstBoundGlobal(var: *mut SCIP_VAR) -> f64;
}
extern "C" {
    #[doc = " gets current lower bound of variable"]
    pub fn SCIPvarGetLbLocal(var: *mut SCIP_VAR) -> f64;
}
extern "C" {
    #[doc = " gets current upper bound of variable"]
    pub fn SCIPvarGetUbLocal(var: *mut SCIP_VAR) -> f64;
}
extern "C" {
    #[doc = " gets the current hole list of an active variable"]
    pub fn SCIPvarGetHolelistLocal(var: *mut SCIP_VAR) -> *mut SCIP_HOLELIST;
}
extern "C" {
    #[doc = " gets best local bound of variable with respect to the objective function"]
    pub fn SCIPvarGetBestBoundLocal(var: *mut SCIP_VAR) -> f64;
}
extern "C" {
    #[doc = " gets worst local bound of variable with respect to the objective function"]
    pub fn SCIPvarGetWorstBoundLocal(var: *mut SCIP_VAR) -> f64;
}
extern "C" {
    #[doc = " gets type (lower or upper) of best bound of variable with respect to the objective function"]
    pub fn SCIPvarGetBestBoundType(var: *mut SCIP_VAR) -> SCIP_BOUNDTYPE;
}
extern "C" {
    #[doc = " gets type (lower or upper) of worst bound of variable with respect to the objective function"]
    pub fn SCIPvarGetWorstBoundType(var: *mut SCIP_VAR) -> SCIP_BOUNDTYPE;
}
extern "C" {
    #[doc = " gets lazy lower bound of variable"]
    pub fn SCIPvarGetLbLazy(var: *mut SCIP_VAR) -> f64;
}
extern "C" {
    #[doc = " gets lazy upper bound of variable"]
    pub fn SCIPvarGetUbLazy(var: *mut SCIP_VAR) -> f64;
}
extern "C" {
    #[doc = " gets the branch factor of the variable; this value can be used in the branching methods to scale the score\n  values of the variables; higher factor leads to a higher probability that this variable is chosen for branching"]
    pub fn SCIPvarGetBranchFactor(var: *mut SCIP_VAR) -> f64;
}
extern "C" {
    #[doc = " gets the branch priority of the variable; variables with higher priority should always be preferred to variables\n  with lower priority"]
    pub fn SCIPvarGetBranchPriority(var: *mut SCIP_VAR) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " gets the preferred branch direction of the variable (downwards, upwards, or auto)"]
    pub fn SCIPvarGetBranchDirection(var: *mut SCIP_VAR) -> SCIP_BRANCHDIR;
}
extern "C" {
    #[doc = " gets number of variable lower bounds x >= b_i*z_i + d_i of given variable x"]
    pub fn SCIPvarGetNVlbs(var: *mut SCIP_VAR) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " gets array with bounding variables z_i in variable lower bounds x >= b_i*z_i + d_i of given variable x;\n  the variable bounds are sorted by increasing variable index of the bounding variable z_i (see SCIPvarGetIndex())"]
    pub fn SCIPvarGetVlbVars(var: *mut SCIP_VAR) -> *mut *mut SCIP_VAR;
}
extern "C" {
    #[doc = " gets array with bounding coefficients b_i in variable lower bounds x >= b_i*z_i + d_i of given variable x"]
    pub fn SCIPvarGetVlbCoefs(var: *mut SCIP_VAR) -> *mut f64;
}
extern "C" {
    #[doc = " gets array with bounding constants d_i in variable lower bounds x >= b_i*z_i + d_i of given variable x"]
    pub fn SCIPvarGetVlbConstants(var: *mut SCIP_VAR) -> *mut f64;
}
extern "C" {
    #[doc = " gets number of variable upper bounds x <= b_i*z_i + d_i of given variable x"]
    pub fn SCIPvarGetNVubs(var: *mut SCIP_VAR) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " gets array with bounding variables z_i in variable upper bounds x <= b_i*z_i + d_i of given variable x;\n  the variable bounds are sorted by increasing variable index of the bounding variable z_i (see SCIPvarGetIndex())"]
    pub fn SCIPvarGetVubVars(var: *mut SCIP_VAR) -> *mut *mut SCIP_VAR;
}
extern "C" {
    #[doc = " gets array with bounding coefficients b_i in variable upper bounds x <= b_i*z_i + d_i of given variable x"]
    pub fn SCIPvarGetVubCoefs(var: *mut SCIP_VAR) -> *mut f64;
}
extern "C" {
    #[doc = " gets array with bounding constants d_i in variable upper bounds x <= b_i*z_i + d_i of given variable x"]
    pub fn SCIPvarGetVubConstants(var: *mut SCIP_VAR) -> *mut f64;
}
extern "C" {
    #[doc = " gets number of implications  y <= b or y >= b for x == 0 or x == 1 of given active problem variable x,\n  there are no implications for nonbinary variable x"]
    pub fn SCIPvarGetNImpls(
        var: *mut SCIP_VAR,
        varfixing: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " gets array with implication variables y of implications  y <= b or y >= b for x == 0 or x == 1 of given active\n  problem variable x, there are no implications for nonbinary variable x;\n  the implications are sorted such that implications with binary implied variables precede the ones with non-binary\n  implied variables, and as a second criteria, the implied variables are sorted by increasing variable index\n  (see SCIPvarGetIndex())"]
    pub fn SCIPvarGetImplVars(
        var: *mut SCIP_VAR,
        varfixing: ::std::os::raw::c_uint,
    ) -> *mut *mut SCIP_VAR;
}
extern "C" {
    #[doc = " gets array with implication types of implications  y <= b or y >= b for x == 0 or x == 1 of given active problem\n  variable x (SCIP_BOUNDTYPE_UPPER if y <= b, SCIP_BOUNDTYPE_LOWER if y >= b),\n  there are no implications for nonbinary variable x"]
    pub fn SCIPvarGetImplTypes(
        var: *mut SCIP_VAR,
        varfixing: ::std::os::raw::c_uint,
    ) -> *mut SCIP_BOUNDTYPE;
}
extern "C" {
    #[doc = " gets array with implication bounds b of implications  y <= b or y >= b for x == 0 or x == 1 of given active problem\n  variable x, there are no implications for nonbinary variable x"]
    pub fn SCIPvarGetImplBounds(var: *mut SCIP_VAR, varfixing: ::std::os::raw::c_uint) -> *mut f64;
}
extern "C" {
    #[doc = " Gets array with unique ids of implications  y <= b or y >= b for x == 0 or x == 1 of given active problem variable x,\n  there are no implications for nonbinary variable x.\n  If an implication is a shortcut, i.e., it was added as part of the transitive closure of another implication,\n  its id is negative, otherwise it is nonnegative."]
    pub fn SCIPvarGetImplIds(
        var: *mut SCIP_VAR,
        varfixing: ::std::os::raw::c_uint,
    ) -> *mut ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " gets number of cliques, the active variable is contained in"]
    pub fn SCIPvarGetNCliques(
        var: *mut SCIP_VAR,
        varfixing: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " gets array of cliques, the active variable is contained in"]
    pub fn SCIPvarGetCliques(
        var: *mut SCIP_VAR,
        varfixing: ::std::os::raw::c_uint,
    ) -> *mut *mut SCIP_CLIQUE;
}
extern "C" {
    #[doc = " gets primal LP solution value of variable"]
    pub fn SCIPvarGetLPSol(var: *mut SCIP_VAR) -> f64;
}
extern "C" {
    #[doc = " gets primal NLP solution value of variable"]
    pub fn SCIPvarGetNLPSol(var: *mut SCIP_VAR) -> f64;
}
extern "C" {
    #[doc = " return lower bound change info at requested position"]
    pub fn SCIPvarGetBdchgInfoLb(
        var: *mut SCIP_VAR,
        pos: ::std::os::raw::c_int,
    ) -> *mut SCIP_BDCHGINFO;
}
extern "C" {
    #[doc = " gets the number of lower bound change info array"]
    pub fn SCIPvarGetNBdchgInfosLb(var: *mut SCIP_VAR) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " return upper bound change info at requested position"]
    pub fn SCIPvarGetBdchgInfoUb(
        var: *mut SCIP_VAR,
        pos: ::std::os::raw::c_int,
    ) -> *mut SCIP_BDCHGINFO;
}
extern "C" {
    #[doc = " gets the number upper bound change info array"]
    pub fn SCIPvarGetNBdchgInfosUb(var: *mut SCIP_VAR) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " returns the value based history for the variable"]
    pub fn SCIPvarGetValuehistory(var: *mut SCIP_VAR) -> *mut SCIP_VALUEHISTORY;
}
extern "C" {
    #[doc = " returns whether a variable has been introduced to define a relaxation\n\n These variables are only valid for the current SCIP solve round,\n they are not contained in any (checked) constraints, but may be used\n in cutting planes, for example.\n Relaxation-only variables are not copied by SCIPcopyVars and cuts\n that contain these variables are not added as linear constraints when\n restarting or transferring information from a copied SCIP to a SCIP.\n Also conflicts with relaxation-only variables are not generated at\n the moment.\n Relaxation-only variables do not appear in the objective."]
    pub fn SCIPvarIsRelaxationOnly(var: *mut SCIP_VAR) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " marks that this variable has only been introduced to define a relaxation\n\n The variable must not have a coefficient in the objective and must be deletable.\n If it is not marked deletable, it will be marked as deletable, which is only possible\n before the variable is added to a problem.\n\n @see SCIPvarIsRelaxationOnly\n @see SCIPvarMarkDeletable"]
    pub fn SCIPvarMarkRelaxationOnly(var: *mut SCIP_VAR);
}
extern "C" {
    #[doc = " gets primal LP solution value of variable"]
    pub fn SCIPvarGetLPSol_rec(var: *mut SCIP_VAR) -> f64;
}
extern "C" {
    #[doc = " gets primal NLP solution value of variable"]
    pub fn SCIPvarGetNLPSol_rec(var: *mut SCIP_VAR) -> f64;
}
extern "C" {
    #[doc = " gets pseudo solution value of variable at current node"]
    pub fn SCIPvarGetPseudoSol(var: *mut SCIP_VAR) -> f64;
}
extern "C" {
    #[doc = " gets current LP or pseudo solution value of variable"]
    pub fn SCIPvarGetSol(var: *mut SCIP_VAR, getlpval: ::std::os::raw::c_uint) -> f64;
}
extern "C" {
    #[doc = " returns the solution of the variable in the last root node's relaxation, if the root relaxation is not yet\n  completely solved, zero is returned"]
    pub fn SCIPvarGetRootSol(var: *mut SCIP_VAR) -> f64;
}
extern "C" {
    #[doc = " returns the best solution (w.r.t. root reduced cost propagation) of the variable in the root node's relaxation, if\n  the root relaxation is not yet completely solved, zero is returned"]
    pub fn SCIPvarGetBestRootSol(var: *mut SCIP_VAR) -> f64;
}
extern "C" {
    #[doc = " returns the best reduced costs (w.r.t. root reduced cost propagation) of the variable in the root node's relaxation,\n  if the root relaxation is not yet completely solved, or the variable was no column of the root LP, SCIP_INVALID is\n  returned"]
    pub fn SCIPvarGetBestRootRedcost(var: *mut SCIP_VAR) -> f64;
}
extern "C" {
    #[doc = " returns the best objective value (w.r.t. root reduced cost propagation) of the root LP which belongs the root\n  reduced cost which is accessible via SCIPvarGetRootRedcost() or the variable was no column of the root LP,\n  SCIP_INVALID is returned"]
    pub fn SCIPvarGetBestRootLPObjval(var: *mut SCIP_VAR) -> f64;
}
extern "C" {
    #[doc = " set the given solution as the best root solution w.r.t. root reduced cost propagation in the variables"]
    pub fn SCIPvarSetBestRootSol(
        var: *mut SCIP_VAR,
        rootsol: f64,
        rootredcost: f64,
        rootlpobjval: f64,
    );
}
extern "C" {
    #[doc = " returns a weighted average solution value of the variable in all feasible primal solutions found so far"]
    pub fn SCIPvarGetAvgSol(var: *mut SCIP_VAR) -> f64;
}
extern "C" {
    #[doc = " returns the bound change information for the last lower bound change on given active problem variable before or\n  after the bound change with the given index was applied;\n  returns NULL, if no change to the lower bound was applied up to this point of time"]
    pub fn SCIPvarGetLbchgInfo(
        var: *mut SCIP_VAR,
        bdchgidx: *mut SCIP_BDCHGIDX,
        after: ::std::os::raw::c_uint,
    ) -> *mut SCIP_BDCHGINFO;
}
extern "C" {
    #[doc = " returns the bound change information for the last upper bound change on given active problem variable before or\n  after the bound change with the given index was applied;\n  returns NULL, if no change to the upper bound was applied up to this point of time"]
    pub fn SCIPvarGetUbchgInfo(
        var: *mut SCIP_VAR,
        bdchgidx: *mut SCIP_BDCHGIDX,
        after: ::std::os::raw::c_uint,
    ) -> *mut SCIP_BDCHGINFO;
}
extern "C" {
    #[doc = " returns the bound change information for the last lower or upper bound change on given active problem variable\n  before or after the bound change with the given index was applied;\n  returns NULL, if no change to the lower/upper bound was applied up to this point of time"]
    pub fn SCIPvarGetBdchgInfo(
        var: *mut SCIP_VAR,
        boundtype: SCIP_BOUNDTYPE,
        bdchgidx: *mut SCIP_BDCHGIDX,
        after: ::std::os::raw::c_uint,
    ) -> *mut SCIP_BDCHGINFO;
}
extern "C" {
    #[doc = " returns lower bound of variable directly before or after the bound change given by the bound change index\n  was applied\n\n  @deprecated Please use SCIPgetVarLbAtIndex()"]
    pub fn SCIPvarGetLbAtIndex(
        var: *mut SCIP_VAR,
        bdchgidx: *mut SCIP_BDCHGIDX,
        after: ::std::os::raw::c_uint,
    ) -> f64;
}
extern "C" {
    #[doc = " returns upper bound of variable directly before or after the bound change given by the bound change index\n  was applied\n\n  @deprecated Please use SCIPgetVarUbAtIndex()"]
    pub fn SCIPvarGetUbAtIndex(
        var: *mut SCIP_VAR,
        bdchgidx: *mut SCIP_BDCHGIDX,
        after: ::std::os::raw::c_uint,
    ) -> f64;
}
extern "C" {
    #[doc = " returns lower or upper bound of variable directly before or after the bound change given by the bound change index\n  was applied\n\n  @deprecated Please use SCIPgetVarBdAtIndex()"]
    pub fn SCIPvarGetBdAtIndex(
        var: *mut SCIP_VAR,
        boundtype: SCIP_BOUNDTYPE,
        bdchgidx: *mut SCIP_BDCHGIDX,
        after: ::std::os::raw::c_uint,
    ) -> f64;
}
extern "C" {
    #[doc = " returns whether the binary variable was fixed at the time given by the bound change index\n\n  @deprecated Please use SCIPgetVarWasFixedAtIndex()"]
    pub fn SCIPvarWasFixedAtIndex(
        var: *mut SCIP_VAR,
        bdchgidx: *mut SCIP_BDCHGIDX,
        after: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " returns the last bound change index, at which the bounds of the given variable were tightened"]
    pub fn SCIPvarGetLastBdchgIndex(var: *mut SCIP_VAR) -> *mut SCIP_BDCHGIDX;
}
extern "C" {
    #[doc = " returns the last depth level, at which the bounds of the given variable were tightened;\n  returns -2, if the variable's bounds are still the global bounds\n  returns -1, if the variable was fixed in presolving"]
    pub fn SCIPvarGetLastBdchgDepth(var: *mut SCIP_VAR) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " returns whether the first binary variable was fixed earlier than the second one;\n  returns FALSE, if the first variable is not fixed, and returns TRUE, if the first variable is fixed, but the\n  second one is not fixed"]
    pub fn SCIPvarWasFixedEarlier(
        var1: *mut SCIP_VAR,
        var2: *mut SCIP_VAR,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " returns whether first bound change index belongs to an earlier applied bound change than second one;\n  if a bound change index is NULL, the bound change index represents the current time, i.e. the time after the\n  last bound change was applied to the current node"]
    pub fn SCIPbdchgidxIsEarlier(
        bdchgidx1: *mut SCIP_BDCHGIDX,
        bdchgidx2: *mut SCIP_BDCHGIDX,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " returns whether first bound change index belongs to an earlier applied bound change than second one"]
    pub fn SCIPbdchgidxIsEarlierNonNull(
        bdchgidx1: *mut SCIP_BDCHGIDX,
        bdchgidx2: *mut SCIP_BDCHGIDX,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " returns old bound that was overwritten for given bound change information"]
    pub fn SCIPbdchginfoGetOldbound(bdchginfo: *mut SCIP_BDCHGINFO) -> f64;
}
extern "C" {
    #[doc = " returns new bound installed for given bound change information"]
    pub fn SCIPbdchginfoGetNewbound(bdchginfo: *mut SCIP_BDCHGINFO) -> f64;
}
extern "C" {
    #[doc = " returns variable that belongs to the given bound change information"]
    pub fn SCIPbdchginfoGetVar(bdchginfo: *mut SCIP_BDCHGINFO) -> *mut SCIP_VAR;
}
extern "C" {
    #[doc = " returns whether the bound change information belongs to a branching decision or a deduction"]
    pub fn SCIPbdchginfoGetChgtype(bdchginfo: *mut SCIP_BDCHGINFO) -> SCIP_BOUNDCHGTYPE;
}
extern "C" {
    #[doc = " returns whether the bound change information belongs to a lower or upper bound change"]
    pub fn SCIPbdchginfoGetBoundtype(bdchginfo: *mut SCIP_BDCHGINFO) -> SCIP_BOUNDTYPE;
}
extern "C" {
    #[doc = " returns depth level of given bound change information"]
    pub fn SCIPbdchginfoGetDepth(bdchginfo: *mut SCIP_BDCHGINFO) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " returns bound change position in its depth level of given bound change information"]
    pub fn SCIPbdchginfoGetPos(bdchginfo: *mut SCIP_BDCHGINFO) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " returns bound change index of given bound change information"]
    pub fn SCIPbdchginfoGetIdx(bdchginfo: *mut SCIP_BDCHGINFO) -> *mut SCIP_BDCHGIDX;
}
extern "C" {
    #[doc = " returns inference variable of given bound change information"]
    pub fn SCIPbdchginfoGetInferVar(bdchginfo: *mut SCIP_BDCHGINFO) -> *mut SCIP_VAR;
}
extern "C" {
    #[doc = " returns inference constraint of given bound change information"]
    pub fn SCIPbdchginfoGetInferCons(bdchginfo: *mut SCIP_BDCHGINFO) -> *mut SCIP_CONS;
}
extern "C" {
    #[doc = " returns inference propagator of given bound change information, or NULL if no propagator was responsible"]
    pub fn SCIPbdchginfoGetInferProp(bdchginfo: *mut SCIP_BDCHGINFO) -> *mut SCIP_PROP;
}
extern "C" {
    #[doc = " returns inference user information of given bound change information"]
    pub fn SCIPbdchginfoGetInferInfo(bdchginfo: *mut SCIP_BDCHGINFO) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " returns inference bound of inference variable of given bound change information"]
    pub fn SCIPbdchginfoGetInferBoundtype(bdchginfo: *mut SCIP_BDCHGINFO) -> SCIP_BOUNDTYPE;
}
extern "C" {
    #[doc = " returns whether the bound change information belongs to a redundant bound change"]
    pub fn SCIPbdchginfoIsRedundant(bdchginfo: *mut SCIP_BDCHGINFO) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " returns whether the bound change has an inference reason (constraint or propagator), that can be resolved"]
    pub fn SCIPbdchginfoHasInferenceReason(
        bdchginfo: *mut SCIP_BDCHGINFO,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " for two bound change informations belonging to the same variable and bound, returns whether the first bound change\n  has a tighter new bound as the second bound change"]
    pub fn SCIPbdchginfoIsTighter(
        bdchginfo1: *mut SCIP_BDCHGINFO,
        bdchginfo2: *mut SCIP_BDCHGINFO,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " returns the new value of the bound in the bound change data"]
    pub fn SCIPboundchgGetNewbound(boundchg: *mut SCIP_BOUNDCHG) -> f64;
}
extern "C" {
    #[doc = " returns the variable of the bound change in the bound change data"]
    pub fn SCIPboundchgGetVar(boundchg: *mut SCIP_BOUNDCHG) -> *mut SCIP_VAR;
}
extern "C" {
    #[doc = " returns the bound change type of the bound change in the bound change data"]
    pub fn SCIPboundchgGetBoundchgtype(boundchg: *mut SCIP_BOUNDCHG) -> SCIP_BOUNDCHGTYPE;
}
extern "C" {
    #[doc = " returns the bound type of the bound change in the bound change data"]
    pub fn SCIPboundchgGetBoundtype(boundchg: *mut SCIP_BOUNDCHG) -> SCIP_BOUNDTYPE;
}
extern "C" {
    #[doc = " returns whether the bound change is redundant due to a more global bound that is at least as strong"]
    pub fn SCIPboundchgIsRedundant(boundchg: *mut SCIP_BOUNDCHG) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " returns the number of bound changes in the domain change data"]
    pub fn SCIPdomchgGetNBoundchgs(domchg: *mut SCIP_DOMCHG) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " returns a particular bound change in the domain change data"]
    pub fn SCIPdomchgGetBoundchg(
        domchg: *mut SCIP_DOMCHG,
        pos: ::std::os::raw::c_int,
    ) -> *mut SCIP_BOUNDCHG;
}
extern "C" {
    #[doc = " returns left bound of open interval in hole"]
    pub fn SCIPholelistGetLeft(holelist: *mut SCIP_HOLELIST) -> f64;
}
extern "C" {
    #[doc = " returns right bound of open interval in hole"]
    pub fn SCIPholelistGetRight(holelist: *mut SCIP_HOLELIST) -> f64;
}
extern "C" {
    #[doc = " returns next hole in list or NULL"]
    pub fn SCIPholelistGetNext(holelist: *mut SCIP_HOLELIST) -> *mut SCIP_HOLELIST;
}
extern "C" {
    #[doc = " gets name and version of LP solver"]
    pub fn SCIPlpiGetSolverName() -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " gets description of LP solver (developer, webpage, ...)"]
    pub fn SCIPlpiGetSolverDesc() -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " gets pointer for LP solver - use only with great care\n\n  The behavior of this function depends on the solver and its use is\n  therefore only recommended if you really know what you are\n  doing. In general, it returns a pointer to the LP solver object."]
    pub fn SCIPlpiGetSolverPointer(lpi: *mut SCIP_LPI) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " pass integrality information about variables to the solver"]
    pub fn SCIPlpiSetIntegralityInformation(
        lpi: *mut SCIP_LPI,
        ncols: ::std::os::raw::c_int,
        intInfo: *mut ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " informs about availability of a primal simplex solving method"]
    pub fn SCIPlpiHasPrimalSolve() -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " informs about availability of a dual simplex solving method"]
    pub fn SCIPlpiHasDualSolve() -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " informs about availability of a barrier solving method"]
    pub fn SCIPlpiHasBarrierSolve() -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " creates an LP problem object"]
    pub fn SCIPlpiCreate(
        lpi: *mut *mut SCIP_LPI,
        messagehdlr: *mut SCIP_MESSAGEHDLR,
        name: *const ::std::os::raw::c_char,
        objsen: SCIP_OBJSEN,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " deletes an LP problem object"]
    pub fn SCIPlpiFree(lpi: *mut *mut SCIP_LPI) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " copies LP data with column matrix into LP solver"]
    pub fn SCIPlpiLoadColLP(
        lpi: *mut SCIP_LPI,
        objsen: SCIP_OBJSEN,
        ncols: ::std::os::raw::c_int,
        obj: *const f64,
        lb: *const f64,
        ub: *const f64,
        colnames: *mut *mut ::std::os::raw::c_char,
        nrows: ::std::os::raw::c_int,
        lhs: *const f64,
        rhs: *const f64,
        rownames: *mut *mut ::std::os::raw::c_char,
        nnonz: ::std::os::raw::c_int,
        beg: *const ::std::os::raw::c_int,
        ind: *const ::std::os::raw::c_int,
        val: *const f64,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " adds columns to the LP\n\n  @note ind array is not checked for duplicates, problems may appear if indices are added more than once"]
    pub fn SCIPlpiAddCols(
        lpi: *mut SCIP_LPI,
        ncols: ::std::os::raw::c_int,
        obj: *const f64,
        lb: *const f64,
        ub: *const f64,
        colnames: *mut *mut ::std::os::raw::c_char,
        nnonz: ::std::os::raw::c_int,
        beg: *const ::std::os::raw::c_int,
        ind: *const ::std::os::raw::c_int,
        val: *const f64,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " deletes all columns in the given range from LP"]
    pub fn SCIPlpiDelCols(
        lpi: *mut SCIP_LPI,
        firstcol: ::std::os::raw::c_int,
        lastcol: ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " deletes columns from SCIP_LPI; the new position of a column must not be greater that its old position"]
    pub fn SCIPlpiDelColset(lpi: *mut SCIP_LPI, dstat: *mut ::std::os::raw::c_int) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " adds rows to the LP\n\n  @note ind array is not checked for duplicates, problems may appear if indices are added more than once"]
    pub fn SCIPlpiAddRows(
        lpi: *mut SCIP_LPI,
        nrows: ::std::os::raw::c_int,
        lhs: *const f64,
        rhs: *const f64,
        rownames: *mut *mut ::std::os::raw::c_char,
        nnonz: ::std::os::raw::c_int,
        beg: *const ::std::os::raw::c_int,
        ind: *const ::std::os::raw::c_int,
        val: *const f64,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " deletes all rows in the given range from LP"]
    pub fn SCIPlpiDelRows(
        lpi: *mut SCIP_LPI,
        firstrow: ::std::os::raw::c_int,
        lastrow: ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " deletes rows from SCIP_LPI; the new position of a row must not be greater that its old position"]
    pub fn SCIPlpiDelRowset(lpi: *mut SCIP_LPI, dstat: *mut ::std::os::raw::c_int) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " clears the whole LP"]
    pub fn SCIPlpiClear(lpi: *mut SCIP_LPI) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " changes lower and upper bounds of columns"]
    pub fn SCIPlpiChgBounds(
        lpi: *mut SCIP_LPI,
        ncols: ::std::os::raw::c_int,
        ind: *const ::std::os::raw::c_int,
        lb: *const f64,
        ub: *const f64,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " changes left and right hand sides of rows"]
    pub fn SCIPlpiChgSides(
        lpi: *mut SCIP_LPI,
        nrows: ::std::os::raw::c_int,
        ind: *const ::std::os::raw::c_int,
        lhs: *const f64,
        rhs: *const f64,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " changes a single coefficient"]
    pub fn SCIPlpiChgCoef(
        lpi: *mut SCIP_LPI,
        row: ::std::os::raw::c_int,
        col: ::std::os::raw::c_int,
        newval: f64,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " changes the objective sense"]
    pub fn SCIPlpiChgObjsen(lpi: *mut SCIP_LPI, objsen: SCIP_OBJSEN) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " changes objective values of columns in the LP"]
    pub fn SCIPlpiChgObj(
        lpi: *mut SCIP_LPI,
        ncols: ::std::os::raw::c_int,
        ind: *const ::std::os::raw::c_int,
        obj: *const f64,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " multiplies a row with a non-zero scalar; for negative scalars, the row's sense is switched accordingly"]
    pub fn SCIPlpiScaleRow(
        lpi: *mut SCIP_LPI,
        row: ::std::os::raw::c_int,
        scaleval: f64,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " multiplies a column with a non-zero scalar; the objective value is multiplied with the scalar, and the bounds\n  are divided by the scalar; for negative scalars, the column's bounds are switched"]
    pub fn SCIPlpiScaleCol(
        lpi: *mut SCIP_LPI,
        col: ::std::os::raw::c_int,
        scaleval: f64,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " gets the number of rows in the LP"]
    pub fn SCIPlpiGetNRows(lpi: *mut SCIP_LPI, nrows: *mut ::std::os::raw::c_int) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " gets the number of columns in the LP"]
    pub fn SCIPlpiGetNCols(lpi: *mut SCIP_LPI, ncols: *mut ::std::os::raw::c_int) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " gets the objective sense of the LP"]
    pub fn SCIPlpiGetObjsen(lpi: *mut SCIP_LPI, objsen: *mut SCIP_OBJSEN) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " gets the number of nonzero elements in the LP constraint matrix"]
    pub fn SCIPlpiGetNNonz(lpi: *mut SCIP_LPI, nnonz: *mut ::std::os::raw::c_int) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " gets columns from LP problem object; the arrays have to be large enough to store all values;\n  Either both, lb and ub, have to be NULL, or both have to be non-NULL,\n  either nnonz, beg, ind, and val have to be NULL, or all of them have to be non-NULL."]
    pub fn SCIPlpiGetCols(
        lpi: *mut SCIP_LPI,
        firstcol: ::std::os::raw::c_int,
        lastcol: ::std::os::raw::c_int,
        lb: *mut f64,
        ub: *mut f64,
        nnonz: *mut ::std::os::raw::c_int,
        beg: *mut ::std::os::raw::c_int,
        ind: *mut ::std::os::raw::c_int,
        val: *mut f64,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " gets rows from LP problem object; the arrays have to be large enough to store all values.\n  Either both, lhs and rhs, have to be NULL, or both have to be non-NULL,\n  either nnonz, beg, ind, and val have to be NULL, or all of them have to be non-NULL."]
    pub fn SCIPlpiGetRows(
        lpi: *mut SCIP_LPI,
        firstrow: ::std::os::raw::c_int,
        lastrow: ::std::os::raw::c_int,
        lhs: *mut f64,
        rhs: *mut f64,
        nnonz: *mut ::std::os::raw::c_int,
        beg: *mut ::std::os::raw::c_int,
        ind: *mut ::std::os::raw::c_int,
        val: *mut f64,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " gets column names"]
    pub fn SCIPlpiGetColNames(
        lpi: *mut SCIP_LPI,
        firstcol: ::std::os::raw::c_int,
        lastcol: ::std::os::raw::c_int,
        colnames: *mut *mut ::std::os::raw::c_char,
        namestorage: *mut ::std::os::raw::c_char,
        namestoragesize: ::std::os::raw::c_int,
        storageleft: *mut ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " gets row names"]
    pub fn SCIPlpiGetRowNames(
        lpi: *mut SCIP_LPI,
        firstrow: ::std::os::raw::c_int,
        lastrow: ::std::os::raw::c_int,
        rownames: *mut *mut ::std::os::raw::c_char,
        namestorage: *mut ::std::os::raw::c_char,
        namestoragesize: ::std::os::raw::c_int,
        storageleft: *mut ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " gets objective coefficients from LP problem object"]
    pub fn SCIPlpiGetObj(
        lpi: *mut SCIP_LPI,
        firstcol: ::std::os::raw::c_int,
        lastcol: ::std::os::raw::c_int,
        vals: *mut f64,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " gets current bounds from LP problem object"]
    pub fn SCIPlpiGetBounds(
        lpi: *mut SCIP_LPI,
        firstcol: ::std::os::raw::c_int,
        lastcol: ::std::os::raw::c_int,
        lbs: *mut f64,
        ubs: *mut f64,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " gets current row sides from LP problem object"]
    pub fn SCIPlpiGetSides(
        lpi: *mut SCIP_LPI,
        firstrow: ::std::os::raw::c_int,
        lastrow: ::std::os::raw::c_int,
        lhss: *mut f64,
        rhss: *mut f64,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " gets a single coefficient"]
    pub fn SCIPlpiGetCoef(
        lpi: *mut SCIP_LPI,
        row: ::std::os::raw::c_int,
        col: ::std::os::raw::c_int,
        val: *mut f64,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " calls primal simplex to solve the LP"]
    pub fn SCIPlpiSolvePrimal(lpi: *mut SCIP_LPI) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " calls dual simplex to solve the LP"]
    pub fn SCIPlpiSolveDual(lpi: *mut SCIP_LPI) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " calls barrier or interior point algorithm to solve the LP with crossover to simplex basis"]
    pub fn SCIPlpiSolveBarrier(
        lpi: *mut SCIP_LPI,
        crossover: ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " start strong branching - call before any strong branching"]
    pub fn SCIPlpiStartStrongbranch(lpi: *mut SCIP_LPI) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " end strong branching - call after any strong branching"]
    pub fn SCIPlpiEndStrongbranch(lpi: *mut SCIP_LPI) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " performs strong branching iterations on one @b fractional candidate"]
    pub fn SCIPlpiStrongbranchFrac(
        lpi: *mut SCIP_LPI,
        col: ::std::os::raw::c_int,
        psol: f64,
        itlim: ::std::os::raw::c_int,
        down: *mut f64,
        up: *mut f64,
        downvalid: *mut ::std::os::raw::c_uint,
        upvalid: *mut ::std::os::raw::c_uint,
        iter: *mut ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " performs strong branching iterations on given @b fractional candidates"]
    pub fn SCIPlpiStrongbranchesFrac(
        lpi: *mut SCIP_LPI,
        cols: *mut ::std::os::raw::c_int,
        ncols: ::std::os::raw::c_int,
        psols: *mut f64,
        itlim: ::std::os::raw::c_int,
        down: *mut f64,
        up: *mut f64,
        downvalid: *mut ::std::os::raw::c_uint,
        upvalid: *mut ::std::os::raw::c_uint,
        iter: *mut ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " performs strong branching iterations on one candidate with @b integral value"]
    pub fn SCIPlpiStrongbranchInt(
        lpi: *mut SCIP_LPI,
        col: ::std::os::raw::c_int,
        psol: f64,
        itlim: ::std::os::raw::c_int,
        down: *mut f64,
        up: *mut f64,
        downvalid: *mut ::std::os::raw::c_uint,
        upvalid: *mut ::std::os::raw::c_uint,
        iter: *mut ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " performs strong branching iterations on given candidates with @b integral values"]
    pub fn SCIPlpiStrongbranchesInt(
        lpi: *mut SCIP_LPI,
        cols: *mut ::std::os::raw::c_int,
        ncols: ::std::os::raw::c_int,
        psols: *mut f64,
        itlim: ::std::os::raw::c_int,
        down: *mut f64,
        up: *mut f64,
        downvalid: *mut ::std::os::raw::c_uint,
        upvalid: *mut ::std::os::raw::c_uint,
        iter: *mut ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " returns whether a solve method was called after the last modification of the LP"]
    pub fn SCIPlpiWasSolved(lpi: *mut SCIP_LPI) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " gets information about primal and dual feasibility of the current LP solution\n\n  The feasibility information is with respect to the last solving call and it is only relevant if SCIPlpiWasSolved()\n  returns true. If the LP is changed, this information might be invalidated.\n\n  Note that @p primalfeasible and @p dualfeasible should only return true if the solver has proved the respective LP to\n  be feasible. Thus, the return values should be equal to the values of SCIPlpiIsPrimalFeasible() and\n  SCIPlpiIsDualFeasible(), respectively. Note that if feasibility cannot be proved, they should return false (even if\n  the problem might actually be feasible)."]
    pub fn SCIPlpiGetSolFeasibility(
        lpi: *mut SCIP_LPI,
        primalfeasible: *mut ::std::os::raw::c_uint,
        dualfeasible: *mut ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " returns TRUE iff LP is proven to have a primal unbounded ray (but not necessary a primal feasible point);\n  this does not necessarily mean, that the solver knows and can return the primal ray"]
    pub fn SCIPlpiExistsPrimalRay(lpi: *mut SCIP_LPI) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " returns TRUE iff LP is proven to have a primal unbounded ray (but not necessary a primal feasible point),\n  and the solver knows and can return the primal ray"]
    pub fn SCIPlpiHasPrimalRay(lpi: *mut SCIP_LPI) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " returns TRUE iff LP is proven to be primal unbounded"]
    pub fn SCIPlpiIsPrimalUnbounded(lpi: *mut SCIP_LPI) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " returns TRUE iff LP is proven to be primal infeasible"]
    pub fn SCIPlpiIsPrimalInfeasible(lpi: *mut SCIP_LPI) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " returns TRUE iff LP is proven to be primal feasible"]
    pub fn SCIPlpiIsPrimalFeasible(lpi: *mut SCIP_LPI) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " returns TRUE iff LP is proven to have a dual unbounded ray (but not necessary a dual feasible point);\n  this does not necessarily mean, that the solver knows and can return the dual ray"]
    pub fn SCIPlpiExistsDualRay(lpi: *mut SCIP_LPI) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " returns TRUE iff LP is proven to have a dual unbounded ray (but not necessary a dual feasible point),\n  and the solver knows and can return the dual ray"]
    pub fn SCIPlpiHasDualRay(lpi: *mut SCIP_LPI) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " returns TRUE iff LP is proven to be dual unbounded"]
    pub fn SCIPlpiIsDualUnbounded(lpi: *mut SCIP_LPI) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " returns TRUE iff LP is proven to be dual infeasible"]
    pub fn SCIPlpiIsDualInfeasible(lpi: *mut SCIP_LPI) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " returns TRUE iff LP is proven to be dual feasible"]
    pub fn SCIPlpiIsDualFeasible(lpi: *mut SCIP_LPI) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " returns TRUE iff LP was solved to optimality"]
    pub fn SCIPlpiIsOptimal(lpi: *mut SCIP_LPI) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " returns TRUE iff current LP solution is stable\n\n  This function should return true if the solution is reliable, i.e., feasible and optimal (or proven\n  infeasible/unbounded) with respect to the original problem. The optimality status might be with respect to a scaled\n  version of the problem, but the solution might not be feasible to the unscaled original problem; in this case,\n  SCIPlpiIsStable() should return false."]
    pub fn SCIPlpiIsStable(lpi: *mut SCIP_LPI) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " returns TRUE iff the objective limit was reached"]
    pub fn SCIPlpiIsObjlimExc(lpi: *mut SCIP_LPI) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " returns TRUE iff the iteration limit was reached"]
    pub fn SCIPlpiIsIterlimExc(lpi: *mut SCIP_LPI) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " returns TRUE iff the time limit was reached"]
    pub fn SCIPlpiIsTimelimExc(lpi: *mut SCIP_LPI) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " returns the internal solution status of the solver"]
    pub fn SCIPlpiGetInternalStatus(lpi: *mut SCIP_LPI) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " tries to reset the internal status of the LP solver in order to ignore an instability of the last solving call"]
    pub fn SCIPlpiIgnoreInstability(
        lpi: *mut SCIP_LPI,
        success: *mut ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " gets objective value of solution"]
    pub fn SCIPlpiGetObjval(lpi: *mut SCIP_LPI, objval: *mut f64) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " gets primal and dual solution vectors for feasible LPs\n\n  Before calling this function, the caller must ensure that the LP has been solved to optimality, i.e., that\n  SCIPlpiIsOptimal() returns true."]
    pub fn SCIPlpiGetSol(
        lpi: *mut SCIP_LPI,
        objval: *mut f64,
        primsol: *mut f64,
        dualsol: *mut f64,
        activity: *mut f64,
        redcost: *mut f64,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " gets primal ray for unbounded LPs"]
    pub fn SCIPlpiGetPrimalRay(lpi: *mut SCIP_LPI, ray: *mut f64) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " gets dual Farkas proof for infeasibility"]
    pub fn SCIPlpiGetDualfarkas(lpi: *mut SCIP_LPI, dualfarkas: *mut f64) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " gets the number of LP iterations of the last solve call"]
    pub fn SCIPlpiGetIterations(
        lpi: *mut SCIP_LPI,
        iterations: *mut ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " gets information about the quality of an LP solution\n\n  Such information is usually only available, if also a (maybe not optimal) solution is available.\n  The LPI should return SCIP_INVALID for @p quality, if the requested quantity is not available."]
    pub fn SCIPlpiGetRealSolQuality(
        lpi: *mut SCIP_LPI,
        qualityindicator: SCIP_LPSOLQUALITY,
        quality: *mut f64,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " gets current basis status for columns and rows; arrays must be large enough to store the basis status"]
    pub fn SCIPlpiGetBase(
        lpi: *mut SCIP_LPI,
        cstat: *mut ::std::os::raw::c_int,
        rstat: *mut ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " sets current basis status for columns and rows"]
    pub fn SCIPlpiSetBase(
        lpi: *mut SCIP_LPI,
        cstat: *const ::std::os::raw::c_int,
        rstat: *const ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " returns the indices of the basic columns and rows; basic column n gives value n, basic row m gives value -1-m"]
    pub fn SCIPlpiGetBasisInd(lpi: *mut SCIP_LPI, bind: *mut ::std::os::raw::c_int)
        -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " get row of inverse basis matrix B^-1\n\n  @note The LP interface defines slack variables to have coefficient +1. This means that if, internally, the LP solver\n        uses a -1 coefficient, then rows associated with slacks variables whose coefficient is -1, should be negated;\n        see also the explanation in lpi.h."]
    pub fn SCIPlpiGetBInvRow(
        lpi: *mut SCIP_LPI,
        r: ::std::os::raw::c_int,
        coef: *mut f64,
        inds: *mut ::std::os::raw::c_int,
        ninds: *mut ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " get column of inverse basis matrix B^-1\n\n  @note The LP interface defines slack variables to have coefficient +1. This means that if, internally, the LP solver\n        uses a -1 coefficient, then rows associated with slacks variables whose coefficient is -1, should be negated;\n        see also the explanation in lpi.h."]
    pub fn SCIPlpiGetBInvCol(
        lpi: *mut SCIP_LPI,
        c: ::std::os::raw::c_int,
        coef: *mut f64,
        inds: *mut ::std::os::raw::c_int,
        ninds: *mut ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " get row of inverse basis matrix times constraint matrix B^-1 * A\n\n  @note The LP interface defines slack variables to have coefficient +1. This means that if, internally, the LP solver\n        uses a -1 coefficient, then rows associated with slacks variables whose coefficient is -1, should be negated;\n        see also the explanation in lpi.h."]
    pub fn SCIPlpiGetBInvARow(
        lpi: *mut SCIP_LPI,
        r: ::std::os::raw::c_int,
        binvrow: *const f64,
        coef: *mut f64,
        inds: *mut ::std::os::raw::c_int,
        ninds: *mut ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " get column of inverse basis matrix times constraint matrix B^-1 * A\n\n  @note The LP interface defines slack variables to have coefficient +1. This means that if, internally, the LP solver\n        uses a -1 coefficient, then rows associated with slacks variables whose coefficient is -1, should be negated;\n        see also the explanation in lpi.h."]
    pub fn SCIPlpiGetBInvACol(
        lpi: *mut SCIP_LPI,
        c: ::std::os::raw::c_int,
        coef: *mut f64,
        inds: *mut ::std::os::raw::c_int,
        ninds: *mut ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " stores LPi state (like basis information) into lpistate object"]
    pub fn SCIPlpiGetState(
        lpi: *mut SCIP_LPI,
        blkmem: *mut BMS_BLKMEM,
        lpistate: *mut *mut SCIP_LPISTATE,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " loads LPi state (like basis information) into solver; note that the LP might have been extended with additional\n  columns and rows since the state was stored with SCIPlpiGetState()"]
    pub fn SCIPlpiSetState(
        lpi: *mut SCIP_LPI,
        blkmem: *mut BMS_BLKMEM,
        lpistate: *const SCIP_LPISTATE,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " clears current LPi state (like basis information) of the solver"]
    pub fn SCIPlpiClearState(lpi: *mut SCIP_LPI) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " frees LPi state information"]
    pub fn SCIPlpiFreeState(
        lpi: *mut SCIP_LPI,
        blkmem: *mut BMS_BLKMEM,
        lpistate: *mut *mut SCIP_LPISTATE,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " checks, whether the given LPi state contains simplex basis information"]
    pub fn SCIPlpiHasStateBasis(
        lpi: *mut SCIP_LPI,
        lpistate: *mut SCIP_LPISTATE,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " reads LPi state (like basis information from a file"]
    pub fn SCIPlpiReadState(
        lpi: *mut SCIP_LPI,
        fname: *const ::std::os::raw::c_char,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " writes LPi state (i.e. basis information) to a file"]
    pub fn SCIPlpiWriteState(
        lpi: *mut SCIP_LPI,
        fname: *const ::std::os::raw::c_char,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " stores LPi pricing norms into lpinorms object"]
    pub fn SCIPlpiGetNorms(
        lpi: *mut SCIP_LPI,
        blkmem: *mut BMS_BLKMEM,
        lpinorms: *mut *mut SCIP_LPINORMS,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " loads LPi pricing norms into solver; note that the LP might have been extended with additional\n  columns and rows since the norms were stored with SCIPlpiGetNorms()"]
    pub fn SCIPlpiSetNorms(
        lpi: *mut SCIP_LPI,
        blkmem: *mut BMS_BLKMEM,
        lpinorms: *const SCIP_LPINORMS,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " frees LPi pricing norms information"]
    pub fn SCIPlpiFreeNorms(
        lpi: *mut SCIP_LPI,
        blkmem: *mut BMS_BLKMEM,
        lpinorms: *mut *mut SCIP_LPINORMS,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " gets integer parameter of LP"]
    pub fn SCIPlpiGetIntpar(
        lpi: *mut SCIP_LPI,
        type_: SCIP_LPPARAM,
        ival: *mut ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " sets integer parameter of LP"]
    pub fn SCIPlpiSetIntpar(
        lpi: *mut SCIP_LPI,
        type_: SCIP_LPPARAM,
        ival: ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " gets floating point parameter of LP"]
    pub fn SCIPlpiGetRealpar(
        lpi: *mut SCIP_LPI,
        type_: SCIP_LPPARAM,
        dval: *mut f64,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " sets floating point parameter of LP"]
    pub fn SCIPlpiSetRealpar(lpi: *mut SCIP_LPI, type_: SCIP_LPPARAM, dval: f64) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " interrupts the currently ongoing lp solve or disables the interrupt"]
    pub fn SCIPlpiInterrupt(lpi: *mut SCIP_LPI, interrupt: ::std::os::raw::c_uint) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " returns value treated as infinity in the LP solver"]
    pub fn SCIPlpiInfinity(lpi: *mut SCIP_LPI) -> f64;
}
extern "C" {
    #[doc = " checks if given value is treated as infinity in the LP solver"]
    pub fn SCIPlpiIsInfinity(lpi: *mut SCIP_LPI, val: f64) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " reads LP from a file"]
    pub fn SCIPlpiReadLP(lpi: *mut SCIP_LPI, fname: *const ::std::os::raw::c_char) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " writes LP to a file"]
    pub fn SCIPlpiWriteLP(lpi: *mut SCIP_LPI, fname: *const ::std::os::raw::c_char)
        -> SCIP_RETCODE;
}
extern "C" {
    #[doc = "@defgroup PublicSpecialPresolveMethods Special Methods\n @ingroup PublicPresolverMethods\n @brief methods commonly used for presolving\n\n @{\n/\n/** try to reduce the necessary variable in a set of variables with corresponding bounds and boundtypes for which one\n  must be fulfilled\n\n  e.g. a set of logicor or bounddisjunctive constraint variables would be such a set\n\n  consider the following set:\n\n  x1 >= 1, x2 >= 3, x3 >= 1, x4 <= 0\n\n  by (global) implication data (cliques, implications, and variable bounds) we have also the following implications\n  given:\n\n  x1 >= 1 => x3 >= 1\n  x2 >= 2 => x3 >= 1\n  x4 <= 0 => x1 >= 1\n\n  Because of the last implication x4 is redundant, because x1 >= 1 would also be fulfilled in the variable set, so we\n  can reduce the set by x4.\n  Also, the both other implications and x3 >= 1 (in the given variable set) all imply exactly x3 >= 1, so we tighten\n  the global lower bound of x3 to 1 and the set of variables gets redundant."]
    pub fn SCIPshrinkDisjunctiveVarSet(
        scip: *mut SCIP,
        vars: *mut *mut SCIP_VAR,
        bounds: *mut f64,
        boundtypes: *mut ::std::os::raw::c_uint,
        redundants: *mut ::std::os::raw::c_uint,
        nvars: ::std::os::raw::c_int,
        nredvars: *mut ::std::os::raw::c_int,
        nglobalred: *mut ::std::os::raw::c_int,
        setredundant: *mut ::std::os::raw::c_uint,
        glbinfeas: *mut ::std::os::raw::c_uint,
        fullshortening: ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_AggrRow {
    #[doc = "< non-zero coefficients of the cut row"]
    pub vals: *mut f64,
    #[doc = "< problem indices of variables with a non-zero coefficient in the cut row"]
    pub inds: *mut ::std::os::raw::c_int,
    #[doc = "< lpposition of rows that have been added to the cutrow"]
    pub rowsinds: *mut ::std::os::raw::c_int,
    #[doc = "< slacksign of rows that have been added to the cutrow"]
    pub slacksign: *mut ::std::os::raw::c_int,
    #[doc = "< weights of rows that have been added to the cutrow"]
    pub rowweights: *mut f64,
    #[doc = "< type used for floating point values"]
    pub rhshi: f64,
    #[doc = "< type used for floating point values"]
    pub rhslo: f64,
    #[doc = "< number of non-zeros in the cut row"]
    pub nnz: ::std::os::raw::c_int,
    #[doc = "< number of rows that have been added to the cutrow"]
    pub nrows: ::std::os::raw::c_int,
    #[doc = "< size of the row and slacksign array"]
    pub rowssize: ::std::os::raw::c_int,
    #[doc = "< rank of the cut row"]
    pub rank: ::std::os::raw::c_int,
    #[doc = "< is the cut row only valid locally?"]
    pub local: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_SCIP_AggrRow() {
    const UNINIT: ::std::mem::MaybeUninit<SCIP_AggrRow> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<SCIP_AggrRow>(),
        80usize,
        concat!("Size of: ", stringify!(SCIP_AggrRow))
    );
    assert_eq!(
        ::std::mem::align_of::<SCIP_AggrRow>(),
        8usize,
        concat!("Alignment of ", stringify!(SCIP_AggrRow))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vals) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SCIP_AggrRow),
            "::",
            stringify!(vals)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).inds) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SCIP_AggrRow),
            "::",
            stringify!(inds)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rowsinds) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(SCIP_AggrRow),
            "::",
            stringify!(rowsinds)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).slacksign) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(SCIP_AggrRow),
            "::",
            stringify!(slacksign)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rowweights) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(SCIP_AggrRow),
            "::",
            stringify!(rowweights)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rhshi) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(SCIP_AggrRow),
            "::",
            stringify!(rhshi)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rhslo) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(SCIP_AggrRow),
            "::",
            stringify!(rhslo)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nnz) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(SCIP_AggrRow),
            "::",
            stringify!(nnz)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nrows) as usize - ptr as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(SCIP_AggrRow),
            "::",
            stringify!(nrows)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rowssize) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(SCIP_AggrRow),
            "::",
            stringify!(rowssize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rank) as usize - ptr as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(SCIP_AggrRow),
            "::",
            stringify!(rank)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).local) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(SCIP_AggrRow),
            "::",
            stringify!(local)
        )
    );
}
pub type SCIP_AGGRROW = SCIP_AggrRow;
extern "C" {
    #[doc = " perform activity based coefficient tigthening on the given cut; returns TRUE if the cut was detected\n  to be redundant due to acitivity bounds\n\n  See also cons_linear.c:consdataTightenCoefs()."]
    pub fn SCIPcutsTightenCoefficients(
        scip: *mut SCIP,
        cutislocal: ::std::os::raw::c_uint,
        cutcoefs: *mut f64,
        cutrhs: *mut f64,
        cutinds: *mut ::std::os::raw::c_int,
        cutnnz: *mut ::std::os::raw::c_int,
        nchgcoefs: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " create an empty the aggregation row"]
    pub fn SCIPaggrRowCreate(scip: *mut SCIP, aggrrow: *mut *mut SCIP_AGGRROW) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " free a the aggregation row"]
    pub fn SCIPaggrRowFree(scip: *mut SCIP, aggrrow: *mut *mut SCIP_AGGRROW);
}
extern "C" {
    #[doc = " output aggregation row to file stream"]
    pub fn SCIPaggrRowPrint(scip: *mut SCIP, aggrrow: *mut SCIP_AGGRROW, file: *mut FILE);
}
extern "C" {
    #[doc = " copy the aggregation row"]
    pub fn SCIPaggrRowCopy(
        scip: *mut SCIP,
        aggrrow: *mut *mut SCIP_AGGRROW,
        source: *mut SCIP_AGGRROW,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " add weighted row to the aggregation row"]
    pub fn SCIPaggrRowAddRow(
        scip: *mut SCIP,
        aggrrow: *mut SCIP_AGGRROW,
        row: *mut SCIP_ROW,
        weight: f64,
        sidetype: ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " Removes a given variable @p var from position @p pos the aggregation row and updates the right-hand side according\n  to sign of the coefficient, i.e., rhs -= coef * bound, where bound = lb if coef >= 0 and bound = ub, otherwise.\n\n  @note: The choice of global or local bounds depend on the validity (global or local) of the aggregation row.\n\n  @note: The list of non-zero indices will be updated by swapping the last non-zero index to @p pos."]
    pub fn SCIPaggrRowCancelVarWithBound(
        scip: *mut SCIP,
        aggrrow: *mut SCIP_AGGRROW,
        var: *mut SCIP_VAR,
        pos: ::std::os::raw::c_int,
        valid: *mut ::std::os::raw::c_uint,
    );
}
extern "C" {
    #[doc = " add the objective function with right-hand side @p rhs and scaled by @p scale to the aggregation row"]
    pub fn SCIPaggrRowAddObjectiveFunction(
        scip: *mut SCIP,
        aggrrow: *mut SCIP_AGGRROW,
        rhs: f64,
        scale: f64,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " add weighted constraint to the aggregation row"]
    pub fn SCIPaggrRowAddCustomCons(
        scip: *mut SCIP,
        aggrrow: *mut SCIP_AGGRROW,
        inds: *mut ::std::os::raw::c_int,
        vals: *mut f64,
        len: ::std::os::raw::c_int,
        rhs: f64,
        weight: f64,
        rank: ::std::os::raw::c_int,
        local: ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " calculates the efficacy norm of the given aggregation row, which depends on the \"separating/efficacynorm\" parameter\n\n  @return the efficacy norm of the given aggregation row, which depends on the \"separating/efficacynorm\" parameter"]
    pub fn SCIPaggrRowCalcEfficacyNorm(scip: *mut SCIP, aggrrow: *mut SCIP_AGGRROW) -> f64;
}
extern "C" {
    #[doc = " clear all entries in the aggregation row but do not free the internal memory"]
    pub fn SCIPaggrRowClear(aggrrow: *mut SCIP_AGGRROW);
}
extern "C" {
    #[doc = " aggregate rows using the given weights; the current content of the aggregation\n  row, \\p aggrrow, gets overwritten"]
    pub fn SCIPaggrRowSumRows(
        scip: *mut SCIP,
        aggrrow: *mut SCIP_AGGRROW,
        weights: *mut f64,
        rowinds: *mut ::std::os::raw::c_int,
        nrowinds: ::std::os::raw::c_int,
        sidetypebasis: ::std::os::raw::c_uint,
        allowlocal: ::std::os::raw::c_uint,
        negslack: ::std::os::raw::c_int,
        maxaggrlen: ::std::os::raw::c_int,
        valid: *mut ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " removes all (close enough to) zero entries in the aggregation row"]
    pub fn SCIPaggrRowRemoveZeros(
        scip: *mut SCIP,
        aggrrow: *mut SCIP_AGGRROW,
        useglbbounds: ::std::os::raw::c_uint,
        valid: *mut ::std::os::raw::c_uint,
    );
}
extern "C" {
    #[doc = " get array with lp positions of aggregated rows"]
    pub fn SCIPaggrRowGetRowInds(aggrrow: *mut SCIP_AGGRROW) -> *mut ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " get array with weights of aggregated rows"]
    pub fn SCIPaggrRowGetRowWeights(aggrrow: *mut SCIP_AGGRROW) -> *mut f64;
}
extern "C" {
    #[doc = " checks whether a given row has been added to the aggregation row"]
    pub fn SCIPaggrRowHasRowBeenAdded(
        aggrrow: *mut SCIP_AGGRROW,
        row: *mut SCIP_ROW,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " gets the min and max absolute value of the weights used to aggregate the rows;\n  must not be called for empty aggregation rows"]
    pub fn SCIPaggrRowGetAbsWeightRange(
        aggrrow: *mut SCIP_AGGRROW,
        minabsrowweight: *mut f64,
        maxabsrowweight: *mut f64,
    );
}
extern "C" {
    #[doc = " gets the array of corresponding variable problem indices for each non-zero in the aggregation row"]
    pub fn SCIPaggrRowGetInds(aggrrow: *mut SCIP_AGGRROW) -> *mut ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " gets the number of non-zeros in the aggregation row"]
    pub fn SCIPaggrRowGetNNz(aggrrow: *mut SCIP_AGGRROW) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " gets the rank of the aggregation row"]
    pub fn SCIPaggrRowGetRank(aggrrow: *mut SCIP_AGGRROW) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " checks if the aggregation row is only valid locally"]
    pub fn SCIPaggrRowIsLocal(aggrrow: *mut SCIP_AGGRROW) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " gets the right hand side of the aggregation row"]
    pub fn SCIPaggrRowGetRhs(aggrrow: *mut SCIP_AGGRROW) -> f64;
}
extern "C" {
    #[doc = " gets the number of row aggregations"]
    pub fn SCIPaggrRowGetNRows(aggrrow: *mut SCIP_AGGRROW) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " calculates an MIR cut out of the weighted sum of LP rows given by an aggregation row; the\n  aggregation row must not contain non-zero weights for modifiable rows, because these rows cannot\n  participate in an MIR cut.\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_SOLVING\n\n  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPcalcMIR(
        scip: *mut SCIP,
        sol: *mut SCIP_SOL,
        postprocess: ::std::os::raw::c_uint,
        boundswitch: f64,
        usevbds: ::std::os::raw::c_uint,
        allowlocal: ::std::os::raw::c_uint,
        fixintegralrhs: ::std::os::raw::c_uint,
        boundsfortrans: *mut ::std::os::raw::c_int,
        boundtypesfortrans: *mut SCIP_BOUNDTYPE,
        minfrac: f64,
        maxfrac: f64,
        scale: f64,
        aggrrow: *mut SCIP_AGGRROW,
        cutcoefs: *mut f64,
        cutrhs: *mut f64,
        cutinds: *mut ::std::os::raw::c_int,
        cutnnz: *mut ::std::os::raw::c_int,
        cutefficacy: *mut f64,
        cutrank: *mut ::std::os::raw::c_int,
        cutislocal: *mut ::std::os::raw::c_uint,
        success: *mut ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " calculates an MIR cut out of the weighted sum of LP rows given by an aggregation row; the\n  aggregation row must not contain non-zero weights for modifiable rows, because these rows cannot\n  participate in an MIR cut. The function uses a cut generation heuristic which tries different scaling\n  factors and complementations of the variables to improve the cut's efficacy.\n  For further details we refer to:\n\n  Marchand, H., & Wolsey, L. A. (2001). Aggregation and mixed integer rounding to solve MIPs.\n  Operations research, 49(3), 363-371.\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_SOLVING\n\n  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPcutGenerationHeuristicCMIR(
        scip: *mut SCIP,
        sol: *mut SCIP_SOL,
        postprocess: ::std::os::raw::c_uint,
        boundswitch: f64,
        usevbds: ::std::os::raw::c_uint,
        allowlocal: ::std::os::raw::c_uint,
        maxtestdelta: ::std::os::raw::c_int,
        boundsfortrans: *mut ::std::os::raw::c_int,
        boundtypesfortrans: *mut SCIP_BOUNDTYPE,
        minfrac: f64,
        maxfrac: f64,
        aggrrow: *mut SCIP_AGGRROW,
        cutcoefs: *mut f64,
        cutrhs: *mut f64,
        cutinds: *mut ::std::os::raw::c_int,
        cutnnz: *mut ::std::os::raw::c_int,
        cutefficacy: *mut f64,
        cutrank: *mut ::std::os::raw::c_int,
        cutislocal: *mut ::std::os::raw::c_uint,
        success: *mut ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " calculates a lifted simple generalized flow cover cut out of the weighted sum of LP rows given by an aggregation row; the\n  aggregation row must not contain non-zero weights for modifiable rows, because these rows cannot\n  participate in the cut.\n  For further details we refer to:\n\n  Gu, Z., Nemhauser, G. L., & Savelsbergh, M. W. (1999). Lifted flow cover inequalities for mixed 0-1 integer programs.\n  Mathematical Programming, 85(3), 439-467.\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_SOLVING\n\n  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPcalcFlowCover(
        scip: *mut SCIP,
        sol: *mut SCIP_SOL,
        postprocess: ::std::os::raw::c_uint,
        boundswitch: f64,
        allowlocal: ::std::os::raw::c_uint,
        aggrrow: *mut SCIP_AGGRROW,
        cutcoefs: *mut f64,
        cutrhs: *mut f64,
        cutinds: *mut ::std::os::raw::c_int,
        cutnnz: *mut ::std::os::raw::c_int,
        cutefficacy: *mut f64,
        cutrank: *mut ::std::os::raw::c_int,
        cutislocal: *mut ::std::os::raw::c_uint,
        success: *mut ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " calculates a lifted knapsack cover cut out of the weighted sum of LP rows given by an aggregation row; the\n  aggregation row must not contain non-zero weights for modifiable rows, because these rows cannot\n  participate in the cut.\n  For further details we refer to:\n\n  Letchford, A. N., & Souli, G. (2019). On lifted cover inequalities: A new lifting procedure with unusual properties.\n  Operations Research Letters, 47(2), 83-87.\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_SOLVING\n\n  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPcalcKnapsackCover(
        scip: *mut SCIP,
        sol: *mut SCIP_SOL,
        allowlocal: ::std::os::raw::c_uint,
        aggrrow: *mut SCIP_AGGRROW,
        cutcoefs: *mut f64,
        cutrhs: *mut f64,
        cutinds: *mut ::std::os::raw::c_int,
        cutnnz: *mut ::std::os::raw::c_int,
        cutefficacy: *mut f64,
        cutrank: *mut ::std::os::raw::c_int,
        cutislocal: *mut ::std::os::raw::c_uint,
        success: *mut ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " calculates a strong CG cut out of the weighted sum of LP rows given by an aggregation row; the\n  aggregation row must not contain non-zero weights for modifiable rows, because these rows cannot\n  participate in a strongcg cut\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_SOLVING\n\n  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPcalcStrongCG(
        scip: *mut SCIP,
        sol: *mut SCIP_SOL,
        postprocess: ::std::os::raw::c_uint,
        boundswitch: f64,
        usevbds: ::std::os::raw::c_uint,
        allowlocal: ::std::os::raw::c_uint,
        minfrac: f64,
        maxfrac: f64,
        scale: f64,
        aggrrow: *mut SCIP_AGGRROW,
        cutcoefs: *mut f64,
        cutrhs: *mut f64,
        cutinds: *mut ::std::os::raw::c_int,
        cutnnz: *mut ::std::os::raw::c_int,
        cutefficacy: *mut f64,
        cutrank: *mut ::std::os::raw::c_int,
        cutislocal: *mut ::std::os::raw::c_uint,
        success: *mut ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " performs a diving within the limits of the @p diveset parameters\n\n  This method performs a diving according to the settings defined by the diving settings @p diveset; Contrary to the\n  name, SCIP enters probing mode (not diving mode) and dives along a path into the tree. Domain propagation\n  is applied at every node in the tree, whereas probing LPs might be solved less frequently.\n\n  Starting from the current LP solution, the algorithm selects candidates which maximize the\n  score defined by the @p diveset and whose solution value has not yet been rendered infeasible by propagation,\n  and propagates the bound change on this candidate.\n\n  The algorithm iteratively selects the the next (unfixed) candidate in the list, until either enough domain changes\n  or the resolve frequency of the LP trigger an LP resolve (and hence, the set of potential candidates changes),\n  or the last node is proven to be infeasible. It optionally backtracks and tries the\n  other branching direction.\n\n  After the set of remaining candidates is empty or the targeted depth is reached, the node LP is\n  solved, and the old candidates are replaced by the new LP candidates.\n\n  @see heur_guideddiving.c for an example implementation of a dive set controlling the diving algorithm.\n\n  @note the node from where the algorithm is called is checked for a basic LP solution. If the solution\n        is non-basic, e.g., when barrier without crossover is used, the method returns without performing a dive.\n\n  @note currently, when multiple diving heuristics call this method and solve an LP at the same node, only the first\n        call will be executed, @see SCIPgetLastDiveNode()."]
    pub fn SCIPperformGenericDivingAlgorithm(
        scip: *mut SCIP,
        diveset: *mut SCIP_DIVESET,
        worksol: *mut SCIP_SOL,
        heur: *mut SCIP_HEUR,
        result: *mut SCIP_RESULT,
        nodeinfeasible: ::std::os::raw::c_uint,
        iterlim: ::std::os::raw::c_longlong,
        nodelimit: ::std::os::raw::c_int,
        lpresolvedomchgquot: f64,
        divecontext: SCIP_DIVECONTEXT,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " get a sub-SCIP copy of the transformed problem"]
    pub fn SCIPcopyLargeNeighborhoodSearch(
        sourcescip: *mut SCIP,
        subscip: *mut SCIP,
        varmap: *mut SCIP_HASHMAP,
        suffix: *const ::std::os::raw::c_char,
        fixedvars: *mut *mut SCIP_VAR,
        fixedvals: *mut f64,
        nfixedvars: ::std::os::raw::c_int,
        uselprows: ::std::os::raw::c_uint,
        copycuts: ::std::os::raw::c_uint,
        success: *mut ::std::os::raw::c_uint,
        valid: *mut ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " adds a trust region neighborhood constraint to the @p targetscip\n\n  a trust region constraint measures the deviation from the current incumbent solution \\f$x^*\\f$ by an auxiliary\n  continuous variable \\f$v \\geq 0\\f$:\n  \\f[\n    \\sum\\limits_{j\\in B} |x_j^* - x_j| = v\n  \\f]\n  Only binary variables are taken into account. The deviation is penalized in the objective function using\n  a positive \\p violpenalty.\n\n  @note: the trust region constraint creates an auxiliary variable to penalize the deviation from\n  the current incumbent solution. This variable can afterwards be accessed using SCIPfindVar() by its name\n  'trustregion_violationvar'"]
    pub fn SCIPaddTrustregionNeighborhoodConstraint(
        scip: *mut SCIP,
        subscip: *mut SCIP,
        subvars: *mut *mut SCIP_VAR,
        violpenalty: f64,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " includes a bandit algorithm virtual function table"]
    pub fn SCIPincludeBanditvtable(
        scip: *mut SCIP,
        banditvtable: *mut *mut SCIP_BANDITVTABLE,
        name: *const ::std::os::raw::c_char,
        banditfree: ::std::option::Option<
            unsafe extern "C" fn(blkmem: *mut BMS_BLKMEM, bandit: *mut SCIP_BANDIT) -> SCIP_RETCODE,
        >,
        banditselect: ::std::option::Option<
            unsafe extern "C" fn(
                bandit: *mut SCIP_BANDIT,
                selection: *mut ::std::os::raw::c_int,
            ) -> SCIP_RETCODE,
        >,
        banditupdate: ::std::option::Option<
            unsafe extern "C" fn(
                bandit: *mut SCIP_BANDIT,
                selection: ::std::os::raw::c_int,
                score: f64,
            ) -> SCIP_RETCODE,
        >,
        banditreset: ::std::option::Option<
            unsafe extern "C" fn(
                bufmem: *mut BMS_BUFMEM,
                bandit: *mut SCIP_BANDIT,
                priorities: *mut f64,
            ) -> SCIP_RETCODE,
        >,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " returns the bandit virtual function table of the given name, or NULL if not existing"]
    pub fn SCIPfindBanditvtable(
        scip: *mut SCIP,
        name: *const ::std::os::raw::c_char,
    ) -> *mut SCIP_BANDITVTABLE;
}
extern "C" {
    #[doc = " calls destructor and frees memory of bandit algorithm"]
    pub fn SCIPfreeBandit(scip: *mut SCIP, bandit: *mut *mut SCIP_BANDIT) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " reset the bandit algorithm"]
    pub fn SCIPresetBandit(
        scip: *mut SCIP,
        bandit: *mut SCIP_BANDIT,
        priorities: *mut f64,
        seed: ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " creates a Benders' decomposition and includes it in SCIP\n\n  To use the Benders' decomposition for solving a problem, it first has to be activated with a call to SCIPactivateBenders().\n  This should be done during the problem creation stage.\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_INIT\n       - \\ref SCIP_STAGE_PROBLEM\n\n  @note method has all Benders' decomposition callbacks as arguments and is thus changed every time a new callback is\n        added in future releases; consider using SCIPincludeBendersBasic() and setter functions\n        if you seek for a method which is less likely to change in future releases"]
    pub fn SCIPincludeBenders(
        scip: *mut SCIP,
        name: *const ::std::os::raw::c_char,
        desc: *const ::std::os::raw::c_char,
        priority: ::std::os::raw::c_int,
        cutlp: ::std::os::raw::c_uint,
        cutpseudo: ::std::os::raw::c_uint,
        cutrelax: ::std::os::raw::c_uint,
        shareauxvars: ::std::os::raw::c_uint,
        benderscopy: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                benders: *mut SCIP_BENDERS,
                threadsafe: ::std::os::raw::c_uint,
            ) -> SCIP_RETCODE,
        >,
        bendersfree: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, benders: *mut SCIP_BENDERS) -> SCIP_RETCODE,
        >,
        bendersinit: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, benders: *mut SCIP_BENDERS) -> SCIP_RETCODE,
        >,
        bendersexit: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, benders: *mut SCIP_BENDERS) -> SCIP_RETCODE,
        >,
        bendersinitpre: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, benders: *mut SCIP_BENDERS) -> SCIP_RETCODE,
        >,
        bendersexitpre: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, benders: *mut SCIP_BENDERS) -> SCIP_RETCODE,
        >,
        bendersinitsol: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, benders: *mut SCIP_BENDERS) -> SCIP_RETCODE,
        >,
        bendersexitsol: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, benders: *mut SCIP_BENDERS) -> SCIP_RETCODE,
        >,
        bendersgetvar: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                benders: *mut SCIP_BENDERS,
                var: *mut SCIP_VAR,
                mappedvar: *mut *mut SCIP_VAR,
                probnumber: ::std::os::raw::c_int,
            ) -> SCIP_RETCODE,
        >,
        benderscreatesub: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                benders: *mut SCIP_BENDERS,
                probnumber: ::std::os::raw::c_int,
            ) -> SCIP_RETCODE,
        >,
        benderspresubsolve: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                benders: *mut SCIP_BENDERS,
                sol: *mut SCIP_SOL,
                type_: SCIP_BENDERSENFOTYPE,
                checkint: ::std::os::raw::c_uint,
                infeasible: *mut ::std::os::raw::c_uint,
                auxviol: *mut ::std::os::raw::c_uint,
                skipsolve: *mut ::std::os::raw::c_uint,
                result: *mut SCIP_RESULT,
            ) -> SCIP_RETCODE,
        >,
        benderssolvesubconvex: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                benders: *mut SCIP_BENDERS,
                sol: *mut SCIP_SOL,
                probnumber: ::std::os::raw::c_int,
                onlyconvexcheck: ::std::os::raw::c_uint,
                objective: *mut f64,
                result: *mut SCIP_RESULT,
            ) -> SCIP_RETCODE,
        >,
        benderssolvesub: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                benders: *mut SCIP_BENDERS,
                sol: *mut SCIP_SOL,
                probnumber: ::std::os::raw::c_int,
                objective: *mut f64,
                result: *mut SCIP_RESULT,
            ) -> SCIP_RETCODE,
        >,
        benderspostsolve: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                benders: *mut SCIP_BENDERS,
                sol: *mut SCIP_SOL,
                type_: SCIP_BENDERSENFOTYPE,
                mergecands: *mut ::std::os::raw::c_int,
                npriomergecands: ::std::os::raw::c_int,
                nmergecands: ::std::os::raw::c_int,
                checkint: ::std::os::raw::c_uint,
                infeasible: ::std::os::raw::c_uint,
                merged: *mut ::std::os::raw::c_uint,
            ) -> SCIP_RETCODE,
        >,
        bendersfreesub: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                benders: *mut SCIP_BENDERS,
                probnumber: ::std::os::raw::c_int,
            ) -> SCIP_RETCODE,
        >,
        bendersdata: *mut SCIP_BENDERSDATA,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " creates a Benders' decomposition and includes it in SCIP with all non-fundamental callbacks set to NULL\n\n  If needed, the non-fundamental callbacks can be added afterwards via setter functions SCIPsetBendersCopy(),\n  SCIPsetBendersFree(), SCIPsetBendersInity(), SCIPsetBendersExit(), SCIPsetBendersInitsol(), SCIPsetBendersExitsol(),\n  SCIPsetBendersFarkas().\n\n  To use the Benders' decomposition for solving a problem, it first has to be activated with a call to SCIPactivateBenders().\n  This should be done during the problem creation stage.\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_INIT\n       - \\ref SCIP_STAGE_PROBLEM\n\n  @note if you want to set all callbacks with a single method call, consider using SCIPincludeBenders() instead"]
    pub fn SCIPincludeBendersBasic(
        scip: *mut SCIP,
        bendersptr: *mut *mut SCIP_BENDERS,
        name: *const ::std::os::raw::c_char,
        desc: *const ::std::os::raw::c_char,
        priority: ::std::os::raw::c_int,
        cutlp: ::std::os::raw::c_uint,
        cutpseudo: ::std::os::raw::c_uint,
        cutrelax: ::std::os::raw::c_uint,
        shareauxvars: ::std::os::raw::c_uint,
        bendersgetvar: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                benders: *mut SCIP_BENDERS,
                var: *mut SCIP_VAR,
                mappedvar: *mut *mut SCIP_VAR,
                probnumber: ::std::os::raw::c_int,
            ) -> SCIP_RETCODE,
        >,
        benderscreatesub: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                benders: *mut SCIP_BENDERS,
                probnumber: ::std::os::raw::c_int,
            ) -> SCIP_RETCODE,
        >,
        bendersdata: *mut SCIP_BENDERSDATA,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " sets copy method of benders\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_INIT\n       - \\ref SCIP_STAGE_PROBLEM"]
    pub fn SCIPsetBendersCopy(
        scip: *mut SCIP,
        benders: *mut SCIP_BENDERS,
        benderscopy: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                benders: *mut SCIP_BENDERS,
                threadsafe: ::std::os::raw::c_uint,
            ) -> SCIP_RETCODE,
        >,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " sets destructor method of benders\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_INIT\n       - \\ref SCIP_STAGE_PROBLEM"]
    pub fn SCIPsetBendersFree(
        scip: *mut SCIP,
        benders: *mut SCIP_BENDERS,
        bendersfree: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, benders: *mut SCIP_BENDERS) -> SCIP_RETCODE,
        >,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " sets initialization method of benders\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_INIT\n       - \\ref SCIP_STAGE_PROBLEM"]
    pub fn SCIPsetBendersInit(
        scip: *mut SCIP,
        benders: *mut SCIP_BENDERS,
        bendersinit: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, benders: *mut SCIP_BENDERS) -> SCIP_RETCODE,
        >,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " sets deinitialization method of benders\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_INIT\n       - \\ref SCIP_STAGE_PROBLEM"]
    pub fn SCIPsetBendersExit(
        scip: *mut SCIP,
        benders: *mut SCIP_BENDERS,
        bendersexit: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, benders: *mut SCIP_BENDERS) -> SCIP_RETCODE,
        >,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " sets presolving initialization method of benders\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_INIT\n       - \\ref SCIP_STAGE_PROBLEM"]
    pub fn SCIPsetBendersInitpre(
        scip: *mut SCIP,
        benders: *mut SCIP_BENDERS,
        bendersinitpre: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, benders: *mut SCIP_BENDERS) -> SCIP_RETCODE,
        >,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " sets presolving deinitialization method of benders\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_INIT\n       - \\ref SCIP_STAGE_PROBLEM"]
    pub fn SCIPsetBendersExitpre(
        scip: *mut SCIP,
        benders: *mut SCIP_BENDERS,
        bendersexitpre: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, benders: *mut SCIP_BENDERS) -> SCIP_RETCODE,
        >,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " sets solving process initialization method of benders\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_INIT\n       - \\ref SCIP_STAGE_PROBLEM"]
    pub fn SCIPsetBendersInitsol(
        scip: *mut SCIP,
        benders: *mut SCIP_BENDERS,
        bendersinitsol: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, benders: *mut SCIP_BENDERS) -> SCIP_RETCODE,
        >,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " sets solving process deinitialization method of benders\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_INIT\n       - \\ref SCIP_STAGE_PROBLEM"]
    pub fn SCIPsetBendersExitsol(
        scip: *mut SCIP,
        benders: *mut SCIP_BENDERS,
        bendersexitsol: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, benders: *mut SCIP_BENDERS) -> SCIP_RETCODE,
        >,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " sets the method called prior to solving the subproblems for benders\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_INIT\n       - \\ref SCIP_STAGE_PROBLEM"]
    pub fn SCIPsetBendersPresubsolve(
        scip: *mut SCIP,
        benders: *mut SCIP_BENDERS,
        benderspresubsolve: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                benders: *mut SCIP_BENDERS,
                sol: *mut SCIP_SOL,
                type_: SCIP_BENDERSENFOTYPE,
                checkint: ::std::os::raw::c_uint,
                infeasible: *mut ::std::os::raw::c_uint,
                auxviol: *mut ::std::os::raw::c_uint,
                skipsolve: *mut ::std::os::raw::c_uint,
                result: *mut SCIP_RESULT,
            ) -> SCIP_RETCODE,
        >,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " sets the subproblem solving and freeing methods for Benders' decomposition\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_INIT\n       - \\ref SCIP_STAGE_PROBLEM"]
    pub fn SCIPsetBendersSolveAndFreesub(
        scip: *mut SCIP,
        benders: *mut SCIP_BENDERS,
        benderssolvesubconvex: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                benders: *mut SCIP_BENDERS,
                sol: *mut SCIP_SOL,
                probnumber: ::std::os::raw::c_int,
                onlyconvexcheck: ::std::os::raw::c_uint,
                objective: *mut f64,
                result: *mut SCIP_RESULT,
            ) -> SCIP_RETCODE,
        >,
        benderssolvesub: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                benders: *mut SCIP_BENDERS,
                sol: *mut SCIP_SOL,
                probnumber: ::std::os::raw::c_int,
                objective: *mut f64,
                result: *mut SCIP_RESULT,
            ) -> SCIP_RETCODE,
        >,
        bendersfreesub: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                benders: *mut SCIP_BENDERS,
                probnumber: ::std::os::raw::c_int,
            ) -> SCIP_RETCODE,
        >,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " sets the post solving methods for benders\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_INIT\n       - \\ref SCIP_STAGE_PROBLEM"]
    pub fn SCIPsetBendersPostsolve(
        scip: *mut SCIP,
        benders: *mut SCIP_BENDERS,
        benderspostsolve: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                benders: *mut SCIP_BENDERS,
                sol: *mut SCIP_SOL,
                type_: SCIP_BENDERSENFOTYPE,
                mergecands: *mut ::std::os::raw::c_int,
                npriomergecands: ::std::os::raw::c_int,
                nmergecands: ::std::os::raw::c_int,
                checkint: ::std::os::raw::c_uint,
                infeasible: ::std::os::raw::c_uint,
                merged: *mut ::std::os::raw::c_uint,
            ) -> SCIP_RETCODE,
        >,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " sets the subproblem comparison method for determining the solving order in Benders' decomposition\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_INIT\n       - \\ref SCIP_STAGE_PROBLEM"]
    pub fn SCIPsetBendersSubproblemComp(
        scip: *mut SCIP,
        benders: *mut SCIP_BENDERS,
        benderssubcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " returns the Benders' decomposition of the given name, or NULL if not existing"]
    pub fn SCIPfindBenders(
        scip: *mut SCIP,
        name: *const ::std::os::raw::c_char,
    ) -> *mut SCIP_BENDERS;
}
extern "C" {
    #[doc = " returns the array of currently available Benders' decomposition; active Benders' decomposition are in the first\n slots of the array"]
    pub fn SCIPgetBenders(scip: *mut SCIP) -> *mut *mut SCIP_BENDERS;
}
extern "C" {
    #[doc = " returns the number of currently available Benders' decomposition"]
    pub fn SCIPgetNBenders(scip: *mut SCIP) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " returns the number of currently active Benders' decomposition"]
    pub fn SCIPgetNActiveBenders(scip: *mut SCIP) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " activates the Benders' decomposition to be used for the current problem\n\n  This method should be called during the problem creation stage for all pricers that are necessary to solve\n  the problem model.\n\n  @note The Benders' decompositions are automatically deactivated when the problem is freed.\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM"]
    pub fn SCIPactivateBenders(
        scip: *mut SCIP,
        benders: *mut SCIP_BENDERS,
        nsubproblems: ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " deactivates the Benders' decomposition\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_EXITSOLVE"]
    pub fn SCIPdeactivateBenders(scip: *mut SCIP, benders: *mut SCIP_BENDERS) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " sets the priority of a Benders' decomposition"]
    pub fn SCIPsetBendersPriority(
        scip: *mut SCIP,
        benders: *mut SCIP_BENDERS,
        priority: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " calls the exec method of Benders' decomposition to solve the subproblems\n\n  The checkint flag indicates whether integer feasibility can be assumed. If it is not assumed, i.e. checkint ==\n  FALSE, then only the convex relaxations of the subproblems are solved. If integer feasibility is assumed, i.e.\n  checkint == TRUE, then the convex relaxations and the full CIP are solved to generate Benders' cuts and check\n  solution feasibility.\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPsolveBendersSubproblems(
        scip: *mut SCIP,
        benders: *mut SCIP_BENDERS,
        sol: *mut SCIP_SOL,
        result: *mut SCIP_RESULT,
        infeasible: *mut ::std::os::raw::c_uint,
        auxviol: *mut ::std::os::raw::c_uint,
        type_: SCIP_BENDERSENFOTYPE,
        checkint: ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " returns the master problem variable for the given subproblem variable\n\n  This function is used as part of the cut generation process.\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPgetBendersMasterVar(
        scip: *mut SCIP,
        benders: *mut SCIP_BENDERS,
        var: *mut SCIP_VAR,
        mappedvar: *mut *mut SCIP_VAR,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " returns the subproblem problem variable for the given master variable\n\n  This function is used as part of the cut generation process.\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPgetBendersSubproblemVar(
        scip: *mut SCIP,
        benders: *mut SCIP_BENDERS,
        var: *mut SCIP_VAR,
        mappedvar: *mut *mut SCIP_VAR,
        probnumber: ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " returns the number of subproblems that are stored in the given Benders' decomposition\n\n  @return the number of subproblems in the Benders' decomposition"]
    pub fn SCIPgetBendersNSubproblems(
        scip: *mut SCIP,
        benders: *mut SCIP_BENDERS,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " registers the Benders' decomposition subproblem with the Benders' decomposition struct.\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_INIT\n       - \\ref SCIP_STAGE_PROBLEM"]
    pub fn SCIPaddBendersSubproblem(
        scip: *mut SCIP,
        benders: *mut SCIP_BENDERS,
        subproblem: *mut SCIP,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " calls the generic subproblem setup method for a Benders' decomposition subproblem\n\n  This is called if the user requires to solve the Benders' decomposition subproblem separately from the main Benders'\n  solving loop. This could be in the case of enhancement techniques.\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPsetupBendersSubproblem(
        scip: *mut SCIP,
        benders: *mut SCIP_BENDERS,
        sol: *mut SCIP_SOL,
        probnumber: ::std::os::raw::c_int,
        type_: SCIP_BENDERSENFOTYPE,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " calls the solving method for a single Benders' decomposition subproblem\n\n  The method either calls the users solve subproblem method or calls the generic method. In the case of the generic\n  method, the user must set up the subproblem prior to calling this method.\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPsolveBendersSubproblem(
        scip: *mut SCIP,
        benders: *mut SCIP_BENDERS,
        sol: *mut SCIP_SOL,
        probnumber: ::std::os::raw::c_int,
        infeasible: *mut ::std::os::raw::c_uint,
        solvecip: ::std::os::raw::c_uint,
        objective: *mut f64,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " frees the subproblem after calling the solve subproblem method\n\n  This will either call the user defined free\n  subproblem callback for Benders' decomposition or the default freeing methods. In the default case, if the\n  subproblem is an LP, then SCIPendProbing is called. If the subproblem is a MIP, then SCIPfreeTransform is called.\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED\n       - \\ref SCIP_STAGE_EXITSOLVE\n       - \\ref SCIP_STAGE_FREETRANS"]
    pub fn SCIPfreeBendersSubproblem(
        scip: *mut SCIP,
        benders: *mut SCIP_BENDERS,
        probnumber: ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " checks the optimality of a Benders' decomposition subproblem by comparing the objective function value against the\n  value of the corresponding auxiliary variable\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED\n\n  @pre This method can be called if requested subproblem is in one of the following stages:\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPcheckBendersSubproblemOptimality(
        scip: *mut SCIP,
        benders: *mut SCIP_BENDERS,
        sol: *mut SCIP_SOL,
        probnumber: ::std::os::raw::c_int,
        optimal: *mut ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " returns the value of the auxiliary variable for a given subproblem"]
    pub fn SCIPgetBendersAuxiliaryVarVal(
        scip: *mut SCIP,
        benders: *mut SCIP_BENDERS,
        sol: *mut SCIP_SOL,
        probnumber: ::std::os::raw::c_int,
    ) -> f64;
}
extern "C" {
    #[doc = " solves an independent subproblem to identify its lower bound and updates the lower bound of the corresponding\n  auxiliary variable\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    pub fn SCIPcomputeBendersSubproblemLowerbound(
        scip: *mut SCIP,
        benders: *mut SCIP_BENDERS,
        probnumber: ::std::os::raw::c_int,
        lowerbound: *mut f64,
        infeasible: *mut ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " merges a subproblem into the master problem.\n\n  This process just adds a copy of the subproblem variables and constraints to the master problem, but keeps the\n  subproblem stored in the Benders' decomposition data structure.  The reason for keeping the subproblem available is\n  for when it is queried for solutions after the problem is solved.\n\n  Once the subproblem is merged into the master problem, then the subproblem is flagged as disabled. This means that\n  it will not be solved in the subsequent subproblem solving loops.\n\n  The associated auxiliary variables are kept in the master problem. The objective function of the merged subproblem\n  is added as an underestimator constraint.\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    pub fn SCIPmergeBendersSubproblemIntoMaster(
        scip: *mut SCIP,
        benders: *mut SCIP_BENDERS,
        varmap: *mut SCIP_HASHMAP,
        consmap: *mut SCIP_HASHMAP,
        probnumber: ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " applies a Benders' decomposition to the selected decomposition from the decomposition store\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    pub fn SCIPapplyBendersDecomposition(
        scip: *mut SCIP,
        decompindex: ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " creates a Benders' cut algorithms and includes it in the associated Benders' decomposition\n\n  This should be called from the SCIPincludeBendersXyz for the associated Benders' decomposition. It is only possible\n  to include a Benders' cut algorithm if a Benders' decomposition has already been included\n  This should be done during the problem creation stage.\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_INIT\n       - \\ref SCIP_STAGE_PROBLEM\n\n  @note method has all Benders' decomposition callbacks as arguments and is thus changed every time a new callback is\n        added in future releases; consider using SCIPincludeBendersBasic() and setter functions\n        if you seek for a method which is less likely to change in future releases"]
    pub fn SCIPincludeBenderscut(
        scip: *mut SCIP,
        benders: *mut SCIP_BENDERS,
        name: *const ::std::os::raw::c_char,
        desc: *const ::std::os::raw::c_char,
        priority: ::std::os::raw::c_int,
        islpcut: ::std::os::raw::c_uint,
        benderscutcopy: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                benders: *mut SCIP_BENDERS,
                benderscut: *mut SCIP_BENDERSCUT,
            ) -> SCIP_RETCODE,
        >,
        benderscutfree: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, benderscut: *mut SCIP_BENDERSCUT) -> SCIP_RETCODE,
        >,
        benderscutinit: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, benderscut: *mut SCIP_BENDERSCUT) -> SCIP_RETCODE,
        >,
        benderscutexit: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, benderscut: *mut SCIP_BENDERSCUT) -> SCIP_RETCODE,
        >,
        benderscutinitsol: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, benderscut: *mut SCIP_BENDERSCUT) -> SCIP_RETCODE,
        >,
        benderscutexitsol: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, benderscut: *mut SCIP_BENDERSCUT) -> SCIP_RETCODE,
        >,
        benderscutexec: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                benders: *mut SCIP_BENDERS,
                benderscut: *mut SCIP_BENDERSCUT,
                sol: *mut SCIP_SOL,
                probnumber: ::std::os::raw::c_int,
                type_: SCIP_BENDERSENFOTYPE,
                result: *mut SCIP_RESULT,
            ) -> SCIP_RETCODE,
        >,
        benderscutdata: *mut SCIP_BENDERSCUTDATA,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " creates a Benders' cut and includes it an associated Benders' decomposition with all non-fundamental callbacks set to NULL\n\n  If needed, the non-fundamental callbacks can be added afterwards via setter functions SCIPsetBenderscutCopy(),\n  SCIPsetBenderscutFree(), SCIPsetBenderscutInit(), SCIPsetBenderscutExit(), SCIPsetBenderscutInitsol(),\n  SCIPsetBenderscutExitsol().\n\n  This should be done during the problem creation stage.\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_INIT\n       - \\ref SCIP_STAGE_PROBLEM\n\n  @note if you want to set all callbacks with a single method call, consider using SCIPincludeBenders() instead"]
    pub fn SCIPincludeBenderscutBasic(
        scip: *mut SCIP,
        benders: *mut SCIP_BENDERS,
        benderscutptr: *mut *mut SCIP_BENDERSCUT,
        name: *const ::std::os::raw::c_char,
        desc: *const ::std::os::raw::c_char,
        priority: ::std::os::raw::c_int,
        islpcut: ::std::os::raw::c_uint,
        benderscutexec: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                benders: *mut SCIP_BENDERS,
                benderscut: *mut SCIP_BENDERSCUT,
                sol: *mut SCIP_SOL,
                probnumber: ::std::os::raw::c_int,
                type_: SCIP_BENDERSENFOTYPE,
                result: *mut SCIP_RESULT,
            ) -> SCIP_RETCODE,
        >,
        benderscutdata: *mut SCIP_BENDERSCUTDATA,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " sets copy method of Benders' decomposition cut\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_INIT\n       - \\ref SCIP_STAGE_PROBLEM"]
    pub fn SCIPsetBenderscutCopy(
        scip: *mut SCIP,
        benderscut: *mut SCIP_BENDERSCUT,
        benderscutcopy: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                benders: *mut SCIP_BENDERS,
                benderscut: *mut SCIP_BENDERSCUT,
            ) -> SCIP_RETCODE,
        >,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " sets destructor method of benderscut\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_INIT\n       - \\ref SCIP_STAGE_PROBLEM"]
    pub fn SCIPsetBenderscutFree(
        scip: *mut SCIP,
        benderscut: *mut SCIP_BENDERSCUT,
        benderscutfree: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, benderscut: *mut SCIP_BENDERSCUT) -> SCIP_RETCODE,
        >,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " sets initialization method of benderscut\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_INIT\n       - \\ref SCIP_STAGE_PROBLEM"]
    pub fn SCIPsetBenderscutInit(
        scip: *mut SCIP,
        benderscut: *mut SCIP_BENDERSCUT,
        benderscutinit: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, benderscut: *mut SCIP_BENDERSCUT) -> SCIP_RETCODE,
        >,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " sets deinitialization method of benderscut\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_INIT\n       - \\ref SCIP_STAGE_PROBLEM"]
    pub fn SCIPsetBenderscutExit(
        scip: *mut SCIP,
        benderscut: *mut SCIP_BENDERSCUT,
        benderscutexit: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, benderscut: *mut SCIP_BENDERSCUT) -> SCIP_RETCODE,
        >,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " sets solving process initialization method of benderscut\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_INIT\n       - \\ref SCIP_STAGE_PROBLEM"]
    pub fn SCIPsetBenderscutInitsol(
        scip: *mut SCIP,
        benderscut: *mut SCIP_BENDERSCUT,
        benderscutinitsol: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, benderscut: *mut SCIP_BENDERSCUT) -> SCIP_RETCODE,
        >,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " sets solving process deinitialization method of benderscut\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_INIT\n       - \\ref SCIP_STAGE_PROBLEM"]
    pub fn SCIPsetBenderscutExitsol(
        scip: *mut SCIP,
        benderscut: *mut SCIP_BENDERSCUT,
        benderscutexitsol: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, benderscut: *mut SCIP_BENDERSCUT) -> SCIP_RETCODE,
        >,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " sets the priority of a Benders' decomposition cut algorithm\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_INIT\n       - \\ref SCIP_STAGE_PROBLEM"]
    pub fn SCIPsetBenderscutPriority(
        scip: *mut SCIP,
        benderscut: *mut SCIP_BENDERSCUT,
        priority: ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " adds the generated cuts to the Benders' cut storage\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPstoreBendersCut(
        scip: *mut SCIP,
        benders: *mut SCIP_BENDERS,
        vars: *mut *mut SCIP_VAR,
        vals: *mut f64,
        lhs: f64,
        rhs: f64,
        nvars: ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " applies the Benders' decomposition cuts in storage to the input SCIP instance\n\n  When calling the function, the user must be sure that the variables are associated with the input SCIP instance.\n  The main use of this method is to transfer Benders' cuts between solvers in ParaSCIP.\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPapplyBendersStoredCuts(scip: *mut SCIP, benders: *mut SCIP_BENDERS) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " creates a branching rule and includes it in SCIP\n\n  @note method has all branching rule callbacks as arguments and is thus changed every time a new\n        callback is added in future releases; consider using SCIPincludeBranchruleBasic() and setter functions\n        if you seek for a method which is less likely to change in future releases"]
    pub fn SCIPincludeBranchrule(
        scip: *mut SCIP,
        name: *const ::std::os::raw::c_char,
        desc: *const ::std::os::raw::c_char,
        priority: ::std::os::raw::c_int,
        maxdepth: ::std::os::raw::c_int,
        maxbounddist: f64,
        branchcopy: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, branchrule: *mut SCIP_BRANCHRULE) -> SCIP_RETCODE,
        >,
        branchfree: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, branchrule: *mut SCIP_BRANCHRULE) -> SCIP_RETCODE,
        >,
        branchinit: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, branchrule: *mut SCIP_BRANCHRULE) -> SCIP_RETCODE,
        >,
        branchexit: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, branchrule: *mut SCIP_BRANCHRULE) -> SCIP_RETCODE,
        >,
        branchinitsol: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, branchrule: *mut SCIP_BRANCHRULE) -> SCIP_RETCODE,
        >,
        branchexitsol: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, branchrule: *mut SCIP_BRANCHRULE) -> SCIP_RETCODE,
        >,
        branchexeclp: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                branchrule: *mut SCIP_BRANCHRULE,
                allowaddcons: ::std::os::raw::c_uint,
                result: *mut SCIP_RESULT,
            ) -> SCIP_RETCODE,
        >,
        branchexecext: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                branchrule: *mut SCIP_BRANCHRULE,
                allowaddcons: ::std::os::raw::c_uint,
                result: *mut SCIP_RESULT,
            ) -> SCIP_RETCODE,
        >,
        branchexecps: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                branchrule: *mut SCIP_BRANCHRULE,
                allowaddcons: ::std::os::raw::c_uint,
                result: *mut SCIP_RESULT,
            ) -> SCIP_RETCODE,
        >,
        branchruledata: *mut SCIP_BRANCHRULEDATA,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " creates a branching rule and includes it in SCIP. All non-fundamental (or optional) callbacks will be set to NULL.\n  Optional callbacks can be set via specific setter functions, see SCIPsetBranchruleInit(), SCIPsetBranchruleExit(),\n  SCIPsetBranchruleCopy(), SCIPsetBranchruleFree(), SCIPsetBranchruleInitsol(), SCIPsetBranchruleExitsol(),\n  SCIPsetBranchruleExecLp(), SCIPsetBranchruleExecExt(), and SCIPsetBranchruleExecPs().\n\n  @note if you want to set all callbacks with a single method call, consider using SCIPincludeBranchrule() instead"]
    pub fn SCIPincludeBranchruleBasic(
        scip: *mut SCIP,
        branchruleptr: *mut *mut SCIP_BRANCHRULE,
        name: *const ::std::os::raw::c_char,
        desc: *const ::std::os::raw::c_char,
        priority: ::std::os::raw::c_int,
        maxdepth: ::std::os::raw::c_int,
        maxbounddist: f64,
        branchruledata: *mut SCIP_BRANCHRULEDATA,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " sets copy method of branching rule"]
    pub fn SCIPsetBranchruleCopy(
        scip: *mut SCIP,
        branchrule: *mut SCIP_BRANCHRULE,
        branchcopy: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, branchrule: *mut SCIP_BRANCHRULE) -> SCIP_RETCODE,
        >,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " sets destructor method of branching rule"]
    pub fn SCIPsetBranchruleFree(
        scip: *mut SCIP,
        branchrule: *mut SCIP_BRANCHRULE,
        branchfree: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, branchrule: *mut SCIP_BRANCHRULE) -> SCIP_RETCODE,
        >,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " sets initialization method of branching rule"]
    pub fn SCIPsetBranchruleInit(
        scip: *mut SCIP,
        branchrule: *mut SCIP_BRANCHRULE,
        branchinit: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, branchrule: *mut SCIP_BRANCHRULE) -> SCIP_RETCODE,
        >,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " sets deinitialization method of branching rule"]
    pub fn SCIPsetBranchruleExit(
        scip: *mut SCIP,
        branchrule: *mut SCIP_BRANCHRULE,
        branchexit: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, branchrule: *mut SCIP_BRANCHRULE) -> SCIP_RETCODE,
        >,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " sets solving process initialization method of branching rule"]
    pub fn SCIPsetBranchruleInitsol(
        scip: *mut SCIP,
        branchrule: *mut SCIP_BRANCHRULE,
        branchinitsol: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, branchrule: *mut SCIP_BRANCHRULE) -> SCIP_RETCODE,
        >,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " sets solving process deinitialization method of branching rule"]
    pub fn SCIPsetBranchruleExitsol(
        scip: *mut SCIP,
        branchrule: *mut SCIP_BRANCHRULE,
        branchexitsol: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, branchrule: *mut SCIP_BRANCHRULE) -> SCIP_RETCODE,
        >,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " sets branching execution method for fractional LP solutions"]
    pub fn SCIPsetBranchruleExecLp(
        scip: *mut SCIP,
        branchrule: *mut SCIP_BRANCHRULE,
        branchexeclp: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                branchrule: *mut SCIP_BRANCHRULE,
                allowaddcons: ::std::os::raw::c_uint,
                result: *mut SCIP_RESULT,
            ) -> SCIP_RETCODE,
        >,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " sets branching execution method for external candidates"]
    pub fn SCIPsetBranchruleExecExt(
        scip: *mut SCIP,
        branchrule: *mut SCIP_BRANCHRULE,
        branchexecext: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                branchrule: *mut SCIP_BRANCHRULE,
                allowaddcons: ::std::os::raw::c_uint,
                result: *mut SCIP_RESULT,
            ) -> SCIP_RETCODE,
        >,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " sets branching execution method for not completely fixed pseudo solutions"]
    pub fn SCIPsetBranchruleExecPs(
        scip: *mut SCIP,
        branchrule: *mut SCIP_BRANCHRULE,
        branchexecps: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                branchrule: *mut SCIP_BRANCHRULE,
                allowaddcons: ::std::os::raw::c_uint,
                result: *mut SCIP_RESULT,
            ) -> SCIP_RETCODE,
        >,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " returns the branching rule of the given name, or NULL if not existing"]
    pub fn SCIPfindBranchrule(
        scip: *mut SCIP,
        name: *const ::std::os::raw::c_char,
    ) -> *mut SCIP_BRANCHRULE;
}
extern "C" {
    #[doc = " returns the array of currently available branching rules"]
    pub fn SCIPgetBranchrules(scip: *mut SCIP) -> *mut *mut SCIP_BRANCHRULE;
}
extern "C" {
    #[doc = " returns the number of currently available branching rules"]
    pub fn SCIPgetNBranchrules(scip: *mut SCIP) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " sets the priority of a branching rule"]
    pub fn SCIPsetBranchrulePriority(
        scip: *mut SCIP,
        branchrule: *mut SCIP_BRANCHRULE,
        priority: ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " sets maximal depth level, up to which this branching rule should be used (-1 for no limit)"]
    pub fn SCIPsetBranchruleMaxdepth(
        scip: *mut SCIP,
        branchrule: *mut SCIP_BRANCHRULE,
        maxdepth: ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " sets maximal relative distance from current node's dual bound to primal bound for applying branching rule"]
    pub fn SCIPsetBranchruleMaxbounddist(
        scip: *mut SCIP,
        branchrule: *mut SCIP_BRANCHRULE,
        maxbounddist: f64,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " gets branching candidates for LP solution branching (fractional variables) along with solution values,\n  fractionalities, and number of branching candidates; The number of branching candidates does NOT\n  account for fractional implicit integer variables which should not be used for branching decisions.\n\n  Fractional implicit integer variables are stored at the positions *nlpcands to *nlpcands + *nfracimplvars - 1\n\n  branching rules should always select the branching candidate among the first npriolpcands of the candidate\n  list\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_SOLVING\n\n  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPgetLPBranchCands(
        scip: *mut SCIP,
        lpcands: *mut *mut *mut SCIP_VAR,
        lpcandssol: *mut *mut f64,
        lpcandsfrac: *mut *mut f64,
        nlpcands: *mut ::std::os::raw::c_int,
        npriolpcands: *mut ::std::os::raw::c_int,
        nfracimplvars: *mut ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " gets number of branching candidates for LP solution branching (number of fractional variables)\n\n  @return the number of branching candidates for LP solution branching (number of fractional variables).\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_SOLVING\n\n  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPgetNLPBranchCands(scip: *mut SCIP) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " gets number of branching candidates with maximal priority for LP solution branching\n\n  @return the number of branching candidates with maximal priority for LP solution branching.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_SOLVING\n\n  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPgetNPrioLPBranchCands(scip: *mut SCIP) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " gets external branching candidates along with solution values, scores, and number of branching candidates;\n  these branching candidates can be used by relaxations or nonlinear constraint handlers;\n  branching rules should always select the branching candidate among the first nprioexterncands of the candidate\n  list\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_SOLVING\n\n  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages.\n\n  @note Candidate variables with maximal priority are ordered: binaries first, then integers, implicit integers and\n        continuous last."]
    pub fn SCIPgetExternBranchCands(
        scip: *mut SCIP,
        externcands: *mut *mut *mut SCIP_VAR,
        externcandssol: *mut *mut f64,
        externcandsscore: *mut *mut f64,
        nexterncands: *mut ::std::os::raw::c_int,
        nprioexterncands: *mut ::std::os::raw::c_int,
        nprioexternbins: *mut ::std::os::raw::c_int,
        nprioexternints: *mut ::std::os::raw::c_int,
        nprioexternimpls: *mut ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " gets number of external branching candidates\n\n  @return the number of external branching candidates.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_SOLVING\n\n  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPgetNExternBranchCands(scip: *mut SCIP) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " gets number of external branching candidates with maximal branch priority\n\n  @return the number of external branching candidates with maximal branch priority.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_SOLVING\n\n  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPgetNPrioExternBranchCands(scip: *mut SCIP) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " gets number of binary external branching candidates with maximal branch priority\n\n  @return the number of binary external branching candidates with maximal branch priority.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_SOLVING\n\n  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPgetNPrioExternBranchBins(scip: *mut SCIP) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " gets number of integer external branching candidates with maximal branch priority\n\n  @return the number of integer external branching candidates with maximal branch priority.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_SOLVING\n\n  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPgetNPrioExternBranchInts(scip: *mut SCIP) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " gets number of implicit integer external branching candidates with maximal branch priority\n\n  @return the number of implicit integer external branching candidates with maximal branch priority.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_SOLVING\n\n  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPgetNPrioExternBranchImpls(scip: *mut SCIP) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " gets number of continuous external branching candidates with maximal branch priority\n\n  @return the number of continuous external branching candidates with maximal branch priority.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_SOLVING\n\n  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPgetNPrioExternBranchConts(scip: *mut SCIP) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " insert variable, its score and its solution value into the external branching candidate storage\n the relative difference of the current lower and upper bounds of a continuous variable must be at least epsilon\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_SOLVING\n\n  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPaddExternBranchCand(
        scip: *mut SCIP,
        var: *mut SCIP_VAR,
        score: f64,
        solval: f64,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " removes all external candidates from the storage for external branching\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_SOLVING\n\n  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPclearExternBranchCands(scip: *mut SCIP);
}
extern "C" {
    #[doc = " checks whether the given variable is contained in the candidate storage for external branching\n\n  @return whether the given variable is contained in the candidate storage for external branching.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_SOLVING\n\n  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPcontainsExternBranchCand(
        scip: *mut SCIP,
        var: *mut SCIP_VAR,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " gets branching candidates for pseudo solution branching (non-fixed variables) along with the number of candidates\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_SOLVING\n\n  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPgetPseudoBranchCands(
        scip: *mut SCIP,
        pseudocands: *mut *mut *mut SCIP_VAR,
        npseudocands: *mut ::std::os::raw::c_int,
        npriopseudocands: *mut ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " gets number of branching candidates for pseudo solution branching (non-fixed variables)\n\n  @return the number branching candidates for pseudo solution branching (non-fixed variables).\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_SOLVING\n\n  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPgetNPseudoBranchCands(scip: *mut SCIP) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " gets number of branching candidates with maximal branch priority for pseudo solution branching\n\n  @return the number of branching candidates with maximal branch priority for pseudo solution branching.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_SOLVING\n\n  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPgetNPrioPseudoBranchCands(scip: *mut SCIP) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " gets number of binary branching candidates with maximal branch priority for pseudo solution branching\n\n  @return the number of binary branching candidates with maximal branch priority for pseudo solution branching.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_SOLVING\n\n  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPgetNPrioPseudoBranchBins(scip: *mut SCIP) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " gets number of integer branching candidates with maximal branch priority for pseudo solution branching\n\n  @return the number of integer branching candidates with maximal branch priority for pseudo solution branching.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_SOLVING\n\n  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPgetNPrioPseudoBranchInts(scip: *mut SCIP) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " gets number of implicit integer branching candidates with maximal branch priority for pseudo solution branching\n\n  @return the number of implicit integer branching candidates with maximal branch priority for pseudo solution branching.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_SOLVING\n\n  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPgetNPrioPseudoBranchImpls(scip: *mut SCIP) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " calculates the branching score out of the gain predictions for a binary branching\n\n  @return the branching score out of the gain predictions for a binary branching.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_SOLVING\n\n  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPgetBranchScore(
        scip: *mut SCIP,
        var: *mut SCIP_VAR,
        downgain: f64,
        upgain: f64,
    ) -> f64;
}
extern "C" {
    #[doc = " calculates the branching score out of the gain predictions for a branching with arbitrary many children\n\n  @return the branching score out of the gain predictions for a branching with arbitrary many children.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_SOLVING\n\n  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPgetBranchScoreMultiple(
        scip: *mut SCIP,
        var: *mut SCIP_VAR,
        nchildren: ::std::os::raw::c_int,
        gains: *mut f64,
    ) -> f64;
}
extern "C" {
    #[doc = " computes a branching point for a continuous or discrete variable\n\n  @see SCIPbranchGetBranchingPoint\n\n  @return the branching point for a continuous or discrete variable.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_SOLVING\n\n  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPgetBranchingPoint(scip: *mut SCIP, var: *mut SCIP_VAR, suggestion: f64) -> f64;
}
extern "C" {
    #[doc = " calculates the node selection priority for moving the given variable's LP value to the given target value;\n  this node selection priority can be given to the SCIPcreateChild() call\n\n  @return the node selection priority for moving the given variable's LP value to the given target value.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_SOLVING\n\n  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPcalcNodeselPriority(
        scip: *mut SCIP,
        var: *mut SCIP_VAR,
        branchdir: SCIP_BRANCHDIR,
        targetvalue: f64,
    ) -> f64;
}
extern "C" {
    #[doc = " calculates an estimate for the objective of the best feasible solution contained in the subtree after applying the given\n  branching; this estimate can be given to the SCIPcreateChild() call\n\n  @return the estimate for the objective of the best feasible solution contained in the subtree after applying the given\n  branching.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_SOLVING\n\n  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPcalcChildEstimate(scip: *mut SCIP, var: *mut SCIP_VAR, targetvalue: f64) -> f64;
}
extern "C" {
    #[doc = " calculates the increase of the estimate for the objective of the best feasible solution contained in the subtree\n  after applying the given branching\n\n  @return the increase of the estimate for the objective of the best feasible solution contained in the subtree after\n          applying the given branching.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_SOLVING\n\n  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPcalcChildEstimateIncrease(
        scip: *mut SCIP,
        var: *mut SCIP_VAR,
        varsol: f64,
        targetvalue: f64,
    ) -> f64;
}
extern "C" {
    #[doc = " creates a child node of the focus node\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_SOLVING\n\n  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPcreateChild(
        scip: *mut SCIP,
        node: *mut *mut SCIP_NODE,
        nodeselprio: f64,
        estimate: f64,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " branches on a non-continuous variable v using the current LP or pseudo solution;\n  if solution value x' is fractional, two child nodes will be created\n  (x <= floor(x'), x >= ceil(x')),\n  if solution value is integral, the x' is equal to lower or upper bound of the branching\n  variable and the bounds of v are finite, then two child nodes will be created\n  (x <= x'', x >= x''+1 with x'' = floor((lb + ub)/2)),\n  otherwise (up to) three child nodes will be created\n  (x <= x'-1, x == x', x >= x'+1)\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_SOLVING\n\n  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPbranchVar(
        scip: *mut SCIP,
        var: *mut SCIP_VAR,
        downchild: *mut *mut SCIP_NODE,
        eqchild: *mut *mut SCIP_NODE,
        upchild: *mut *mut SCIP_NODE,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " branches a variable x using a given domain hole; two child nodes (x <= left, x >= right) are created\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_SOLVING\n\n  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPbranchVarHole(
        scip: *mut SCIP,
        var: *mut SCIP_VAR,
        left: f64,
        right: f64,
        downchild: *mut *mut SCIP_NODE,
        upchild: *mut *mut SCIP_NODE,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " branches on a variable x using a given value x';\n  for continuous variables with relative domain width larger epsilon, x' must not be one of the bounds;\n  two child nodes (x <= x', x >= x') are created;\n  for integer variables, if solution value x' is fractional, two child nodes are created\n  (x <= floor(x'), x >= ceil(x')),\n  if x' is integral, three child nodes are created\n  (x <= x'-1, x == x', x >= x'+1)\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_SOLVING\n\n  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPbranchVarVal(
        scip: *mut SCIP,
        var: *mut SCIP_VAR,
        val: f64,
        downchild: *mut *mut SCIP_NODE,
        eqchild: *mut *mut SCIP_NODE,
        upchild: *mut *mut SCIP_NODE,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " n-ary branching on a variable x using a given value\n\n  Branches on variable x such that up to n/2 children are created on each side of the usual branching value.\n  The branching value is selected as in SCIPbranchVarVal().\n  The parameters minwidth and widthfactor determine the domain width of the branching variable in the child nodes.\n  If n is odd, one child with domain width 'width' and having the branching value in the middle is created.\n  Otherwise, two children with domain width 'width' and being left and right of the branching value are created.\n  Next further nodes to the left and right are created, where width is multiplied by widthfactor with increasing distance\n  from the first nodes.\n  The initial width is calculated such that n/2 nodes are created to the left and to the right of the branching value.\n  If this value is below minwidth, the initial width is set to minwidth, which may result in creating less than n nodes.\n\n  Giving a large value for widthfactor results in creating children with small domain when close to the branching value\n  and large domain when closer to the current variable bounds. That is, setting widthfactor to a very large value and n to 3\n  results in a ternary branching where the branching variable is mostly fixed in the middle child.\n  Setting widthfactor to 1.0 results in children where the branching variable always has the same domain width\n  (except for one child if the branching value is not in the middle).\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_SOLVING\n\n  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPbranchVarValNary(
        scip: *mut SCIP,
        var: *mut SCIP_VAR,
        val: f64,
        n: ::std::os::raw::c_int,
        minwidth: f64,
        widthfactor: f64,
        nchildren: *mut ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " calls branching rules to branch on an LP solution; if no fractional variables exist, the result is SCIP_DIDNOTRUN;\n  if the branch priority of an unfixed variable is larger than the maximal branch priority of the fractional\n  variables, pseudo solution branching is applied on the unfixed variables with maximal branch priority\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_SOLVING\n\n  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPbranchLP(scip: *mut SCIP, result: *mut SCIP_RESULT) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " calls branching rules to branch on a external candidates; if no such candidates exist, the result is SCIP_DIDNOTRUN\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_SOLVING\n\n  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPbranchExtern(scip: *mut SCIP, result: *mut SCIP_RESULT) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " calls branching rules to branch on a pseudo solution; if no unfixed variables exist, the result is SCIP_DIDNOTRUN\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_SOLVING\n\n  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPbranchPseudo(scip: *mut SCIP, result: *mut SCIP_RESULT) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = "@addtogroup PublicCompressionMethods\n\n @{\n/\n/** creates a tree compression and includes it in SCIP.\n\n  @note method has all compression callbacks as arguments and is thus changed every time a new\n        callback is added in future releases; consider using SCIPincludeComprBasic() and setter functions\n        if you seek for a method which is less likely to change in future releases"]
    pub fn SCIPincludeCompr(
        scip: *mut SCIP,
        name: *const ::std::os::raw::c_char,
        desc: *const ::std::os::raw::c_char,
        priority: ::std::os::raw::c_int,
        minnnodes: ::std::os::raw::c_int,
        comprcopy: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, compr: *mut SCIP_COMPR) -> SCIP_RETCODE,
        >,
        comprfree: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, compr: *mut SCIP_COMPR) -> SCIP_RETCODE,
        >,
        comprinit: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, compr: *mut SCIP_COMPR) -> SCIP_RETCODE,
        >,
        comprexit: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, compr: *mut SCIP_COMPR) -> SCIP_RETCODE,
        >,
        comprinitsol: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, compr: *mut SCIP_COMPR) -> SCIP_RETCODE,
        >,
        comprexitsol: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, compr: *mut SCIP_COMPR) -> SCIP_RETCODE,
        >,
        comprexec: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                compr: *mut SCIP_COMPR,
                result: *mut SCIP_RESULT,
            ) -> SCIP_RETCODE,
        >,
        comprdata: *mut SCIP_COMPRDATA,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " creates a tree compression and includes it in SCIP with its most fundamental callbacks.\n  All non-fundamental (or optional) callbacks\n  as, e. g., init and exit callbacks, will be set to NULL.\n  Optional callbacks can be set via specific setter functions, see SCIPsetComprCopy(), SCIPsetComprFree(),\n  SCIPsetComprInit(), SCIPsetComprExit(), SCIPsetComprInitsol(), and SCIPsetComprExitsol()\n\n  @note if you want to set all callbacks with a single method call, consider using SCIPincludeCompr() instead"]
    pub fn SCIPincludeComprBasic(
        scip: *mut SCIP,
        compr: *mut *mut SCIP_COMPR,
        name: *const ::std::os::raw::c_char,
        desc: *const ::std::os::raw::c_char,
        priority: ::std::os::raw::c_int,
        minnnodes: ::std::os::raw::c_int,
        comprexec: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                compr: *mut SCIP_COMPR,
                result: *mut SCIP_RESULT,
            ) -> SCIP_RETCODE,
        >,
        comprdata: *mut SCIP_COMPRDATA,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " sets copy method of tree compression"]
    pub fn SCIPsetComprCopy(
        scip: *mut SCIP,
        compr: *mut SCIP_COMPR,
        comprcopy: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, compr: *mut SCIP_COMPR) -> SCIP_RETCODE,
        >,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " sets destructor method of tree compression"]
    pub fn SCIPsetComprFree(
        scip: *mut SCIP,
        compr: *mut SCIP_COMPR,
        comprfree: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, compr: *mut SCIP_COMPR) -> SCIP_RETCODE,
        >,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " sets initialization method of tree compression"]
    pub fn SCIPsetComprInit(
        scip: *mut SCIP,
        compr: *mut SCIP_COMPR,
        comprinit: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, compr: *mut SCIP_COMPR) -> SCIP_RETCODE,
        >,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " sets deinitialization method of tree compression"]
    pub fn SCIPsetComprExit(
        scip: *mut SCIP,
        compr: *mut SCIP_COMPR,
        comprexit: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, compr: *mut SCIP_COMPR) -> SCIP_RETCODE,
        >,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " sets solving process initialization method of tree compression"]
    pub fn SCIPsetComprInitsol(
        scip: *mut SCIP,
        compr: *mut SCIP_COMPR,
        comprinitsol: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, compr: *mut SCIP_COMPR) -> SCIP_RETCODE,
        >,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " sets solving process deinitialization method of tree compression"]
    pub fn SCIPsetComprExitsol(
        scip: *mut SCIP,
        compr: *mut SCIP_COMPR,
        comprexitsol: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, compr: *mut SCIP_COMPR) -> SCIP_RETCODE,
        >,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " returns the tree compression of the given name, or NULL if not existing"]
    pub fn SCIPfindCompr(scip: *mut SCIP, name: *const ::std::os::raw::c_char) -> *mut SCIP_COMPR;
}
extern "C" {
    #[doc = " returns the array of currently available tree compression"]
    pub fn SCIPgetComprs(scip: *mut SCIP) -> *mut *mut SCIP_COMPR;
}
extern "C" {
    #[doc = " returns the number of currently available tree compression"]
    pub fn SCIPgetNCompr(scip: *mut SCIP) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " set the priority of a tree compression method"]
    pub fn SCIPsetComprPriority(
        scip: *mut SCIP,
        compr: *mut SCIP_COMPR,
        priority: ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " creates a concurrent solver type and includes it in SCIP.\n\n  @return \\ref SCIP_OKAY is returned if everything worked. otherwise a suitable error code is passed. see \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_INIT\n       - \\ref SCIP_STAGE_PROBLEM"]
    pub fn SCIPincludeConcsolverType(
        scip: *mut SCIP,
        name: *const ::std::os::raw::c_char,
        prefpriodefault: f64,
        concsolvercreateinst: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                concsolvertype: *mut SCIP_CONCSOLVERTYPE,
                concsolver: *mut SCIP_CONCSOLVER,
            ) -> SCIP_RETCODE,
        >,
        concsolverdestroyinst: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, concsolver: *mut SCIP_CONCSOLVER) -> SCIP_RETCODE,
        >,
        concsolverinitseeds: ::std::option::Option<
            unsafe extern "C" fn(
                concsolver: *mut SCIP_CONCSOLVER,
                seed: ::std::os::raw::c_uint,
            ) -> SCIP_RETCODE,
        >,
        concsolverexec: ::std::option::Option<
            unsafe extern "C" fn(
                concsolver: *mut SCIP_CONCSOLVER,
                solvingtime: *mut f64,
                nlpiterations: *mut ::std::os::raw::c_longlong,
                nnodes: *mut ::std::os::raw::c_longlong,
            ) -> SCIP_RETCODE,
        >,
        concsolvercopysolvdata: ::std::option::Option<
            unsafe extern "C" fn(concsolver: *mut SCIP_CONCSOLVER, scip: *mut SCIP) -> SCIP_RETCODE,
        >,
        concsolverstop: ::std::option::Option<
            unsafe extern "C" fn(concsolver: *mut SCIP_CONCSOLVER) -> SCIP_RETCODE,
        >,
        concsolversyncwrite: ::std::option::Option<
            unsafe extern "C" fn(
                concsolver: *mut SCIP_CONCSOLVER,
                syncstore: *mut SCIP_SYNCSTORE,
                syncdata: *mut SCIP_SYNCDATA,
                maxcandsols: ::std::os::raw::c_int,
                maxsharedsols: ::std::os::raw::c_int,
                nsolsshared: *mut ::std::os::raw::c_int,
            ) -> SCIP_RETCODE,
        >,
        concsolversyncread: ::std::option::Option<
            unsafe extern "C" fn(
                concsolver: *mut SCIP_CONCSOLVER,
                syncstore: *mut SCIP_SYNCSTORE,
                syncdata: *mut SCIP_SYNCDATA,
                nsolsrecvd: *mut ::std::os::raw::c_int,
                ntighterbnds: *mut ::std::os::raw::c_int,
                ntighterintbnds: *mut ::std::os::raw::c_int,
            ) -> SCIP_RETCODE,
        >,
        concsolvertypefreedata: ::std::option::Option<
            unsafe extern "C" fn(data: *mut *mut SCIP_CONCSOLVERTYPEDATA),
        >,
        data: *mut SCIP_CONCSOLVERTYPEDATA,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " returns the concurrent solver type with the given name, or NULL if not existing"]
    pub fn SCIPfindConcsolverType(
        scip: *mut SCIP,
        name: *const ::std::os::raw::c_char,
    ) -> *mut SCIP_CONCSOLVERTYPE;
}
extern "C" {
    #[doc = " returns the array of included concurrent solver types"]
    pub fn SCIPgetConcsolverTypes(scip: *mut SCIP) -> *mut *mut SCIP_CONCSOLVERTYPE;
}
extern "C" {
    #[doc = " returns the number of included concurrent solver types"]
    pub fn SCIPgetNConcsolverTypes(scip: *mut SCIP) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Constructs the parallel interface to execute processes concurrently.\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMING\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED\n       - \\ref SCIP_STAGE_EXITSOLVE\n       - \\ref SCIP_STAGE_FREETRANS\n\n  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPconstructSyncstore(scip: *mut SCIP) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " releases the current synchronization store\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMING\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED\n       - \\ref SCIP_STAGE_EXITSOLVE\n       - \\ref SCIP_STAGE_FREETRANS\n       - \\ref SCIP_STAGE_FREE\n\n  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPfreeSyncstore(scip: *mut SCIP) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " Gets the synchronization store.\n\n  @return the \\ref SCIP_SYNCSTORE parallel interface pointer to submit jobs for concurrent processing.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_INIT\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMING\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED\n       - \\ref SCIP_STAGE_EXITSOLVE\n       - \\ref SCIP_STAGE_FREETRANS\n\n  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPgetSyncstore(scip: *mut SCIP) -> *mut SCIP_SYNCSTORE;
}
extern "C" {
    #[doc = " creates a conflict handler and includes it in SCIP\n\n  @note method has all conflict handler callbacks as arguments and is thus changed every time a new\n        callback is added\n        in future releases; consider using SCIPincludeConflicthdlrBasic() and setter functions\n        if you seek for a method which is less likely to change in future releases"]
    pub fn SCIPincludeConflicthdlr(
        scip: *mut SCIP,
        name: *const ::std::os::raw::c_char,
        desc: *const ::std::os::raw::c_char,
        priority: ::std::os::raw::c_int,
        conflictcopy: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                conflicthdlr: *mut SCIP_CONFLICTHDLR,
            ) -> SCIP_RETCODE,
        >,
        conflictfree: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                conflicthdlr: *mut SCIP_CONFLICTHDLR,
            ) -> SCIP_RETCODE,
        >,
        conflictinit: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                conflicthdlr: *mut SCIP_CONFLICTHDLR,
            ) -> SCIP_RETCODE,
        >,
        conflictexit: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                conflicthdlr: *mut SCIP_CONFLICTHDLR,
            ) -> SCIP_RETCODE,
        >,
        conflictinitsol: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                conflicthdlr: *mut SCIP_CONFLICTHDLR,
            ) -> SCIP_RETCODE,
        >,
        conflictexitsol: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                conflicthdlr: *mut SCIP_CONFLICTHDLR,
            ) -> SCIP_RETCODE,
        >,
        conflictexec: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                conflicthdlr: *mut SCIP_CONFLICTHDLR,
                node: *mut SCIP_NODE,
                validnode: *mut SCIP_NODE,
                bdchginfos: *mut *mut SCIP_BDCHGINFO,
                relaxedbds: *mut f64,
                nbdchginfos: ::std::os::raw::c_int,
                conftype: SCIP_CONFTYPE,
                cutoffinvolved: ::std::os::raw::c_uint,
                separate: ::std::os::raw::c_uint,
                local: ::std::os::raw::c_uint,
                dynamic: ::std::os::raw::c_uint,
                removable: ::std::os::raw::c_uint,
                resolved: ::std::os::raw::c_uint,
                result: *mut SCIP_RESULT,
            ) -> SCIP_RETCODE,
        >,
        conflicthdlrdata: *mut SCIP_CONFLICTHDLRDATA,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " creates a conflict handler and includes it in SCIP with its most fundamental callbacks. All non-fundamental\n  (or optional) callbacks as, e.g., init and exit callbacks, will be set to NULL.\n  Optional callbacks can be set via specific setter functions SCIPsetConflicthdlrCopy(), SCIPsetConflicthdlrFree(),\n  SCIPsetConflicthdlrInit(), SCIPsetConflicthdlrExit(), SCIPsetConflicthdlrInitsol(),\n  and SCIPsetConflicthdlrExitsol()\n\n  @note if you want to set all callbacks with a single method call, consider using SCIPincludeConflicthdlr() instead"]
    pub fn SCIPincludeConflicthdlrBasic(
        scip: *mut SCIP,
        conflicthdlrptr: *mut *mut SCIP_CONFLICTHDLR,
        name: *const ::std::os::raw::c_char,
        desc: *const ::std::os::raw::c_char,
        priority: ::std::os::raw::c_int,
        conflictexec: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                conflicthdlr: *mut SCIP_CONFLICTHDLR,
                node: *mut SCIP_NODE,
                validnode: *mut SCIP_NODE,
                bdchginfos: *mut *mut SCIP_BDCHGINFO,
                relaxedbds: *mut f64,
                nbdchginfos: ::std::os::raw::c_int,
                conftype: SCIP_CONFTYPE,
                cutoffinvolved: ::std::os::raw::c_uint,
                separate: ::std::os::raw::c_uint,
                local: ::std::os::raw::c_uint,
                dynamic: ::std::os::raw::c_uint,
                removable: ::std::os::raw::c_uint,
                resolved: ::std::os::raw::c_uint,
                result: *mut SCIP_RESULT,
            ) -> SCIP_RETCODE,
        >,
        conflicthdlrdata: *mut SCIP_CONFLICTHDLRDATA,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " set copy method of conflict handler"]
    pub fn SCIPsetConflicthdlrCopy(
        scip: *mut SCIP,
        conflicthdlr: *mut SCIP_CONFLICTHDLR,
        conflictcopy: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                conflicthdlr: *mut SCIP_CONFLICTHDLR,
            ) -> SCIP_RETCODE,
        >,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " set destructor of conflict handler"]
    pub fn SCIPsetConflicthdlrFree(
        scip: *mut SCIP,
        conflicthdlr: *mut SCIP_CONFLICTHDLR,
        conflictfree: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                conflicthdlr: *mut SCIP_CONFLICTHDLR,
            ) -> SCIP_RETCODE,
        >,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " set initialization method of conflict handler"]
    pub fn SCIPsetConflicthdlrInit(
        scip: *mut SCIP,
        conflicthdlr: *mut SCIP_CONFLICTHDLR,
        conflictinit: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                conflicthdlr: *mut SCIP_CONFLICTHDLR,
            ) -> SCIP_RETCODE,
        >,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " set deinitialization method of conflict handler"]
    pub fn SCIPsetConflicthdlrExit(
        scip: *mut SCIP,
        conflicthdlr: *mut SCIP_CONFLICTHDLR,
        conflictexit: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                conflicthdlr: *mut SCIP_CONFLICTHDLR,
            ) -> SCIP_RETCODE,
        >,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " set solving process initialization method of conflict handler"]
    pub fn SCIPsetConflicthdlrInitsol(
        scip: *mut SCIP,
        conflicthdlr: *mut SCIP_CONFLICTHDLR,
        conflictinitsol: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                conflicthdlr: *mut SCIP_CONFLICTHDLR,
            ) -> SCIP_RETCODE,
        >,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " set solving process deinitialization method of conflict handler"]
    pub fn SCIPsetConflicthdlrExitsol(
        scip: *mut SCIP,
        conflicthdlr: *mut SCIP_CONFLICTHDLR,
        conflictexitsol: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                conflicthdlr: *mut SCIP_CONFLICTHDLR,
            ) -> SCIP_RETCODE,
        >,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " returns the conflict handler of the given name, or NULL if not existing"]
    pub fn SCIPfindConflicthdlr(
        scip: *mut SCIP,
        name: *const ::std::os::raw::c_char,
    ) -> *mut SCIP_CONFLICTHDLR;
}
extern "C" {
    #[doc = " returns the array of currently available conflict handlers"]
    pub fn SCIPgetConflicthdlrs(scip: *mut SCIP) -> *mut *mut SCIP_CONFLICTHDLR;
}
extern "C" {
    #[doc = " returns the number of currently available conflict handlers"]
    pub fn SCIPgetNConflicthdlrs(scip: *mut SCIP) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " sets the priority of a conflict handler"]
    pub fn SCIPsetConflicthdlrPriority(
        scip: *mut SCIP,
        conflicthdlr: *mut SCIP_CONFLICTHDLR,
        priority: ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " return TRUE if conflict analysis is applicable; In case the function return FALSE there is no need to initialize the\n  conflict analysis since it will not be applied\n\n  @return return TRUE if conflict analysis is applicable; In case the function return FALSE there is no need to initialize the\n          conflict analysis since it will not be applied\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_SOLVING\n\n  @note SCIP stage does not get changed"]
    pub fn SCIPisConflictAnalysisApplicable(scip: *mut SCIP) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " initializes the conflict analysis by clearing the conflict candidate queue; this method must be called before you\n  enter the conflict variables by calling SCIPaddConflictLb(), SCIPaddConflictUb(), SCIPaddConflictBd(),\n  SCIPaddConflictRelaxedLb(), SCIPaddConflictRelaxedUb(), SCIPaddConflictRelaxedBd(), or SCIPaddConflictBinvar();\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_SOLVING\n\n  @note SCIP stage does not get changed"]
    pub fn SCIPinitConflictAnalysis(
        scip: *mut SCIP,
        conftype: SCIP_CONFTYPE,
        iscutoffinvolved: ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " adds lower bound of variable at the time of the given bound change index to the conflict analysis' candidate storage;\n  this method should be called in one of the following two cases:\n   1. Before calling the SCIPanalyzeConflict() method, SCIPaddConflictLb() should be called for each lower bound\n      that led to the conflict (e.g. the infeasibility of globally or locally valid constraint).\n   2. In the propagation conflict resolving method of a constraint handler, SCIPaddConflictLb() should be called\n      for each lower bound, whose current assignment led to the deduction of the given conflict bound.\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_SOLVING\n\n  @note SCIP stage does not get changed"]
    pub fn SCIPaddConflictLb(
        scip: *mut SCIP,
        var: *mut SCIP_VAR,
        bdchgidx: *mut SCIP_BDCHGIDX,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " adds lower bound of variable at the time of the given bound change index to the conflict analysis' candidate storage\n  with the additional information of a relaxed lower bound; this relaxed lower bound is the one which would be enough\n  to explain a certain bound change;\n  this method should be called in one of the following two cases:\n   1. Before calling the SCIPanalyzeConflict() method, SCIPaddConflictRelaxedLb() should be called for each (relaxed) lower bound\n      that led to the conflict (e.g. the infeasibility of globally or locally valid constraint).\n   2. In the propagation conflict resolving method of a constraint handler, SCIPaddConflictRelexedLb() should be called\n      for each (relaxed) lower bound, whose current assignment led to the deduction of the given conflict bound.\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_SOLVING\n\n  @note SCIP stage does not get changed"]
    pub fn SCIPaddConflictRelaxedLb(
        scip: *mut SCIP,
        var: *mut SCIP_VAR,
        bdchgidx: *mut SCIP_BDCHGIDX,
        relaxedlb: f64,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " adds upper bound of variable at the time of the given bound change index to the conflict analysis' candidate storage;\n  this method should be called in one of the following two cases:\n   1. Before calling the SCIPanalyzeConflict() method, SCIPaddConflictUb() should be called for each upper bound that\n      led to the conflict (e.g. the infeasibility of globally or locally valid constraint).\n   2. In the propagation conflict resolving method of a constraint handler, SCIPaddConflictUb() should be called for\n      each upper bound, whose current assignment led to the deduction of the given conflict bound.\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_SOLVING\n\n  @note SCIP stage does not get changed"]
    pub fn SCIPaddConflictUb(
        scip: *mut SCIP,
        var: *mut SCIP_VAR,
        bdchgidx: *mut SCIP_BDCHGIDX,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " adds upper bound of variable at the time of the given bound change index to the conflict analysis' candidate storage\n  with the additional information of a relaxed upper bound; this relaxed upper bound is the one which would be enough\n  to explain a certain bound change;\n  this method should be called in one of the following two cases:\n   1. Before calling the SCIPanalyzeConflict() method, SCIPaddConflictRelaxedUb() should be called for each (relaxed) upper\n      bound that led to the conflict (e.g. the infeasibility of globally or locally valid constraint).\n   2. In the propagation conflict resolving method of a constraint handler, SCIPaddConflictRelaxedUb() should be\n      called for each (relaxed) upper bound, whose current assignment led to the deduction of the given conflict\n      bound.\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_SOLVING\n\n  @note SCIP stage does not get changed"]
    pub fn SCIPaddConflictRelaxedUb(
        scip: *mut SCIP,
        var: *mut SCIP_VAR,
        bdchgidx: *mut SCIP_BDCHGIDX,
        relaxedub: f64,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " adds lower or upper bound of variable at the time of the given bound change index to the conflict analysis' candidate\n  storage; this method should be called in one of the following two cases:\n   1. Before calling the SCIPanalyzeConflict() method, SCIPaddConflictBd() should be called for each bound\n      that led to the conflict (e.g. the infeasibility of globally or locally valid constraint).\n   2. In the propagation conflict resolving method of a constraint handler, SCIPaddConflictBd() should be called\n      for each bound, whose current assignment led to the deduction of the given conflict bound.\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_SOLVING\n\n  @note SCIP stage does not get changed"]
    pub fn SCIPaddConflictBd(
        scip: *mut SCIP,
        var: *mut SCIP_VAR,
        boundtype: SCIP_BOUNDTYPE,
        bdchgidx: *mut SCIP_BDCHGIDX,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " adds lower or upper bound of variable at the time of the given bound change index to the conflict analysis'\n  candidate storage; with the additional information of a relaxed upper bound; this relaxed upper bound is the one\n  which would be enough to explain a certain bound change;\n  this method should be called in one of the following two cases:\n   1. Before calling the SCIPanalyzeConflict() method, SCIPaddConflictRelaxedBd() should be called for each (relaxed)\n      bound that led to the conflict (e.g. the infeasibility of globally or locally valid constraint).\n   2. In the propagation conflict resolving method of a constraint handler, SCIPaddConflictRelaxedBd() should be\n      called for each (relaxed) bound, whose current assignment led to the deduction of the given conflict bound.\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_SOLVING\n\n  @note SCIP stage does not get changed"]
    pub fn SCIPaddConflictRelaxedBd(
        scip: *mut SCIP,
        var: *mut SCIP_VAR,
        boundtype: SCIP_BOUNDTYPE,
        bdchgidx: *mut SCIP_BDCHGIDX,
        relaxedbd: f64,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " adds changed bound of fixed binary variable to the conflict analysis' candidate storage;\n  this method should be called in one of the following two cases:\n   1. Before calling the SCIPanalyzeConflict() method, SCIPaddConflictBinvar() should be called for each fixed binary\n      variable that led to the conflict (e.g. the infeasibility of globally or locally valid constraint).\n   2. In the propagation conflict resolving method of a constraint handler, SCIPaddConflictBinvar() should be called\n      for each binary variable, whose current fixing led to the deduction of the given conflict bound.\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_SOLVING\n\n  @note SCIP stage does not get changed"]
    pub fn SCIPaddConflictBinvar(scip: *mut SCIP, var: *mut SCIP_VAR) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " checks if the given variable is already part of the current conflict set or queued for resolving with the same or\n  even stronger bound\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_SOLVING\n\n  @note SCIP stage does not get changed"]
    pub fn SCIPisConflictVarUsed(
        scip: *mut SCIP,
        var: *mut SCIP_VAR,
        boundtype: SCIP_BOUNDTYPE,
        bdchgidx: *mut SCIP_BDCHGIDX,
        used: *mut ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " returns the conflict lower bound if the variable is present in the current conflict set; otherwise the global lower\n  bound\n\n  @return returns the conflict lower bound if the variable is present in the current conflict set; otherwise the global lower\n          bound\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_SOLVING\n\n  @note SCIP stage does not get changed"]
    pub fn SCIPgetConflictVarLb(scip: *mut SCIP, var: *mut SCIP_VAR) -> f64;
}
extern "C" {
    #[doc = " returns the conflict upper bound if the variable is present in the current conflict set; otherwise minus global\n  upper bound\n\n  @return returns the conflict upper bound if the variable is present in the current conflict set; otherwise minus global\n          upper bound\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_SOLVING\n\n  @note SCIP stage does not get changed"]
    pub fn SCIPgetConflictVarUb(scip: *mut SCIP, var: *mut SCIP_VAR) -> f64;
}
extern "C" {
    #[doc = " analyzes conflict bounds that were added after a call to SCIPinitConflictAnalysis() with calls to\n  SCIPaddConflictLb(), SCIPaddConflictUb(), SCIPaddConflictBd(), SCIPaddConflictRelaxedLb(),\n  SCIPaddConflictRelaxedUb(), SCIPaddConflictRelaxedBd(), or SCIPaddConflictBinvar(); on success, calls the conflict\n  handlers to create a conflict constraint out of the resulting conflict set; the given valid depth must be a depth\n  level, at which the conflict set defined by calls to SCIPaddConflictLb(), SCIPaddConflictUb(), SCIPaddConflictBd(),\n  SCIPaddConflictRelaxedLb(), SCIPaddConflictRelaxedUb(), SCIPaddConflictRelaxedBd(), and SCIPaddConflictBinvar() is\n  valid for the whole subtree; if the conflict was found by a violated constraint, use SCIPanalyzeConflictCons()\n  instead of SCIPanalyzeConflict() to make sure, that the correct valid depth is used\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_SOLVING\n\n  @note SCIP stage does not get changed"]
    pub fn SCIPanalyzeConflict(
        scip: *mut SCIP,
        validdepth: ::std::os::raw::c_int,
        success: *mut ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " analyzes conflict bounds that were added with calls to SCIPaddConflictLb(), SCIPaddConflictUb(),\n  SCIPaddConflictBd(), SCIPaddConflictRelaxedLb(), SCIPaddConflictRelaxedUb(), SCIPaddConflictRelaxedBd(), or\n  SCIPaddConflictBinvar(); on success, calls the conflict handlers to create a conflict constraint out of the\n  resulting conflict set; the given constraint must be the constraint that detected the conflict, i.e. the constraint\n  that is infeasible in the local bounds of the initial conflict set (defined by calls to SCIPaddConflictLb(),\n  SCIPaddConflictUb(), SCIPaddConflictBd(), SCIPaddConflictRelaxedLb(), SCIPaddConflictRelaxedUb(),\n  SCIPaddConflictRelaxedBd(), and SCIPaddConflictBinvar())\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_SOLVING\n\n  @note SCIP stage does not get changed"]
    pub fn SCIPanalyzeConflictCons(
        scip: *mut SCIP,
        cons: *mut SCIP_CONS,
        success: *mut ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " creates a constraint handler and includes it in SCIP.\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_INIT\n       - \\ref SCIP_STAGE_PROBLEM\n\n  @note method has all constraint handler callbacks as arguments and is thus changed every time a new\n        callback is added\n        in future releases; consider using SCIPincludeConshdlrBasic() and setter functions\n        if you seek for a method which is less likely to change in future releases"]
    pub fn SCIPincludeConshdlr(
        scip: *mut SCIP,
        name: *const ::std::os::raw::c_char,
        desc: *const ::std::os::raw::c_char,
        sepapriority: ::std::os::raw::c_int,
        enfopriority: ::std::os::raw::c_int,
        chckpriority: ::std::os::raw::c_int,
        sepafreq: ::std::os::raw::c_int,
        propfreq: ::std::os::raw::c_int,
        eagerfreq: ::std::os::raw::c_int,
        maxprerounds: ::std::os::raw::c_int,
        delaysepa: ::std::os::raw::c_uint,
        delayprop: ::std::os::raw::c_uint,
        needscons: ::std::os::raw::c_uint,
        proptiming: SCIP_PROPTIMING,
        presoltiming: SCIP_PRESOLTIMING,
        conshdlrcopy: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                conshdlr: *mut SCIP_CONSHDLR,
                valid: *mut ::std::os::raw::c_uint,
            ) -> SCIP_RETCODE,
        >,
        consfree: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, conshdlr: *mut SCIP_CONSHDLR) -> SCIP_RETCODE,
        >,
        consinit: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                conshdlr: *mut SCIP_CONSHDLR,
                conss: *mut *mut SCIP_CONS,
                nconss: ::std::os::raw::c_int,
            ) -> SCIP_RETCODE,
        >,
        consexit: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                conshdlr: *mut SCIP_CONSHDLR,
                conss: *mut *mut SCIP_CONS,
                nconss: ::std::os::raw::c_int,
            ) -> SCIP_RETCODE,
        >,
        consinitpre: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                conshdlr: *mut SCIP_CONSHDLR,
                conss: *mut *mut SCIP_CONS,
                nconss: ::std::os::raw::c_int,
            ) -> SCIP_RETCODE,
        >,
        consexitpre: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                conshdlr: *mut SCIP_CONSHDLR,
                conss: *mut *mut SCIP_CONS,
                nconss: ::std::os::raw::c_int,
            ) -> SCIP_RETCODE,
        >,
        consinitsol: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                conshdlr: *mut SCIP_CONSHDLR,
                conss: *mut *mut SCIP_CONS,
                nconss: ::std::os::raw::c_int,
            ) -> SCIP_RETCODE,
        >,
        consexitsol: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                conshdlr: *mut SCIP_CONSHDLR,
                conss: *mut *mut SCIP_CONS,
                nconss: ::std::os::raw::c_int,
                restart: ::std::os::raw::c_uint,
            ) -> SCIP_RETCODE,
        >,
        consdelete: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                conshdlr: *mut SCIP_CONSHDLR,
                cons: *mut SCIP_CONS,
                consdata: *mut *mut SCIP_CONSDATA,
            ) -> SCIP_RETCODE,
        >,
        constrans: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                conshdlr: *mut SCIP_CONSHDLR,
                sourcecons: *mut SCIP_CONS,
                targetcons: *mut *mut SCIP_CONS,
            ) -> SCIP_RETCODE,
        >,
        consinitlp: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                conshdlr: *mut SCIP_CONSHDLR,
                conss: *mut *mut SCIP_CONS,
                nconss: ::std::os::raw::c_int,
                infeasible: *mut ::std::os::raw::c_uint,
            ) -> SCIP_RETCODE,
        >,
        conssepalp: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                conshdlr: *mut SCIP_CONSHDLR,
                conss: *mut *mut SCIP_CONS,
                nconss: ::std::os::raw::c_int,
                nusefulconss: ::std::os::raw::c_int,
                result: *mut SCIP_RESULT,
            ) -> SCIP_RETCODE,
        >,
        conssepasol: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                conshdlr: *mut SCIP_CONSHDLR,
                conss: *mut *mut SCIP_CONS,
                nconss: ::std::os::raw::c_int,
                nusefulconss: ::std::os::raw::c_int,
                sol: *mut SCIP_SOL,
                result: *mut SCIP_RESULT,
            ) -> SCIP_RETCODE,
        >,
        consenfolp: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                conshdlr: *mut SCIP_CONSHDLR,
                conss: *mut *mut SCIP_CONS,
                nconss: ::std::os::raw::c_int,
                nusefulconss: ::std::os::raw::c_int,
                solinfeasible: ::std::os::raw::c_uint,
                result: *mut SCIP_RESULT,
            ) -> SCIP_RETCODE,
        >,
        consenforelax: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                sol: *mut SCIP_SOL,
                conshdlr: *mut SCIP_CONSHDLR,
                conss: *mut *mut SCIP_CONS,
                nconss: ::std::os::raw::c_int,
                nusefulconss: ::std::os::raw::c_int,
                solinfeasible: ::std::os::raw::c_uint,
                result: *mut SCIP_RESULT,
            ) -> SCIP_RETCODE,
        >,
        consenfops: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                conshdlr: *mut SCIP_CONSHDLR,
                conss: *mut *mut SCIP_CONS,
                nconss: ::std::os::raw::c_int,
                nusefulconss: ::std::os::raw::c_int,
                solinfeasible: ::std::os::raw::c_uint,
                objinfeasible: ::std::os::raw::c_uint,
                result: *mut SCIP_RESULT,
            ) -> SCIP_RETCODE,
        >,
        conscheck: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                conshdlr: *mut SCIP_CONSHDLR,
                conss: *mut *mut SCIP_CONS,
                nconss: ::std::os::raw::c_int,
                sol: *mut SCIP_SOL,
                checkintegrality: ::std::os::raw::c_uint,
                checklprows: ::std::os::raw::c_uint,
                printreason: ::std::os::raw::c_uint,
                completely: ::std::os::raw::c_uint,
                result: *mut SCIP_RESULT,
            ) -> SCIP_RETCODE,
        >,
        consprop: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                conshdlr: *mut SCIP_CONSHDLR,
                conss: *mut *mut SCIP_CONS,
                nconss: ::std::os::raw::c_int,
                nusefulconss: ::std::os::raw::c_int,
                nmarkedconss: ::std::os::raw::c_int,
                proptiming: SCIP_PROPTIMING,
                result: *mut SCIP_RESULT,
            ) -> SCIP_RETCODE,
        >,
        conspresol: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                conshdlr: *mut SCIP_CONSHDLR,
                conss: *mut *mut SCIP_CONS,
                nconss: ::std::os::raw::c_int,
                nrounds: ::std::os::raw::c_int,
                presoltiming: SCIP_PRESOLTIMING,
                nnewfixedvars: ::std::os::raw::c_int,
                nnewaggrvars: ::std::os::raw::c_int,
                nnewchgvartypes: ::std::os::raw::c_int,
                nnewchgbds: ::std::os::raw::c_int,
                nnewholes: ::std::os::raw::c_int,
                nnewdelconss: ::std::os::raw::c_int,
                nnewaddconss: ::std::os::raw::c_int,
                nnewupgdconss: ::std::os::raw::c_int,
                nnewchgcoefs: ::std::os::raw::c_int,
                nnewchgsides: ::std::os::raw::c_int,
                nfixedvars: *mut ::std::os::raw::c_int,
                naggrvars: *mut ::std::os::raw::c_int,
                nchgvartypes: *mut ::std::os::raw::c_int,
                nchgbds: *mut ::std::os::raw::c_int,
                naddholes: *mut ::std::os::raw::c_int,
                ndelconss: *mut ::std::os::raw::c_int,
                naddconss: *mut ::std::os::raw::c_int,
                nupgdconss: *mut ::std::os::raw::c_int,
                nchgcoefs: *mut ::std::os::raw::c_int,
                nchgsides: *mut ::std::os::raw::c_int,
                result: *mut SCIP_RESULT,
            ) -> SCIP_RETCODE,
        >,
        consresprop: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                conshdlr: *mut SCIP_CONSHDLR,
                cons: *mut SCIP_CONS,
                infervar: *mut SCIP_VAR,
                inferinfo: ::std::os::raw::c_int,
                boundtype: SCIP_BOUNDTYPE,
                bdchgidx: *mut SCIP_BDCHGIDX,
                relaxedbd: f64,
                result: *mut SCIP_RESULT,
            ) -> SCIP_RETCODE,
        >,
        conslock: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                conshdlr: *mut SCIP_CONSHDLR,
                cons: *mut SCIP_CONS,
                locktype: SCIP_LOCKTYPE,
                nlockspos: ::std::os::raw::c_int,
                nlocksneg: ::std::os::raw::c_int,
            ) -> SCIP_RETCODE,
        >,
        consactive: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                conshdlr: *mut SCIP_CONSHDLR,
                cons: *mut SCIP_CONS,
            ) -> SCIP_RETCODE,
        >,
        consdeactive: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                conshdlr: *mut SCIP_CONSHDLR,
                cons: *mut SCIP_CONS,
            ) -> SCIP_RETCODE,
        >,
        consenable: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                conshdlr: *mut SCIP_CONSHDLR,
                cons: *mut SCIP_CONS,
            ) -> SCIP_RETCODE,
        >,
        consdisable: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                conshdlr: *mut SCIP_CONSHDLR,
                cons: *mut SCIP_CONS,
            ) -> SCIP_RETCODE,
        >,
        consdelvars: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                conshdlr: *mut SCIP_CONSHDLR,
                conss: *mut *mut SCIP_CONS,
                nconss: ::std::os::raw::c_int,
            ) -> SCIP_RETCODE,
        >,
        consprint: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                conshdlr: *mut SCIP_CONSHDLR,
                cons: *mut SCIP_CONS,
                file: *mut FILE,
            ) -> SCIP_RETCODE,
        >,
        conscopy: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                cons: *mut *mut SCIP_CONS,
                name: *const ::std::os::raw::c_char,
                sourcescip: *mut SCIP,
                sourceconshdlr: *mut SCIP_CONSHDLR,
                sourcecons: *mut SCIP_CONS,
                varmap: *mut SCIP_HASHMAP,
                consmap: *mut SCIP_HASHMAP,
                initial: ::std::os::raw::c_uint,
                separate: ::std::os::raw::c_uint,
                enforce: ::std::os::raw::c_uint,
                check: ::std::os::raw::c_uint,
                propagate: ::std::os::raw::c_uint,
                local: ::std::os::raw::c_uint,
                modifiable: ::std::os::raw::c_uint,
                dynamic: ::std::os::raw::c_uint,
                removable: ::std::os::raw::c_uint,
                stickingatnode: ::std::os::raw::c_uint,
                global: ::std::os::raw::c_uint,
                valid: *mut ::std::os::raw::c_uint,
            ) -> SCIP_RETCODE,
        >,
        consparse: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                conshdlr: *mut SCIP_CONSHDLR,
                cons: *mut *mut SCIP_CONS,
                name: *const ::std::os::raw::c_char,
                str_: *const ::std::os::raw::c_char,
                initial: ::std::os::raw::c_uint,
                separate: ::std::os::raw::c_uint,
                enforce: ::std::os::raw::c_uint,
                check: ::std::os::raw::c_uint,
                propagate: ::std::os::raw::c_uint,
                local: ::std::os::raw::c_uint,
                modifiable: ::std::os::raw::c_uint,
                dynamic: ::std::os::raw::c_uint,
                removable: ::std::os::raw::c_uint,
                stickingatnode: ::std::os::raw::c_uint,
                success: *mut ::std::os::raw::c_uint,
            ) -> SCIP_RETCODE,
        >,
        consgetvars: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                conshdlr: *mut SCIP_CONSHDLR,
                cons: *mut SCIP_CONS,
                vars: *mut *mut SCIP_VAR,
                varssize: ::std::os::raw::c_int,
                success: *mut ::std::os::raw::c_uint,
            ) -> SCIP_RETCODE,
        >,
        consgetnvars: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                conshdlr: *mut SCIP_CONSHDLR,
                cons: *mut SCIP_CONS,
                nvars: *mut ::std::os::raw::c_int,
                success: *mut ::std::os::raw::c_uint,
            ) -> SCIP_RETCODE,
        >,
        consgetdivebdchgs: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                conshdlr: *mut SCIP_CONSHDLR,
                diveset: *mut SCIP_DIVESET,
                sol: *mut SCIP_SOL,
                success: *mut ::std::os::raw::c_uint,
                infeasible: *mut ::std::os::raw::c_uint,
            ) -> SCIP_RETCODE,
        >,
        consgetpermsymgraph: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                conshdlr: *mut SCIP_CONSHDLR,
                cons: *mut SCIP_CONS,
                graph: *mut SYM_GRAPH,
                success: *mut ::std::os::raw::c_uint,
            ) -> SCIP_RETCODE,
        >,
        consgetsignedpermsymgraph: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                conshdlr: *mut SCIP_CONSHDLR,
                cons: *mut SCIP_CONS,
                graph: *mut SYM_GRAPH,
                success: *mut ::std::os::raw::c_uint,
            ) -> SCIP_RETCODE,
        >,
        conshdlrdata: *mut SCIP_CONSHDLRDATA,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " creates a constraint handler and includes it in SCIP. All non-fundamental (or optional) callbacks will be set to NULL.\n  Optional callbacks can be set via specific setter functions, see SCIPsetConshdlrInit(), SCIPsetConshdlrExit(),\n  SCIPsetConshdlrCopy(), SCIPsetConshdlrFree(), SCIPsetConshdlrInitsol(), SCIPsetConshdlrExitsol(),\n  SCIPsetConshdlrInitpre(), SCIPsetConshdlrExitpre(), SCIPsetConshdlrPresol(), SCIPsetConshdlrDelete(),\n  SCIPsetConshdlrDelvars(), SCIPsetConshdlrInitlp(), SCIPsetConshdlrActive(), SCIPsetConshdlrDeactive(),\n  SCIPsetConshdlrEnable(), SCIPsetConshdlrDisable(), SCIPsetConshdlrResprop(), SCIPsetConshdlrTrans(),\n  SCIPsetConshdlrPrint(), SCIPsetConshdlrParse(), SCIPsetConshdlrGetVars(), SCIPsetConshdlrGetNVars(), and\n  SCIPsetConshdlrGetDiveBdChgs().\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_INIT\n       - \\ref SCIP_STAGE_PROBLEM\n\n  @note if you want to set all callbacks with a single method call, consider using SCIPincludeConshdlr() instead"]
    pub fn SCIPincludeConshdlrBasic(
        scip: *mut SCIP,
        conshdlrptr: *mut *mut SCIP_CONSHDLR,
        name: *const ::std::os::raw::c_char,
        desc: *const ::std::os::raw::c_char,
        enfopriority: ::std::os::raw::c_int,
        chckpriority: ::std::os::raw::c_int,
        eagerfreq: ::std::os::raw::c_int,
        needscons: ::std::os::raw::c_uint,
        consenfolp: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                conshdlr: *mut SCIP_CONSHDLR,
                conss: *mut *mut SCIP_CONS,
                nconss: ::std::os::raw::c_int,
                nusefulconss: ::std::os::raw::c_int,
                solinfeasible: ::std::os::raw::c_uint,
                result: *mut SCIP_RESULT,
            ) -> SCIP_RETCODE,
        >,
        consenfops: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                conshdlr: *mut SCIP_CONSHDLR,
                conss: *mut *mut SCIP_CONS,
                nconss: ::std::os::raw::c_int,
                nusefulconss: ::std::os::raw::c_int,
                solinfeasible: ::std::os::raw::c_uint,
                objinfeasible: ::std::os::raw::c_uint,
                result: *mut SCIP_RESULT,
            ) -> SCIP_RETCODE,
        >,
        conscheck: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                conshdlr: *mut SCIP_CONSHDLR,
                conss: *mut *mut SCIP_CONS,
                nconss: ::std::os::raw::c_int,
                sol: *mut SCIP_SOL,
                checkintegrality: ::std::os::raw::c_uint,
                checklprows: ::std::os::raw::c_uint,
                printreason: ::std::os::raw::c_uint,
                completely: ::std::os::raw::c_uint,
                result: *mut SCIP_RESULT,
            ) -> SCIP_RETCODE,
        >,
        conslock: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                conshdlr: *mut SCIP_CONSHDLR,
                cons: *mut SCIP_CONS,
                locktype: SCIP_LOCKTYPE,
                nlockspos: ::std::os::raw::c_int,
                nlocksneg: ::std::os::raw::c_int,
            ) -> SCIP_RETCODE,
        >,
        conshdlrdata: *mut SCIP_CONSHDLRDATA,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " sets all separation related callbacks/parameters of the constraint handler\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_INIT\n       - \\ref SCIP_STAGE_PROBLEM"]
    pub fn SCIPsetConshdlrSepa(
        scip: *mut SCIP,
        conshdlr: *mut SCIP_CONSHDLR,
        conssepalp: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                conshdlr: *mut SCIP_CONSHDLR,
                conss: *mut *mut SCIP_CONS,
                nconss: ::std::os::raw::c_int,
                nusefulconss: ::std::os::raw::c_int,
                result: *mut SCIP_RESULT,
            ) -> SCIP_RETCODE,
        >,
        conssepasol: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                conshdlr: *mut SCIP_CONSHDLR,
                conss: *mut *mut SCIP_CONS,
                nconss: ::std::os::raw::c_int,
                nusefulconss: ::std::os::raw::c_int,
                sol: *mut SCIP_SOL,
                result: *mut SCIP_RESULT,
            ) -> SCIP_RETCODE,
        >,
        sepafreq: ::std::os::raw::c_int,
        sepapriority: ::std::os::raw::c_int,
        delaysepa: ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " sets both the propagation callback and the propagation frequency of the constraint handler\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_INIT\n       - \\ref SCIP_STAGE_PROBLEM"]
    pub fn SCIPsetConshdlrProp(
        scip: *mut SCIP,
        conshdlr: *mut SCIP_CONSHDLR,
        consprop: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                conshdlr: *mut SCIP_CONSHDLR,
                conss: *mut *mut SCIP_CONS,
                nconss: ::std::os::raw::c_int,
                nusefulconss: ::std::os::raw::c_int,
                nmarkedconss: ::std::os::raw::c_int,
                proptiming: SCIP_PROPTIMING,
                result: *mut SCIP_RESULT,
            ) -> SCIP_RETCODE,
        >,
        propfreq: ::std::os::raw::c_int,
        delayprop: ::std::os::raw::c_uint,
        proptiming: SCIP_PROPTIMING,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " sets relaxation enforcement method of the constraint handler\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_INIT\n       - \\ref SCIP_STAGE_PROBLEM"]
    pub fn SCIPsetConshdlrEnforelax(
        scip: *mut SCIP,
        conshdlr: *mut SCIP_CONSHDLR,
        consenforelax: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                sol: *mut SCIP_SOL,
                conshdlr: *mut SCIP_CONSHDLR,
                conss: *mut *mut SCIP_CONS,
                nconss: ::std::os::raw::c_int,
                nusefulconss: ::std::os::raw::c_int,
                solinfeasible: ::std::os::raw::c_uint,
                result: *mut SCIP_RESULT,
            ) -> SCIP_RETCODE,
        >,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " sets copy method of both the constraint handler and each associated constraint\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_INIT\n       - \\ref SCIP_STAGE_PROBLEM"]
    pub fn SCIPsetConshdlrCopy(
        scip: *mut SCIP,
        conshdlr: *mut SCIP_CONSHDLR,
        conshdlrcopy: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                conshdlr: *mut SCIP_CONSHDLR,
                valid: *mut ::std::os::raw::c_uint,
            ) -> SCIP_RETCODE,
        >,
        conscopy: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                cons: *mut *mut SCIP_CONS,
                name: *const ::std::os::raw::c_char,
                sourcescip: *mut SCIP,
                sourceconshdlr: *mut SCIP_CONSHDLR,
                sourcecons: *mut SCIP_CONS,
                varmap: *mut SCIP_HASHMAP,
                consmap: *mut SCIP_HASHMAP,
                initial: ::std::os::raw::c_uint,
                separate: ::std::os::raw::c_uint,
                enforce: ::std::os::raw::c_uint,
                check: ::std::os::raw::c_uint,
                propagate: ::std::os::raw::c_uint,
                local: ::std::os::raw::c_uint,
                modifiable: ::std::os::raw::c_uint,
                dynamic: ::std::os::raw::c_uint,
                removable: ::std::os::raw::c_uint,
                stickingatnode: ::std::os::raw::c_uint,
                global: ::std::os::raw::c_uint,
                valid: *mut ::std::os::raw::c_uint,
            ) -> SCIP_RETCODE,
        >,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " sets destructor method of constraint handler\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_INIT\n       - \\ref SCIP_STAGE_PROBLEM"]
    pub fn SCIPsetConshdlrFree(
        scip: *mut SCIP,
        conshdlr: *mut SCIP_CONSHDLR,
        consfree: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, conshdlr: *mut SCIP_CONSHDLR) -> SCIP_RETCODE,
        >,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " sets initialization method of constraint handler\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_INIT\n       - \\ref SCIP_STAGE_PROBLEM"]
    pub fn SCIPsetConshdlrInit(
        scip: *mut SCIP,
        conshdlr: *mut SCIP_CONSHDLR,
        consinit: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                conshdlr: *mut SCIP_CONSHDLR,
                conss: *mut *mut SCIP_CONS,
                nconss: ::std::os::raw::c_int,
            ) -> SCIP_RETCODE,
        >,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " sets deinitialization method of constraint handler\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_INIT\n       - \\ref SCIP_STAGE_PROBLEM"]
    pub fn SCIPsetConshdlrExit(
        scip: *mut SCIP,
        conshdlr: *mut SCIP_CONSHDLR,
        consexit: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                conshdlr: *mut SCIP_CONSHDLR,
                conss: *mut *mut SCIP_CONS,
                nconss: ::std::os::raw::c_int,
            ) -> SCIP_RETCODE,
        >,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " sets solving process initialization method of constraint handler\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_INIT\n       - \\ref SCIP_STAGE_PROBLEM"]
    pub fn SCIPsetConshdlrInitsol(
        scip: *mut SCIP,
        conshdlr: *mut SCIP_CONSHDLR,
        consinitsol: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                conshdlr: *mut SCIP_CONSHDLR,
                conss: *mut *mut SCIP_CONS,
                nconss: ::std::os::raw::c_int,
            ) -> SCIP_RETCODE,
        >,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " sets solving process deinitialization method of constraint handler\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_INIT\n       - \\ref SCIP_STAGE_PROBLEM"]
    pub fn SCIPsetConshdlrExitsol(
        scip: *mut SCIP,
        conshdlr: *mut SCIP_CONSHDLR,
        consexitsol: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                conshdlr: *mut SCIP_CONSHDLR,
                conss: *mut *mut SCIP_CONS,
                nconss: ::std::os::raw::c_int,
                restart: ::std::os::raw::c_uint,
            ) -> SCIP_RETCODE,
        >,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " sets preprocessing initialization method of constraint handler\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_INIT\n       - \\ref SCIP_STAGE_PROBLEM"]
    pub fn SCIPsetConshdlrInitpre(
        scip: *mut SCIP,
        conshdlr: *mut SCIP_CONSHDLR,
        consinitpre: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                conshdlr: *mut SCIP_CONSHDLR,
                conss: *mut *mut SCIP_CONS,
                nconss: ::std::os::raw::c_int,
            ) -> SCIP_RETCODE,
        >,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " sets preprocessing deinitialization method of constraint handler\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_INIT\n       - \\ref SCIP_STAGE_PROBLEM"]
    pub fn SCIPsetConshdlrExitpre(
        scip: *mut SCIP,
        conshdlr: *mut SCIP_CONSHDLR,
        consexitpre: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                conshdlr: *mut SCIP_CONSHDLR,
                conss: *mut *mut SCIP_CONS,
                nconss: ::std::os::raw::c_int,
            ) -> SCIP_RETCODE,
        >,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " sets presolving method of constraint handler\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_INIT\n       - \\ref SCIP_STAGE_PROBLEM"]
    pub fn SCIPsetConshdlrPresol(
        scip: *mut SCIP,
        conshdlr: *mut SCIP_CONSHDLR,
        conspresol: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                conshdlr: *mut SCIP_CONSHDLR,
                conss: *mut *mut SCIP_CONS,
                nconss: ::std::os::raw::c_int,
                nrounds: ::std::os::raw::c_int,
                presoltiming: SCIP_PRESOLTIMING,
                nnewfixedvars: ::std::os::raw::c_int,
                nnewaggrvars: ::std::os::raw::c_int,
                nnewchgvartypes: ::std::os::raw::c_int,
                nnewchgbds: ::std::os::raw::c_int,
                nnewholes: ::std::os::raw::c_int,
                nnewdelconss: ::std::os::raw::c_int,
                nnewaddconss: ::std::os::raw::c_int,
                nnewupgdconss: ::std::os::raw::c_int,
                nnewchgcoefs: ::std::os::raw::c_int,
                nnewchgsides: ::std::os::raw::c_int,
                nfixedvars: *mut ::std::os::raw::c_int,
                naggrvars: *mut ::std::os::raw::c_int,
                nchgvartypes: *mut ::std::os::raw::c_int,
                nchgbds: *mut ::std::os::raw::c_int,
                naddholes: *mut ::std::os::raw::c_int,
                ndelconss: *mut ::std::os::raw::c_int,
                naddconss: *mut ::std::os::raw::c_int,
                nupgdconss: *mut ::std::os::raw::c_int,
                nchgcoefs: *mut ::std::os::raw::c_int,
                nchgsides: *mut ::std::os::raw::c_int,
                result: *mut SCIP_RESULT,
            ) -> SCIP_RETCODE,
        >,
        maxprerounds: ::std::os::raw::c_int,
        presoltiming: SCIP_PRESOLTIMING,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " sets method of constraint handler to free specific constraint data\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_INIT\n       - \\ref SCIP_STAGE_PROBLEM"]
    pub fn SCIPsetConshdlrDelete(
        scip: *mut SCIP,
        conshdlr: *mut SCIP_CONSHDLR,
        consdelete: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                conshdlr: *mut SCIP_CONSHDLR,
                cons: *mut SCIP_CONS,
                consdata: *mut *mut SCIP_CONSDATA,
            ) -> SCIP_RETCODE,
        >,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " sets method of constraint handler to transform constraint data into data belonging to the transformed problem\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_INIT\n       - \\ref SCIP_STAGE_PROBLEM"]
    pub fn SCIPsetConshdlrTrans(
        scip: *mut SCIP,
        conshdlr: *mut SCIP_CONSHDLR,
        constrans: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                conshdlr: *mut SCIP_CONSHDLR,
                sourcecons: *mut SCIP_CONS,
                targetcons: *mut *mut SCIP_CONS,
            ) -> SCIP_RETCODE,
        >,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " sets method of constraint handler to initialize LP with relaxations of \"initial\" constraints\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_INIT\n       - \\ref SCIP_STAGE_PROBLEM"]
    pub fn SCIPsetConshdlrInitlp(
        scip: *mut SCIP,
        conshdlr: *mut SCIP_CONSHDLR,
        consinitlp: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                conshdlr: *mut SCIP_CONSHDLR,
                conss: *mut *mut SCIP_CONS,
                nconss: ::std::os::raw::c_int,
                infeasible: *mut ::std::os::raw::c_uint,
            ) -> SCIP_RETCODE,
        >,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " sets propagation conflict resolving method of constraint handler\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_INIT\n       - \\ref SCIP_STAGE_PROBLEM"]
    pub fn SCIPsetConshdlrResprop(
        scip: *mut SCIP,
        conshdlr: *mut SCIP_CONSHDLR,
        consresprop: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                conshdlr: *mut SCIP_CONSHDLR,
                cons: *mut SCIP_CONS,
                infervar: *mut SCIP_VAR,
                inferinfo: ::std::os::raw::c_int,
                boundtype: SCIP_BOUNDTYPE,
                bdchgidx: *mut SCIP_BDCHGIDX,
                relaxedbd: f64,
                result: *mut SCIP_RESULT,
            ) -> SCIP_RETCODE,
        >,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " sets activation notification method of constraint handler\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_INIT\n       - \\ref SCIP_STAGE_PROBLEM"]
    pub fn SCIPsetConshdlrActive(
        scip: *mut SCIP,
        conshdlr: *mut SCIP_CONSHDLR,
        consactive: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                conshdlr: *mut SCIP_CONSHDLR,
                cons: *mut SCIP_CONS,
            ) -> SCIP_RETCODE,
        >,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " sets deactivation notification method of constraint handler\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_INIT\n       - \\ref SCIP_STAGE_PROBLEM"]
    pub fn SCIPsetConshdlrDeactive(
        scip: *mut SCIP,
        conshdlr: *mut SCIP_CONSHDLR,
        consdeactive: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                conshdlr: *mut SCIP_CONSHDLR,
                cons: *mut SCIP_CONS,
            ) -> SCIP_RETCODE,
        >,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " sets enabling notification method of constraint handler\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_INIT\n       - \\ref SCIP_STAGE_PROBLEM"]
    pub fn SCIPsetConshdlrEnable(
        scip: *mut SCIP,
        conshdlr: *mut SCIP_CONSHDLR,
        consenable: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                conshdlr: *mut SCIP_CONSHDLR,
                cons: *mut SCIP_CONS,
            ) -> SCIP_RETCODE,
        >,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " sets disabling notification method of constraint handler\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_INIT\n       - \\ref SCIP_STAGE_PROBLEM"]
    pub fn SCIPsetConshdlrDisable(
        scip: *mut SCIP,
        conshdlr: *mut SCIP_CONSHDLR,
        consdisable: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                conshdlr: *mut SCIP_CONSHDLR,
                cons: *mut SCIP_CONS,
            ) -> SCIP_RETCODE,
        >,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " sets variable deletion method of constraint handler\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_INIT\n       - \\ref SCIP_STAGE_PROBLEM"]
    pub fn SCIPsetConshdlrDelvars(
        scip: *mut SCIP,
        conshdlr: *mut SCIP_CONSHDLR,
        consdelvars: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                conshdlr: *mut SCIP_CONSHDLR,
                conss: *mut *mut SCIP_CONS,
                nconss: ::std::os::raw::c_int,
            ) -> SCIP_RETCODE,
        >,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " sets constraint display method of constraint handler\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_INIT\n       - \\ref SCIP_STAGE_PROBLEM"]
    pub fn SCIPsetConshdlrPrint(
        scip: *mut SCIP,
        conshdlr: *mut SCIP_CONSHDLR,
        consprint: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                conshdlr: *mut SCIP_CONSHDLR,
                cons: *mut SCIP_CONS,
                file: *mut FILE,
            ) -> SCIP_RETCODE,
        >,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " sets constraint parsing method of constraint handler\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_INIT\n       - \\ref SCIP_STAGE_PROBLEM"]
    pub fn SCIPsetConshdlrParse(
        scip: *mut SCIP,
        conshdlr: *mut SCIP_CONSHDLR,
        consparse: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                conshdlr: *mut SCIP_CONSHDLR,
                cons: *mut *mut SCIP_CONS,
                name: *const ::std::os::raw::c_char,
                str_: *const ::std::os::raw::c_char,
                initial: ::std::os::raw::c_uint,
                separate: ::std::os::raw::c_uint,
                enforce: ::std::os::raw::c_uint,
                check: ::std::os::raw::c_uint,
                propagate: ::std::os::raw::c_uint,
                local: ::std::os::raw::c_uint,
                modifiable: ::std::os::raw::c_uint,
                dynamic: ::std::os::raw::c_uint,
                removable: ::std::os::raw::c_uint,
                stickingatnode: ::std::os::raw::c_uint,
                success: *mut ::std::os::raw::c_uint,
            ) -> SCIP_RETCODE,
        >,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " sets constraint variable getter method of constraint handler\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_INIT\n       - \\ref SCIP_STAGE_PROBLEM"]
    pub fn SCIPsetConshdlrGetVars(
        scip: *mut SCIP,
        conshdlr: *mut SCIP_CONSHDLR,
        consgetvars: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                conshdlr: *mut SCIP_CONSHDLR,
                cons: *mut SCIP_CONS,
                vars: *mut *mut SCIP_VAR,
                varssize: ::std::os::raw::c_int,
                success: *mut ::std::os::raw::c_uint,
            ) -> SCIP_RETCODE,
        >,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " sets constraint variable number getter method of constraint handler\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_INIT\n       - \\ref SCIP_STAGE_PROBLEM"]
    pub fn SCIPsetConshdlrGetNVars(
        scip: *mut SCIP,
        conshdlr: *mut SCIP_CONSHDLR,
        consgetnvars: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                conshdlr: *mut SCIP_CONSHDLR,
                cons: *mut SCIP_CONS,
                nvars: *mut ::std::os::raw::c_int,
                success: *mut ::std::os::raw::c_uint,
            ) -> SCIP_RETCODE,
        >,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " sets diving enforcement method of constraint handler\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_INIT\n       - \\ref SCIP_STAGE_PROBLEM"]
    pub fn SCIPsetConshdlrGetDiveBdChgs(
        scip: *mut SCIP,
        conshdlr: *mut SCIP_CONSHDLR,
        consgetdivebdchgs: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                conshdlr: *mut SCIP_CONSHDLR,
                diveset: *mut SCIP_DIVESET,
                sol: *mut SCIP_SOL,
                success: *mut ::std::os::raw::c_uint,
                infeasible: *mut ::std::os::raw::c_uint,
            ) -> SCIP_RETCODE,
        >,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " sets permutation symmetry detection graph getter method of constraint handler\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPsetConshdlrGetPermsymGraph(
        scip: *mut SCIP,
        conshdlr: *mut SCIP_CONSHDLR,
        consgetpermsymgraph: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                conshdlr: *mut SCIP_CONSHDLR,
                cons: *mut SCIP_CONS,
                graph: *mut SYM_GRAPH,
                success: *mut ::std::os::raw::c_uint,
            ) -> SCIP_RETCODE,
        >,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " sets signed permutation symmetry detection graph getter method of constraint handler\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPsetConshdlrGetSignedPermsymGraph(
        scip: *mut SCIP,
        conshdlr: *mut SCIP_CONSHDLR,
        consgetsignedpermsymgraph: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                conshdlr: *mut SCIP_CONSHDLR,
                cons: *mut SCIP_CONS,
                graph: *mut SYM_GRAPH,
                success: *mut ::std::os::raw::c_uint,
            ) -> SCIP_RETCODE,
        >,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " returns the constraint handler of the given name, or NULL if not existing"]
    pub fn SCIPfindConshdlr(
        scip: *mut SCIP,
        name: *const ::std::os::raw::c_char,
    ) -> *mut SCIP_CONSHDLR;
}
extern "C" {
    #[doc = " returns the array of currently available constraint handlers"]
    pub fn SCIPgetConshdlrs(scip: *mut SCIP) -> *mut *mut SCIP_CONSHDLR;
}
extern "C" {
    #[doc = " returns the number of currently available constraint handlers"]
    pub fn SCIPgetNConshdlrs(scip: *mut SCIP) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " creates and captures a constraint of the given constraint handler\n\n  @warning If a constraint is marked to be checked for feasibility but not to be enforced, a LP or pseudo solution may\n           be declared feasible even if it violates this particular constraint.  This constellation should only be\n           used, if no LP or pseudo solution can violate the constraint -- e.g. if a local constraint is redundant due\n           to the variable's local bounds.\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMING\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_EXITSOLVE\n\n  @note the constraint gets captured, hence at one point you have to release it using the method SCIPreleaseCons()"]
    pub fn SCIPcreateCons(
        scip: *mut SCIP,
        cons: *mut *mut SCIP_CONS,
        name: *const ::std::os::raw::c_char,
        conshdlr: *mut SCIP_CONSHDLR,
        consdata: *mut SCIP_CONSDATA,
        initial: ::std::os::raw::c_uint,
        separate: ::std::os::raw::c_uint,
        enforce: ::std::os::raw::c_uint,
        check: ::std::os::raw::c_uint,
        propagate: ::std::os::raw::c_uint,
        local: ::std::os::raw::c_uint,
        modifiable: ::std::os::raw::c_uint,
        dynamic: ::std::os::raw::c_uint,
        removable: ::std::os::raw::c_uint,
        stickingatnode: ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " parses constraint information (in cip format) out of a string; if the parsing process was successful a constraint is\n  creates and captures;\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMING\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_EXITSOLVE\n\n  @warning If a constraint is marked to be checked for feasibility but not to be enforced, a LP or pseudo solution may\n           be declared feasible even if it violates this particular constraint.  This constellation should only be\n           used, if no LP or pseudo solution can violate the constraint -- e.g. if a local constraint is redundant due\n           to the variable's local bounds."]
    pub fn SCIPparseCons(
        scip: *mut SCIP,
        cons: *mut *mut SCIP_CONS,
        str_: *const ::std::os::raw::c_char,
        initial: ::std::os::raw::c_uint,
        separate: ::std::os::raw::c_uint,
        enforce: ::std::os::raw::c_uint,
        check: ::std::os::raw::c_uint,
        propagate: ::std::os::raw::c_uint,
        local: ::std::os::raw::c_uint,
        modifiable: ::std::os::raw::c_uint,
        dynamic: ::std::os::raw::c_uint,
        removable: ::std::os::raw::c_uint,
        stickingatnode: ::std::os::raw::c_uint,
        success: *mut ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " increases usage counter of constraint\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMING\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPcaptureCons(scip: *mut SCIP, cons: *mut SCIP_CONS) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " decreases usage counter of constraint, if the usage pointer reaches zero the constraint gets freed\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMING\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED\n       - \\ref SCIP_STAGE_EXITSOLVE\n       - \\ref SCIP_STAGE_FREETRANS\n\n  @note the pointer of the constraint will be NULLed"]
    pub fn SCIPreleaseCons(scip: *mut SCIP, cons: *mut *mut SCIP_CONS) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " change constraint name\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n\n  @note to get the current name of a constraint, use SCIPconsGetName() from pub_cons.h"]
    pub fn SCIPchgConsName(
        scip: *mut SCIP,
        cons: *mut SCIP_CONS,
        name: *const ::std::os::raw::c_char,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " sets the initial flag of the given constraint\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMING\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPsetConsInitial(
        scip: *mut SCIP,
        cons: *mut SCIP_CONS,
        initial: ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " sets the separate flag of the given constraint\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMING\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPsetConsSeparated(
        scip: *mut SCIP,
        cons: *mut SCIP_CONS,
        separate: ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " sets the enforce flag of the given constraint\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMING\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPsetConsEnforced(
        scip: *mut SCIP,
        cons: *mut SCIP_CONS,
        enforce: ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " sets the check flag of the given constraint\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMING\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPsetConsChecked(
        scip: *mut SCIP,
        cons: *mut SCIP_CONS,
        check: ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " sets the propagate flag of the given constraint\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMING\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPsetConsPropagated(
        scip: *mut SCIP,
        cons: *mut SCIP_CONS,
        propagate: ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " sets the local flag of the given constraint\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMING\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPsetConsLocal(
        scip: *mut SCIP,
        cons: *mut SCIP_CONS,
        local: ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " sets the modifiable flag of the given constraint\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMING\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_EXITSOLVE"]
    pub fn SCIPsetConsModifiable(
        scip: *mut SCIP,
        cons: *mut SCIP_CONS,
        modifiable: ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " sets the dynamic flag of the given constraint\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMING\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPsetConsDynamic(
        scip: *mut SCIP,
        cons: *mut SCIP_CONS,
        dynamic: ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " sets the removable flag of the given constraint\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMING\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPsetConsRemovable(
        scip: *mut SCIP,
        cons: *mut SCIP_CONS,
        removable: ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " sets the stickingatnode flag of the given constraint\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMING\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPsetConsStickingAtNode(
        scip: *mut SCIP,
        cons: *mut SCIP_CONS,
        stickingatnode: ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " updates the flags of the first constraint according to the ones of the second constraint\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMING\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPupdateConsFlags(
        scip: *mut SCIP,
        cons0: *mut SCIP_CONS,
        cons1: *mut SCIP_CONS,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " gets and captures transformed constraint of a given constraint; if the constraint is not yet transformed,\n  a new transformed constraint for this constraint is created\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_TRANSFORMING\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPtransformCons(
        scip: *mut SCIP,
        cons: *mut SCIP_CONS,
        transcons: *mut *mut SCIP_CONS,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " gets and captures transformed constraints for an array of constraints;\n  if a constraint in the array is not yet transformed, a new transformed constraint for this constraint is created;\n  it is possible to call this method with conss == transconss\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_TRANSFORMING\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPtransformConss(
        scip: *mut SCIP,
        nconss: ::std::os::raw::c_int,
        conss: *mut *mut SCIP_CONS,
        transconss: *mut *mut SCIP_CONS,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " gets corresponding transformed constraint of a given constraint;\n  returns NULL as transcons, if transformed constraint is not yet existing\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_TRANSFORMING\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED\n       - \\ref SCIP_STAGE_EXITSOLVE\n       - \\ref SCIP_STAGE_FREETRANS"]
    pub fn SCIPgetTransformedCons(
        scip: *mut SCIP,
        cons: *mut SCIP_CONS,
        transcons: *mut *mut SCIP_CONS,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " gets corresponding transformed constraints for an array of constraints;\n  stores NULL in a transconss slot, if the transformed constraint is not yet existing;\n  it is possible to call this method with conss == transconss, but remember that constraints that are not\n  yet transformed will be replaced with NULL\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_TRANSFORMING\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED\n       - \\ref SCIP_STAGE_EXITSOLVE\n       - \\ref SCIP_STAGE_FREETRANS"]
    pub fn SCIPgetTransformedConss(
        scip: *mut SCIP,
        nconss: ::std::os::raw::c_int,
        conss: *mut *mut SCIP_CONS,
        transconss: *mut *mut SCIP_CONS,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " adds given value to age of constraint, but age can never become negative;\n  should be called\n   - in constraint separation, if no cut was found for this constraint,\n   - in constraint enforcing, if constraint was feasible, and\n   - in constraint propagation, if no domain reduction was deduced;\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPaddConsAge(scip: *mut SCIP, cons: *mut SCIP_CONS, deltaage: f64) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " increases age of constraint by 1.0;\n  should be called\n   - in constraint separation, if no cut was found for this constraint,\n   - in constraint enforcing, if constraint was feasible, and\n   - in constraint propagation, if no domain reduction was deduced;\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPincConsAge(scip: *mut SCIP, cons: *mut SCIP_CONS) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " resets age of constraint to zero;\n  should be called\n   - in constraint separation, if a cut was found for this constraint,\n   - in constraint enforcing, if the constraint was violated, and\n   - in constraint propagation, if a domain reduction was deduced;\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPresetConsAge(scip: *mut SCIP, cons: *mut SCIP_CONS) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " enables constraint's separation, propagation, and enforcing capabilities\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPenableCons(scip: *mut SCIP, cons: *mut SCIP_CONS) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " disables constraint's separation, propagation, and enforcing capabilities, s.t. the constraint is not propagated,\n  separated, and enforced anymore until it is enabled again with a call to SCIPenableCons();\n  in contrast to SCIPdelConsLocal() and SCIPdelConsNode(), the disabling is not associated to a node in the tree and\n  does not consume memory; therefore, the constraint is neither automatically enabled on leaving the node nor\n  automatically disabled again on entering the node again;\n  note that the constraints enforcing capabilities are necessary for the solution's feasibility, if the constraint\n  is a model constraint; that means, you must be sure that the constraint cannot be violated in the current subtree,\n  and you have to enable it again manually by calling SCIPenableCons(), if this subtree is left (e.g. by using\n  an appropriate event handler that watches the corresponding variables' domain changes)\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPdisableCons(scip: *mut SCIP, cons: *mut SCIP_CONS) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " enables constraint's separation capabilities\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPenableConsSeparation(scip: *mut SCIP, cons: *mut SCIP_CONS) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " disables constraint's separation capabilities s.t. the constraint is not propagated anymore until the separation\n  is enabled again with a call to SCIPenableConsSeparation(); in contrast to SCIPdelConsLocal() and SCIPdelConsNode(),\n  the disabling is not associated to a node in the tree and does not consume memory; therefore, the constraint\n  is neither automatically enabled on leaving the node nor automatically disabled again on entering the node again\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPdisableConsSeparation(scip: *mut SCIP, cons: *mut SCIP_CONS) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " enables constraint's propagation capabilities\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPenableConsPropagation(scip: *mut SCIP, cons: *mut SCIP_CONS) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " disables constraint's propagation capabilities s.t. the constraint is not propagated anymore until the propagation\n  is enabled again with a call to SCIPenableConsPropagation(); in contrast to SCIPdelConsLocal() and SCIPdelConsNode(),\n  the disabling is not associated to a node in the tree and does not consume memory; therefore, the constraint\n  is neither automatically enabled on leaving the node nor automatically disabled again on entering the node again\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPdisableConsPropagation(scip: *mut SCIP, cons: *mut SCIP_CONS) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " marks constraint to be propagated\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_TRANSFORMING\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED\n\n  @note if a constraint is marked to be propagated, the age of the constraint will be ignored for propagation"]
    pub fn SCIPmarkConsPropagate(scip: *mut SCIP, cons: *mut SCIP_CONS) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " unmarks the constraint to be propagated\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPunmarkConsPropagate(scip: *mut SCIP, cons: *mut SCIP_CONS) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " adds given values to lock status of type @p locktype of the constraint and updates the rounding locks of the involved variables\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMING\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_EXITSOLVE\n       - \\ref SCIP_STAGE_FREETRANS"]
    pub fn SCIPaddConsLocksType(
        scip: *mut SCIP,
        cons: *mut SCIP_CONS,
        locktype: SCIP_LOCKTYPE,
        nlockspos: ::std::os::raw::c_int,
        nlocksneg: ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " adds given values to lock status of the constraint and updates the rounding locks of the involved variables\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMING\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_EXITSOLVE\n       - \\ref SCIP_STAGE_FREETRANS\n\n  @note This methods always adds locks of type model"]
    pub fn SCIPaddConsLocks(
        scip: *mut SCIP,
        cons: *mut SCIP_CONS,
        nlockspos: ::std::os::raw::c_int,
        nlocksneg: ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " checks single constraint for feasibility of the given solution\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPcheckCons(
        scip: *mut SCIP,
        cons: *mut SCIP_CONS,
        sol: *mut SCIP_SOL,
        checkintegrality: ::std::os::raw::c_uint,
        checklprows: ::std::os::raw::c_uint,
        printreason: ::std::os::raw::c_uint,
        result: *mut SCIP_RESULT,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " enforces single constraint for a given pseudo solution\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_SOLVING\n\n  @note This is an advanced method and should be used with caution.  It may only be called for constraints that were not\n        added to SCIP beforehand."]
    pub fn SCIPenfopsCons(
        scip: *mut SCIP,
        cons: *mut SCIP_CONS,
        solinfeasible: ::std::os::raw::c_uint,
        objinfeasible: ::std::os::raw::c_uint,
        result: *mut SCIP_RESULT,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " enforces single constraint for a given LP solution\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_SOLVING\n\n  @note This is an advanced method and should be used with caution.  It may only be called for constraints that were not\n        added to SCIP beforehand."]
    pub fn SCIPenfolpCons(
        scip: *mut SCIP,
        cons: *mut SCIP_CONS,
        solinfeasible: ::std::os::raw::c_uint,
        result: *mut SCIP_RESULT,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " enforces single constraint for a given relaxation solution\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_SOLVING\n\n  @note This is an advanced method and should be used with caution.  It may only be called for constraints that were not\n        added to SCIP beforehand."]
    pub fn SCIPenforelaxCons(
        scip: *mut SCIP,
        cons: *mut SCIP_CONS,
        sol: *mut SCIP_SOL,
        solinfeasible: ::std::os::raw::c_uint,
        result: *mut SCIP_RESULT,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " calls LP initialization method for single constraint\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_SOLVING\n\n  @note This is an advanced method and should be used with caution.  It may only be called for constraints that were not\n        added to SCIP beforehand."]
    pub fn SCIPinitlpCons(
        scip: *mut SCIP,
        cons: *mut SCIP_CONS,
        infeasible: *mut ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " calls separation method of single constraint for LP solution\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_SOLVING\n\n  @note This is an advanced method and should be used with caution."]
    pub fn SCIPsepalpCons(
        scip: *mut SCIP,
        cons: *mut SCIP_CONS,
        result: *mut SCIP_RESULT,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " calls separation method of single constraint for given primal solution\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_SOLVING\n\n  @note This is an advanced method and should be used with caution."]
    pub fn SCIPsepasolCons(
        scip: *mut SCIP,
        cons: *mut SCIP_CONS,
        sol: *mut SCIP_SOL,
        result: *mut SCIP_RESULT,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " calls domain propagation method of single constraint\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_SOLVING\n\n  @note This is an advanced method and should be used with caution."]
    pub fn SCIPpropCons(
        scip: *mut SCIP,
        cons: *mut SCIP_CONS,
        proptiming: SCIP_PROPTIMING,
        result: *mut SCIP_RESULT,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " resolves propagation conflict of single constraint\n\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_SOLVING\n\n  @note This is an advanced method and should be used with caution.  It may only be called for constraints that were not\n        added to SCIP beforehand."]
    pub fn SCIPrespropCons(
        scip: *mut SCIP,
        cons: *mut SCIP_CONS,
        infervar: *mut SCIP_VAR,
        inferinfo: ::std::os::raw::c_int,
        boundtype: SCIP_BOUNDTYPE,
        bdchgidx: *mut SCIP_BDCHGIDX,
        relaxedbd: f64,
        result: *mut SCIP_RESULT,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " presolves of single constraint\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_PRESOLVING\n\n  @note This is an advanced method and should be used with caution."]
    pub fn SCIPpresolCons(
        scip: *mut SCIP,
        cons: *mut SCIP_CONS,
        nrounds: ::std::os::raw::c_int,
        presoltiming: SCIP_PRESOLTIMING,
        nnewfixedvars: ::std::os::raw::c_int,
        nnewaggrvars: ::std::os::raw::c_int,
        nnewchgvartypes: ::std::os::raw::c_int,
        nnewchgbds: ::std::os::raw::c_int,
        nnewholes: ::std::os::raw::c_int,
        nnewdelconss: ::std::os::raw::c_int,
        nnewaddconss: ::std::os::raw::c_int,
        nnewupgdconss: ::std::os::raw::c_int,
        nnewchgcoefs: ::std::os::raw::c_int,
        nnewchgsides: ::std::os::raw::c_int,
        nfixedvars: *mut ::std::os::raw::c_int,
        naggrvars: *mut ::std::os::raw::c_int,
        nchgvartypes: *mut ::std::os::raw::c_int,
        nchgbds: *mut ::std::os::raw::c_int,
        naddholes: *mut ::std::os::raw::c_int,
        ndelconss: *mut ::std::os::raw::c_int,
        naddconss: *mut ::std::os::raw::c_int,
        nupgdconss: *mut ::std::os::raw::c_int,
        nchgcoefs: *mut ::std::os::raw::c_int,
        nchgsides: *mut ::std::os::raw::c_int,
        result: *mut SCIP_RESULT,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " calls constraint activation notification method of single constraint\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_TRANSFORMING\n\n  @note This is an advanced method and should be used with caution.  It may only be called for constraints that were not\n      added to SCIP beforehand."]
    pub fn SCIPactiveCons(scip: *mut SCIP, cons: *mut SCIP_CONS) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " calls constraint deactivation notification method of single constraint\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_SOLVING\n\n  @note This is an advanced method and should be used with caution. It may only be called for constraints that were not\n        added to SCIP beforehand."]
    pub fn SCIPdeactiveCons(scip: *mut SCIP, cons: *mut SCIP_CONS) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " outputs constraint information to file stream via the message handler system\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMING\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED\n       - \\ref SCIP_STAGE_EXITSOLVE\n       - \\ref SCIP_STAGE_FREETRANS\n\n  @note If the message handler is set to a NULL pointer nothing will be printed.\n  @note The file stream will not be flushed directly, this can be achieved by calling SCIPinfoMessage() printing a\n        newline character."]
    pub fn SCIPprintCons(scip: *mut SCIP, cons: *mut SCIP_CONS, file: *mut FILE) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " method to collect the variables of a constraint\n\n  If the number of variables is greater than the available slots in the variable array, nothing happens except that\n  the success point is set to FALSE. With the method SCIPgetConsNVars() it is possible to get the number of variables\n  a constraint has in its scope.\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMING\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED\n       - \\ref SCIP_STAGE_EXITSOLVE\n       - \\ref SCIP_STAGE_FREETRANS\n\n  @note The success pointer indicates if all variables were copied into the vars arrray.\n\n  @note It might be that a constraint handler does not support this functionality, in that case the success pointer is\n        set to FALSE."]
    pub fn SCIPgetConsVars(
        scip: *mut SCIP,
        cons: *mut SCIP_CONS,
        vars: *mut *mut SCIP_VAR,
        varssize: ::std::os::raw::c_int,
        success: *mut ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " method to collect the number of variables of a constraint\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMING\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED\n       - \\ref SCIP_STAGE_EXITSOLVE\n       - \\ref SCIP_STAGE_FREETRANS\n\n  @note The success pointer indicates if the contraint handler was able to return the number of variables\n\n  @note It might be that a constraint handler does not support this functionality, in that case the success pointer is\n        set to FALSE"]
    pub fn SCIPgetConsNVars(
        scip: *mut SCIP,
        cons: *mut SCIP_CONS,
        nvars: *mut ::std::os::raw::c_int,
        success: *mut ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " method to get the permutation symmetry detection graph of a constraint\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPgetConsPermsymGraph(
        scip: *mut SCIP,
        cons: *mut SCIP_CONS,
        graph: *mut SYM_GRAPH,
        success: *mut ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " method to get the signed permutation symmetry detection graph of a constraint\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPgetConsSignedPermsymGraph(
        scip: *mut SCIP,
        cons: *mut SCIP_CONS,
        graph: *mut SYM_GRAPH,
        success: *mut ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " copies plugins from sourcescip to targetscip; in case that a constraint handler which does not need constraints\n  cannot be copied, valid will return FALSE. All plugins can declare that, if their copy process failed, the\n  copied SCIP instance might not represent the same problem semantics as the original.\n  Note that in this case dual reductions might be invalid.\n\n  @note In a multi thread case, you need to lock the copying procedure from outside with a mutex.\n        Also, 'passmessagehdlr' should be set to FALSE.\n\n  @note Do not change the source SCIP environment during the copying process.\n\n  @note This method does not copy Benders' plugins. To this end, the method SCIPcopyBenders() must be called\n        separately.\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if sourcescip is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED\n\n  @pre This method can be called if targetscip is in one of the following stages:\n       - \\ref SCIP_STAGE_INIT\n       - \\ref SCIP_STAGE_FREE\n\n  @post After calling this method targetscip reaches one of the following stages depending on if and when the solution\n        process was interrupted:\n       - \\ref SCIP_STAGE_PROBLEM\n\n  @note sourcescip stage does not get changed\n\n  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPcopyPlugins(
        sourcescip: *mut SCIP,
        targetscip: *mut SCIP,
        copyreaders: ::std::os::raw::c_uint,
        copypricers: ::std::os::raw::c_uint,
        copyconshdlrs: ::std::os::raw::c_uint,
        copyconflicthdlrs: ::std::os::raw::c_uint,
        copypresolvers: ::std::os::raw::c_uint,
        copyrelaxators: ::std::os::raw::c_uint,
        copyseparators: ::std::os::raw::c_uint,
        copycutselectors: ::std::os::raw::c_uint,
        copypropagators: ::std::os::raw::c_uint,
        copyheuristics: ::std::os::raw::c_uint,
        copyeventhdlrs: ::std::os::raw::c_uint,
        copynodeselectors: ::std::os::raw::c_uint,
        copybranchrules: ::std::os::raw::c_uint,
        copydisplays: ::std::os::raw::c_uint,
        copydialogs: ::std::os::raw::c_uint,
        copytables: ::std::os::raw::c_uint,
        copyexprhdlrs: ::std::os::raw::c_uint,
        copynlpis: ::std::os::raw::c_uint,
        passmessagehdlr: ::std::os::raw::c_uint,
        valid: *mut ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " copies all Benders' decomposition plugins\n\n  @note In a multi thread case, you need to lock the copying procedure from outside with a mutex.\n  @note the 'threadsafe' parameter must be set to TRUE if you are absolutely certain that the source and target\n        SCIP instances will be solved in parallel. The usual case is to set this to FALSE, since thread safety\n        typically incurs a performance cost.\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if sourcescip is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED\n\n  @pre This method can be called if targetscip is in one of the following stages:\n       - \\ref SCIP_STAGE_INIT\n       - \\ref SCIP_STAGE_FREE\n\n  @post After calling this method targetscip reaches one of the following stages depending on if and when the solution\n        process was interrupted:\n       - \\ref SCIP_STAGE_PROBLEM\n\n  @note sourcescip stage does not get changed\n\n  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPcopyBenders(
        sourcescip: *mut SCIP,
        targetscip: *mut SCIP,
        varmap: *mut SCIP_HASHMAP,
        threadsafe: ::std::os::raw::c_uint,
        valid: *mut ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " create a problem by copying the problem data of the source SCIP\n\n  @note In a multi thread case, you need to lock the copying procedure from outside with a mutex.\n  @note Do not change the source SCIP environment during the copying process\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if sourcescip is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED\n\n  @pre This method can be called if targetscip is in one of the following stages:\n       - \\ref SCIP_STAGE_INIT\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED\n       - \\ref SCIP_STAGE_FREE\n\n  @post After calling this method targetscip reaches one of the following stages depending on if and when the solution\n        process was interrupted:\n       - \\ref SCIP_STAGE_PROBLEM\n\n  @note sourcescip stage does not get changed\n\n  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPcopyProb(
        sourcescip: *mut SCIP,
        targetscip: *mut SCIP,
        varmap: *mut SCIP_HASHMAP,
        consmap: *mut SCIP_HASHMAP,
        global: ::std::os::raw::c_uint,
        name: *const ::std::os::raw::c_char,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " create a problem by copying the original problem data of the source SCIP\n\n  @note In a multi thread case, you need to lock the copying procedure from outside with a mutex.\n  @note Do not change the source SCIP environment during the copying process\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if sourcescip is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED\n\n  @pre This method can be called if targetscip is in one of the following stages:\n       - \\ref SCIP_STAGE_INIT\n       - \\ref SCIP_STAGE_FREE\n\n  @post After calling this method targetscip reaches one of the following stages depending on if and when the solution\n        process was interrupted:\n       - \\ref SCIP_STAGE_PROBLEM\n\n  @note sourcescip stage does not get changed\n\n  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPcopyOrigProb(
        sourcescip: *mut SCIP,
        targetscip: *mut SCIP,
        varmap: *mut SCIP_HASHMAP,
        consmap: *mut SCIP_HASHMAP,
        name: *const ::std::os::raw::c_char,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " enables constraint compression.\n\n  If constraint compression is enabled, fixed variables will be treated as constants\n  by all constraints that are copied after calling this method.\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if scip is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n\n  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPenableConsCompression(scip: *mut SCIP) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " is constraint compression enabled?\n\n  If constraint compression is enabled, fixed variables can be treated as constants\n  by all constraints that are copied after calling this method.\n\n  @return TRUE if problem constraint compression is enabled, otherwise FALSE\n\n  @pre This method can be called if scip is in one of the following stages:\n      - \\ref SCIP_STAGE_PROBLEM\n      - \\ref SCIP_STAGE_TRANSFORMING\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED\n       - \\ref SCIP_STAGE_EXITSOLVE\n       - \\ref SCIP_STAGE_FREETRANS\n\n  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPisConsCompressionEnabled(scip: *mut SCIP) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " returns copy of the source variable; if there already is a copy of the source variable in the variable hash map,\n  it is just returned as target variable; otherwise, if the variables it not marked as relaxation-only, a new variable\n  will be created and added to the target SCIP; this created variable is added to the variable hash map and returned as target variable;\n  relaxation-only variables are not copied and FALSE is returned in *success\n\n  @note In a multi thread case, you need to lock the copying procedure from outside with a mutex.\n  @note Do not change the source SCIP environment during the copying process\n  @note if a new variable was created, this variable will be added to the target-SCIP, but it is not captured\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if sourcescip is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED\n\n  @pre This method can be called if targetscip is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_SOLVING\n\n  @note targetscip stage does not get changed\n\n  @note sourcescip stage does not get changed\n\n  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPgetVarCopy(
        sourcescip: *mut SCIP,
        targetscip: *mut SCIP,
        sourcevar: *mut SCIP_VAR,
        targetvar: *mut *mut SCIP_VAR,
        varmap: *mut SCIP_HASHMAP,
        consmap: *mut SCIP_HASHMAP,
        global: ::std::os::raw::c_uint,
        success: *mut ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " Copies all active (thus unfixed) variables from source-SCIP, except those that are marked as relaxation only,\n  and adds these variable to the target-SCIP.\n\n  The mapping between these variables are stored in the variable hashmap.\n\n  The target-SCIP has to be in problem creation stage.\n\n  @note the variables are added to the target-SCIP but not captured\n\n  @note In a multi thread case, you need to lock the copying procedure from outside with a mutex.\n  @note Do not change the source SCIP environment during the copying process\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if sourcescip is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED\n\n  @pre This method can be called if targetscip is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n\n  @note sourcescip stage does not get changed\n\n  @note targetscip stage does not get changed\n\n  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPcopyVars(
        sourcescip: *mut SCIP,
        targetscip: *mut SCIP,
        varmap: *mut SCIP_HASHMAP,
        consmap: *mut SCIP_HASHMAP,
        fixedvars: *mut *mut SCIP_VAR,
        fixedvals: *mut f64,
        nfixedvars: ::std::os::raw::c_int,
        global: ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " copies all original variables from source-SCIP and adds these variable to the target-SCIP; the mapping between these\n  variables are stored in the variable hashmap, target-SCIP has to be in problem creation stage, fixed and aggregated\n  variables do not get copied\n\n  @note the variables are added to the target-SCIP but not captured\n\n  @note In a multi thread case, you need to lock the copying procedure from outside with a mutex.\n  @note Do not change the source SCIP environment during the copying process\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if sourcescip is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED\n\n  @pre This method can be called if targetscip is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n\n  @note sourcescip stage does not get changed\n\n  @note targetscip stage does not get changed\n\n  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPcopyOrigVars(
        sourcescip: *mut SCIP,
        targetscip: *mut SCIP,
        varmap: *mut SCIP_HASHMAP,
        consmap: *mut SCIP_HASHMAP,
        fixedvars: *mut *mut SCIP_VAR,
        fixedvals: *mut f64,
        nfixedvars: ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " merges the histories of variables from a source SCIP into a target SCIP. The two data structures should point to\n  different SCIP instances.\n\n  @note the notion of source and target is inverted here; \\p sourcescip usually denotes a copied SCIP instance, whereas\n        \\p targetscip denotes the original instance"]
    pub fn SCIPmergeVariableStatistics(
        sourcescip: *mut SCIP,
        targetscip: *mut SCIP,
        sourcevars: *mut *mut SCIP_VAR,
        targetvars: *mut *mut SCIP_VAR,
        nvars: ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " merges the statistics of NLPIs from a source SCIP into a target SCIP\n\n The two SCIP instances should point to different SCIP instances.\n\n  @note the notion of source and target is inverted here; \\p sourcescip usually denotes a copied SCIP instance, whereas\n        \\p targetscip denotes the original instance"]
    pub fn SCIPmergeNLPIStatistics(
        sourcescip: *mut SCIP,
        targetscip: *mut SCIP,
        reset: ::std::os::raw::c_uint,
    );
}
extern "C" {
    #[doc = " translates a solution from a subscip to the main scip\n\n Variables that are relaxation-only in the master SCIP are set to 0 or the bound closest to 0. Such variables\n are represented as NULL entry in the \\p subvars array.\n\n @note This method allocates a new solution of the main \\p scip that needs to be freed by the user."]
    pub fn SCIPtranslateSubSol(
        scip: *mut SCIP,
        subscip: *mut SCIP,
        subsol: *mut SCIP_SOL,
        heur: *mut SCIP_HEUR,
        subvars: *mut *mut SCIP_VAR,
        newsol: *mut *mut SCIP_SOL,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " checks the solutions from the subscip and adds the first one that is found feasible to the master SCIP\n\n Variables that are relaxation-only in the master SCIP are set to 0 or the bound closest to 0. Such variables\n are represented as NULL entry in the \\p subvars array."]
    pub fn SCIPtranslateSubSols(
        scip: *mut SCIP,
        subscip: *mut SCIP,
        heur: *mut SCIP_HEUR,
        subvars: *mut *mut SCIP_VAR,
        success: *mut ::std::os::raw::c_uint,
        solindex: *mut ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " returns copy of the source constraint; if there already is a copy of the source constraint in the constraint hash\n  map, it is just returned as target constraint; elsewise a new constraint will be created; this created constraint is\n  added to the constraint hash map and returned as target constraint; the variable map is used to map the variables of\n  the source SCIP to the variables of the target SCIP\n\n  @warning If a constraint is marked to be checked for feasibility but not to be enforced, a LP or pseudo solution may\n           be declared feasible even if it violates this particular constraint.  This constellation should only be\n           used, if no LP or pseudo solution can violate the constraint -- e.g. if a local constraint is redundant due\n           to the variable's local bounds.\n\n  @note The constraint is not added to the target SCIP. You can check whether a constraint is added by calling\n        SCIPconsIsAdded(). (If you mix SCIPgetConsCopy() with SCIPcopyConss() you should pay attention to what you add\n        explicitly and what is already added.)\n\n  @note The constraint is always captured, either during the creation of the copy or after finding the copy of the\n        constraint in the constraint hash map\n\n  @note In a multi thread case, you need to lock the copying procedure from outside with a mutex.\n  @note Do not change the source SCIP environment during the copying process\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if sourcescip is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED\n\n  @pre This method can be called if targetscip is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMING\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_EXITSOLVE\n\n  @note sourcescip stage does not get changed\n\n  @note targetscip stage does not get changed\n\n  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPgetConsCopy(
        sourcescip: *mut SCIP,
        targetscip: *mut SCIP,
        sourcecons: *mut SCIP_CONS,
        targetcons: *mut *mut SCIP_CONS,
        sourceconshdlr: *mut SCIP_CONSHDLR,
        varmap: *mut SCIP_HASHMAP,
        consmap: *mut SCIP_HASHMAP,
        name: *const ::std::os::raw::c_char,
        initial: ::std::os::raw::c_uint,
        separate: ::std::os::raw::c_uint,
        enforce: ::std::os::raw::c_uint,
        check: ::std::os::raw::c_uint,
        propagate: ::std::os::raw::c_uint,
        local: ::std::os::raw::c_uint,
        modifiable: ::std::os::raw::c_uint,
        dynamic: ::std::os::raw::c_uint,
        removable: ::std::os::raw::c_uint,
        stickingatnode: ::std::os::raw::c_uint,
        global: ::std::os::raw::c_uint,
        valid: *mut ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " copies constraints from the source-SCIP and adds these to the target-SCIP; for mapping the\n  variables between the source and the target SCIP a hash map can be given; if the variable hash\n  map is NULL or necessary variable mapping is missing, the required variables are created in the\n  target-SCIP and added to the hash map, if not NULL; all variables which are created are added to\n  the target-SCIP but not (user) captured; if the constraint hash map is not NULL the mapping\n  between the constraints of the source and target-SCIP is stored\n\n  *valid is set to TRUE iff all constraints that are marked as checked or enforced were copied successfully.\n  If other constraints could not be copied, *valid can still be set to TRUE.\n\n  @note the constraints are added to the target-SCIP but are not (user) captured in the target SCIP. (If you mix\n        SCIPgetConsCopy() with SCIPcopyConss() you should pay attention to what you add explicitly and what is already\n        added.) You can check whether a constraint is added by calling SCIPconsIsAdded().\n\n  @note In a multi thread case, you need to lock the copying procedure from outside with a mutex.\n  @note Do not change the source SCIP environment during the copying process\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if sourcescip is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED\n\n  @pre This method can be called if targetscip is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n\n  @note sourcescip stage does not get changed\n\n  @note targetscip stage does not get changed\n\n  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPcopyConss(
        sourcescip: *mut SCIP,
        targetscip: *mut SCIP,
        varmap: *mut SCIP_HASHMAP,
        consmap: *mut SCIP_HASHMAP,
        global: ::std::os::raw::c_uint,
        enablepricing: ::std::os::raw::c_uint,
        valid: *mut ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " copies all original constraints from the source-SCIP and adds these to the target-SCIP; for mapping the\n  variables between the source and the target SCIP a hash map can be given; if the variable hash\n  map is NULL or necessary variable mapping is missing, the required variables are created in the\n  target-SCIP and added to the hash map, if not NULL; all variables which are created are added to\n  the target-SCIP but not (user) captured; if the constraint hash map is not NULL the mapping\n  between the constraints of the source and target-SCIP is stored\n\n  @note the constraints are added to the target-SCIP but are not (user) captured in the target SCIP. (If you mix\n        SCIPgetConsCopy() with SCIPcopyConss() you should pay attention to what you add explicitly and what is already\n        added.) You can check whether a constraint is added by calling SCIPconsIsAdded().\n\n  @note In a multi thread case, you need to lock the copying procedure from outside with a mutex.\n  @note Do not change the source SCIP environment during the copying process\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if sourcescip is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED\n\n  @pre This method can be called if targetscip is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n\n  @note sourcescip stage does not get changed\n\n  @note targetscip stage does not get changed\n\n  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPcopyOrigConss(
        sourcescip: *mut SCIP,
        targetscip: *mut SCIP,
        varmap: *mut SCIP_HASHMAP,
        consmap: *mut SCIP_HASHMAP,
        enablepricing: ::std::os::raw::c_uint,
        valid: *mut ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " convert all active cuts from cutpool to linear constraints\n\n  @note Do not change the source SCIP environment during the copying process\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_EXITSOLVE\n\n  @note SCIP stage does not get changed\n\n  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPconvertCutsToConss(
        scip: *mut SCIP,
        varmap: *mut SCIP_HASHMAP,
        consmap: *mut SCIP_HASHMAP,
        global: ::std::os::raw::c_uint,
        ncutsadded: *mut ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " copies all active cuts from cutpool of sourcescip to linear constraints in targetscip\n\n  Cuts that contain variables that are marked as relaxation-only are skipped.\n\n  @note In a multi thread case, you need to lock the copying procedure from outside with a mutex.\n  @note Do not change the source SCIP environment during the copying process\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if sourcescip is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED\n       - \\ref SCIP_STAGE_EXITSOLVE\n\n  @pre This method can be called if targetscip is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_EXITSOLVE\n\n  @note sourcescip stage does not get changed\n\n  @note targetscip stage does not get changed\n\n  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPcopyCuts(
        sourcescip: *mut SCIP,
        targetscip: *mut SCIP,
        varmap: *mut SCIP_HASHMAP,
        consmap: *mut SCIP_HASHMAP,
        global: ::std::os::raw::c_uint,
        ncutsadded: *mut ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " copies all active conflicts from the conflict pool of sourcescip and adds them as linear constraints to targetscip\n\n  @note In a multi thread case, you need to lock the copying procedure from outside with a mutex.\n  @note Do not change the source SCIP environment during the copying process\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if sourcescip is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED\n       - \\ref SCIP_STAGE_EXITSOLVE\n\n  @pre This method can be called if targetscip is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_EXITSOLVE\n\n  @note sourcescip stage does not change\n\n  @note targetscip stage does not change\n\n  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPcopyConflicts(
        sourcescip: *mut SCIP,
        targetscip: *mut SCIP,
        varmap: *mut SCIP_HASHMAP,
        consmap: *mut SCIP_HASHMAP,
        global: ::std::os::raw::c_uint,
        enablepricing: ::std::os::raw::c_uint,
        valid: *mut ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " copies implications and cliques of sourcescip to targetscip\n\n  This function should be called for a targetscip in transformed stage. It can save time in presolving of the\n  targetscip, since implications and cliques are copied.\n\n  @note In a multi thread case, you need to lock the copying procedure from outside with a mutex.\n  @note Do not change the source SCIP environment during the copying process\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if sourcescip is in one of the following stages:\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED\n       - \\ref SCIP_STAGE_EXITSOLVE\n\n  @pre This method can be called if targetscip is in one of the following stages:\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n\n  @note sourcescip stage does not get changed\n\n  @note targetscip stage does not get changed\n\n  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPcopyImplicationsCliques(
        sourcescip: *mut SCIP,
        targetscip: *mut SCIP,
        varmap: *mut SCIP_HASHMAP,
        consmap: *mut SCIP_HASHMAP,
        global: ::std::os::raw::c_uint,
        infeasible: *mut ::std::os::raw::c_uint,
        nbdchgs: *mut ::std::os::raw::c_int,
        ncopied: *mut ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " copies parameter settings from sourcescip to targetscip\n\n  @note In a multi thread case, you need to lock the copying procedure from outside with a mutex.\n  @note Do not change the source SCIP environment during the copying process\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if sourcescip is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED\n\n  @pre This method can be called if targetscip is in one of the following stages:\n       - \\ref SCIP_STAGE_INIT\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_FREE\n\n  @note sourcescip stage does not get changed\n\n  @note targetscip stage does not get changed\n\n  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPcopyParamSettings(sourcescip: *mut SCIP, targetscip: *mut SCIP) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " gets depth of current scip instance (increased by each copy call)\n\n  @return Depth of subscip of SCIP is returned.\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMING\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED\n       - \\ref SCIP_STAGE_EXITSOLVE\n       - \\ref SCIP_STAGE_FREETRANS\n\n  @note SCIP stage does not get changed\n\n  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPgetSubscipDepth(scip: *mut SCIP) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " sets depth of scip instance\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n\n  @note SCIP stage does not get changed\n\n  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPsetSubscipDepth(scip: *mut SCIP, newdepth: ::std::os::raw::c_int);
}
extern "C" {
    #[doc = " copies source SCIP to target SCIP; the copying process is done in the following order:\n  1) copy the plugins\n  2) copy the settings\n  3) create problem data in target-SCIP and copy the problem data of the source-SCIP\n  4) copy all active variables except those are marked as relaxation-only\n  5) copy all constraints\n\n  The source problem depends on the stage of the \\p sourcescip - In SCIP_STAGE_PROBLEM, the original problem is copied,\n  otherwise, the transformed problem is copied. For an explicit copy of the original problem, use SCIPcopyOrig().\n\n  @note all variables and constraints which are created in the target-SCIP are not (user) captured\n\n  @note In a multi thread case, you need to lock the copying procedure from outside with a mutex.\n        Also, 'passmessagehdlr' should be set to FALSE.\n  @note the 'threadsafe' parameter should only be set to TRUE if you are absolutely certain that the source and target\n        SCIP instances will be solved in parallel. The usual case is to set this to FALSE, since thread safety\n        typically incurs a performance cost.\n  @note Do not change the source SCIP environment during the copying process\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if sourcescip is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED\n\n  @pre This method can be called if targetscip is in one of the following stages:\n       - \\ref SCIP_STAGE_INIT\n       - \\ref SCIP_STAGE_FREE\n\n  @note sourcescip stage does not get changed\n\n  @note targetscip stage does not get changed\n\n  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPcopy(
        sourcescip: *mut SCIP,
        targetscip: *mut SCIP,
        varmap: *mut SCIP_HASHMAP,
        consmap: *mut SCIP_HASHMAP,
        suffix: *const ::std::os::raw::c_char,
        global: ::std::os::raw::c_uint,
        enablepricing: ::std::os::raw::c_uint,
        threadsafe: ::std::os::raw::c_uint,
        passmessagehdlr: ::std::os::raw::c_uint,
        valid: *mut ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " copies source SCIP to target SCIP but compresses constraints\n\n  constraint compression is performed by removing fixed variables immediately\n  during constraint creation if the involved constraint handlers support\n  compression\n\n  the copying process is done in the following order:\n  1) copy the plugins\n  2) copy the settings\n  3) create problem data in target-SCIP and copy the problem data of the source-SCIP\n  4) copy all active variables except those are marked as relaxation-only\n     a) fix all variable copies specified by \\p fixedvars, \\p fixedvals, and \\p nfixedvars\n     b) enable constraint compression\n  5) copy all constraints\n\n The source problem depends on the stage of the \\p sourcescip - In SCIP_STAGE_PROBLEM, the original problem is copied,\n otherwise, the transformed problem is copied. For an explicit copy of the original problem, use SCIPcopyOrigConsCompression().\n\n  @note: in case that a combination of local bounds and explicit fixing values should be used,\n         the fixing value of a variable is preferred if local bounds and fixing value disagree.\n\n  @note all variables and constraints which are created in the target-SCIP are not (user) captured\n\n  @note In a multi thread case, you need to lock the copying procedure from outside with a mutex.\n        Also, 'passmessagehdlr' should be set to FALSE.\n  @note the 'threadsafe' parameter should only be set to TRUE if you are absolutely certain that the source and target\n        SCIP instances will be solved in parallel. The usual case is to set this to FALSE, since thread safety\n        typically incurs a performance cost.\n  @note Do not change the source SCIP environment during the copying process\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if sourcescip is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED\n\n  @pre This method can be called if targetscip is in one of the following stages:\n       - \\ref SCIP_STAGE_INIT\n       - \\ref SCIP_STAGE_FREE\n\n  @note sourcescip stage does not get changed\n\n  @note targetscip stage does not get changed\n\n  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPcopyConsCompression(
        sourcescip: *mut SCIP,
        targetscip: *mut SCIP,
        varmap: *mut SCIP_HASHMAP,
        consmap: *mut SCIP_HASHMAP,
        suffix: *const ::std::os::raw::c_char,
        fixedvars: *mut *mut SCIP_VAR,
        fixedvals: *mut f64,
        nfixedvars: ::std::os::raw::c_int,
        global: ::std::os::raw::c_uint,
        enablepricing: ::std::os::raw::c_uint,
        threadsafe: ::std::os::raw::c_uint,
        passmessagehdlr: ::std::os::raw::c_uint,
        valid: *mut ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " copies source SCIP original problem to target SCIP; the copying process is done in the following order:\n  1) copy the plugins\n  2) copy the settings\n  3) create problem data in target-SCIP and copy the original problem data of the source-SCIP\n  4) copy all original variables\n  5) copy all original constraints\n\n  @note all variables and constraints which are created in the target-SCIP are not (user) captured\n\n  @note In a multi thread case, you need to lock the copying procedure from outside with a mutex.\n        Also, 'passmessagehdlr' should be set to FALSE.\n  @note the 'threadsafe' parameter should only be set to TRUE if you are absolutely certain that the source and target\n        SCIP instances will be solved in parallel. The usual case is to set this to FALSE, since thread safety\n        typically incurs a performance cost.\n  @note Do not change the source SCIP environment during the copying process\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if sourcescip is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED\n\n  @pre This method can be called if targetscip is in one of the following stages:\n       - \\ref SCIP_STAGE_INIT\n       - \\ref SCIP_STAGE_FREE\n\n  @note sourcescip stage does not get changed\n\n  @note targetscip stage does not get changed\n\n  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPcopyOrig(
        sourcescip: *mut SCIP,
        targetscip: *mut SCIP,
        varmap: *mut SCIP_HASHMAP,
        consmap: *mut SCIP_HASHMAP,
        suffix: *const ::std::os::raw::c_char,
        enablepricing: ::std::os::raw::c_uint,
        threadsafe: ::std::os::raw::c_uint,
        passmessagehdlr: ::std::os::raw::c_uint,
        valid: *mut ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " copies source SCIP original problem to target SCIP but compresses constraints\n\n  constraint compression is performed by removing fixed variables immediately\n  during constraint creation if the involved constraint handlers support\n  compression\n\n  the copying process is done in the following order:\n  1) copy the plugins\n  2) copy the settings\n  3) create problem data in target-SCIP and copy the problem data of the source-SCIP\n  4) copy all original variables\n     a) fix all variable copies specified by \\p fixedvars, \\p fixedvals, and \\p nfixedvars\n     b) enable constraint compression\n  5) copy all constraints\n\n  @note all variables and constraints which are created in the target-SCIP are not (user) captured\n\n  @note In a multi thread case, you need to lock the copying procedure from outside with a mutex.\n        Also, 'passmessagehdlr' should be set to FALSE.\n  @note the 'threadsafe' parameter should only be set to TRUE if you are absolutely certain that the source and target\n        SCIP instances will be solved in parallel. The usual case is to set this to FALSE, since thread safety\n        typically incurs a performance cost.\n  @note Do not change the source SCIP environment during the copying process\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if sourcescip is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED\n\n  @pre This method can be called if targetscip is in one of the following stages:\n       - \\ref SCIP_STAGE_INIT\n       - \\ref SCIP_STAGE_FREE\n\n  @note sourcescip stage does not get changed\n\n  @note targetscip stage does not get changed\n\n  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPcopyOrigConsCompression(
        sourcescip: *mut SCIP,
        targetscip: *mut SCIP,
        varmap: *mut SCIP_HASHMAP,
        consmap: *mut SCIP_HASHMAP,
        suffix: *const ::std::os::raw::c_char,
        fixedvars: *mut *mut SCIP_VAR,
        fixedvals: *mut f64,
        nfixedvars: ::std::os::raw::c_int,
        enablepricing: ::std::os::raw::c_uint,
        threadsafe: ::std::os::raw::c_uint,
        passmessagehdlr: ::std::os::raw::c_uint,
        valid: *mut ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " checks if there is enough time and memory left for copying the sourcescip into a sub-SCIP and solve the sub-SCIP\n\n  This is the case if the time and memory limit that would be passed to the sub-SCIP are larger than 0.0\n\n  @pre This method can be called if sourcescip is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED\n\n  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPcheckCopyLimits(
        sourcescip: *mut SCIP,
        success: *mut ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " copies limits from source SCIP to target SCIP\n\n  @note time and memory limit are reduced by the amount already spent in the source SCIP before installing the limit\n        in the target SCIP\n  @note all other limits are disabled and need to be enabled afterwards, if needed\n\n  @see SCIPsetCommonSubscipParams() to set further working limits and other parameters commonly used for auxiliary problems\n\n  @pre This method can be called if sourcescip is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED\n\n  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPcopyLimits(sourcescip: *mut SCIP, targetscip: *mut SCIP) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " sets the working limits as well as common search parameters for the auxiliary problem\n\n  @note memory and time limits are not affected, and must be set using SCIPcopyLimits() instead"]
    pub fn SCIPsetCommonSubscipParams(
        sourcescip: *mut SCIP,
        subscip: *mut SCIP,
        nsubnodes: ::std::os::raw::c_longlong,
        nstallnodes: ::std::os::raw::c_longlong,
        bestsollimit: ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " returns row's cutoff distance in the direction of the given primal solution\n\n  @return the cutoff distance of the cut with respect to the LP solution in the direction of the given primal solution\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPgetCutLPSolCutoffDistance(
        scip: *mut SCIP,
        sol: *mut SCIP_SOL,
        cut: *mut SCIP_ROW,
    ) -> f64;
}
extern "C" {
    #[doc = " returns efficacy of the cut with respect to the given primal solution or the current LP solution:\n  e = -feasibility/norm\n\n  @return the efficacy of the cut with respect to the given primal solution or the current LP solution:\n          e = -feasibility/norm\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPgetCutEfficacy(scip: *mut SCIP, sol: *mut SCIP_SOL, cut: *mut SCIP_ROW) -> f64;
}
extern "C" {
    #[doc = " returns whether the cut's efficacy with respect to the given primal solution or the current LP solution is greater\n  than the minimal cut efficacy\n\n  @return TRUE if the cut's efficacy with respect to the given primal solution or the current LP solution is greater\n          than the minimal cut efficacy, otherwise FALSE\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPisCutEfficacious(
        scip: *mut SCIP,
        sol: *mut SCIP_SOL,
        cut: *mut SCIP_ROW,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " checks, if the given cut's efficacy is larger than the minimal cut efficacy\n\n  @return TRUE if the given cut's efficacy is larger than the minimal cut efficacy, otherwise FALSE"]
    pub fn SCIPisEfficacious(scip: *mut SCIP, efficacy: f64) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " calculates the efficacy norm of the given vector, which depends on the \"separating/efficacynorm\" parameter\n\n  @return the efficacy norm of the given vector, which depends on the \"separating/efficacynorm\" parameter"]
    pub fn SCIPgetVectorEfficacyNorm(
        scip: *mut SCIP,
        vals: *mut f64,
        nvals: ::std::os::raw::c_int,
    ) -> f64;
}
extern "C" {
    #[doc = " indicates whether a cut is applicable\n\n  If the cut has only one variable and this method returns FALSE, it may\n  still be possible that the cut can be added to the LP (as a row instead\n  of a boundchange), but it will be a very weak cut. The user is asked\n  to avoid such cuts.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_SOLVING\n\n  @return whether the cut is modifiable, not a bound change, or a bound change that changes bounds by at least epsilon"]
    pub fn SCIPisCutApplicable(scip: *mut SCIP, cut: *mut SCIP_ROW) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " adds cut to separation storage\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_SOLVING\n\n  @deprecated Please use SCIPaddRow() instead, or, if the row is a global cut and it might be useful to keep it for future use,\n  consider adding it to the global cutpool with SCIPaddPoolCut()."]
    pub fn SCIPaddCut(
        scip: *mut SCIP,
        sol: *mut SCIP_SOL,
        cut: *mut SCIP_ROW,
        forcecut: ::std::os::raw::c_uint,
        infeasible: *mut ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " adds row to separation storage\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPaddRow(
        scip: *mut SCIP,
        row: *mut SCIP_ROW,
        forcecut: ::std::os::raw::c_uint,
        infeasible: *mut ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " checks if cut is already existing in global cutpool\n\n  @return TRUE is returned if the cut is not already existing in the global cutpool, FALSE otherwise\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPisCutNew(scip: *mut SCIP, row: *mut SCIP_ROW) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " if not already existing, adds row to global cut pool\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPaddPoolCut(scip: *mut SCIP, row: *mut SCIP_ROW) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " removes the row from the global cut pool\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPdelPoolCut(scip: *mut SCIP, row: *mut SCIP_ROW) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " gets current cuts in the global cut pool\n\n  @return the current cuts in the global cut pool\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED\n       - \\ref SCIP_STAGE_EXITSOLVE"]
    pub fn SCIPgetPoolCuts(scip: *mut SCIP) -> *mut *mut SCIP_CUT;
}
extern "C" {
    #[doc = " gets current number of rows in the global cut pool\n\n  @return the current number of rows in the global cut pool\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED\n       - \\ref SCIP_STAGE_EXITSOLVE"]
    pub fn SCIPgetNPoolCuts(scip: *mut SCIP) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " gets the global cut pool used by SCIP\n\n  @return the global cut pool used by SCIP\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED\n       - \\ref SCIP_STAGE_EXITSOLVE"]
    pub fn SCIPgetGlobalCutpool(scip: *mut SCIP) -> *mut SCIP_CUTPOOL;
}
extern "C" {
    #[doc = " creates a cut pool\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_TRANSFORMING\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPcreateCutpool(
        scip: *mut SCIP,
        cutpool: *mut *mut SCIP_CUTPOOL,
        agelimit: ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " frees a cut pool\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_TRANSFORMING\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED\n       - \\ref SCIP_STAGE_EXITSOLVE\n       - \\ref SCIP_STAGE_FREETRANS"]
    pub fn SCIPfreeCutpool(scip: *mut SCIP, cutpool: *mut *mut SCIP_CUTPOOL) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " if not already existing, adds row to a cut pool and captures it\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPaddRowCutpool(
        scip: *mut SCIP,
        cutpool: *mut SCIP_CUTPOOL,
        row: *mut SCIP_ROW,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " adds row to a cut pool and captures it; doesn't check for multiple cuts\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPaddNewRowCutpool(
        scip: *mut SCIP,
        cutpool: *mut SCIP_CUTPOOL,
        row: *mut SCIP_ROW,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " removes the LP row from a cut pool\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPdelRowCutpool(
        scip: *mut SCIP,
        cutpool: *mut SCIP_CUTPOOL,
        row: *mut SCIP_ROW,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " separates cuts from a cut pool\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPseparateCutpool(
        scip: *mut SCIP,
        cutpool: *mut SCIP_CUTPOOL,
        result: *mut SCIP_RESULT,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " separates cuts w.r.t. given solution from a cut pool\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPseparateSolCutpool(
        scip: *mut SCIP,
        cutpool: *mut SCIP_CUTPOOL,
        sol: *mut SCIP_SOL,
        pretendroot: ::std::os::raw::c_uint,
        result: *mut SCIP_RESULT,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " if not already existing, adds row to the delayed global cut pool\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is the stages \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPaddDelayedPoolCut(scip: *mut SCIP, row: *mut SCIP_ROW) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " removes the row from the delayed global cut pool\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is the stages \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPdelDelayedPoolCut(scip: *mut SCIP, row: *mut SCIP_ROW) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " gets current cuts in the delayed global cut pool\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is the stages \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPgetDelayedPoolCuts(scip: *mut SCIP) -> *mut *mut SCIP_CUT;
}
extern "C" {
    #[doc = " gets current number of rows in the delayed global cut pool\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is the stages \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPgetNDelayedPoolCuts(scip: *mut SCIP) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " gets the delayed global cut pool used by SCIP\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is the stages \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPgetDelayedGlobalCutpool(scip: *mut SCIP) -> *mut SCIP_CUTPOOL;
}
extern "C" {
    #[doc = " separates the given primal solution or the current LP solution by calling the separators and constraint handlers'\n  separation methods;\n  the generated cuts are stored in the separation storage and can be accessed with the methods SCIPgetCuts() and\n  SCIPgetNCuts();\n  after evaluating the cuts, you have to call SCIPclearCuts() in order to remove the cuts from the\n  separation storage;\n  it is possible to call SCIPseparateSol() multiple times with different solutions and evaluate the found cuts\n  afterwards\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPseparateSol(
        scip: *mut SCIP,
        sol: *mut SCIP_SOL,
        pretendroot: ::std::os::raw::c_uint,
        allowlocal: ::std::os::raw::c_uint,
        onlydelayed: ::std::os::raw::c_uint,
        delayed: *mut ::std::os::raw::c_uint,
        cutoff: *mut ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " gets the array of cuts currently stored in the separation storage\n\n  @return the array of cuts currently stored in the separation storage\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPgetCuts(scip: *mut SCIP) -> *mut *mut SCIP_ROW;
}
extern "C" {
    #[doc = " get current number of cuts in the separation storage\n\n  @return the current number of cuts in the separation storage\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPgetNCuts(scip: *mut SCIP) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " clears the separation storage\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPclearCuts(scip: *mut SCIP) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " removes cuts that are inefficacious w.r.t. the current LP solution from separation storage without adding the cuts to the LP\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPremoveInefficaciousCuts(scip: *mut SCIP) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " creates a dynamic array of real values\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    pub fn SCIPcreateRealarray(
        scip: *mut SCIP,
        realarray: *mut *mut SCIP_REALARRAY,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " frees a dynamic array of real values\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    pub fn SCIPfreeRealarray(scip: *mut SCIP, realarray: *mut *mut SCIP_REALARRAY) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " extends dynamic array to be able to store indices from minidx to maxidx\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    pub fn SCIPextendRealarray(
        scip: *mut SCIP,
        realarray: *mut SCIP_REALARRAY,
        minidx: ::std::os::raw::c_int,
        maxidx: ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " clears a dynamic real array\n\n  @return clears a dynamic real array"]
    pub fn SCIPclearRealarray(scip: *mut SCIP, realarray: *mut SCIP_REALARRAY) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " gets value of entry in dynamic array"]
    pub fn SCIPgetRealarrayVal(
        scip: *mut SCIP,
        realarray: *mut SCIP_REALARRAY,
        idx: ::std::os::raw::c_int,
    ) -> f64;
}
extern "C" {
    #[doc = " sets value of entry in dynamic array\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    pub fn SCIPsetRealarrayVal(
        scip: *mut SCIP,
        realarray: *mut SCIP_REALARRAY,
        idx: ::std::os::raw::c_int,
        val: f64,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " increases value of entry in dynamic array\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    pub fn SCIPincRealarrayVal(
        scip: *mut SCIP,
        realarray: *mut SCIP_REALARRAY,
        idx: ::std::os::raw::c_int,
        incval: f64,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " returns the minimal index of all stored non-zero elements\n\n  @return the minimal index of all stored non-zero elements"]
    pub fn SCIPgetRealarrayMinIdx(
        scip: *mut SCIP,
        realarray: *mut SCIP_REALARRAY,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " returns the maximal index of all stored non-zero elements\n\n  @return the maximal index of all stored non-zero elements"]
    pub fn SCIPgetRealarrayMaxIdx(
        scip: *mut SCIP,
        realarray: *mut SCIP_REALARRAY,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " creates a dynamic array of int values\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    pub fn SCIPcreateIntarray(scip: *mut SCIP, intarray: *mut *mut SCIP_INTARRAY) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " frees a dynamic array of int values\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    pub fn SCIPfreeIntarray(scip: *mut SCIP, intarray: *mut *mut SCIP_INTARRAY) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " extends dynamic array to be able to store indices from minidx to maxidx\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    pub fn SCIPextendIntarray(
        scip: *mut SCIP,
        intarray: *mut SCIP_INTARRAY,
        minidx: ::std::os::raw::c_int,
        maxidx: ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " clears a dynamic int array\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    pub fn SCIPclearIntarray(scip: *mut SCIP, intarray: *mut SCIP_INTARRAY) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " gets value of entry in dynamic array\n\n  @return value of entry in dynamic array"]
    pub fn SCIPgetIntarrayVal(
        scip: *mut SCIP,
        intarray: *mut SCIP_INTARRAY,
        idx: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " sets value of entry in dynamic array\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    pub fn SCIPsetIntarrayVal(
        scip: *mut SCIP,
        intarray: *mut SCIP_INTARRAY,
        idx: ::std::os::raw::c_int,
        val: ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " increases value of entry in dynamic array\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    pub fn SCIPincIntarrayVal(
        scip: *mut SCIP,
        intarray: *mut SCIP_INTARRAY,
        idx: ::std::os::raw::c_int,
        incval: ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " returns the minimal index of all stored non-zero elements\n\n  @return the minimal index of all stored non-zero elements"]
    pub fn SCIPgetIntarrayMinIdx(
        scip: *mut SCIP,
        intarray: *mut SCIP_INTARRAY,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " returns the maximal index of all stored non-zero elements\n\n  @return the maximal index of all stored non-zero elements"]
    pub fn SCIPgetIntarrayMaxIdx(
        scip: *mut SCIP,
        intarray: *mut SCIP_INTARRAY,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " creates a dynamic array of bool values\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    pub fn SCIPcreateBoolarray(
        scip: *mut SCIP,
        boolarray: *mut *mut SCIP_BOOLARRAY,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " frees a dynamic array of bool values\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    pub fn SCIPfreeBoolarray(scip: *mut SCIP, boolarray: *mut *mut SCIP_BOOLARRAY) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " extends dynamic array to be able to store indices from minidx to maxidx\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    pub fn SCIPextendBoolarray(
        scip: *mut SCIP,
        boolarray: *mut SCIP_BOOLARRAY,
        minidx: ::std::os::raw::c_int,
        maxidx: ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " clears a dynamic bool array\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    pub fn SCIPclearBoolarray(scip: *mut SCIP, boolarray: *mut SCIP_BOOLARRAY) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " gets value of entry in dynamic array\n\n  @return value of entry in dynamic array at position idx"]
    pub fn SCIPgetBoolarrayVal(
        scip: *mut SCIP,
        boolarray: *mut SCIP_BOOLARRAY,
        idx: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " sets value of entry in dynamic array\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    pub fn SCIPsetBoolarrayVal(
        scip: *mut SCIP,
        boolarray: *mut SCIP_BOOLARRAY,
        idx: ::std::os::raw::c_int,
        val: ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " returns the minimal index of all stored non-zero elements\n\n  @return the minimal index of all stored non-zero elements"]
    pub fn SCIPgetBoolarrayMinIdx(
        scip: *mut SCIP,
        boolarray: *mut SCIP_BOOLARRAY,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " returns the maximal index of all stored non-zero elements\n\n  @return the maximal index of all stored non-zero elements"]
    pub fn SCIPgetBoolarrayMaxIdx(
        scip: *mut SCIP,
        boolarray: *mut SCIP_BOOLARRAY,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " creates a dynamic array of pointers\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    pub fn SCIPcreatePtrarray(scip: *mut SCIP, ptrarray: *mut *mut SCIP_PTRARRAY) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " frees a dynamic array of pointers\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    pub fn SCIPfreePtrarray(scip: *mut SCIP, ptrarray: *mut *mut SCIP_PTRARRAY) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " extends dynamic array to be able to store indices from minidx to maxidx\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    pub fn SCIPextendPtrarray(
        scip: *mut SCIP,
        ptrarray: *mut SCIP_PTRARRAY,
        minidx: ::std::os::raw::c_int,
        maxidx: ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " clears a dynamic pointer array\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    pub fn SCIPclearPtrarray(scip: *mut SCIP, ptrarray: *mut SCIP_PTRARRAY) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " gets value of entry in dynamic array"]
    pub fn SCIPgetPtrarrayVal(
        scip: *mut SCIP,
        ptrarray: *mut SCIP_PTRARRAY,
        idx: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " sets value of entry in dynamic array\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    pub fn SCIPsetPtrarrayVal(
        scip: *mut SCIP,
        ptrarray: *mut SCIP_PTRARRAY,
        idx: ::std::os::raw::c_int,
        val: *mut ::std::os::raw::c_void,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " returns the minimal index of all stored non-zero elements\n\n  @return the minimal index of all stored non-zero elements"]
    pub fn SCIPgetPtrarrayMinIdx(
        scip: *mut SCIP,
        ptrarray: *mut SCIP_PTRARRAY,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " returns the maximal index of all stored non-zero elements\n\n  @return the maximal index of all stored non-zero elements"]
    pub fn SCIPgetPtrarrayMaxIdx(
        scip: *mut SCIP,
        ptrarray: *mut SCIP_PTRARRAY,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " creates a disjoint set (union find) structure \\p djset for \\p ncomponents many components (of size one)"]
    pub fn SCIPcreateDisjointset(
        scip: *mut SCIP,
        djset: *mut *mut SCIP_DISJOINTSET,
        ncomponents: ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " frees the disjoint set (union find) data structure"]
    pub fn SCIPfreeDisjointset(scip: *mut SCIP, djset: *mut *mut SCIP_DISJOINTSET);
}
extern "C" {
    #[doc = " creates directed graph structure"]
    pub fn SCIPcreateDigraph(
        scip: *mut SCIP,
        digraph: *mut *mut SCIP_DIGRAPH,
        nnodes: ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " copies directed graph structure\n\n  The copying procedure uses the memory of the passed SCIP instance. The user must ensure that the digraph lives\n  as most as long as the SCIP instance.\n\n  @note The data in nodedata is copied verbatim. This possibly has to be adapted by the user."]
    pub fn SCIPcopyDigraph(
        scip: *mut SCIP,
        targetdigraph: *mut *mut SCIP_DIGRAPH,
        sourcedigraph: *mut SCIP_DIGRAPH,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " enable debug solution mechanism\n\n  the debug solution mechanism allows to trace back the invalidation of\n  a debug solution during the solution process of SCIP. It must be explicitly\n  enabled for the SCIP data structure.\n\n  @see debug.h for more information on debug solution mechanism"]
    pub fn SCIPenableDebugSol(scip: *mut SCIP);
}
extern "C" {
    #[doc = " disable solution debugging mechanism\n\n  @see debug.h for more information on debug solution mechanism"]
    pub fn SCIPdisableDebugSol(scip: *mut SCIP);
}
extern "C" {
    #[doc = " creates a decomposition"]
    pub fn SCIPcreateDecomp(
        scip: *mut SCIP,
        decomp: *mut *mut SCIP_DECOMP,
        nblocks: ::std::os::raw::c_int,
        original: ::std::os::raw::c_uint,
        benderslabels: ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " frees a decomposition"]
    pub fn SCIPfreeDecomp(scip: *mut SCIP, decomp: *mut *mut SCIP_DECOMP);
}
extern "C" {
    #[doc = " adds decomposition to SCIP"]
    pub fn SCIPaddDecomp(scip: *mut SCIP, decomp: *mut SCIP_DECOMP) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " gets available user decompositions for either the original or transformed problem"]
    pub fn SCIPgetDecomps(
        scip: *mut SCIP,
        decomps: *mut *mut *mut SCIP_DECOMP,
        ndecomps: *mut ::std::os::raw::c_int,
        original: ::std::os::raw::c_uint,
    );
}
extern "C" {
    #[doc = " returns TRUE if the constraint \\p cons contains only linking variables in decomposition \\p decomp"]
    pub fn SCIPhasConsOnlyLinkVars(
        scip: *mut SCIP,
        decomp: *mut SCIP_DECOMP,
        cons: *mut SCIP_CONS,
        hasonlylinkvars: *mut ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " computes constraint labels from variable labels\n\n  Existing labels for the constraints are simply overridden\n\n  The computed labels depend on the flag SCIPdecompUseBendersLabels() of the decomposition. If the flag is set\n  to FALSE, the labeling assigns\n\n  - label i, if only variables labeled i are present in the constraint (and optionally linking variables)\n  - SCIP_DECOMP_LINKCONS, if there are either only variables labeled with SCIP_DECOMP_LINKVAR present, or\n    if there are variables with more than one block label.\n\n  If the flag is set to TRUE, the assignment is the same, unless variables from 2 named blocks occur in the same\n  constraint, which is an invalid labeling for the Benders case."]
    pub fn SCIPcomputeDecompConsLabels(
        scip: *mut SCIP,
        decomp: *mut SCIP_DECOMP,
        conss: *mut *mut SCIP_CONS,
        nconss: ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " creates a decomposition of the variables from a labeling of the constraints\n\n  NOTE: by default, the variable labeling is based on a Dantzig-Wolfe decomposition. This means that constraints in named\n  blocks have have precedence over linking constraints. If a variable exists in constraints from\n  two or more named blocks, then this variable is marked as a linking variable.\n  If a variable occurs in exactly one named block i>=0, it is assigned label i.\n  Variables which are only in linking constraints are unlabeled. However, SCIPdecompGetVarsLabels() will\n  label them as linking variables.\n\n  If the variables should be labeled for the application of Benders' decomposition, the decomposition must be\n  flagged explicitly via SCIPdecompSetUseBendersLabels().\n  With this setting, the presence in linking constraints takes precedence over the presence in named blocks.\n  Now, a variable is considered linking if it is present in at least one linking constraint and an arbitrary\n  number of constraints from named blocks."]
    pub fn SCIPcomputeDecompVarsLabels(
        scip: *mut SCIP,
        decomp: *mut SCIP_DECOMP,
        conss: *mut *mut SCIP_CONS,
        nconss: ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " assigns linking constraints to blocks\n\n Each linking constraint is assigned to the most frequent block among its variables.\n Variables of other blocks are relabeled as linking variables.\n Constraints that have only linking variables are skipped.\n\n @note: In contrast to SCIPcomputeDecompConsLabels(), this method potentially relabels variables."]
    pub fn SCIPassignDecompLinkConss(
        scip: *mut SCIP,
        decomp: *mut SCIP_DECOMP,
        conss: *mut *mut SCIP_CONS,
        nconss: ::std::os::raw::c_int,
        nskipconss: *mut ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " computes decomposition statistics and store them in the decomposition object"]
    pub fn SCIPcomputeDecompStats(
        scip: *mut SCIP,
        decomp: *mut SCIP_DECOMP,
        uselimits: ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " creates and includes dialog\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    pub fn SCIPincludeDialog(
        scip: *mut SCIP,
        dialog: *mut *mut SCIP_DIALOG,
        dialogcopy: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, dialog: *mut SCIP_DIALOG) -> SCIP_RETCODE,
        >,
        dialogexec: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                dialog: *mut SCIP_DIALOG,
                dialoghdlr: *mut SCIP_DIALOGHDLR,
                nextdialog: *mut *mut SCIP_DIALOG,
            ) -> SCIP_RETCODE,
        >,
        dialogdesc: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, dialog: *mut SCIP_DIALOG) -> SCIP_RETCODE,
        >,
        dialogfree: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, dialog: *mut SCIP_DIALOG) -> SCIP_RETCODE,
        >,
        name: *const ::std::os::raw::c_char,
        desc: *const ::std::os::raw::c_char,
        issubmenu: ::std::os::raw::c_uint,
        dialogdata: *mut SCIP_DIALOGDATA,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " returns if the dialog already exists\n\n  @return TRUE is returned if the dialog exists, otherwise FALSE."]
    pub fn SCIPexistsDialog(scip: *mut SCIP, dialog: *mut SCIP_DIALOG) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " captures a dialog\n\n  @return \\ref SCIP_OKAY is returned if everything worked. otherwise a suitable error code is passed. see \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    pub fn SCIPcaptureDialog(scip: *mut SCIP, dialog: *mut SCIP_DIALOG) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " releases a dialog\n\n  @return \\ref SCIP_OKAY is returned if everything worked. otherwise a suitable error code is passed. see \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    pub fn SCIPreleaseDialog(scip: *mut SCIP, dialog: *mut *mut SCIP_DIALOG) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " makes given dialog the root dialog of SCIP's interactive user shell; captures dialog and releases former root dialog\n\n  @return \\ref SCIP_OKAY is returned if everything worked. otherwise a suitable error code is passed. see \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    pub fn SCIPsetRootDialog(scip: *mut SCIP, dialog: *mut SCIP_DIALOG) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " returns the root dialog of SCIP's interactive user shell\n\n  @return the root dialog of SCIP's interactive user shell is returned."]
    pub fn SCIPgetRootDialog(scip: *mut SCIP) -> *mut SCIP_DIALOG;
}
extern "C" {
    #[doc = " adds a sub dialog to the given dialog as menu entry and captures it\n\n  @return \\ref SCIP_OKAY is returned if everything worked. otherwise a suitable error code is passed. see \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    pub fn SCIPaddDialogEntry(
        scip: *mut SCIP,
        dialog: *mut SCIP_DIALOG,
        subdialog: *mut SCIP_DIALOG,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " adds a single line of input which is treated as if the user entered the command line\n\n  @return \\ref SCIP_OKAY is returned if everything worked. otherwise a suitable error code is passed. see \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    pub fn SCIPaddDialogInputLine(
        scip: *mut SCIP,
        inputline: *const ::std::os::raw::c_char,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " adds a single line of input to the command history which can be accessed with the cursor keys\n\n  @return \\ref SCIP_OKAY is returned if everything worked. otherwise a suitable error code is passed. see \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    pub fn SCIPaddDialogHistoryLine(
        scip: *mut SCIP,
        inputline: *const ::std::os::raw::c_char,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " starts interactive mode of SCIP by executing the root dialog\n\n  @return \\ref SCIP_OKAY is returned if everything worked. otherwise a suitable error code is passed. see \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_INIT\n       - \\ref SCIP_STAGE_FREE\n\n  @post After calling this method \\SCIP reaches one of the following stages depending on if and when the\n        interactive shell was closed:\n        - \\ref SCIP_STAGE_PROBLEM if the interactive shell was closed after the problem was created\n        - \\ref SCIP_STAGE_TRANSFORMED if the interactive shell was closed after the problem was transformed\n        - \\ref SCIP_STAGE_PRESOLVING if the interactive shell was closed  during presolving\n        - \\ref SCIP_STAGE_PRESOLVED if the interactive shell was closed after presolve\n        - \\ref SCIP_STAGE_SOLVING if the interactive shell was closed during the tree search\n        - \\ref SCIP_STAGE_SOLVED if the interactive shell was closed after the problem was solved\n        - \\ref SCIP_STAGE_FREE if the interactive shell was closed after the problem was freed\n\n  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPstartInteraction(scip: *mut SCIP) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " creates a display column and includes it in SCIP"]
    pub fn SCIPincludeDisp(
        scip: *mut SCIP,
        name: *const ::std::os::raw::c_char,
        desc: *const ::std::os::raw::c_char,
        header: *const ::std::os::raw::c_char,
        dispstatus: SCIP_DISPSTATUS,
        dispcopy: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, disp: *mut SCIP_DISP) -> SCIP_RETCODE,
        >,
        dispfree: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, disp: *mut SCIP_DISP) -> SCIP_RETCODE,
        >,
        dispinit: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, disp: *mut SCIP_DISP) -> SCIP_RETCODE,
        >,
        dispexit: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, disp: *mut SCIP_DISP) -> SCIP_RETCODE,
        >,
        dispinitsol: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, disp: *mut SCIP_DISP) -> SCIP_RETCODE,
        >,
        dispexitsol: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, disp: *mut SCIP_DISP) -> SCIP_RETCODE,
        >,
        dispoutput: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                disp: *mut SCIP_DISP,
                file: *mut FILE,
            ) -> SCIP_RETCODE,
        >,
        dispdata: *mut SCIP_DISPDATA,
        width: ::std::os::raw::c_int,
        priority: ::std::os::raw::c_int,
        position: ::std::os::raw::c_int,
        stripline: ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " returns the display column of the given name, or NULL if not existing"]
    pub fn SCIPfindDisp(scip: *mut SCIP, name: *const ::std::os::raw::c_char) -> *mut SCIP_DISP;
}
extern "C" {
    #[doc = " returns the array of currently available display columns"]
    pub fn SCIPgetDisps(scip: *mut SCIP) -> *mut *mut SCIP_DISP;
}
extern "C" {
    #[doc = " returns the number of currently available display columns"]
    pub fn SCIPgetNDisps(scip: *mut SCIP) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " automatically selects display columns for being shown w.r.t. the display width parameter"]
    pub fn SCIPautoselectDisps(scip: *mut SCIP) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " changes the display column mode"]
    pub fn SCIPchgDispMode(disp: *mut SCIP_DISP, mode: SCIP_DISPMODE);
}
extern "C" {
    #[doc = " creates an event handler and includes it in SCIP\n\n  @note method has all event handler callbacks as arguments and is thus changed every time a new\n        callback is added in future releases; consider using SCIPincludeEventhdlrBasic() and setter functions\n        if you seek for a method which is less likely to change in future releases"]
    pub fn SCIPincludeEventhdlr(
        scip: *mut SCIP,
        name: *const ::std::os::raw::c_char,
        desc: *const ::std::os::raw::c_char,
        eventcopy: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, eventhdlr: *mut SCIP_EVENTHDLR) -> SCIP_RETCODE,
        >,
        eventfree: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, eventhdlr: *mut SCIP_EVENTHDLR) -> SCIP_RETCODE,
        >,
        eventinit: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, eventhdlr: *mut SCIP_EVENTHDLR) -> SCIP_RETCODE,
        >,
        eventexit: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, eventhdlr: *mut SCIP_EVENTHDLR) -> SCIP_RETCODE,
        >,
        eventinitsol: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, eventhdlr: *mut SCIP_EVENTHDLR) -> SCIP_RETCODE,
        >,
        eventexitsol: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, eventhdlr: *mut SCIP_EVENTHDLR) -> SCIP_RETCODE,
        >,
        eventdelete: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                eventhdlr: *mut SCIP_EVENTHDLR,
                eventdata: *mut *mut SCIP_EVENTDATA,
            ) -> SCIP_RETCODE,
        >,
        eventexec: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                eventhdlr: *mut SCIP_EVENTHDLR,
                event: *mut SCIP_EVENT,
                eventdata: *mut SCIP_EVENTDATA,
            ) -> SCIP_RETCODE,
        >,
        eventhdlrdata: *mut SCIP_EVENTHDLRDATA,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " creates an event handler and includes it in SCIP with all its non-fundamental callbacks set\n  to NULL; if needed, non-fundamental callbacks can be set afterwards via setter functions\n  SCIPsetEventhdlrCopy(), SCIPsetEventhdlrFree(), SCIPsetEventhdlrInit(), SCIPsetEventhdlrExit(),\n  SCIPsetEventhdlrInitsol(), SCIPsetEventhdlrExitsol(), and SCIPsetEventhdlrDelete()\n\n  @note if you want to set all callbacks with a single method call, consider using SCIPincludeEventhdlr() instead"]
    pub fn SCIPincludeEventhdlrBasic(
        scip: *mut SCIP,
        eventhdlrptr: *mut *mut SCIP_EVENTHDLR,
        name: *const ::std::os::raw::c_char,
        desc: *const ::std::os::raw::c_char,
        eventexec: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                eventhdlr: *mut SCIP_EVENTHDLR,
                event: *mut SCIP_EVENT,
                eventdata: *mut SCIP_EVENTDATA,
            ) -> SCIP_RETCODE,
        >,
        eventhdlrdata: *mut SCIP_EVENTHDLRDATA,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " sets copy callback of the event handler"]
    pub fn SCIPsetEventhdlrCopy(
        scip: *mut SCIP,
        eventhdlr: *mut SCIP_EVENTHDLR,
        eventcopy: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, eventhdlr: *mut SCIP_EVENTHDLR) -> SCIP_RETCODE,
        >,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " sets deinitialization callback of the event handler"]
    pub fn SCIPsetEventhdlrFree(
        scip: *mut SCIP,
        eventhdlr: *mut SCIP_EVENTHDLR,
        eventfree: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, eventhdlr: *mut SCIP_EVENTHDLR) -> SCIP_RETCODE,
        >,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " sets initialization callback of the event handler"]
    pub fn SCIPsetEventhdlrInit(
        scip: *mut SCIP,
        eventhdlr: *mut SCIP_EVENTHDLR,
        eventinit: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, eventhdlr: *mut SCIP_EVENTHDLR) -> SCIP_RETCODE,
        >,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " sets deinitialization callback of the event handler"]
    pub fn SCIPsetEventhdlrExit(
        scip: *mut SCIP,
        eventhdlr: *mut SCIP_EVENTHDLR,
        eventexit: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, eventhdlr: *mut SCIP_EVENTHDLR) -> SCIP_RETCODE,
        >,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " sets solving process initialization callback of the event handler"]
    pub fn SCIPsetEventhdlrInitsol(
        scip: *mut SCIP,
        eventhdlr: *mut SCIP_EVENTHDLR,
        eventinitsol: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, eventhdlr: *mut SCIP_EVENTHDLR) -> SCIP_RETCODE,
        >,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " sets solving process deinitialization callback of the event handler"]
    pub fn SCIPsetEventhdlrExitsol(
        scip: *mut SCIP,
        eventhdlr: *mut SCIP_EVENTHDLR,
        eventexitsol: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, eventhdlr: *mut SCIP_EVENTHDLR) -> SCIP_RETCODE,
        >,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " sets callback of the event handler to free specific event data"]
    pub fn SCIPsetEventhdlrDelete(
        scip: *mut SCIP,
        eventhdlr: *mut SCIP_EVENTHDLR,
        eventdelete: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                eventhdlr: *mut SCIP_EVENTHDLR,
                eventdata: *mut *mut SCIP_EVENTDATA,
            ) -> SCIP_RETCODE,
        >,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " returns the event handler of the given name, or NULL if not existing"]
    pub fn SCIPfindEventhdlr(
        scip: *mut SCIP,
        name: *const ::std::os::raw::c_char,
    ) -> *mut SCIP_EVENTHDLR;
}
extern "C" {
    #[doc = " returns the array of currently available event handlers"]
    pub fn SCIPgetEventhdlrs(scip: *mut SCIP) -> *mut *mut SCIP_EVENTHDLR;
}
extern "C" {
    #[doc = " returns the number of currently available event handlers"]
    pub fn SCIPgetNEventhdlrs(scip: *mut SCIP) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " catches a global (not variable or row dependent) event\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_TRANSFORMING\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED\n       - \\ref SCIP_STAGE_EXITSOLVE\n       - \\ref SCIP_STAGE_FREETRANS"]
    pub fn SCIPcatchEvent(
        scip: *mut SCIP,
        eventtype: SCIP_EVENTTYPE,
        eventhdlr: *mut SCIP_EVENTHDLR,
        eventdata: *mut SCIP_EVENTDATA,
        filterpos: *mut ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " drops a global event (stops to track event)\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_TRANSFORMING\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED\n       - \\ref SCIP_STAGE_EXITSOLVE\n       - \\ref SCIP_STAGE_FREETRANS"]
    pub fn SCIPdropEvent(
        scip: *mut SCIP,
        eventtype: SCIP_EVENTTYPE,
        eventhdlr: *mut SCIP_EVENTHDLR,
        eventdata: *mut SCIP_EVENTDATA,
        filterpos: ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " catches an objective value or domain change event on the given transformed variable\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_TRANSFORMING\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED\n       - \\ref SCIP_STAGE_EXITSOLVE\n       - \\ref SCIP_STAGE_FREETRANS"]
    pub fn SCIPcatchVarEvent(
        scip: *mut SCIP,
        var: *mut SCIP_VAR,
        eventtype: SCIP_EVENTTYPE,
        eventhdlr: *mut SCIP_EVENTHDLR,
        eventdata: *mut SCIP_EVENTDATA,
        filterpos: *mut ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " drops an objective value or domain change event (stops to track event) on the given transformed variable\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_TRANSFORMING\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED\n       - \\ref SCIP_STAGE_EXITSOLVE\n       - \\ref SCIP_STAGE_FREETRANS"]
    pub fn SCIPdropVarEvent(
        scip: *mut SCIP,
        var: *mut SCIP_VAR,
        eventtype: SCIP_EVENTTYPE,
        eventhdlr: *mut SCIP_EVENTHDLR,
        eventdata: *mut SCIP_EVENTDATA,
        filterpos: ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " catches a row coefficient, constant, or side change event on the given row\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_TRANSFORMING\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED\n       - \\ref SCIP_STAGE_EXITSOLVE\n       - \\ref SCIP_STAGE_FREETRANS"]
    pub fn SCIPcatchRowEvent(
        scip: *mut SCIP,
        row: *mut SCIP_ROW,
        eventtype: SCIP_EVENTTYPE,
        eventhdlr: *mut SCIP_EVENTHDLR,
        eventdata: *mut SCIP_EVENTDATA,
        filterpos: *mut ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " drops a row coefficient, constant, or side change event (stops to track event) on the given row\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_TRANSFORMING\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED\n       - \\ref SCIP_STAGE_EXITSOLVE\n       - \\ref SCIP_STAGE_FREETRANS"]
    pub fn SCIPdropRowEvent(
        scip: *mut SCIP,
        row: *mut SCIP_ROW,
        eventtype: SCIP_EVENTTYPE,
        eventhdlr: *mut SCIP_EVENTHDLR,
        eventdata: *mut SCIP_EVENTDATA,
        filterpos: ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " creates the handler for an expression handler and includes it into SCIP"]
    pub fn SCIPincludeExprhdlr(
        scip: *mut SCIP,
        exprhdlr: *mut *mut SCIP_EXPRHDLR,
        name: *const ::std::os::raw::c_char,
        desc: *const ::std::os::raw::c_char,
        precedence: ::std::os::raw::c_uint,
        eval: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                expr: *mut SCIP_EXPR,
                val: *mut f64,
                sol: *mut SCIP_SOL,
            ) -> SCIP_RETCODE,
        >,
        data: *mut SCIP_EXPRHDLRDATA,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " gives expression handlers"]
    pub fn SCIPgetExprhdlrs(scip: *mut SCIP) -> *mut *mut SCIP_EXPRHDLR;
}
extern "C" {
    #[doc = " gives number of expression handlers"]
    pub fn SCIPgetNExprhdlrs(scip: *mut SCIP) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " returns an expression handler of a given name (or NULL if not found)"]
    pub fn SCIPfindExprhdlr(
        scip: *mut SCIP,
        name: *const ::std::os::raw::c_char,
    ) -> *mut SCIP_EXPRHDLR;
}
extern "C" {
    #[doc = " returns expression handler for variable expressions (or NULL if not included)"]
    pub fn SCIPgetExprhdlrVar(scip: *mut SCIP) -> *mut SCIP_EXPRHDLR;
}
extern "C" {
    #[doc = " returns expression handler for constant value expressions (or NULL if not included)"]
    pub fn SCIPgetExprhdlrValue(scip: *mut SCIP) -> *mut SCIP_EXPRHDLR;
}
extern "C" {
    #[doc = " returns expression handler for sum expressions (or NULL if not included)"]
    pub fn SCIPgetExprhdlrSum(scip: *mut SCIP) -> *mut SCIP_EXPRHDLR;
}
extern "C" {
    #[doc = " returns expression handler for product expressions (or NULL if not included)"]
    pub fn SCIPgetExprhdlrProduct(scip: *mut SCIP) -> *mut SCIP_EXPRHDLR;
}
extern "C" {
    #[doc = " returns expression handler for power expressions (or NULL if not included)"]
    pub fn SCIPgetExprhdlrPower(scip: *mut SCIP) -> *mut SCIP_EXPRHDLR;
}
extern "C" {
    #[doc = " creates and captures an expression with given expression data and children"]
    pub fn SCIPcreateExpr(
        scip: *mut SCIP,
        expr: *mut *mut SCIP_EXPR,
        exprhdlr: *mut SCIP_EXPRHDLR,
        exprdata: *mut SCIP_EXPRDATA,
        nchildren: ::std::os::raw::c_int,
        children: *mut *mut SCIP_EXPR,
        ownercreate: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                expr: *mut SCIP_EXPR,
                ownerdata: *mut *mut SCIP_EXPR_OWNERDATA,
                ownerfree: *mut ::std::option::Option<
                    unsafe extern "C" fn(
                        scip: *mut SCIP,
                        expr: *mut SCIP_EXPR,
                        ownerdata: *mut *mut SCIP_EXPR_OWNERDATA,
                    ) -> SCIP_RETCODE,
                >,
                ownerprint: *mut ::std::option::Option<
                    unsafe extern "C" fn(
                        scip: *mut SCIP,
                        file: *mut FILE,
                        expr: *mut SCIP_EXPR,
                        ownerdata: *mut SCIP_EXPR_OWNERDATA,
                    ) -> SCIP_RETCODE,
                >,
                ownerevalactivity: *mut ::std::option::Option<
                    unsafe extern "C" fn(
                        scip: *mut SCIP,
                        expr: *mut SCIP_EXPR,
                        ownerdata: *mut SCIP_EXPR_OWNERDATA,
                    ) -> SCIP_RETCODE,
                >,
                ownercreatedata: *mut ::std::os::raw::c_void,
            ) -> SCIP_RETCODE,
        >,
        ownercreatedata: *mut ::std::os::raw::c_void,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " creates and captures an expression with given expression data and up to two children"]
    pub fn SCIPcreateExpr2(
        scip: *mut SCIP,
        expr: *mut *mut SCIP_EXPR,
        exprhdlr: *mut SCIP_EXPRHDLR,
        exprdata: *mut SCIP_EXPRDATA,
        child1: *mut SCIP_EXPR,
        child2: *mut SCIP_EXPR,
        ownercreate: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                expr: *mut SCIP_EXPR,
                ownerdata: *mut *mut SCIP_EXPR_OWNERDATA,
                ownerfree: *mut ::std::option::Option<
                    unsafe extern "C" fn(
                        scip: *mut SCIP,
                        expr: *mut SCIP_EXPR,
                        ownerdata: *mut *mut SCIP_EXPR_OWNERDATA,
                    ) -> SCIP_RETCODE,
                >,
                ownerprint: *mut ::std::option::Option<
                    unsafe extern "C" fn(
                        scip: *mut SCIP,
                        file: *mut FILE,
                        expr: *mut SCIP_EXPR,
                        ownerdata: *mut SCIP_EXPR_OWNERDATA,
                    ) -> SCIP_RETCODE,
                >,
                ownerevalactivity: *mut ::std::option::Option<
                    unsafe extern "C" fn(
                        scip: *mut SCIP,
                        expr: *mut SCIP_EXPR,
                        ownerdata: *mut SCIP_EXPR_OWNERDATA,
                    ) -> SCIP_RETCODE,
                >,
                ownercreatedata: *mut ::std::os::raw::c_void,
            ) -> SCIP_RETCODE,
        >,
        ownercreatedata: *mut ::std::os::raw::c_void,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " creates and captures an expression representing a quadratic function"]
    pub fn SCIPcreateExprQuadratic(
        scip: *mut SCIP,
        expr: *mut *mut SCIP_EXPR,
        nlinvars: ::std::os::raw::c_int,
        linvars: *mut *mut SCIP_VAR,
        lincoefs: *mut f64,
        nquadterms: ::std::os::raw::c_int,
        quadvars1: *mut *mut SCIP_VAR,
        quadvars2: *mut *mut SCIP_VAR,
        quadcoefs: *mut f64,
        ownercreate: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                expr: *mut SCIP_EXPR,
                ownerdata: *mut *mut SCIP_EXPR_OWNERDATA,
                ownerfree: *mut ::std::option::Option<
                    unsafe extern "C" fn(
                        scip: *mut SCIP,
                        expr: *mut SCIP_EXPR,
                        ownerdata: *mut *mut SCIP_EXPR_OWNERDATA,
                    ) -> SCIP_RETCODE,
                >,
                ownerprint: *mut ::std::option::Option<
                    unsafe extern "C" fn(
                        scip: *mut SCIP,
                        file: *mut FILE,
                        expr: *mut SCIP_EXPR,
                        ownerdata: *mut SCIP_EXPR_OWNERDATA,
                    ) -> SCIP_RETCODE,
                >,
                ownerevalactivity: *mut ::std::option::Option<
                    unsafe extern "C" fn(
                        scip: *mut SCIP,
                        expr: *mut SCIP_EXPR,
                        ownerdata: *mut SCIP_EXPR_OWNERDATA,
                    ) -> SCIP_RETCODE,
                >,
                ownercreatedata: *mut ::std::os::raw::c_void,
            ) -> SCIP_RETCODE,
        >,
        ownercreatedata: *mut ::std::os::raw::c_void,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " creates and captures an expression representing a monomial\n\n @note In deviation from the actual definition of monomials, we also allow for negative and rational exponents.\n So this function actually creates an expression for a signomial that has exactly one term."]
    pub fn SCIPcreateExprMonomial(
        scip: *mut SCIP,
        expr: *mut *mut SCIP_EXPR,
        nfactors: ::std::os::raw::c_int,
        vars: *mut *mut SCIP_VAR,
        exponents: *mut f64,
        ownercreate: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                expr: *mut SCIP_EXPR,
                ownerdata: *mut *mut SCIP_EXPR_OWNERDATA,
                ownerfree: *mut ::std::option::Option<
                    unsafe extern "C" fn(
                        scip: *mut SCIP,
                        expr: *mut SCIP_EXPR,
                        ownerdata: *mut *mut SCIP_EXPR_OWNERDATA,
                    ) -> SCIP_RETCODE,
                >,
                ownerprint: *mut ::std::option::Option<
                    unsafe extern "C" fn(
                        scip: *mut SCIP,
                        file: *mut FILE,
                        expr: *mut SCIP_EXPR,
                        ownerdata: *mut SCIP_EXPR_OWNERDATA,
                    ) -> SCIP_RETCODE,
                >,
                ownerevalactivity: *mut ::std::option::Option<
                    unsafe extern "C" fn(
                        scip: *mut SCIP,
                        expr: *mut SCIP_EXPR,
                        ownerdata: *mut SCIP_EXPR_OWNERDATA,
                    ) -> SCIP_RETCODE,
                >,
                ownercreatedata: *mut ::std::os::raw::c_void,
            ) -> SCIP_RETCODE,
        >,
        ownercreatedata: *mut ::std::os::raw::c_void,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " appends child to the children list of expr\n\n @attention Only use if you really know what you are doing. The expression handler of the expression needs to be able to handle an increase in the number of children."]
    pub fn SCIPappendExprChild(
        scip: *mut SCIP,
        expr: *mut SCIP_EXPR,
        child: *mut SCIP_EXPR,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " overwrites/replaces a child of an expressions\n\n The old child is released and the newchild is captured, unless they are the same (=same pointer)."]
    pub fn SCIPreplaceExprChild(
        scip: *mut SCIP,
        expr: *mut SCIP_EXPR,
        childidx: ::std::os::raw::c_int,
        newchild: *mut SCIP_EXPR,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " remove all children of expr\n\n @attention Only use if you really know what you are doing. The expression handler of the expression needs to be able to handle the removal of all children."]
    pub fn SCIPremoveExprChildren(scip: *mut SCIP, expr: *mut SCIP_EXPR) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " duplicates the given expression and its children"]
    pub fn SCIPduplicateExpr(
        scip: *mut SCIP,
        expr: *mut SCIP_EXPR,
        copyexpr: *mut *mut SCIP_EXPR,
        mapexpr: ::std::option::Option<
            unsafe extern "C" fn(
                targetscip: *mut SCIP,
                targetexpr: *mut *mut SCIP_EXPR,
                sourcescip: *mut SCIP,
                sourceexpr: *mut SCIP_EXPR,
                ownercreate: ::std::option::Option<
                    unsafe extern "C" fn(
                        scip: *mut SCIP,
                        expr: *mut SCIP_EXPR,
                        ownerdata: *mut *mut SCIP_EXPR_OWNERDATA,
                        ownerfree: *mut ::std::option::Option<
                            unsafe extern "C" fn(
                                scip: *mut SCIP,
                                expr: *mut SCIP_EXPR,
                                ownerdata: *mut *mut SCIP_EXPR_OWNERDATA,
                            ) -> SCIP_RETCODE,
                        >,
                        ownerprint: *mut ::std::option::Option<
                            unsafe extern "C" fn(
                                scip: *mut SCIP,
                                file: *mut FILE,
                                expr: *mut SCIP_EXPR,
                                ownerdata: *mut SCIP_EXPR_OWNERDATA,
                            ) -> SCIP_RETCODE,
                        >,
                        ownerevalactivity: *mut ::std::option::Option<
                            unsafe extern "C" fn(
                                scip: *mut SCIP,
                                expr: *mut SCIP_EXPR,
                                ownerdata: *mut SCIP_EXPR_OWNERDATA,
                            ) -> SCIP_RETCODE,
                        >,
                        ownercreatedata: *mut ::std::os::raw::c_void,
                    ) -> SCIP_RETCODE,
                >,
                ownercreatedata: *mut ::std::os::raw::c_void,
                mapexprdata: *mut ::std::os::raw::c_void,
            ) -> SCIP_RETCODE,
        >,
        mapexprdata: *mut ::std::os::raw::c_void,
        ownercreate: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                expr: *mut SCIP_EXPR,
                ownerdata: *mut *mut SCIP_EXPR_OWNERDATA,
                ownerfree: *mut ::std::option::Option<
                    unsafe extern "C" fn(
                        scip: *mut SCIP,
                        expr: *mut SCIP_EXPR,
                        ownerdata: *mut *mut SCIP_EXPR_OWNERDATA,
                    ) -> SCIP_RETCODE,
                >,
                ownerprint: *mut ::std::option::Option<
                    unsafe extern "C" fn(
                        scip: *mut SCIP,
                        file: *mut FILE,
                        expr: *mut SCIP_EXPR,
                        ownerdata: *mut SCIP_EXPR_OWNERDATA,
                    ) -> SCIP_RETCODE,
                >,
                ownerevalactivity: *mut ::std::option::Option<
                    unsafe extern "C" fn(
                        scip: *mut SCIP,
                        expr: *mut SCIP_EXPR,
                        ownerdata: *mut SCIP_EXPR_OWNERDATA,
                    ) -> SCIP_RETCODE,
                >,
                ownercreatedata: *mut ::std::os::raw::c_void,
            ) -> SCIP_RETCODE,
        >,
        ownercreatedata: *mut ::std::os::raw::c_void,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " duplicates the given expression, but reuses its children"]
    pub fn SCIPduplicateExprShallow(
        scip: *mut SCIP,
        expr: *mut SCIP_EXPR,
        copyexpr: *mut *mut SCIP_EXPR,
        ownercreate: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                expr: *mut SCIP_EXPR,
                ownerdata: *mut *mut SCIP_EXPR_OWNERDATA,
                ownerfree: *mut ::std::option::Option<
                    unsafe extern "C" fn(
                        scip: *mut SCIP,
                        expr: *mut SCIP_EXPR,
                        ownerdata: *mut *mut SCIP_EXPR_OWNERDATA,
                    ) -> SCIP_RETCODE,
                >,
                ownerprint: *mut ::std::option::Option<
                    unsafe extern "C" fn(
                        scip: *mut SCIP,
                        file: *mut FILE,
                        expr: *mut SCIP_EXPR,
                        ownerdata: *mut SCIP_EXPR_OWNERDATA,
                    ) -> SCIP_RETCODE,
                >,
                ownerevalactivity: *mut ::std::option::Option<
                    unsafe extern "C" fn(
                        scip: *mut SCIP,
                        expr: *mut SCIP_EXPR,
                        ownerdata: *mut SCIP_EXPR_OWNERDATA,
                    ) -> SCIP_RETCODE,
                >,
                ownercreatedata: *mut ::std::os::raw::c_void,
            ) -> SCIP_RETCODE,
        >,
        ownercreatedata: *mut ::std::os::raw::c_void,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " copies an expression including children to use in a (possibly different) SCIP instance"]
    pub fn SCIPcopyExpr(
        sourcescip: *mut SCIP,
        targetscip: *mut SCIP,
        expr: *mut SCIP_EXPR,
        copyexpr: *mut *mut SCIP_EXPR,
        ownercreate: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                expr: *mut SCIP_EXPR,
                ownerdata: *mut *mut SCIP_EXPR_OWNERDATA,
                ownerfree: *mut ::std::option::Option<
                    unsafe extern "C" fn(
                        scip: *mut SCIP,
                        expr: *mut SCIP_EXPR,
                        ownerdata: *mut *mut SCIP_EXPR_OWNERDATA,
                    ) -> SCIP_RETCODE,
                >,
                ownerprint: *mut ::std::option::Option<
                    unsafe extern "C" fn(
                        scip: *mut SCIP,
                        file: *mut FILE,
                        expr: *mut SCIP_EXPR,
                        ownerdata: *mut SCIP_EXPR_OWNERDATA,
                    ) -> SCIP_RETCODE,
                >,
                ownerevalactivity: *mut ::std::option::Option<
                    unsafe extern "C" fn(
                        scip: *mut SCIP,
                        expr: *mut SCIP_EXPR,
                        ownerdata: *mut SCIP_EXPR_OWNERDATA,
                    ) -> SCIP_RETCODE,
                >,
                ownercreatedata: *mut ::std::os::raw::c_void,
            ) -> SCIP_RETCODE,
        >,
        ownercreatedata: *mut ::std::os::raw::c_void,
        varmap: *mut SCIP_HASHMAP,
        consmap: *mut SCIP_HASHMAP,
        global: ::std::os::raw::c_uint,
        valid: *mut ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " creates an expression from a string\n\n We specify the grammar that defines the syntax of an expression.\n Loosely speaking, a `Base` will be any \"block\", a `Factor` is a `Base` to a power,\n a `Term` is a product of `Factors` and an `Expression` is a sum of `Terms`.\n\n The actual definition:\n <pre>\n Expression -> [\"+\" | \"-\"] Term { [ (\"+\" | \"-\" | \"number *\") Term | (\"number\" <varname>) ] }\n Term       -> Factor { (\"*\" | \"/\" ) Factor }\n Factor     -> Base [ \"^\" \"number\" | \"^(\" \"number\" \")\" ]\n Base       -> \"number\" | \"<varname>\" | \"(\" Expression \")\" | Op \"(\" OpExpression \")\n </pre>\n where `[a|b]` means `a` or `b` or none, `(a|b)` means `a` or `b`, `{a}` means 0 or more `a`.\n\n Note that `Op` and `OpExpression` are undefined.\n `Op` corresponds to the name of an expression handler and `OpExpression` to whatever string the expression handler accepts (through its parse method)."]
    pub fn SCIPparseExpr(
        scip: *mut SCIP,
        expr: *mut *mut SCIP_EXPR,
        exprstr: *const ::std::os::raw::c_char,
        finalpos: *mut *const ::std::os::raw::c_char,
        ownercreate: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                expr: *mut SCIP_EXPR,
                ownerdata: *mut *mut SCIP_EXPR_OWNERDATA,
                ownerfree: *mut ::std::option::Option<
                    unsafe extern "C" fn(
                        scip: *mut SCIP,
                        expr: *mut SCIP_EXPR,
                        ownerdata: *mut *mut SCIP_EXPR_OWNERDATA,
                    ) -> SCIP_RETCODE,
                >,
                ownerprint: *mut ::std::option::Option<
                    unsafe extern "C" fn(
                        scip: *mut SCIP,
                        file: *mut FILE,
                        expr: *mut SCIP_EXPR,
                        ownerdata: *mut SCIP_EXPR_OWNERDATA,
                    ) -> SCIP_RETCODE,
                >,
                ownerevalactivity: *mut ::std::option::Option<
                    unsafe extern "C" fn(
                        scip: *mut SCIP,
                        expr: *mut SCIP_EXPR,
                        ownerdata: *mut SCIP_EXPR_OWNERDATA,
                    ) -> SCIP_RETCODE,
                >,
                ownercreatedata: *mut ::std::os::raw::c_void,
            ) -> SCIP_RETCODE,
        >,
        ownercreatedata: *mut ::std::os::raw::c_void,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " captures an expression (increments usage count)"]
    pub fn SCIPcaptureExpr(expr: *mut SCIP_EXPR);
}
extern "C" {
    #[doc = " releases an expression (decrements usage count and possibly frees expression)"]
    pub fn SCIPreleaseExpr(scip: *mut SCIP, expr: *mut *mut SCIP_EXPR) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " returns whether an expression is a variable expression"]
    pub fn SCIPisExprVar(scip: *mut SCIP, expr: *mut SCIP_EXPR) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " returns whether an expression is a value expression"]
    pub fn SCIPisExprValue(scip: *mut SCIP, expr: *mut SCIP_EXPR) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " returns whether an expression is a sum expression"]
    pub fn SCIPisExprSum(scip: *mut SCIP, expr: *mut SCIP_EXPR) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " returns whether an expression is a product expression"]
    pub fn SCIPisExprProduct(scip: *mut SCIP, expr: *mut SCIP_EXPR) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " returns whether an expression is a power expression"]
    pub fn SCIPisExprPower(scip: *mut SCIP, expr: *mut SCIP_EXPR) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " print an expression as info-message"]
    pub fn SCIPprintExpr(scip: *mut SCIP, expr: *mut SCIP_EXPR, file: *mut FILE) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " initializes printing of expressions in dot format to a give FILE* pointer"]
    pub fn SCIPprintExprDotInit(
        scip: *mut SCIP,
        printdata: *mut *mut SCIP_EXPRPRINTDATA,
        file: *mut FILE,
        whattoprint: SCIP_EXPRPRINT_WHAT,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " initializes printing of expressions in dot format to a file with given filename"]
    pub fn SCIPprintExprDotInit2(
        scip: *mut SCIP,
        printdata: *mut *mut SCIP_EXPRPRINTDATA,
        filename: *const ::std::os::raw::c_char,
        whattoprint: SCIP_EXPRPRINT_WHAT,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " main part of printing an expression in dot format"]
    pub fn SCIPprintExprDot(
        scip: *mut SCIP,
        printdata: *mut SCIP_EXPRPRINTDATA,
        expr: *mut SCIP_EXPR,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " finishes printing of expressions in dot format"]
    pub fn SCIPprintExprDotFinal(
        scip: *mut SCIP,
        printdata: *mut *mut SCIP_EXPRPRINTDATA,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " shows a single expression by use of dot and gv\n\n This function is meant for debugging purposes.\n It's signature is kept as simple as possible to make it\n easily callable from gdb, for example.\n\n It prints the expression into a temporary file in dot format, then calls dot to create a postscript file, then calls ghostview (gv) to show the file.\n SCIP will hold until ghostscript is closed."]
    pub fn SCIPshowExpr(scip: *mut SCIP, expr: *mut SCIP_EXPR) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " prints structure of an expression a la Maple's dismantle"]
    pub fn SCIPdismantleExpr(
        scip: *mut SCIP,
        file: *mut FILE,
        expr: *mut SCIP_EXPR,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " evaluate an expression in a point\n\n Iterates over expressions to also evaluate children, if necessary.\n Value can be received via SCIPexprGetEvalValue().\n If an evaluation error (division by zero, ...) occurs, this value will\n be set to SCIP_INVALID.\n\n If a nonzero \\p soltag is passed, then only (sub)expressions are\n reevaluated that have a different solution tag. If a soltag of 0\n is passed, then subexpressions are always reevaluated.\n The tag is stored together with the value and can be received via\n SCIPexprGetEvalTag()."]
    pub fn SCIPevalExpr(
        scip: *mut SCIP,
        expr: *mut SCIP_EXPR,
        sol: *mut SCIP_SOL,
        soltag: ::std::os::raw::c_longlong,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " returns a previously unused solution tag for expression evaluation"]
    pub fn SCIPgetExprNewSoltag(scip: *mut SCIP) -> ::std::os::raw::c_longlong;
}
extern "C" {
    #[doc = " evaluates gradient of an expression for a given point\n\n Initiates an expression walk to also evaluate children, if necessary.\n Value can be received via SCIPgetExprPartialDiffNonlinear().\n If an error (division by zero, ...) occurs, this value will\n be set to SCIP_INVALID."]
    pub fn SCIPevalExprGradient(
        scip: *mut SCIP,
        expr: *mut SCIP_EXPR,
        sol: *mut SCIP_SOL,
        soltag: ::std::os::raw::c_longlong,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " evaluates Hessian-vector product of an expression for a given point and direction\n\n Evaluates children, if necessary.\n Value can be received via SCIPgetExprPartialDiffGradientDirNonlinear().\n If an error (division by zero, ...) occurs, this value will\n be set to SCIP_INVALID."]
    pub fn SCIPevalExprHessianDir(
        scip: *mut SCIP,
        expr: *mut SCIP_EXPR,
        sol: *mut SCIP_SOL,
        soltag: ::std::os::raw::c_longlong,
        direction: *mut SCIP_SOL,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " possibly reevaluates and then returns the activity of the expression\n\n Reevaluate activity if currently stored is no longer uptodate (some bound was changed since last evaluation).\n\n The owner of the expression may overwrite the methods used to evaluate the activity,\n including whether the local or global domain of variables is used.\n By default (no owner, or owner doesn't overwrite activity evaluation),\n the local domain of variables is used.\n\n @note If expression is set to be integral, then activities are tightened to integral values.\n   Thus, ensure that the integrality information is valid (if set to TRUE; the default (FALSE) is always ok)."]
    pub fn SCIPevalExprActivity(scip: *mut SCIP, expr: *mut SCIP_EXPR) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " compare expressions\n @return -1, 0 or 1 if expr1 <, =, > expr2, respectively\n @note The given expressions are assumed to be simplified."]
    pub fn SCIPcompareExpr(
        scip: *mut SCIP,
        expr1: *mut SCIP_EXPR,
        expr2: *mut SCIP_EXPR,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " compute the hash value of an expression"]
    pub fn SCIPhashExpr(
        scip: *mut SCIP,
        expr: *mut SCIP_EXPR,
        hashval: *mut ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " simplifies an expression\n\n This is largely inspired by Joel Cohen's\n *Computer algebra and symbolic computation: Mathematical methods*,\n in particular Chapter 3.\n The other fountain of inspiration are the simplifying methods of expr.c in SCIP 7.\n\n Note: The things to keep in mind when adding simplification rules are the following.\n I will be using the product expressions (see expr_product.c) as an example.\n There are mainly 3 parts of the simplification process. You need to decide\n at which stage the simplification rule makes sense.\n 1. Simplify each factor (simplifyFactor()): At this stage we got the children of the product expression.\n    At this point, each child is simplified when viewed as a stand-alone expression, but not necessarily when viewed as child of a product expression.\n    Rules like SP2, SP7, etc are enforced at this point.\n 2. Multiply the factors (mergeProductExprlist()): At this point rules like SP4, SP5 and SP14 are enforced.\n 3. Build the actual simplified product expression (buildSimplifiedProduct()):\n    At this point rules like SP10, SP11, etc are enforced.\n\n During steps 1 and 2 do not forget to set the flag `changed` to TRUE when something actually changes.\n\n \\par Definition of simplified expressions\n\n An expression is simplified if it\n - is a value expression\n - is a var expression\n - is a product expression such that\n   - SP1: every child is simplified\n   - SP2: no child is a product\n   - SP4: no two children are the same expression (those should be multiplied)\n   - SP5: the children are sorted [commutative rule]\n   - SP7: no child is a value\n   - SP8: its coefficient is 1.0 (otherwise should be written as sum)\n   - SP10: it has at least two children\n   - TODO?: at most one child is an `abs`\n   - SP11: no two children are `expr*log(expr)`\n     (TODO: we could handle more complicated stuff like \\f$xy\\log(x) \\to - y * \\mathrm{entropy}(x)\\f$, but I am not sure this should happen at the simplification level;\n            similar for \\f$(xy) \\log(xy)\\f$, which currently simplifies to \\f$xy \\log(xy)\\f$)\n   - SP12: if it has two children, then neither of them is a sum (expand sums)\n   - SP12b: if it has at least two children and expandalways is set, then no child is a sum (expand sums always)\n   - SP13: no child is a sum with a single term\n   - SP14: at most one child is an `exp`\n - is a power expression such that\n   - POW1: exponent is not 0\n   - POW2: exponent is not 1\n   - POW3: its child is not a value\n   - POW4: its child is simplified\n   - POW5: if exponent is integer, its child is not a product\n   - POW5a: if exponent is fractional and distribfracexponent param is enabled, its child is not a product\n   - POW6: if exponent is integer, its child is not a sum with a single term (\\f$(2x)^2 \\to 4x^2\\f$)\n   - POW7: if exponent is integer and at most expandmaxeponent param, its child is not a sum (expand sums)\n   - POW8: its child is not a power unless \\f$(x^n)^m\\f$ with \\f$nm\\f$ being integer and \\f$n\\f$ or \\f$m\\f$ fractional and \\f$n\\f$ not being even integer\n   - POW9: its child is not a sum with a single term with a positive coefficient: \\f$(25x)^{0.5} \\to 5 x^{0.5}\\f$\n   - POW10: its child is not a binary variable: \\f$b^e, e > 0 \\to b\\f$; \\f$b^e, e < 0 \\to b := 1\\f$\n   - POW11: its child is not an exponential: \\f$\\exp(\\text{expr})^e \\to \\exp(e\\cdot\\text{expr})\\f$\n   - POW12: its child is not an absolute value if the exponent is an even integer: \\f$\\abs(\\text{expr})^e, e \\text{ even} \\to \\text{expr}^e\\f$\n - is a signedpower expression such that\n   - SPOW1: exponent is not 0\n   - SPOW2: exponent is not 1\n   - SPOW3: its child is not a value\n   - SPOW4: its child is simplified\n   - SPOW5: (TODO) do we want to distribute signpowers over products like we do for powers?\n   - SPOW6: exponent is not an odd integer: (signpow odd expr) -> (pow odd expr)\n   - SPOW8: if exponent is integer, its child is not a power\n   - SPOW9: its child is not a sum with a single term: \\f$\\mathrm{signpow}(25x,0.5) \\to 5\\mathrm{signpow}(x,0.5)\\f$\n   - SPOW10: its child is not a binary variable: \\f$\\mathrm{signpow}(b,e), e > 0 \\to b\\f$; \\f$\\mathrm{signpow}(b,e), e < 0 \\to b := 1\\f$\n   - SPOW11: its child is not an exponential: \\f$\\mathrm{signpow}(\\exp(\\text{expr}),e) \\to \\exp(e\\cdot\\text{expr})\\f$\n   - TODO: what happens when child is another signed power?\n   - TODO: if child &ge; 0 -> transform to normal power; if child < 0 -> transform to - normal power\n\n   TODO: Some of these criteria are too restrictive for signed powers; for example, the exponent does not need to be\n   an integer for signedpower to distribute over a product (SPOW5, SPOW6, SPOW8). Others can also be improved.\n - is a sum expression such that\n   - SS1: every child is simplified\n   - SS2: no child is a sum\n   - SS3: no child is a value (values should go in the constant of the sum)\n   - SS4: no two children are the same expression (those should be summed up)\n   - SS5: the children are sorted [commutative rule]\n   - SS6: it has at least one child\n   - SS7: if it consists of a single child, then either constant is != 0.0 or coef != 1\n   - SS8: no child has coefficient 0\n   - SS9: if a child c is a product that has an exponential expression as one of its factors, then the coefficient of c is +/-1.0\n   - SS10: if a child c is an exponential, then the coefficient of c is +/-1.0\n - it is a function with simplified arguments, but not all of them can be values\n - TODO? a logarithm doesn't have a product as a child\n - TODO? the exponent of an exponential is always 1\n\n \\par Ordering Rules (see SCIPexprCompare())\n \\anchor EXPR_ORDER\n These rules define a total order on *simplified* expressions.\n There are two groups of rules, when comparing equal type expressions and different type expressions.\n\n Equal type expressions:\n - OR1: u,v value expressions: u < v &hArr; val(u) < val(v)\n - OR2: u,v var expressions: u < v &hArr; `SCIPvarGetIndex(var(u))` < `SCIPvarGetIndex(var(v))`\n - OR3: u,v are both sum or product expression: < is a lexicographical order on the terms\n - OR4: u,v are both pow: u < v &hArr; base(u) < base(v) or, base(u) = base(v) and expo(u) < expo(v)\n - OR5: u,v are \\f$u = f(u_1, ..., u_n), v = f(v_1, ..., v_m)\\f$: u < v &hArr; For the first k such that \\f$u_k \\neq v_k\\f$, \\f$u_k < v_k\\f$, or if such a \\f$k\\f$ doesn't exist, then \\f$n < m\\f$.\n\n Different type expressions:\n - OR6: u value, v other: u < v always\n - OR7: u sum, v var or func: u < v &hArr; u < 0+v;\n        In other words, if \\f$u = \\sum_{i=1}^n \\alpha_i u_i\\f$, then u < v &hArr; \\f$u_n\\f$ < v or if \\f$u_n\\f$ = v and \\f$\\alpha_n\\f$ < 1.\n - OR8: u product, v pow, sum, var or func: u < v &hArr; u < 1*v;\n        In other words, if \\f$u = \\prod_{i=1}^n u_i\\f$, then u < v &hArr; \\f$u_n\\f$ < v.\n        Note: since this applies only to simplified expressions, the form of the product is correct.\n              Simplified products  do *not* have constant coefficients.\n - OR9: u pow, v sum, var or func: u < v &hArr; u < v^1\n - OR10: u var, v func: u < v always\n - OR11: u func, v other type of func: u < v &hArr; name(type(u)) < name(type(v))\n - OR12: none of the rules apply: u < v &hArr; ! v < u\n\n Examples:\n - x < x^2 ?:  x is var and x^2 power, so none applies (OR12).\n   Hence, we try to answer x^2 < x ?: x^2 < x &hArr; x < x or if x = x and 2 < 1 &hArr; 2 < 1 &hArr; False. So x < x^2 is True.\n - x < x^-1 --OR12&rarr; ~(x^-1 < x) --OR9&rarr; ~(x^-1 < x^1) --OR4&rarr; ~(x < x or -1 < 1) &rarr; ~True &rarr; False\n - x*y < x --OR8&rarr; x*y < 1*x --OR3&rarr; y < x --OR2&rarr; False\n - x*y < y --OR8&rarr; x*y < 1*y --OR3&rarr; y < x --OR2&rarr; False\n\n \\par Algorithm\n\n The recursive version of the algorithm is\n\n     EXPR simplify(expr)\n        for c in 1..expr->nchildren\n           expr->children[c] = simplify(expr->children[c])\n        end\n        return expr->exprhdlr->simplify(expr)\n     end\n\n Important: Whatever is returned by a simplify callback **has** to be simplified.\n Also, all children of the given expression **are** already simplified."]
    pub fn SCIPsimplifyExpr(
        scip: *mut SCIP,
        rootexpr: *mut SCIP_EXPR,
        simplified: *mut *mut SCIP_EXPR,
        changed: *mut ::std::os::raw::c_uint,
        infeasible: *mut ::std::os::raw::c_uint,
        ownercreate: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                expr: *mut SCIP_EXPR,
                ownerdata: *mut *mut SCIP_EXPR_OWNERDATA,
                ownerfree: *mut ::std::option::Option<
                    unsafe extern "C" fn(
                        scip: *mut SCIP,
                        expr: *mut SCIP_EXPR,
                        ownerdata: *mut *mut SCIP_EXPR_OWNERDATA,
                    ) -> SCIP_RETCODE,
                >,
                ownerprint: *mut ::std::option::Option<
                    unsafe extern "C" fn(
                        scip: *mut SCIP,
                        file: *mut FILE,
                        expr: *mut SCIP_EXPR,
                        ownerdata: *mut SCIP_EXPR_OWNERDATA,
                    ) -> SCIP_RETCODE,
                >,
                ownerevalactivity: *mut ::std::option::Option<
                    unsafe extern "C" fn(
                        scip: *mut SCIP,
                        expr: *mut SCIP_EXPR,
                        ownerdata: *mut SCIP_EXPR_OWNERDATA,
                    ) -> SCIP_RETCODE,
                >,
                ownercreatedata: *mut ::std::os::raw::c_void,
            ) -> SCIP_RETCODE,
        >,
        ownercreatedata: *mut ::std::os::raw::c_void,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " retrieves symmetry information from an expression"]
    pub fn SCIPgetSymDataExpr(
        scip: *mut SCIP,
        expr: *mut SCIP_EXPR,
        symdata: *mut *mut SYM_EXPRDATA,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " replaces common sub-expressions in a given expression graph by using a hash key for each expression\n\n  The algorithm consists of two steps:\n\n  1. traverse through all given expressions and compute for each of them a (not necessarily unique) hash\n\n  2. initialize an empty hash table and traverse through all expression; check for each of them if we can find a\n     structural equivalent expression in the hash table; if yes we replace the expression by the expression inside the\n     hash table, otherwise we add it to the hash table\n\n  @note the hash keys of the expressions are used for the hashing inside the hash table; to compute if two expressions\n  (with the same hash) are structurally the same we use the function SCIPexprCompare()."]
    pub fn SCIPreplaceCommonSubexpressions(
        scip: *mut SCIP,
        exprs: *mut *mut SCIP_EXPR,
        nexprs: ::std::os::raw::c_int,
        replacedroot: *mut ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " computes the curvature of a given expression and all its subexpressions\n\n  @note this function also evaluates all subexpressions w.r.t. current variable bounds\n  @note this function relies on information from the curvature callback of expression handlers only,\n    consider using function @ref SCIPhasExprCurvature() of the convex-nlhdlr instead, as that uses more information to deduce convexity"]
    pub fn SCIPcomputeExprCurvature(scip: *mut SCIP, expr: *mut SCIP_EXPR) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " computes integrality information of a given expression and all its subexpressions\n\n The integrality information can be accessed via SCIPexprIsIntegral()."]
    pub fn SCIPcomputeExprIntegrality(scip: *mut SCIP, expr: *mut SCIP_EXPR) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " returns the total number of variable expressions in an expression\n\n The function counts variable expressions in common sub-expressions only once, but\n counts variables appearing in several variable expressions multiple times."]
    pub fn SCIPgetExprNVars(
        scip: *mut SCIP,
        expr: *mut SCIP_EXPR,
        nvars: *mut ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " returns all variable expressions contained in a given expression\n\n The array to store all variable expressions needs to be at least of size\n the number of unique variable expressions in the expression which is given by SCIPgetExprNVars().\n\n If every variable is represented by only one variable expression (common subexpression have been removed)\n then SCIPgetExprNVars() can be bounded by SCIPgetNTotalVars().\n If, in addition, non-active variables have been removed from the expression, e.g., by simplifying,\n then SCIPgetExprNVars() can be bounded by SCIPgetNVars().\n\n @note function captures variable expressions"]
    pub fn SCIPgetExprVarExprs(
        scip: *mut SCIP,
        expr: *mut SCIP_EXPR,
        varexprs: *mut *mut SCIP_EXPR,
        nvarexprs: *mut ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
extern "C" {
    pub fn SCIPcallExprPrint(
        scip: *mut SCIP,
        expr: *mut SCIP_EXPR,
        stage: SCIP_EXPRITER_STAGE,
        currentchild: ::std::os::raw::c_int,
        parentprecedence: ::std::os::raw::c_uint,
        file: *mut FILE,
    ) -> SCIP_RETCODE;
}
extern "C" {
    pub fn SCIPcallExprCurvature(
        scip: *mut SCIP,
        expr: *mut SCIP_EXPR,
        exprcurvature: SCIP_EXPRCURV,
        success: *mut ::std::os::raw::c_uint,
        childcurv: *mut SCIP_EXPRCURV,
    ) -> SCIP_RETCODE;
}
extern "C" {
    pub fn SCIPcallExprMonotonicity(
        scip: *mut SCIP,
        expr: *mut SCIP_EXPR,
        childidx: ::std::os::raw::c_int,
        result: *mut SCIP_MONOTONE,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " calls the eval callback for an expression with given values for children\n\n Does not iterates over expressions, but requires values for children to be given.\n Value is not stored in expression, but returned in `val`.\n If an evaluation error (division by zero, ...) occurs, this value will\n be set to `SCIP_INVALID`."]
    pub fn SCIPcallExprEval(
        scip: *mut SCIP,
        expr: *mut SCIP_EXPR,
        childrenvalues: *mut f64,
        val: *mut f64,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " calls the eval and fwdiff callback of an expression with given values for children\n\n Does not iterates over expressions, but requires values for children and direction to be given.\n\n Value is not stored in expression, but returned in `val`.\n If an evaluation error (division by zero, ...) occurs, this value will be set to `SCIP_INVALID`.\n\n Direction is not stored in expression, but returned in `dot`.\n If an differentiation error (division by zero, ...) occurs, this value will be set to `SCIP_INVALID`."]
    pub fn SCIPcallExprEvalFwdiff(
        scip: *mut SCIP,
        expr: *mut SCIP_EXPR,
        childrenvalues: *mut f64,
        direction: *mut f64,
        val: *mut f64,
        dot: *mut f64,
    ) -> SCIP_RETCODE;
}
extern "C" {
    pub fn SCIPcallExprInteval(
        scip: *mut SCIP,
        expr: *mut SCIP_EXPR,
        interval: *mut SCIP_INTERVAL,
        intevalvar: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                var: *mut SCIP_VAR,
                intevalvardata: *mut ::std::os::raw::c_void,
            ) -> SCIP_INTERVAL,
        >,
        intevalvardata: *mut ::std::os::raw::c_void,
    ) -> SCIP_RETCODE;
}
extern "C" {
    pub fn SCIPcallExprEstimate(
        scip: *mut SCIP,
        expr: *mut SCIP_EXPR,
        localbounds: *mut SCIP_INTERVAL,
        globalbounds: *mut SCIP_INTERVAL,
        refpoint: *mut f64,
        overestimate: ::std::os::raw::c_uint,
        targetvalue: f64,
        coefs: *mut f64,
        constant: *mut f64,
        islocal: *mut ::std::os::raw::c_uint,
        success: *mut ::std::os::raw::c_uint,
        branchcand: *mut ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    pub fn SCIPcallExprInitestimates(
        scip: *mut SCIP,
        expr: *mut SCIP_EXPR,
        bounds: *mut SCIP_INTERVAL,
        overestimate: ::std::os::raw::c_uint,
        coefs: *mut *mut f64,
        constant: *mut f64,
        nreturned: *mut ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
extern "C" {
    pub fn SCIPcallExprSimplify(
        scip: *mut SCIP,
        expr: *mut SCIP_EXPR,
        simplifiedexpr: *mut *mut SCIP_EXPR,
        ownercreate: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                expr: *mut SCIP_EXPR,
                ownerdata: *mut *mut SCIP_EXPR_OWNERDATA,
                ownerfree: *mut ::std::option::Option<
                    unsafe extern "C" fn(
                        scip: *mut SCIP,
                        expr: *mut SCIP_EXPR,
                        ownerdata: *mut *mut SCIP_EXPR_OWNERDATA,
                    ) -> SCIP_RETCODE,
                >,
                ownerprint: *mut ::std::option::Option<
                    unsafe extern "C" fn(
                        scip: *mut SCIP,
                        file: *mut FILE,
                        expr: *mut SCIP_EXPR,
                        ownerdata: *mut SCIP_EXPR_OWNERDATA,
                    ) -> SCIP_RETCODE,
                >,
                ownerevalactivity: *mut ::std::option::Option<
                    unsafe extern "C" fn(
                        scip: *mut SCIP,
                        expr: *mut SCIP_EXPR,
                        ownerdata: *mut SCIP_EXPR_OWNERDATA,
                    ) -> SCIP_RETCODE,
                >,
                ownercreatedata: *mut ::std::os::raw::c_void,
            ) -> SCIP_RETCODE,
        >,
        ownercreatedata: *mut ::std::os::raw::c_void,
    ) -> SCIP_RETCODE;
}
extern "C" {
    pub fn SCIPcallExprReverseprop(
        scip: *mut SCIP,
        expr: *mut SCIP_EXPR,
        bounds: SCIP_INTERVAL,
        childrenbounds: *mut SCIP_INTERVAL,
        infeasible: *mut ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    pub fn SCIPcallExprGetSymData(
        scip: *mut SCIP,
        expr: *mut SCIP_EXPR,
        symdata: *mut *mut SYM_EXPRDATA,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " creates an expression iterator"]
    pub fn SCIPcreateExpriter(scip: *mut SCIP, iterator: *mut *mut SCIP_EXPRITER) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " frees an expression iterator"]
    pub fn SCIPfreeExpriter(iterator: *mut *mut SCIP_EXPRITER);
}
extern "C" {
    #[doc = " checks whether an expression is quadratic\n\n An expression is quadratic if it is either a square (of some expression), a product (of two expressions),\n or a sum of terms where at least one is a square or a product.\n\n Use SCIPexprGetQuadraticData() to get data about the representation as quadratic."]
    pub fn SCIPcheckExprQuadratic(
        scip: *mut SCIP,
        expr: *mut SCIP_EXPR,
        isquadratic: *mut ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " frees information on quadratic representation of an expression\n\n Before doing changes to an expression, it can be useful to call this function."]
    pub fn SCIPfreeExprQuadratic(scip: *mut SCIP, expr: *mut SCIP_EXPR);
}
extern "C" {
    #[doc = " evaluates quadratic term in a solution\n\n \\note This requires that every expression used in the quadratic data is a variable expression."]
    pub fn SCIPevalExprQuadratic(scip: *mut SCIP, expr: *mut SCIP_EXPR, sol: *mut SCIP_SOL) -> f64;
}
extern "C" {
    #[doc = " prints quadratic expression"]
    pub fn SCIPprintExprQuadratic(scip: *mut SCIP, expr: *mut SCIP_EXPR) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " checks the curvature of the quadratic expression\n\n For this, it builds the matrix Q of quadratic coefficients and computes its eigenvalues using LAPACK.\n If Q is\n - semidefinite positive -> curv is set to convex,\n - semidefinite negative -> curv is set to concave,\n - otherwise -> curv is set to unknown.\n\n If `assumevarfixed` is given and some expressions in quadratic terms correspond to variables present in\n this hashmap, then the corresponding rows and columns are ignored in the matrix Q."]
    pub fn SCIPcomputeExprQuadraticCurvature(
        scip: *mut SCIP,
        expr: *mut SCIP_EXPR,
        curv: *mut SCIP_EXPRCURV,
        assumevarfixed: *mut SCIP_HASHMAP,
        storeeigeninfo: ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " returns a monomial representation of a product expression\n\n The array to store all factor expressions needs to be of size the number of\n children in the expression which is given by SCIPexprGetNChildren().\n\n Given a non-trivial monomial expression, the function finds its representation as \\f$cx^\\alpha\\f$, where\n \\f$c\\f$ is a real coefficient, \\f$x\\f$ is a vector of auxiliary or original variables (where some entries can\n be NULL is the auxiliary variable has not been created yet), and \\f$\\alpha\\f$ is a real vector of exponents.\n\n A non-trivial monomial is a product of a least two expressions."]
    pub fn SCIPgetExprMonomialData(
        scip: *mut SCIP,
        expr: *mut SCIP_EXPR,
        coef: *mut f64,
        exponents: *mut f64,
        factors: *mut *mut SCIP_EXPR,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " returns complete SCIP version number in the format \"major . minor tech\"\n\n  @return complete SCIP version"]
    pub fn SCIPversion() -> f64;
}
extern "C" {
    #[doc = " returns SCIP major version\n\n  @return major SCIP version"]
    pub fn SCIPmajorVersion() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " returns SCIP minor version\n\n  @return minor SCIP version"]
    pub fn SCIPminorVersion() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " returns SCIP technical version\n\n  @return technical SCIP version"]
    pub fn SCIPtechVersion() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " returns SCIP sub version number\n\n  @return subversion SCIP version"]
    pub fn SCIPsubversion() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " prints a version information line to a file stream via the message handler system\n\n  @note If the message handler is set to a NULL pointer nothing will be printed"]
    pub fn SCIPprintVersion(scip: *mut SCIP, file: *mut FILE);
}
extern "C" {
    #[doc = " prints detailed information on the compile-time flags\n\n  @note If the message handler is set to a NULL pointer nothing will be printed"]
    pub fn SCIPprintBuildOptions(scip: *mut SCIP, file: *mut FILE);
}
extern "C" {
    #[doc = " prints error message for the given SCIP_RETCODE via the error prints method"]
    pub fn SCIPprintError(retcode: SCIP_RETCODE);
}
extern "C" {
    #[doc = " creates and initializes SCIP data structures\n\n  @note The SCIP default message handler is installed. Use the method SCIPsetMessagehdlr() to install your own\n        message handler or SCIPsetMessagehdlrLogfile() and SCIPsetMessagehdlrQuiet() to write into a log\n        file and turn off/on the display output, respectively.\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @post After calling this method @p scip reached the solving stage \\ref SCIP_STAGE_INIT\n\n  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPcreate(scip: *mut *mut SCIP) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " frees SCIP data structures\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_INIT\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED\n       - \\ref SCIP_STAGE_FREE\n\n  @post After calling this method \\SCIP reached the solving stage \\ref SCIP_STAGE_FREE\n\n  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPfree(scip: *mut *mut SCIP) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " returns current stage of SCIP\n\n  @return the current SCIP stage\n\n  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPgetStage(scip: *mut SCIP) -> SCIP_STAGE;
}
extern "C" {
    #[doc = " outputs SCIP stage and solution status if applicable via the message handler\n\n  @note If the message handler is set to a NULL pointer nothing will be printed\n\n  @note If limits have been changed between the solution and the call to this function, the status is recomputed and\n        thus may to correspond to the original status.\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPprintStage(scip: *mut SCIP, file: *mut FILE) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " gets solution status\n\n  @return SCIP solution status\n\n  See \\ref SCIP_Status \"SCIP_STATUS\" for a complete list of all possible solving status."]
    pub fn SCIPgetStatus(scip: *mut SCIP) -> SCIP_STATUS;
}
extern "C" {
    #[doc = " outputs solution status\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  See \\ref SCIP_Status \"SCIP_STATUS\" for a complete list of all possible solving status."]
    pub fn SCIPprintStatus(scip: *mut SCIP, file: *mut FILE) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " returns whether the current stage belongs to the transformed problem space\n\n  @return Returns TRUE if the \\SCIP instance is transformed, otherwise FALSE"]
    pub fn SCIPisTransformed(scip: *mut SCIP) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " returns whether the solution process is arithmetically exact, i.e., not subject to roundoff errors\n\n  @note This feature is not supported yet!\n\n  @return Returns TRUE if \\SCIP is exact solving mode, otherwise FALSE"]
    pub fn SCIPisExactSolve(scip: *mut SCIP) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " returns whether the presolving process would be finished given no more presolving reductions are found in this\n  presolving round\n\n  Checks whether the number of presolving rounds is not exceeded and the presolving reductions found in the current\n  presolving round suffice to trigger another presolving round.\n\n  @note if subsequent presolvers find more reductions, presolving might continue even if the method returns FALSE\n  @note does not check whether infeasibility or unboundedness was already detected in presolving (which would result\n        in presolving being stopped although the method returns TRUE)\n\n  @return Returns TRUE if presolving is finished if no further reductions are detected"]
    pub fn SCIPisPresolveFinished(scip: *mut SCIP) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " returns whether SCIP has performed presolving during the last solve\n\n  @return Returns TRUE if presolving was performed during the last solve"]
    pub fn SCIPhasPerformedPresolve(scip: *mut SCIP) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " returns whether the user pressed CTRL-C to interrupt the solving process\n\n  @return Returns TRUE if Ctrl-C was pressed, otherwise FALSE."]
    pub fn SCIPpressedCtrlC(scip: *mut SCIP) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " returns whether the solving process should be / was stopped before proving optimality;\n  if the solving process should be / was stopped, the status returned by SCIPgetStatus() yields\n  the reason for the premature abort\n\n  @return Returns TRUE if solving process is stopped/interrupted, otherwise FALSE."]
    pub fn SCIPisStopped(scip: *mut SCIP) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " includes information about an external code linked into the SCIP library"]
    pub fn SCIPincludeExternalCodeInformation(
        scip: *mut SCIP,
        name: *const ::std::os::raw::c_char,
        description: *const ::std::os::raw::c_char,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " returns an array of names of currently included external codes"]
    pub fn SCIPgetExternalCodeNames(scip: *mut SCIP) -> *mut *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " returns an array of the descriptions of currently included external codes\n\n  @note some descriptions may be NULL"]
    pub fn SCIPgetExternalCodeDescriptions(scip: *mut SCIP) -> *mut *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " returns the number of currently included information on external codes"]
    pub fn SCIPgetNExternalCodes(scip: *mut SCIP) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " prints information on external codes to a file stream via the message handler system\n\n  @note If the message handler is set to a NULL pointer nothing will be printed"]
    pub fn SCIPprintExternalCodes(scip: *mut SCIP, file: *mut FILE);
}
extern "C" {
    #[doc = " creates a primal heuristic and includes it in SCIP.\n\n  @note method has all heuristic callbacks as arguments and is thus changed every time a new\n        callback is added in future releases; consider using SCIPincludeHeurBasic() and setter functions\n        if you seek for a method which is less likely to change in future releases\n\n  @return \\ref SCIP_OKAY is returned if everything worked. otherwise a suitable error code is passed. see \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_INIT\n       - \\ref SCIP_STAGE_PROBLEM"]
    pub fn SCIPincludeHeur(
        scip: *mut SCIP,
        name: *const ::std::os::raw::c_char,
        desc: *const ::std::os::raw::c_char,
        dispchar: ::std::os::raw::c_char,
        priority: ::std::os::raw::c_int,
        freq: ::std::os::raw::c_int,
        freqofs: ::std::os::raw::c_int,
        maxdepth: ::std::os::raw::c_int,
        timingmask: SCIP_HEURTIMING,
        usessubscip: ::std::os::raw::c_uint,
        heurcopy: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, heur: *mut SCIP_HEUR) -> SCIP_RETCODE,
        >,
        heurfree: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, heur: *mut SCIP_HEUR) -> SCIP_RETCODE,
        >,
        heurinit: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, heur: *mut SCIP_HEUR) -> SCIP_RETCODE,
        >,
        heurexit: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, heur: *mut SCIP_HEUR) -> SCIP_RETCODE,
        >,
        heurinitsol: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, heur: *mut SCIP_HEUR) -> SCIP_RETCODE,
        >,
        heurexitsol: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, heur: *mut SCIP_HEUR) -> SCIP_RETCODE,
        >,
        heurexec: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                heur: *mut SCIP_HEUR,
                heurtiming: SCIP_HEURTIMING,
                nodeinfeasible: ::std::os::raw::c_uint,
                result: *mut SCIP_RESULT,
            ) -> SCIP_RETCODE,
        >,
        heurdata: *mut SCIP_HEURDATA,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " creates a primal heuristic and includes it in SCIP with its most fundamental callbacks.\n  All non-fundamental (or optional) callbacks\n  as, e. g., init and exit callbacks, will be set to NULL.\n  Optional callbacks can be set via specific setter functions, see SCIPsetHeurCopy(), SCIPsetHeurFree(),\n  SCIPsetHeurInit(), SCIPsetHeurExit(), SCIPsetHeurInitsol(), and SCIPsetHeurExitsol()\n\n  @note if you want to set all callbacks with a single method call, consider using SCIPincludeHeur() instead"]
    pub fn SCIPincludeHeurBasic(
        scip: *mut SCIP,
        heur: *mut *mut SCIP_HEUR,
        name: *const ::std::os::raw::c_char,
        desc: *const ::std::os::raw::c_char,
        dispchar: ::std::os::raw::c_char,
        priority: ::std::os::raw::c_int,
        freq: ::std::os::raw::c_int,
        freqofs: ::std::os::raw::c_int,
        maxdepth: ::std::os::raw::c_int,
        timingmask: SCIP_HEURTIMING,
        usessubscip: ::std::os::raw::c_uint,
        heurexec: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                heur: *mut SCIP_HEUR,
                heurtiming: SCIP_HEURTIMING,
                nodeinfeasible: ::std::os::raw::c_uint,
                result: *mut SCIP_RESULT,
            ) -> SCIP_RETCODE,
        >,
        heurdata: *mut SCIP_HEURDATA,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " sets copy method of primal heuristic"]
    pub fn SCIPsetHeurCopy(
        scip: *mut SCIP,
        heur: *mut SCIP_HEUR,
        heurcopy: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, heur: *mut SCIP_HEUR) -> SCIP_RETCODE,
        >,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " sets destructor method of primal heuristic"]
    pub fn SCIPsetHeurFree(
        scip: *mut SCIP,
        heur: *mut SCIP_HEUR,
        heurfree: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, heur: *mut SCIP_HEUR) -> SCIP_RETCODE,
        >,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " sets initialization method of primal heuristic"]
    pub fn SCIPsetHeurInit(
        scip: *mut SCIP,
        heur: *mut SCIP_HEUR,
        heurinit: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, heur: *mut SCIP_HEUR) -> SCIP_RETCODE,
        >,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " sets deinitialization method of primal heuristic"]
    pub fn SCIPsetHeurExit(
        scip: *mut SCIP,
        heur: *mut SCIP_HEUR,
        heurexit: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, heur: *mut SCIP_HEUR) -> SCIP_RETCODE,
        >,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " sets solving process initialization method of primal heuristic"]
    pub fn SCIPsetHeurInitsol(
        scip: *mut SCIP,
        heur: *mut SCIP_HEUR,
        heurinitsol: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, heur: *mut SCIP_HEUR) -> SCIP_RETCODE,
        >,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " sets solving process deinitialization method of primal heuristic"]
    pub fn SCIPsetHeurExitsol(
        scip: *mut SCIP,
        heur: *mut SCIP_HEUR,
        heurexitsol: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, heur: *mut SCIP_HEUR) -> SCIP_RETCODE,
        >,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " returns the primal heuristic of the given name, or NULL if not existing"]
    pub fn SCIPfindHeur(scip: *mut SCIP, name: *const ::std::os::raw::c_char) -> *mut SCIP_HEUR;
}
extern "C" {
    #[doc = " returns the array of currently available primal heuristics"]
    pub fn SCIPgetHeurs(scip: *mut SCIP) -> *mut *mut SCIP_HEUR;
}
extern "C" {
    #[doc = " returns the number of currently available primal heuristics"]
    pub fn SCIPgetNHeurs(scip: *mut SCIP) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " sets the priority of a primal heuristic"]
    pub fn SCIPsetHeurPriority(
        scip: *mut SCIP,
        heur: *mut SCIP_HEUR,
        priority: ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " create a diving set associated with a primal heuristic. The primal heuristic needs to be included\n  before this method can be called. The diveset is installed in the array of divesets of the heuristic\n  and can be retrieved later by accessing SCIPheurGetDivesets()\n\n  @return \\ref SCIP_OKAY is returned if everything worked. otherwise a suitable error code is passed. see \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_INIT\n       - \\ref SCIP_STAGE_PROBLEM"]
    pub fn SCIPcreateDiveset(
        scip: *mut SCIP,
        diveset: *mut *mut SCIP_DIVESET,
        heur: *mut SCIP_HEUR,
        name: *const ::std::os::raw::c_char,
        minreldepth: f64,
        maxreldepth: f64,
        maxlpiterquot: f64,
        maxdiveubquot: f64,
        maxdiveavgquot: f64,
        maxdiveubquotnosol: f64,
        maxdiveavgquotnosol: f64,
        lpresolvedomchgquot: f64,
        lpsolvefreq: ::std::os::raw::c_int,
        maxlpiterofs: ::std::os::raw::c_int,
        initialseed: ::std::os::raw::c_uint,
        backtrack: ::std::os::raw::c_uint,
        onlylpbranchcands: ::std::os::raw::c_uint,
        ispublic: ::std::os::raw::c_uint,
        specificsos1score: ::std::os::raw::c_uint,
        divesetgetscore: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                diveset: *mut SCIP_DIVESET,
                divetype: SCIP_DIVETYPE,
                cand: *mut SCIP_VAR,
                candsol: f64,
                candsfrac: f64,
                score: *mut f64,
                roundup: *mut ::std::os::raw::c_uint,
            ) -> SCIP_RETCODE,
        >,
        divesetavailable: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                diveset: *mut SCIP_DIVESET,
                available: *mut ::std::os::raw::c_uint,
            ) -> SCIP_RETCODE,
        >,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " check specific preconditions for diving, e.g., if an incumbent solution is available"]
    pub fn SCIPisDivesetAvailable(
        scip: *mut SCIP,
        diveset: *mut SCIP_DIVESET,
        available: *mut ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " returns, whether the LP was or is to be solved in the current node\n\n  @return whether the LP was or is to be solved in the current node.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_SOLVING\n\n  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPhasCurrentNodeLP(scip: *mut SCIP) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " returns, whether the LP of the current node is already constructed\n\n  @return whether the LP of the current node is already constructed.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_SOLVING\n\n  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPisLPConstructed(scip: *mut SCIP) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " makes sure that the LP of the current node is loaded and may be accessed through the LP information methods\n\n  @warning Contructing the LP might change the amount of variables known in the transformed problem and therefore also\n           the variables array of SCIP (returned by SCIPgetVars() and SCIPgetVarsData()), so it might be necessary to\n           call one of the later method after this one\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_SOLVING\n\n  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPconstructLP(scip: *mut SCIP, cutoff: *mut ::std::os::raw::c_uint) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " makes sure that the LP of the current node is flushed\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_SOLVING\n\n  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPflushLP(scip: *mut SCIP) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " gets solution status of current LP\n\n  @return the solution status of current LP.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_SOLVING\n\n  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPgetLPSolstat(scip: *mut SCIP) -> SCIP_LPSOLSTAT;
}
extern "C" {
    #[doc = " returns whether the current LP solution passed the primal feasibility check\n\n  @returns whether the current LP solution passed the primal feasibility check.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_SOLVING\n\n  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPisLPPrimalReliable(scip: *mut SCIP) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " returns whether the current LP solution passed the dual feasibility check\n\n  @returns whether the current LP solution passed the dual feasibility check.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_SOLVING\n\n  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPisLPDualReliable(scip: *mut SCIP) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " returns whether the current lp is a relaxation of the current problem and its optimal objective value is a local lower bound\n\n  @return whether the current lp is a relaxation of the current problem and its optimal objective value is a local lower bound.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_SOLVING\n\n  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPisLPRelax(scip: *mut SCIP) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " gets objective value of current LP (which is the sum of column and loose objective value)\n\n  @return the objective value of current LP (which is the sum of column and loose objective value).\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_SOLVING\n\n  @note This method returns the objective value of the current LP solution, which might be primal or dual infeasible\n        if a limit was hit during solving. It must not be used as a dual bound if the LP solution status returned by\n        SCIPgetLPSolstat() is SCIP_LPSOLSTAT_ITERLIMIT or SCIP_LPSOLSTAT_TIMELIMIT.\n\n  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPgetLPObjval(scip: *mut SCIP) -> f64;
}
extern "C" {
    #[doc = " gets part of objective value of current LP that results from COLUMN variables only\n\n  @return the part of objective value of current LP that results from COLUMN variables only.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_SOLVING\n\n  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPgetLPColumnObjval(scip: *mut SCIP) -> f64;
}
extern "C" {
    #[doc = " gets part of objective value of current LP that results from LOOSE variables only\n\n  @return part of objective value of current LP that results from LOOSE variables only.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_SOLVING\n\n  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPgetLPLooseObjval(scip: *mut SCIP) -> f64;
}
extern "C" {
    #[doc = " gets the global pseudo objective value; that is all variables set to their best  (w.r.t. the objective\n  function) global bound\n\n  @return the global pseudo objective value; that is all variables set to their best  (w.r.t. the objective\n  function) global bound.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n\n  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPgetGlobalPseudoObjval(scip: *mut SCIP) -> f64;
}
extern "C" {
    #[doc = " gets the pseudo objective value for the current search node; that is all variables set to their best (w.r.t. the\n  objective function) local bound\n\n  @return the pseudo objective value for the current search node; that is all variables set to their best (w.r.t. the\n  objective function) local bound.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n\n  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPgetPseudoObjval(scip: *mut SCIP) -> f64;
}
extern "C" {
    #[doc = " returns whether the root lp is a relaxation of the problem and its optimal objective value is a global lower bound\n\n  @return whether the root lp is a relaxation of the problem and its optimal objective value is a global lower bound.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_SOLVING\n\n  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPisRootLPRelax(scip: *mut SCIP) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " gets the objective value of the root node LP or SCIP_INVALID if the root node LP was not (yet) solved\n\n  @return the objective value of the root node LP or SCIP_INVALID if the root node LP was not (yet) solved.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_SOLVING\n\n  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPgetLPRootObjval(scip: *mut SCIP) -> f64;
}
extern "C" {
    #[doc = " gets part of the objective value of the root node LP that results from COLUMN variables only;\n  returns SCIP_INVALID if the root node LP was not (yet) solved\n\n  @return the part of the objective value of the root node LP that results from COLUMN variables only;\n  or SCIP_INVALID if the root node LP was not (yet) solved.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_SOLVING\n\n  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPgetLPRootColumnObjval(scip: *mut SCIP) -> f64;
}
extern "C" {
    #[doc = " gets part of the objective value of the root node LP that results from LOOSE variables only;\n  returns SCIP_INVALID if the root node LP was not (yet) solved\n\n  @return the part of the objective value of the root node LP that results from LOOSE variables only;\n  or SCIP_INVALID if the root node LP was not (yet) solved.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_SOLVING\n\n  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPgetLPRootLooseObjval(scip: *mut SCIP) -> f64;
}
extern "C" {
    #[doc = " gets current primal feasibility tolerance of LP"]
    pub fn SCIPgetLPFeastol(scip: *mut SCIP) -> f64;
}
extern "C" {
    #[doc = " sets primal feasibility tolerance of LP"]
    pub fn SCIPsetLPFeastol(scip: *mut SCIP, newfeastol: f64);
}
extern "C" {
    #[doc = " resets primal feasibility tolerance of LP\n\n Sets primal feasibility tolerance to min of numerics/lpfeastolfactor * numerics/feastol and relaxfeastol."]
    pub fn SCIPresetLPFeastol(scip: *mut SCIP);
}
extern "C" {
    #[doc = " gets current LP columns along with the current number of LP columns\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_SOLVING\n\n  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPgetLPColsData(
        scip: *mut SCIP,
        cols: *mut *mut *mut SCIP_COL,
        ncols: *mut ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " gets current LP columns\n\n  @return the current LP columns.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_SOLVING\n\n  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPgetLPCols(scip: *mut SCIP) -> *mut *mut SCIP_COL;
}
extern "C" {
    #[doc = " gets current number of LP columns\n\n  @return the current number of LP columns.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_SOLVING\n\n  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPgetNLPCols(scip: *mut SCIP) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " gets current number of unfixed LP columns\n\n  @return the current number of unfixed LP columns.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_SOLVING\n\n  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPgetNUnfixedLPCols(scip: *mut SCIP) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " gets current LP rows along with the current number of LP rows\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_SOLVING\n\n  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPgetLPRowsData(
        scip: *mut SCIP,
        rows: *mut *mut *mut SCIP_ROW,
        nrows: *mut ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " gets current LP rows\n\n  @return the current LP rows.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_SOLVING\n\n  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPgetLPRows(scip: *mut SCIP) -> *mut *mut SCIP_ROW;
}
extern "C" {
    #[doc = " gets current number of LP rows\n\n  @return the current number of LP rows.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_SOLVING\n\n  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPgetNLPRows(scip: *mut SCIP) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " returns TRUE iff all columns, i.e. every variable with non-empty column w.r.t. all ever created rows, are present\n  in the LP, and FALSE, if there are additional already existing columns, that may be added to the LP in pricing\n\n  @return TRUE iff all columns, i.e. every variable with non-empty column w.r.t. all ever created rows, are present\n  in the LP, and FALSE, if there are additional already existing columns, that may be added to the LP in pricing.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_SOLVING\n\n  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPallColsInLP(scip: *mut SCIP) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " returns whether the current LP solution is basic, i.e. is defined by a valid simplex basis\n\n  @return whether the current LP solution is basic, i.e. is defined by a valid simplex basis.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_SOLVING\n\n  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPisLPSolBasic(scip: *mut SCIP) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " gets all indices of basic columns and rows: index i >= 0 corresponds to column i, index i < 0 to row -i-1\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_SOLVING\n\n  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPgetLPBasisInd(scip: *mut SCIP, basisind: *mut ::std::os::raw::c_int)
        -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " gets a row from the inverse basis matrix B^-1\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_SOLVING\n\n  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPgetLPBInvRow(
        scip: *mut SCIP,
        r: ::std::os::raw::c_int,
        coefs: *mut f64,
        inds: *mut ::std::os::raw::c_int,
        ninds: *mut ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " gets a column from the inverse basis matrix B^-1\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_SOLVING\n\n  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPgetLPBInvCol(
        scip: *mut SCIP,
        c: ::std::os::raw::c_int,
        coefs: *mut f64,
        inds: *mut ::std::os::raw::c_int,
        ninds: *mut ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " gets a row from the product of inverse basis matrix B^-1 and coefficient matrix A (i.e. from B^-1 * A)\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_SOLVING\n\n  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPgetLPBInvARow(
        scip: *mut SCIP,
        r: ::std::os::raw::c_int,
        binvrow: *mut f64,
        coefs: *mut f64,
        inds: *mut ::std::os::raw::c_int,
        ninds: *mut ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " gets a column from the product of inverse basis matrix B^-1 and coefficient matrix A (i.e. from B^-1 * A),\n  i.e., it computes B^-1 * A_c with A_c being the c'th column of A\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_SOLVING\n\n  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPgetLPBInvACol(
        scip: *mut SCIP,
        c: ::std::os::raw::c_int,
        coefs: *mut f64,
        inds: *mut ::std::os::raw::c_int,
        ninds: *mut ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " calculates a weighted sum of all LP rows; for negative weights, the left and right hand side of the corresponding\n  LP row are swapped in the summation\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_SOLVING\n\n  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPsumLPRows(
        scip: *mut SCIP,
        weights: *mut f64,
        sumcoef: *mut SCIP_REALARRAY,
        sumlhs: *mut f64,
        sumrhs: *mut f64,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " interrupts or disables the interrupt of the currently ongoing lp solve; if the lp is not currently constructed just returns with no effect\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_SOLVING\n\n  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPinterruptLP(scip: *mut SCIP, interrupt: ::std::os::raw::c_uint) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " writes current LP to a file\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_SOLVING\n\n  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPwriteLP(scip: *mut SCIP, filename: *const ::std::os::raw::c_char) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " writes MIP relaxation of the current branch-and-bound node to a file\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_SOLVING\n\n  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPwriteMIP(
        scip: *mut SCIP,
        filename: *const ::std::os::raw::c_char,
        genericnames: ::std::os::raw::c_uint,
        origobj: ::std::os::raw::c_uint,
        lazyconss: ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " gets the LP interface of SCIP;\n  with the LPI you can use all of the methods defined in lpi/lpi.h;\n\n  @warning You have to make sure, that the full internal state of the LPI does not change or is recovered completely\n           after the end of the method that uses the LPI. In particular, if you manipulate the LP or its solution\n           (e.g. by calling one of the SCIPlpiAdd...() or one of the SCIPlpiSolve...() methods), you have to check in\n           advance with SCIPlpiWasSolved() whether the LP is currently solved. If this is the case, you have to make\n           sure, the internal solution status is recovered completely at the end of your method. This can be achieved\n           by getting the LPI state before applying any LPI manipulations with SCIPlpiGetState() and restoring it\n           afterwards with SCIPlpiSetState() and SCIPlpiFreeState(). Additionally you have to resolve the LP with the\n           appropriate SCIPlpiSolve...() call in order to reinstall the internal solution status.\n\n  @warning Make also sure, that all parameter values that you have changed are set back to their original values.\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED\n       - \\ref SCIP_STAGE_EXITSOLVE\n\n  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPgetLPI(scip: *mut SCIP, lpi: *mut *mut SCIP_LPI) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " Displays quality information about the current LP solution. An LP solution need to be available. Information printed\n  is subject to what the LP solver supports\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_INIT\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED\n       - \\ref SCIP_STAGE_FREE\n\n  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages.\n\n  @note The printing process is done via the message handler system."]
    pub fn SCIPprintLPSolutionQuality(scip: *mut SCIP, file: *mut FILE) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " compute relative interior point to current LP\n  @see SCIPlpComputeRelIntPoint\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED\n\n  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPcomputeLPRelIntPoint(
        scip: *mut SCIP,
        relaxrows: ::std::os::raw::c_uint,
        inclobjcutoff: ::std::os::raw::c_uint,
        timelimit: f64,
        iterlimit: ::std::os::raw::c_int,
        point: *mut *mut SCIP_SOL,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " returns the reduced costs of a column in the last (feasible) LP\n\n  @return the reduced costs of a column in the last (feasible) LP\n\n  @pre this method can be called in one of the following stages of the SCIP solving process:\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED\n\n  @note calling this method in SCIP_STAGE_SOLVED is only recommended to experienced users and should only be called\n        for pure LP instances (without presolving)\n\n  @note The return value of this method should be used carefully if the dual feasibility check was explictely disabled."]
    pub fn SCIPgetColRedcost(scip: *mut SCIP, col: *mut SCIP_COL) -> f64;
}
extern "C" {
    #[doc = " returns the Farkas coefficient of a column in the last (infeasible) LP\n\n  @return the Farkas coefficient of a column in the last (infeasible) LP\n\n  @pre this method can be called in one of the following stages of the SCIP solving process:\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPgetColFarkasCoef(scip: *mut SCIP, col: *mut SCIP_COL) -> f64;
}
extern "C" {
    #[doc = " marks a column to be not removable from the LP in the current node\n\n  @pre this method can be called in the following stage of the SCIP solving process:\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPmarkColNotRemovableLocal(scip: *mut SCIP, col: *mut SCIP_COL);
}
extern "C" {
    #[doc = " creates and captures an LP row from a constraint handler\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre this method can be called in one of the following stages of the SCIP solving process:\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPcreateRowConshdlr(
        scip: *mut SCIP,
        row: *mut *mut SCIP_ROW,
        conshdlr: *mut SCIP_CONSHDLR,
        name: *const ::std::os::raw::c_char,
        len: ::std::os::raw::c_int,
        cols: *mut *mut SCIP_COL,
        vals: *mut f64,
        lhs: f64,
        rhs: f64,
        local: ::std::os::raw::c_uint,
        modifiable: ::std::os::raw::c_uint,
        removable: ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " creates and captures an LP row from a constraint\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre this method can be called in one of the following stages of the SCIP solving process:\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPcreateRowCons(
        scip: *mut SCIP,
        row: *mut *mut SCIP_ROW,
        cons: *mut SCIP_CONS,
        name: *const ::std::os::raw::c_char,
        len: ::std::os::raw::c_int,
        cols: *mut *mut SCIP_COL,
        vals: *mut f64,
        lhs: f64,
        rhs: f64,
        local: ::std::os::raw::c_uint,
        modifiable: ::std::os::raw::c_uint,
        removable: ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " creates and captures an LP row from a separator\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre this method can be called in one of the following stages of the SCIP solving process:\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPcreateRowSepa(
        scip: *mut SCIP,
        row: *mut *mut SCIP_ROW,
        sepa: *mut SCIP_SEPA,
        name: *const ::std::os::raw::c_char,
        len: ::std::os::raw::c_int,
        cols: *mut *mut SCIP_COL,
        vals: *mut f64,
        lhs: f64,
        rhs: f64,
        local: ::std::os::raw::c_uint,
        modifiable: ::std::os::raw::c_uint,
        removable: ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " creates and captures an LP row from an unspecified source\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre this method can be called in one of the following stages of the SCIP solving process:\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPcreateRowUnspec(
        scip: *mut SCIP,
        row: *mut *mut SCIP_ROW,
        name: *const ::std::os::raw::c_char,
        len: ::std::os::raw::c_int,
        cols: *mut *mut SCIP_COL,
        vals: *mut f64,
        lhs: f64,
        rhs: f64,
        local: ::std::os::raw::c_uint,
        modifiable: ::std::os::raw::c_uint,
        removable: ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " creates and captures an LP row\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre this method can be called in one of the following stages of the SCIP solving process:\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n\n  @deprecated Please use SCIPcreateRowConshdlr() or SCIPcreateRowSepa() when calling from a constraint handler or separator in order\n              to facilitate correct statistics. If the call is from neither a constraint handler or separator, use SCIPcreateRowUnspec()."]
    pub fn SCIPcreateRow(
        scip: *mut SCIP,
        row: *mut *mut SCIP_ROW,
        name: *const ::std::os::raw::c_char,
        len: ::std::os::raw::c_int,
        cols: *mut *mut SCIP_COL,
        vals: *mut f64,
        lhs: f64,
        rhs: f64,
        local: ::std::os::raw::c_uint,
        modifiable: ::std::os::raw::c_uint,
        removable: ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " creates and captures an LP row without any coefficients from a constraint handler\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre this method can be called in one of the following stages of the SCIP solving process:\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPcreateEmptyRowConshdlr(
        scip: *mut SCIP,
        row: *mut *mut SCIP_ROW,
        conshdlr: *mut SCIP_CONSHDLR,
        name: *const ::std::os::raw::c_char,
        lhs: f64,
        rhs: f64,
        local: ::std::os::raw::c_uint,
        modifiable: ::std::os::raw::c_uint,
        removable: ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " creates and captures an LP row without any coefficients from a constraint\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre this method can be called in one of the following stages of the SCIP solving process:\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPcreateEmptyRowCons(
        scip: *mut SCIP,
        row: *mut *mut SCIP_ROW,
        cons: *mut SCIP_CONS,
        name: *const ::std::os::raw::c_char,
        lhs: f64,
        rhs: f64,
        local: ::std::os::raw::c_uint,
        modifiable: ::std::os::raw::c_uint,
        removable: ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " creates and captures an LP row without any coefficients from a separator\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre this method can be called in one of the following stages of the SCIP solving process:\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPcreateEmptyRowSepa(
        scip: *mut SCIP,
        row: *mut *mut SCIP_ROW,
        sepa: *mut SCIP_SEPA,
        name: *const ::std::os::raw::c_char,
        lhs: f64,
        rhs: f64,
        local: ::std::os::raw::c_uint,
        modifiable: ::std::os::raw::c_uint,
        removable: ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " creates and captures an LP row without any coefficients from an unspecified source\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre this method can be called in one of the following stages of the SCIP solving process:\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPcreateEmptyRowUnspec(
        scip: *mut SCIP,
        row: *mut *mut SCIP_ROW,
        name: *const ::std::os::raw::c_char,
        lhs: f64,
        rhs: f64,
        local: ::std::os::raw::c_uint,
        modifiable: ::std::os::raw::c_uint,
        removable: ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " creates and captures an LP row without any coefficients\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre this method can be called in one of the following stages of the SCIP solving process:\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n\n  @deprecated Please use SCIPcreateEmptyRowConshdlr() or SCIPcreateEmptyRowSepa() when calling from a constraint handler or separator in order\n              to facilitate correct statistics. If the call is from neither a constraint handler or separator, use SCIPcreateEmptyRowUnspec()."]
    pub fn SCIPcreateEmptyRow(
        scip: *mut SCIP,
        row: *mut *mut SCIP_ROW,
        name: *const ::std::os::raw::c_char,
        lhs: f64,
        rhs: f64,
        local: ::std::os::raw::c_uint,
        modifiable: ::std::os::raw::c_uint,
        removable: ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " increases usage counter of LP row\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre this method can be called in one of the following stages of the SCIP solving process:\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPcaptureRow(scip: *mut SCIP, row: *mut SCIP_ROW) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " decreases usage counter of LP row, and frees memory if necessary\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre this method can be called in one of the following stages of the SCIP solving process:\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_EXITSOLVE"]
    pub fn SCIPreleaseRow(scip: *mut SCIP, row: *mut *mut SCIP_ROW) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " changes left hand side of LP row\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre this method can be called in one of the following stages of the SCIP solving process:\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPchgRowLhs(scip: *mut SCIP, row: *mut SCIP_ROW, lhs: f64) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " changes right hand side of LP row\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre this method can be called in one of the following stages of the SCIP solving process:\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPchgRowRhs(scip: *mut SCIP, row: *mut SCIP_ROW, rhs: f64) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " informs row, that all subsequent additions of variables to the row should be cached and not directly applied;\n  after all additions were applied, SCIPflushRowExtensions() must be called;\n  while the caching of row extensions is activated, information methods of the row give invalid results;\n  caching should be used, if a row is build with SCIPaddVarToRow() calls variable by variable to increase\n  the performance\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre this method can be called in one of the following stages of the SCIP solving process:\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPcacheRowExtensions(scip: *mut SCIP, row: *mut SCIP_ROW) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " flushes all cached row extensions after a call of SCIPcacheRowExtensions() and merges coefficients with\n  equal columns into a single coefficient\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre this method can be called in one of the following stages of the SCIP solving process:\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPflushRowExtensions(scip: *mut SCIP, row: *mut SCIP_ROW) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " resolves variable to columns and adds them with the coefficient to the row\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @attention If the absolute value of val is below the SCIP epsilon tolerance, the variable will not added.\n\n  @pre this method can be called in one of the following stages of the SCIP solving process:\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n\n  @note In case calling this method in the enforcement process of an lp solution, it might be that some variables,\n        that were not yet in the LP (e.g. dynamic columns) will change their lp solution value returned by SCIP.\n        For example, a variable, which has a negative objective value, that has no column in the lp yet, is in the lp solution\n        on its upper bound (variables with status SCIP_VARSTATUS_LOOSE are in an lp solution on it's best bound), but\n        creating the column, changes the solution value (variable than has status SCIP_VARSTATUS_COLUMN, and the\n        initialization sets the lp solution value) to 0.0. (This leads to the conclusion that, if a constraint was\n        violated, the linear relaxation might not be violated anymore.)\n\n  @note When several variables are added to a row with the use of this function, performance can be improved by\n        calling SCIPcacheRowExtensions() before these additions and SCIPflushRowExtensions() after."]
    pub fn SCIPaddVarToRow(
        scip: *mut SCIP,
        row: *mut SCIP_ROW,
        var: *mut SCIP_VAR,
        val: f64,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " resolves variables to columns and adds them with the coefficients to the row;\n  this method caches the row extensions and flushes them afterwards to gain better performance\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @attention If a coefficients absolute value is below the SCIP epsilon tolerance, the variable with its value is not added.\n\n  @pre this method can be called in one of the following stages of the SCIP solving process:\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPaddVarsToRow(
        scip: *mut SCIP,
        row: *mut SCIP_ROW,
        nvars: ::std::os::raw::c_int,
        vars: *mut *mut SCIP_VAR,
        vals: *mut f64,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " resolves variables to columns and adds them with the same single coefficient to the row;\n  this method caches the row extensions and flushes them afterwards to gain better performance\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @attention If the absolute value of val is below the SCIP epsilon tolerance, the variables will not added.\n\n  @pre this method can be called in one of the following stages of the SCIP solving process:\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPaddVarsToRowSameCoef(
        scip: *mut SCIP,
        row: *mut SCIP_ROW,
        nvars: ::std::os::raw::c_int,
        vars: *mut *mut SCIP_VAR,
        val: f64,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " tries to find a value, such that all row coefficients, if scaled with this value become integral\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre this method can be called in one of the following stages of the SCIP solving process:\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPcalcRowIntegralScalar(
        scip: *mut SCIP,
        row: *mut SCIP_ROW,
        mindelta: f64,
        maxdelta: f64,
        maxdnom: ::std::os::raw::c_longlong,
        maxscale: f64,
        usecontvars: ::std::os::raw::c_uint,
        intscalar: *mut f64,
        success: *mut ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " tries to scale row, s.t. all coefficients (of integer variables) become integral\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre this method can be called in one of the following stages of the SCIP solving process:\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPmakeRowIntegral(
        scip: *mut SCIP,
        row: *mut SCIP_ROW,
        mindelta: f64,
        maxdelta: f64,
        maxdnom: ::std::os::raw::c_longlong,
        maxscale: f64,
        usecontvars: ::std::os::raw::c_uint,
        success: *mut ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " marks a row to be not removable from the LP in the current node\n\n  @pre this method can be called in the following stage of the SCIP solving process:\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPmarkRowNotRemovableLocal(scip: *mut SCIP, row: *mut SCIP_ROW);
}
extern "C" {
    #[doc = " returns number of integral columns in the row\n\n  @return number of integral columns in the row\n\n  @pre this method can be called in one of the following stages of the SCIP solving process:\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPgetRowNumIntCols(scip: *mut SCIP, row: *mut SCIP_ROW) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " returns minimal absolute value of row vector's non-zero coefficients\n\n  @return minimal absolute value of row vector's non-zero coefficients\n\n  @pre this method can be called in one of the following stages of the SCIP solving process:\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPgetRowMinCoef(scip: *mut SCIP, row: *mut SCIP_ROW) -> f64;
}
extern "C" {
    #[doc = " returns maximal absolute value of row vector's non-zero coefficients\n\n  @return maximal absolute value of row vector's non-zero coefficients\n\n  @pre this method can be called in one of the following stages of the SCIP solving process:\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPgetRowMaxCoef(scip: *mut SCIP, row: *mut SCIP_ROW) -> f64;
}
extern "C" {
    #[doc = " returns the minimal activity of a row w.r.t. the column's bounds\n\n  @return the minimal activity of a row w.r.t. the column's bounds\n\n  @pre this method can be called in one of the following stages of the SCIP solving process:\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPgetRowMinActivity(scip: *mut SCIP, row: *mut SCIP_ROW) -> f64;
}
extern "C" {
    #[doc = " returns the maximal activity of a row w.r.t. the column's bounds\n\n  @return the maximal activity of a row w.r.t. the column's bounds\n\n  @pre this method can be called in one of the following stages of the SCIP solving process:\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPgetRowMaxActivity(scip: *mut SCIP, row: *mut SCIP_ROW) -> f64;
}
extern "C" {
    #[doc = " recalculates the activity of a row in the last LP solution\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre this method can be called in one of the following stages of the SCIP solving process:\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPrecalcRowLPActivity(scip: *mut SCIP, row: *mut SCIP_ROW) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " returns the activity of a row in the last LP solution\n\n  @return activity of a row in the last LP solution\n\n  @pre this method can be called in one of the following stages of the SCIP solving process:\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPgetRowLPActivity(scip: *mut SCIP, row: *mut SCIP_ROW) -> f64;
}
extern "C" {
    #[doc = " returns the feasibility of a row in the last LP solution\n\n  @return the feasibility of a row in the last LP solution: negative value means infeasibility\n\n  @pre this method can be called in one of the following stages of the SCIP solving process:\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPgetRowLPFeasibility(scip: *mut SCIP, row: *mut SCIP_ROW) -> f64;
}
extern "C" {
    #[doc = " recalculates the activity of a row for the current pseudo solution\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre this method can be called in one of the following stages of the SCIP solving process:\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPrecalcRowPseudoActivity(scip: *mut SCIP, row: *mut SCIP_ROW) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " returns the activity of a row for the current pseudo solution\n\n  @return the activity of a row for the current pseudo solution\n\n  @pre this method can be called in one of the following stages of the SCIP solving process:\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPgetRowPseudoActivity(scip: *mut SCIP, row: *mut SCIP_ROW) -> f64;
}
extern "C" {
    #[doc = " returns the feasibility of a row for the current pseudo solution: negative value means infeasibility\n\n  @return the feasibility of a row for the current pseudo solution: negative value means infeasibility\n\n  @pre this method can be called in one of the following stages of the SCIP solving process:\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPgetRowPseudoFeasibility(scip: *mut SCIP, row: *mut SCIP_ROW) -> f64;
}
extern "C" {
    #[doc = " recalculates the activity of a row in the last LP or pseudo solution\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre this method can be called in one of the following stages of the SCIP solving process:\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPrecalcRowActivity(scip: *mut SCIP, row: *mut SCIP_ROW) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " returns the activity of a row in the last LP or pseudo solution\n\n  @return the activity of a row in the last LP or pseudo solution\n\n  @pre this method can be called in one of the following stages of the SCIP solving process:\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPgetRowActivity(scip: *mut SCIP, row: *mut SCIP_ROW) -> f64;
}
extern "C" {
    #[doc = " returns the feasibility of a row in the last LP or pseudo solution\n\n  @return the feasibility of a row in the last LP or pseudo solution\n\n  @pre this method can be called in one of the following stages of the SCIP solving process:\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPgetRowFeasibility(scip: *mut SCIP, row: *mut SCIP_ROW) -> f64;
}
extern "C" {
    #[doc = " returns the activity of a row for the given primal solution\n\n  @return the activitiy of a row for the given primal solution\n\n  @pre this method can be called in one of the following stages of the SCIP solving process:\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPgetRowSolActivity(scip: *mut SCIP, row: *mut SCIP_ROW, sol: *mut SCIP_SOL) -> f64;
}
extern "C" {
    #[doc = " returns the feasibility of a row for the given primal solution\n\n  @return the feasibility of a row for the given primal solution\n\n  @pre this method can be called in one of the following stages of the SCIP solving process:\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPgetRowSolFeasibility(scip: *mut SCIP, row: *mut SCIP_ROW, sol: *mut SCIP_SOL)
        -> f64;
}
extern "C" {
    #[doc = " returns the parallelism of row with objective function\n\n  @return 1 is returned if the row is parallel to the objective function and 0 if it is orthogonal\n\n  @pre this method can be called in one of the following stages of the SCIP solving process:\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPgetRowObjParallelism(scip: *mut SCIP, row: *mut SCIP_ROW) -> f64;
}
extern "C" {
    #[doc = " output row to file stream via the message handler system\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre this method can be called in one of the following stages of the SCIP solving process:\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED\n       - \\ref SCIP_STAGE_EXITSOLVE"]
    pub fn SCIPprintRow(scip: *mut SCIP, row: *mut SCIP_ROW, file: *mut FILE) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " initiates LP diving, making methods SCIPchgVarObjDive(), SCIPchgVarLbDive(), and SCIPchgVarUbDive() available\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_SOLVING\n\n  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages.\n\n  @note diving is allowed even if the current LP is not flushed, not solved, or not solved to optimality; be aware\n  that solving the (first) diving LP may take longer than expect and that the latter two cases could stem from\n  numerical troubles during the last LP solve; because of this, most users will want to call this method only if\n  SCIPgetLPSolstat(scip) == SCIP_LPSOLSTAT_OPTIMAL"]
    pub fn SCIPstartDive(scip: *mut SCIP) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " quits LP diving and resets bounds and objective values of columns to the current node's values\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_SOLVING\n\n  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPendDive(scip: *mut SCIP) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " changes cutoffbound in current dive\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_SOLVING\n\n  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPchgCutoffboundDive(scip: *mut SCIP, newcutoffbound: f64) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " changes variable's objective value in current dive\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_SOLVING\n\n  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPchgVarObjDive(scip: *mut SCIP, var: *mut SCIP_VAR, newobj: f64) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " changes variable's lower bound in current dive\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_SOLVING\n\n  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPchgVarLbDive(scip: *mut SCIP, var: *mut SCIP_VAR, newbound: f64) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " changes variable's upper bound in current dive\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_SOLVING\n\n  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPchgVarUbDive(scip: *mut SCIP, var: *mut SCIP_VAR, newbound: f64) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " adds a row to the LP in current dive\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_SOLVING\n\n  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPaddRowDive(scip: *mut SCIP, row: *mut SCIP_ROW) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " changes row lhs in current dive, change will be undone after diving ends, for permanent changes use SCIPchgRowLhs()\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_SOLVING\n\n  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPchgRowLhsDive(scip: *mut SCIP, row: *mut SCIP_ROW, newlhs: f64) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " changes row rhs in current dive, change will be undone after diving ends, for permanent changes use SCIPchgRowRhs()\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_SOLVING\n\n  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPchgRowRhsDive(scip: *mut SCIP, row: *mut SCIP_ROW, newrhs: f64) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " gets variable's objective value in current dive\n\n  @return the variable's objective value in current dive.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_SOLVING\n\n  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPgetVarObjDive(scip: *mut SCIP, var: *mut SCIP_VAR) -> f64;
}
extern "C" {
    #[doc = " gets variable's lower bound in current dive\n\n  @return the variable's lower bound in current dive.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_SOLVING\n\n  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPgetVarLbDive(scip: *mut SCIP, var: *mut SCIP_VAR) -> f64;
}
extern "C" {
    #[doc = " gets variable's upper bound in current dive\n\n  @return the variable's upper bound in current dive.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_SOLVING\n\n  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPgetVarUbDive(scip: *mut SCIP, var: *mut SCIP_VAR) -> f64;
}
extern "C" {
    #[doc = " solves the LP of the current dive; no separation or pricing is applied\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_SOLVING\n\n  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages.\n\n  @note be aware that the LP solve may take longer than expected if SCIPgetLPSolstat(scip) != SCIP_LPSOLSTAT_OPTIMAL,\n  compare the explanation of SCIPstartDive()"]
    pub fn SCIPsolveDiveLP(
        scip: *mut SCIP,
        itlim: ::std::os::raw::c_int,
        lperror: *mut ::std::os::raw::c_uint,
        cutoff: *mut ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " returns the number of the node in the current branch and bound run, where the last LP was solved in diving\n  or probing mode\n\n  @return the number of the node in the current branch and bound run, where the last LP was solved in diving\n  or probing mode.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_TRANSFORMING\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED\n       - \\ref SCIP_STAGE_EXITSOLVE\n       - \\ref SCIP_STAGE_FREETRANS\n\n  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPgetLastDivenode(scip: *mut SCIP) -> ::std::os::raw::c_longlong;
}
extern "C" {
    #[doc = " returns whether we are in diving mode\n\n  @return whether we are in diving mode.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_TRANSFORMING\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED\n       - \\ref SCIP_STAGE_EXITSOLVE\n       - \\ref SCIP_STAGE_FREETRANS\n\n  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPinDive(scip: *mut SCIP) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " computes two measures for dual degeneracy (dual degeneracy rate and variable-constraint ratio)\n  based on the changes applied when reducing the problem to the optimal face\n\n  returns the dual degeneracy rate, i.e., the share of nonbasic variables with reduced cost 0\n  and the variable-constraint ratio, i.e., the number of unfixed variables in relation to the basis size"]
    pub fn SCIPgetLPDualDegeneracy(
        scip: *mut SCIP,
        degeneracy: *mut f64,
        varconsratio: *mut f64,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " returns block memory to use at the current time\n\n  @return the block memory to use at the current time."]
    pub fn SCIPblkmem(scip: *mut SCIP) -> *mut BMS_BLKMEM;
}
extern "C" {
    #[doc = " returns buffer memory for short living temporary objects\n\n  @return the buffer memory for short living temporary objects"]
    pub fn SCIPbuffer(scip: *mut SCIP) -> *mut BMS_BUFMEM;
}
extern "C" {
    #[doc = " returns clean buffer memory for short living temporary objects initialized to all zero\n\n  @return the buffer memory for short living temporary objects initialized to all zero"]
    pub fn SCIPcleanbuffer(scip: *mut SCIP) -> *mut BMS_BUFMEM;
}
extern "C" {
    #[doc = " returns the total number of bytes used in block and buffer memory\n\n  @return the total number of bytes used in block and buffer memory."]
    pub fn SCIPgetMemUsed(scip: *mut SCIP) -> ::std::os::raw::c_longlong;
}
extern "C" {
    #[doc = " returns the total number of bytes in block and buffer memory\n\n  @return the total number of bytes in block and buffer memory."]
    pub fn SCIPgetMemTotal(scip: *mut SCIP) -> ::std::os::raw::c_longlong;
}
extern "C" {
    #[doc = " returns the estimated number of bytes used by external software, e.g., the LP solver\n\n  @return the estimated number of bytes used by external software, e.g., the LP solver."]
    pub fn SCIPgetMemExternEstim(scip: *mut SCIP) -> ::std::os::raw::c_longlong;
}
extern "C" {
    #[doc = " calculate memory size for dynamically allocated arrays\n\n  @return the memory size for dynamically allocated arrays."]
    pub fn SCIPcalcMemGrowSize(
        scip: *mut SCIP,
        num: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " extends a dynamically allocated block memory array to be able to store at least the given number of elements;\n  use SCIPensureBlockMemoryArray() define to call this method!\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    pub fn SCIPensureBlockMemoryArray_call(
        scip: *mut SCIP,
        arrayptr: *mut *mut ::std::os::raw::c_void,
        elemsize: usize,
        arraysize: *mut ::std::os::raw::c_int,
        minsize: ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " prints output about used memory"]
    pub fn SCIPprintMemoryDiagnostic(scip: *mut SCIP);
}
extern "C" {
    #[doc = " installs the given message handler, such that all messages are passed to this handler. A messages handler can be\n  created via SCIPmessagehdlrCreate().\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre this method can be called in one of the following stages of the SCIP solving process:\n       - \\ref SCIP_STAGE_INIT\n       - \\ref SCIP_STAGE_PROBLEM\n\n  @note The currently installed messages handler gets freed if this SCIP instance is its last user (w.r.t. capture/release)."]
    pub fn SCIPsetMessagehdlr(scip: *mut SCIP, messagehdlr: *mut SCIP_MESSAGEHDLR) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " returns the currently installed message handler\n\n  @return the currently installed message handler, or NULL if messages are currently suppressed"]
    pub fn SCIPgetMessagehdlr(scip: *mut SCIP) -> *mut SCIP_MESSAGEHDLR;
}
extern "C" {
    #[doc = " sets the log file name for the currently installed message handler"]
    pub fn SCIPsetMessagehdlrLogfile(scip: *mut SCIP, filename: *const ::std::os::raw::c_char);
}
extern "C" {
    #[doc = " sets the currently installed message handler to be quiet (or not)"]
    pub fn SCIPsetMessagehdlrQuiet(scip: *mut SCIP, quiet: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn SCIPwarningMessage(scip: *mut SCIP, formatstr: *const ::std::os::raw::c_char, ...);
}
extern "C" {
    pub fn SCIPprintDebugMessage(
        scip: *mut SCIP,
        sourcefile: *const ::std::os::raw::c_char,
        sourceline: ::std::os::raw::c_int,
        formatstr: *const ::std::os::raw::c_char,
        ...
    );
}
extern "C" {
    pub fn SCIPdebugMessagePrint(scip: *mut SCIP, formatstr: *const ::std::os::raw::c_char, ...);
}
extern "C" {
    pub fn SCIPdialogMessage(
        scip: *mut SCIP,
        file: *mut FILE,
        formatstr: *const ::std::os::raw::c_char,
        ...
    );
}
extern "C" {
    pub fn SCIPinfoMessage(
        scip: *mut SCIP,
        file: *mut FILE,
        formatstr: *const ::std::os::raw::c_char,
        ...
    );
}
extern "C" {
    pub fn SCIPverbMessage(
        scip: *mut SCIP,
        msgverblevel: SCIP_VERBLEVEL,
        file: *mut FILE,
        formatstr: *const ::std::os::raw::c_char,
        ...
    );
}
extern "C" {
    #[doc = " returns the current message verbosity level\n\n  @return message verbosity level of SCIP\n\n  @see \\ref SCIP_VerbLevel \"SCIP_VERBLEVEL\" for a list of all verbosity levels"]
    pub fn SCIPgetVerbLevel(scip: *mut SCIP) -> SCIP_VERBLEVEL;
}
extern "C" {
    #[doc = " returns whether the NLP relaxation has been enabled\n\n  If the NLP relaxation is enabled, then SCIP will construct the NLP relaxation when the solving process is about to begin.\n  To check whether an NLP is existing, use SCIPisNLPConstructed().\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n\n  @see SCIPenableNLP"]
    pub fn SCIPisNLPEnabled(scip: *mut SCIP) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " notifies SCIP that the NLP relaxation should be initialized in INITSOLVE\n\n  This method is typically called by a constraint handler that handles constraints that have a nonlinear representation as nonlinear rows, e.g., cons_nonlinear.\n\n  The function should be called before the branch-and-bound process is initialized, e.g., when presolve is exiting.\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED"]
    pub fn SCIPenableNLP(scip: *mut SCIP);
}
extern "C" {
    #[doc = " returns, whether an NLP has been constructed\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPisNLPConstructed(scip: *mut SCIP) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " checks whether the NLP has a continuous variable in a nonlinear term\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPhasNLPContinuousNonlinearity(
        scip: *mut SCIP,
        result: *mut ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " gets current NLP variables along with the current number of NLP variables\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPgetNLPVarsData(
        scip: *mut SCIP,
        vars: *mut *mut *mut SCIP_VAR,
        nvars: *mut ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " gets array with variables of the NLP\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPgetNLPVars(scip: *mut SCIP) -> *mut *mut SCIP_VAR;
}
extern "C" {
    #[doc = " gets current number of variables in NLP\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPgetNNLPVars(scip: *mut SCIP) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " computes for each variables the number of NLP rows in which the variable appears in the nonlinear part\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPgetNLPVarsNonlinearity(
        scip: *mut SCIP,
        nlcount: *mut ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " returns dual solution values associated with lower bounds of NLP variables\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPgetNLPVarsLbDualsol(scip: *mut SCIP) -> *mut f64;
}
extern "C" {
    #[doc = " returns dual solution values associated with upper bounds of NLP variables\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPgetNLPVarsUbDualsol(scip: *mut SCIP) -> *mut f64;
}
extern "C" {
    #[doc = " gets current NLP nonlinear rows along with the current number of NLP nonlinear rows\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPgetNLPNlRowsData(
        scip: *mut SCIP,
        nlrows: *mut *mut *mut SCIP_NLROW,
        nnlrows: *mut ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " gets array with nonlinear rows of the NLP\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPgetNLPNlRows(scip: *mut SCIP) -> *mut *mut SCIP_NLROW;
}
extern "C" {
    #[doc = " gets current number of nonlinear rows in NLP\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPgetNNLPNlRows(scip: *mut SCIP) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " gets statistics on convexity of rows in NLP\n\n  Reports counts on the current number of linear rows, convex inequalities, nonconvex inequalities, and nonlinear equalities or ranged rows.\n  - A nonlinear inequality with infinity left-hand-side is accounted as convex if its expression has been marked as convex.\n  - A nonlinear inequality with infinity right-hand-side is accounted as convex if its expression has been marked as concave.\n  - Other nonlinear rows are accounted as nonconvex. Note that convexity for a nonlinear row may just not have been detected.\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPgetNLPNlRowsStat(
        scip: *mut SCIP,
        nlinear: *mut ::std::os::raw::c_int,
        nconvexineq: *mut ::std::os::raw::c_int,
        nnonconvexineq: *mut ::std::os::raw::c_int,
        nnonlineareq: *mut ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " adds a nonlinear row to the NLP. This row is captured by the NLP.\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPaddNlRow(scip: *mut SCIP, nlrow: *mut SCIP_NLROW) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " removes a nonlinear row from the NLP\n\n  This row is released in the NLP.\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED\n       - \\ref SCIP_STAGE_EXITSOLVE"]
    pub fn SCIPdelNlRow(scip: *mut SCIP, nlrow: *mut SCIP_NLROW) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " makes sure that the NLP of the current node is flushed\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPflushNLP(scip: *mut SCIP) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " sets or clears initial primal guess for NLP solution (start point for NLP solver)\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPsetNLPInitialGuess(scip: *mut SCIP, initialguess: *mut f64) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " sets initial primal guess for NLP solution (start point for NLP solver)\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPsetNLPInitialGuessSol(scip: *mut SCIP, sol: *mut SCIP_SOL) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " solves the current NLP (or diving NLP if in diving mode) with given parameters\n\n  Typical use is\n\n      SCIP_NLPPARAM nlparam = { SCIP_NLPPARAM_DEFAULT(scip); }\n      nlpparam.iterlimit = 42;\n      SCIP_CALL( SCIPsolveNLPParam(scip, nlpparam) );\n\n  or, in one line:\n\n      SCIP_CALL( SCIPsolveNLPParam(scip, (SCIP_NLPPARAM){ SCIP_NLPPARAM_DEFAULT(scip), .iterlimit = 42 }) );\n\n  To get the latter, also \\ref SCIPsolveNLP can be used.\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPsolveNLPParam(scip: *mut SCIP, param: SCIP_NLPPARAM) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " gets solution status of current NLP\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPgetNLPSolstat(scip: *mut SCIP) -> SCIP_NLPSOLSTAT;
}
extern "C" {
    #[doc = " gets termination status of last NLP solve\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPgetNLPTermstat(scip: *mut SCIP) -> SCIP_NLPTERMSTAT;
}
extern "C" {
    #[doc = " gives statistics (number of iterations, solving time, ...) of last NLP solve\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPgetNLPStatistics(
        scip: *mut SCIP,
        statistics: *mut SCIP_NLPSTATISTICS,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " gets objective value of current NLP\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPgetNLPObjval(scip: *mut SCIP) -> f64;
}
extern "C" {
    #[doc = " indicates whether a solution for the current NLP is available\n\n The solution may be optimal, feasible, or infeasible.\n Thus, returns whether the NLP solution status is at most \\ref SCIP_NLPSOLSTAT_LOCINFEASIBLE.\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPhasNLPSolution(scip: *mut SCIP) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " gets fractional variables of last NLP solution along with solution values and fractionalities\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPgetNLPFracVars(
        scip: *mut SCIP,
        fracvars: *mut *mut *mut SCIP_VAR,
        fracvarssol: *mut *mut f64,
        fracvarsfrac: *mut *mut f64,
        nfracvars: *mut ::std::os::raw::c_int,
        npriofracvars: *mut ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " writes current NLP to a file\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPwriteNLP(scip: *mut SCIP, filename: *const ::std::os::raw::c_char) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " gets the NLP interface and problem used by the SCIP NLP\n\n  @warning With the NLPI and its problem, all methods defined in \\ref scip_nlpi.h and \\ref pub_nlpi.h can be used.\n           It needs to be ensured that the full internal state of the NLPI does not change or is recovered completely\n           after the end of the method that uses the NLPI. In particular, if the NLP or its solution is manipulated\n           (e.g. by calling one of the SCIPaddNlpi...() or the SCIPsolveNlpi() method), one has to check in advance\n           whether the NLP is currently solved.  If this is the case, one has to make sure that the internal solution\n           status is recovered completely again. Additionally one has to resolve the NLP with\n           SCIPsolveNlpi() in order to reinstall the internal solution status.\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPgetNLPI(
        scip: *mut SCIP,
        nlpi: *mut *mut SCIP_NLPI,
        nlpiproblem: *mut *mut SCIP_NLPIPROBLEM,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " initiates NLP diving\n\n  Makes functions SCIPchgVarObjDiveNLP(), SCIPchgVarBoundsDiveNLP() and SCIPchgVarsBoundsDiveNLP() available.\n  Further, SCIPsolveNLP() can be used to solve the diving NLP.\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPstartDiveNLP(scip: *mut SCIP) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " ends NLP diving\n\n  Resets changes made by SCIPchgVarObjDiveNLP(), SCIPchgVarBoundsDiveNLP(), and SCIPchgVarsBoundsDiveNLP().\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPendDiveNLP(scip: *mut SCIP) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " changes linear objective coefficient of a variable in diving NLP\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPchgVarObjDiveNLP(scip: *mut SCIP, var: *mut SCIP_VAR, coef: f64) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " changes bounds of a variable in diving NLP\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPchgVarBoundsDiveNLP(
        scip: *mut SCIP,
        var: *mut SCIP_VAR,
        lb: f64,
        ub: f64,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " changes bounds of a set of variables in diving NLP\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPchgVarsBoundsDiveNLP(
        scip: *mut SCIP,
        nvars: ::std::os::raw::c_int,
        vars: *mut *mut SCIP_VAR,
        lbs: *mut f64,
        ubs: *mut f64,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " creates and captures a nonlinear row\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPcreateNlRow(
        scip: *mut SCIP,
        nlrow: *mut *mut SCIP_NLROW,
        name: *const ::std::os::raw::c_char,
        constant: f64,
        nlinvars: ::std::os::raw::c_int,
        linvars: *mut *mut SCIP_VAR,
        lincoefs: *mut f64,
        expr: *mut SCIP_EXPR,
        lhs: f64,
        rhs: f64,
        curvature: SCIP_EXPRCURV,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " creates and captures a nonlinear row without any coefficients\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPcreateEmptyNlRow(
        scip: *mut SCIP,
        nlrow: *mut *mut SCIP_NLROW,
        name: *const ::std::os::raw::c_char,
        lhs: f64,
        rhs: f64,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " creates and captures a nonlinear row from a linear row\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPcreateNlRowFromRow(
        scip: *mut SCIP,
        nlrow: *mut *mut SCIP_NLROW,
        row: *mut SCIP_ROW,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " increases usage counter of a nonlinear row\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPcaptureNlRow(scip: *mut SCIP, nlrow: *mut SCIP_NLROW) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " decreases usage counter of a nonlinear row, and frees memory if necessary\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_EXITSOLVE"]
    pub fn SCIPreleaseNlRow(scip: *mut SCIP, nlrow: *mut *mut SCIP_NLROW) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " changes left hand side of a nonlinear row\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPchgNlRowLhs(scip: *mut SCIP, nlrow: *mut SCIP_NLROW, lhs: f64) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " changes right hand side of a nonlinear row\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPchgNlRowRhs(scip: *mut SCIP, nlrow: *mut SCIP_NLROW, rhs: f64) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " changes constant of a nonlinear row\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPchgNlRowConstant(
        scip: *mut SCIP,
        nlrow: *mut SCIP_NLROW,
        constant: f64,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " set curvature of a nonlinear row"]
    pub fn SCIPsetNlRowCurvature(scip: *mut SCIP, nlrow: *mut SCIP_NLROW, curvature: SCIP_EXPRCURV);
}
extern "C" {
    #[doc = " adds variable with a linear coefficient to a nonlinear row\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPaddLinearCoefToNlRow(
        scip: *mut SCIP,
        nlrow: *mut SCIP_NLROW,
        var: *mut SCIP_VAR,
        val: f64,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " adds variables with linear coefficients to a row\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPaddLinearCoefsToNlRow(
        scip: *mut SCIP,
        nlrow: *mut SCIP_NLROW,
        nvars: ::std::os::raw::c_int,
        vars: *mut *mut SCIP_VAR,
        vals: *mut f64,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " changes linear coefficient of a variables in a nonlinear row\n\n  Setting the coefficient to 0.0 means that it is removed from the row.\n  The variable does not need to exists before.\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPchgNlRowLinearCoef(
        scip: *mut SCIP,
        nlrow: *mut SCIP_NLROW,
        var: *mut SCIP_VAR,
        coef: f64,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " sets or deletes expression in a nonlinear row\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPsetNlRowExpr(
        scip: *mut SCIP,
        nlrow: *mut SCIP_NLROW,
        expr: *mut SCIP_EXPR,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " recalculates the activity of a nonlinear row in the last NLP solution\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPrecalcNlRowNLPActivity(scip: *mut SCIP, nlrow: *mut SCIP_NLROW) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " returns the activity of a nonlinear row in the last NLP solution\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPgetNlRowNLPActivity(
        scip: *mut SCIP,
        nlrow: *mut SCIP_NLROW,
        activity: *mut f64,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " gives the feasibility of a nonlinear row in the last NLP solution: negative value means infeasibility\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPgetNlRowNLPFeasibility(
        scip: *mut SCIP,
        nlrow: *mut SCIP_NLROW,
        feasibility: *mut f64,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " recalculates the activity of a nonlinear row for the current pseudo solution\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPrecalcNlRowPseudoActivity(scip: *mut SCIP, nlrow: *mut SCIP_NLROW) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " gives the activity of a nonlinear row for the current pseudo solution\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPgetNlRowPseudoActivity(
        scip: *mut SCIP,
        nlrow: *mut SCIP_NLROW,
        pseudoactivity: *mut f64,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " gives the feasibility of a nonlinear row for the current pseudo solution: negative value means infeasibility\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPgetNlRowPseudoFeasibility(
        scip: *mut SCIP,
        nlrow: *mut SCIP_NLROW,
        pseudofeasibility: *mut f64,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " recalculates the activity of a nonlinear row in the last NLP or pseudo solution\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPrecalcNlRowActivity(scip: *mut SCIP, nlrow: *mut SCIP_NLROW) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " gives the activity of a nonlinear row in the last NLP or pseudo solution\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPgetNlRowActivity(
        scip: *mut SCIP,
        nlrow: *mut SCIP_NLROW,
        activity: *mut f64,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " gives the feasibility of a nonlinear row in the last NLP or pseudo solution\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPgetNlRowFeasibility(
        scip: *mut SCIP,
        nlrow: *mut SCIP_NLROW,
        feasibility: *mut f64,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " gives the activity of a nonlinear row for the given primal solution or NLP solution or pseudo solution\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPgetNlRowSolActivity(
        scip: *mut SCIP,
        nlrow: *mut SCIP_NLROW,
        sol: *mut SCIP_SOL,
        activity: *mut f64,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " gives the feasibility of a nonlinear row for the given primal solution\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPgetNlRowSolFeasibility(
        scip: *mut SCIP,
        nlrow: *mut SCIP_NLROW,
        sol: *mut SCIP_SOL,
        feasibility: *mut f64,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " gives the minimal and maximal activity of a nonlinear row w.r.t. the variable's bounds\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPgetNlRowActivityBounds(
        scip: *mut SCIP,
        nlrow: *mut SCIP_NLROW,
        minactivity: *mut f64,
        maxactivity: *mut f64,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " prints a nonlinear row to file stream\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPprintNlRow(scip: *mut SCIP, nlrow: *mut SCIP_NLROW, file: *mut FILE)
        -> SCIP_RETCODE;
}
extern "C" {
    pub fn SCIPnlpiComp(
        elem1: *mut ::std::os::raw::c_void,
        elem2: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " gets data of an NLPI"]
    pub fn SCIPnlpiGetData(nlpi: *mut SCIP_NLPI) -> *mut SCIP_NLPIDATA;
}
extern "C" {
    #[doc = " gets NLP solver name"]
    pub fn SCIPnlpiGetName(nlpi: *mut SCIP_NLPI) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " gets NLP solver description"]
    pub fn SCIPnlpiGetDesc(nlpi: *mut SCIP_NLPI) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " gets NLP solver priority"]
    pub fn SCIPnlpiGetPriority(nlpi: *mut SCIP_NLPI) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " gives number of problems created for NLP solver so far"]
    pub fn SCIPnlpiGetNProblems(nlpi: *mut SCIP_NLPI) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " gives total time spend in problem creation/modification/freeing"]
    pub fn SCIPnlpiGetProblemTime(nlpi: *mut SCIP_NLPI) -> f64;
}
extern "C" {
    #[doc = " total number of NLP solves so far"]
    pub fn SCIPnlpiGetNSolves(nlpi: *mut SCIP_NLPI) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " gives total time spend in NLP solves (as reported by solver)"]
    pub fn SCIPnlpiGetSolveTime(nlpi: *mut SCIP_NLPI) -> f64;
}
extern "C" {
    #[doc = " gives total time spend in function evaluation during NLP solves\n\n If parameter `timing/nlpieval` is off (the default), depending on the NLP solver, this may just return 0."]
    pub fn SCIPnlpiGetEvalTime(nlpi: *mut SCIP_NLPI) -> f64;
}
extern "C" {
    #[doc = " gives total number of iterations spend by NLP solver so far"]
    pub fn SCIPnlpiGetNIterations(nlpi: *mut SCIP_NLPI) -> ::std::os::raw::c_longlong;
}
extern "C" {
    #[doc = " gives number of times a solve ended with a specific termination status"]
    pub fn SCIPnlpiGetNTermStat(
        nlpi: *mut SCIP_NLPI,
        termstatus: SCIP_NLPTERMSTAT,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " gives number of times a solve ended with a specific solution status"]
    pub fn SCIPnlpiGetNSolStat(
        nlpi: *mut SCIP_NLPI,
        solstatus: SCIP_NLPSOLSTAT,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " adds statistics from one NLPI to another"]
    pub fn SCIPnlpiMergeStatistics(
        targetnlpi: *mut SCIP_NLPI,
        sourcenlpi: *mut SCIP_NLPI,
        reset: ::std::os::raw::c_uint,
    );
}
extern "C" {
    #[doc = " creates an NLPI and includes it into SCIP"]
    pub fn SCIPincludeNlpi(
        scip: *mut SCIP,
        name: *const ::std::os::raw::c_char,
        description: *const ::std::os::raw::c_char,
        priority: ::std::os::raw::c_int,
        nlpicopy: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, sourcenlpi: *mut SCIP_NLPI) -> SCIP_RETCODE,
        >,
        nlpifree: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                nlpi: *mut SCIP_NLPI,
                nlpidata: *mut *mut SCIP_NLPIDATA,
            ) -> SCIP_RETCODE,
        >,
        nlpigetsolverpointer: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                nlpi: *mut SCIP_NLPI,
                problem: *mut SCIP_NLPIPROBLEM,
            ) -> *mut ::std::os::raw::c_void,
        >,
        nlpicreateproblem: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                nlpi: *mut SCIP_NLPI,
                problem: *mut *mut SCIP_NLPIPROBLEM,
                name: *const ::std::os::raw::c_char,
            ) -> SCIP_RETCODE,
        >,
        nlpifreeproblem: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                nlpi: *mut SCIP_NLPI,
                problem: *mut *mut SCIP_NLPIPROBLEM,
            ) -> SCIP_RETCODE,
        >,
        nlpigetproblempointer: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                nlpi: *mut SCIP_NLPI,
                problem: *mut SCIP_NLPIPROBLEM,
            ) -> *mut ::std::os::raw::c_void,
        >,
        nlpiaddvars: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                nlpi: *mut SCIP_NLPI,
                problem: *mut SCIP_NLPIPROBLEM,
                nvars: ::std::os::raw::c_int,
                lbs: *const f64,
                ubs: *const f64,
                varnames: *mut *const ::std::os::raw::c_char,
            ) -> SCIP_RETCODE,
        >,
        nlpiaddconstraints: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                nlpi: *mut SCIP_NLPI,
                problem: *mut SCIP_NLPIPROBLEM,
                nconss: ::std::os::raw::c_int,
                lhss: *const f64,
                rhss: *const f64,
                nlininds: *const ::std::os::raw::c_int,
                lininds: *const *mut ::std::os::raw::c_int,
                linvals: *const *mut f64,
                exprs: *mut *mut SCIP_EXPR,
                names: *mut *const ::std::os::raw::c_char,
            ) -> SCIP_RETCODE,
        >,
        nlpisetobjective: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                nlpi: *mut SCIP_NLPI,
                problem: *mut SCIP_NLPIPROBLEM,
                nlins: ::std::os::raw::c_int,
                lininds: *const ::std::os::raw::c_int,
                linvals: *const f64,
                expr: *mut SCIP_EXPR,
                constant: f64,
            ) -> SCIP_RETCODE,
        >,
        nlpichgvarbounds: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                nlpi: *mut SCIP_NLPI,
                problem: *mut SCIP_NLPIPROBLEM,
                nvars: ::std::os::raw::c_int,
                indices: *const ::std::os::raw::c_int,
                lbs: *const f64,
                ubs: *const f64,
            ) -> SCIP_RETCODE,
        >,
        nlpichgconssides: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                nlpi: *mut SCIP_NLPI,
                problem: *mut SCIP_NLPIPROBLEM,
                nconss: ::std::os::raw::c_int,
                indices: *const ::std::os::raw::c_int,
                lhss: *const f64,
                rhss: *const f64,
            ) -> SCIP_RETCODE,
        >,
        nlpidelvarset: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                nlpi: *mut SCIP_NLPI,
                problem: *mut SCIP_NLPIPROBLEM,
                dstats: *mut ::std::os::raw::c_int,
                dstatssize: ::std::os::raw::c_int,
            ) -> SCIP_RETCODE,
        >,
        nlpidelconsset: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                nlpi: *mut SCIP_NLPI,
                problem: *mut SCIP_NLPIPROBLEM,
                dstats: *mut ::std::os::raw::c_int,
                dstatssize: ::std::os::raw::c_int,
            ) -> SCIP_RETCODE,
        >,
        nlpichglinearcoefs: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                nlpi: *mut SCIP_NLPI,
                problem: *mut SCIP_NLPIPROBLEM,
                idx: ::std::os::raw::c_int,
                nvals: ::std::os::raw::c_int,
                varidxs: *const ::std::os::raw::c_int,
                vals: *const f64,
            ) -> SCIP_RETCODE,
        >,
        nlpichgexpr: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                nlpi: *mut SCIP_NLPI,
                problem: *mut SCIP_NLPIPROBLEM,
                idxcons: ::std::os::raw::c_int,
                expr: *mut SCIP_EXPR,
            ) -> SCIP_RETCODE,
        >,
        nlpichgobjconstant: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                nlpi: *mut SCIP_NLPI,
                problem: *mut SCIP_NLPIPROBLEM,
                objconstant: f64,
            ) -> SCIP_RETCODE,
        >,
        nlpisetinitialguess: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                nlpi: *mut SCIP_NLPI,
                problem: *mut SCIP_NLPIPROBLEM,
                primalvalues: *mut f64,
                consdualvalues: *mut f64,
                varlbdualvalues: *mut f64,
                varubdualvalues: *mut f64,
            ) -> SCIP_RETCODE,
        >,
        nlpisolve: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                nlpi: *mut SCIP_NLPI,
                problem: *mut SCIP_NLPIPROBLEM,
                param: SCIP_NLPPARAM,
            ) -> SCIP_RETCODE,
        >,
        nlpigetsolstat: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                nlpi: *mut SCIP_NLPI,
                problem: *mut SCIP_NLPIPROBLEM,
            ) -> SCIP_NLPSOLSTAT,
        >,
        nlpigettermstat: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                nlpi: *mut SCIP_NLPI,
                problem: *mut SCIP_NLPIPROBLEM,
            ) -> SCIP_NLPTERMSTAT,
        >,
        nlpigetsolution: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                nlpi: *mut SCIP_NLPI,
                problem: *mut SCIP_NLPIPROBLEM,
                primalvalues: *mut *mut f64,
                consdualvalues: *mut *mut f64,
                varlbdualvalues: *mut *mut f64,
                varubdualvalues: *mut *mut f64,
                objval: *mut f64,
            ) -> SCIP_RETCODE,
        >,
        nlpigetstatistics: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                nlpi: *mut SCIP_NLPI,
                problem: *mut SCIP_NLPIPROBLEM,
                statistics: *mut SCIP_NLPSTATISTICS,
            ) -> SCIP_RETCODE,
        >,
        nlpidata: *mut SCIP_NLPIDATA,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " returns the NLPI of the given name, or NULL if not existing"]
    pub fn SCIPfindNlpi(scip: *mut SCIP, name: *const ::std::os::raw::c_char) -> *mut SCIP_NLPI;
}
extern "C" {
    #[doc = " returns the array of currently available NLPIs (sorted by priority)"]
    pub fn SCIPgetNlpis(scip: *mut SCIP) -> *mut *mut SCIP_NLPI;
}
extern "C" {
    #[doc = " returns the number of currently available NLPIs"]
    pub fn SCIPgetNNlpis(scip: *mut SCIP) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " sets the priority of an NLPI"]
    pub fn SCIPsetNlpiPriority(
        scip: *mut SCIP,
        nlpi: *mut SCIP_NLPI,
        priority: ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
extern "C" {
    pub fn SCIPgetNlpiSolverPointer(
        scip: *mut SCIP,
        nlpi: *mut SCIP_NLPI,
        problem: *mut SCIP_NLPIPROBLEM,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn SCIPcreateNlpiProblem(
        scip: *mut SCIP,
        nlpi: *mut SCIP_NLPI,
        problem: *mut *mut SCIP_NLPIPROBLEM,
        name: *const ::std::os::raw::c_char,
    ) -> SCIP_RETCODE;
}
extern "C" {
    pub fn SCIPfreeNlpiProblem(
        scip: *mut SCIP,
        nlpi: *mut SCIP_NLPI,
        problem: *mut *mut SCIP_NLPIPROBLEM,
    ) -> SCIP_RETCODE;
}
extern "C" {
    pub fn SCIPgetNlpiProblemPointer(
        scip: *mut SCIP,
        nlpi: *mut SCIP_NLPI,
        problem: *mut SCIP_NLPIPROBLEM,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn SCIPaddNlpiVars(
        scip: *mut SCIP,
        nlpi: *mut SCIP_NLPI,
        problem: *mut SCIP_NLPIPROBLEM,
        nvars: ::std::os::raw::c_int,
        lbs: *const f64,
        ubs: *const f64,
        varnames: *mut *const ::std::os::raw::c_char,
    ) -> SCIP_RETCODE;
}
extern "C" {
    pub fn SCIPaddNlpiConstraints(
        scip: *mut SCIP,
        nlpi: *mut SCIP_NLPI,
        problem: *mut SCIP_NLPIPROBLEM,
        nconss: ::std::os::raw::c_int,
        lhss: *const f64,
        rhss: *const f64,
        nlininds: *const ::std::os::raw::c_int,
        lininds: *const *mut ::std::os::raw::c_int,
        linvals: *const *mut f64,
        exprs: *mut *mut SCIP_EXPR,
        names: *mut *const ::std::os::raw::c_char,
    ) -> SCIP_RETCODE;
}
extern "C" {
    pub fn SCIPsetNlpiObjective(
        scip: *mut SCIP,
        nlpi: *mut SCIP_NLPI,
        problem: *mut SCIP_NLPIPROBLEM,
        nlins: ::std::os::raw::c_int,
        lininds: *const ::std::os::raw::c_int,
        linvals: *const f64,
        expr: *mut SCIP_EXPR,
        constant: f64,
    ) -> SCIP_RETCODE;
}
extern "C" {
    pub fn SCIPchgNlpiVarBounds(
        scip: *mut SCIP,
        nlpi: *mut SCIP_NLPI,
        problem: *mut SCIP_NLPIPROBLEM,
        nvars: ::std::os::raw::c_int,
        indices: *const ::std::os::raw::c_int,
        lbs: *const f64,
        ubs: *const f64,
    ) -> SCIP_RETCODE;
}
extern "C" {
    pub fn SCIPchgNlpiConsSides(
        scip: *mut SCIP,
        nlpi: *mut SCIP_NLPI,
        problem: *mut SCIP_NLPIPROBLEM,
        nconss: ::std::os::raw::c_int,
        indices: *const ::std::os::raw::c_int,
        lhss: *const f64,
        rhss: *const f64,
    ) -> SCIP_RETCODE;
}
extern "C" {
    pub fn SCIPdelNlpiVarSet(
        scip: *mut SCIP,
        nlpi: *mut SCIP_NLPI,
        problem: *mut SCIP_NLPIPROBLEM,
        dstats: *mut ::std::os::raw::c_int,
        dstatssize: ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
extern "C" {
    pub fn SCIPdelNlpiConsSet(
        scip: *mut SCIP,
        nlpi: *mut SCIP_NLPI,
        problem: *mut SCIP_NLPIPROBLEM,
        dstats: *mut ::std::os::raw::c_int,
        dstatssize: ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
extern "C" {
    pub fn SCIPchgNlpiLinearCoefs(
        scip: *mut SCIP,
        nlpi: *mut SCIP_NLPI,
        problem: *mut SCIP_NLPIPROBLEM,
        idx: ::std::os::raw::c_int,
        nvals: ::std::os::raw::c_int,
        varidxs: *const ::std::os::raw::c_int,
        vals: *const f64,
    ) -> SCIP_RETCODE;
}
extern "C" {
    pub fn SCIPchgNlpiExpr(
        scip: *mut SCIP,
        nlpi: *mut SCIP_NLPI,
        problem: *mut SCIP_NLPIPROBLEM,
        idxcons: ::std::os::raw::c_int,
        expr: *mut SCIP_EXPR,
    ) -> SCIP_RETCODE;
}
extern "C" {
    pub fn SCIPchgNlpiObjConstant(
        scip: *mut SCIP,
        nlpi: *mut SCIP_NLPI,
        problem: *mut SCIP_NLPIPROBLEM,
        objconstant: f64,
    ) -> SCIP_RETCODE;
}
extern "C" {
    pub fn SCIPsetNlpiInitialGuess(
        scip: *mut SCIP,
        nlpi: *mut SCIP_NLPI,
        problem: *mut SCIP_NLPIPROBLEM,
        primalvalues: *mut f64,
        consdualvalues: *mut f64,
        varlbdualvalues: *mut f64,
        varubdualvalues: *mut f64,
    ) -> SCIP_RETCODE;
}
extern "C" {
    pub fn SCIPsolveNlpiParam(
        scip: *mut SCIP,
        nlpi: *mut SCIP_NLPI,
        problem: *mut SCIP_NLPIPROBLEM,
        param: SCIP_NLPPARAM,
    ) -> SCIP_RETCODE;
}
extern "C" {
    pub fn SCIPgetNlpiSolstat(
        scip: *mut SCIP,
        nlpi: *mut SCIP_NLPI,
        problem: *mut SCIP_NLPIPROBLEM,
    ) -> SCIP_NLPSOLSTAT;
}
extern "C" {
    pub fn SCIPgetNlpiTermstat(
        scip: *mut SCIP,
        nlpi: *mut SCIP_NLPI,
        problem: *mut SCIP_NLPIPROBLEM,
    ) -> SCIP_NLPTERMSTAT;
}
extern "C" {
    pub fn SCIPgetNlpiSolution(
        scip: *mut SCIP,
        nlpi: *mut SCIP_NLPI,
        problem: *mut SCIP_NLPIPROBLEM,
        primalvalues: *mut *mut f64,
        consdualvalues: *mut *mut f64,
        varlbdualvalues: *mut *mut f64,
        varubdualvalues: *mut *mut f64,
        objval: *mut f64,
    ) -> SCIP_RETCODE;
}
extern "C" {
    pub fn SCIPgetNlpiStatistics(
        scip: *mut SCIP,
        nlpi: *mut SCIP_NLPI,
        problem: *mut SCIP_NLPIPROBLEM,
        statistics: *mut SCIP_NLPSTATISTICS,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " creates a NLPI problem from given nonlinear rows\n\n The function computes for each variable the number of non-linear occurrences and stores it in the nlscore array.\n\n @note the first row corresponds always to the cutoff row (even if cutoffbound is SCIPinfinity(scip))"]
    pub fn SCIPcreateNlpiProblemFromNlRows(
        scip: *mut SCIP,
        nlpi: *mut SCIP_NLPI,
        nlpiprob: *mut *mut SCIP_NLPIPROBLEM,
        name: *const ::std::os::raw::c_char,
        nlrows: *mut *mut SCIP_NLROW,
        nnlrows: ::std::os::raw::c_int,
        var2idx: *mut SCIP_HASHMAP,
        nlrow2idx: *mut SCIP_HASHMAP,
        nlscore: *mut f64,
        cutoffbound: f64,
        setobj: ::std::os::raw::c_uint,
        onlyconvex: ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " updates variable bounds and the cutoff row in a NLPI problem\n\n The NLPI problem must have been setup by SCIPcreateNlpiProblemFromNlRows()."]
    pub fn SCIPupdateNlpiProblem(
        scip: *mut SCIP,
        nlpi: *mut SCIP_NLPI,
        nlpiprob: *mut SCIP_NLPIPROBLEM,
        var2nlpiidx: *mut SCIP_HASHMAP,
        nlpivars: *mut *mut SCIP_VAR,
        nlpinvars: ::std::os::raw::c_int,
        cutoffbound: f64,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " adds SCIP_ROWs to a NLPI problem"]
    pub fn SCIPaddNlpiProblemRows(
        scip: *mut SCIP,
        nlpi: *mut SCIP_NLPI,
        nlpiprob: *mut SCIP_NLPIPROBLEM,
        var2idx: *mut SCIP_HASHMAP,
        rows: *mut *mut SCIP_ROW,
        nrows: ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " adds SCIP_NLROWs to a NLPI problem"]
    pub fn SCIPaddNlpiProblemNlRows(
        scip: *mut SCIP,
        nlpi: *mut SCIP_NLPI,
        nlpiprob: *mut SCIP_NLPIPROBLEM,
        var2idx: *mut SCIP_HASHMAP,
        nlrows: *mut *mut SCIP_NLROW,
        nnlrows: ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " creates a node selector and includes it in SCIP.\n\n  @note method has all node selector callbacks as arguments and is thus changed every time a new\n        callback is added in future releases; consider using SCIPincludeNodeselBasic() and setter functions\n        if you seek for a method which is less likely to change in future releases"]
    pub fn SCIPincludeNodesel(
        scip: *mut SCIP,
        name: *const ::std::os::raw::c_char,
        desc: *const ::std::os::raw::c_char,
        stdpriority: ::std::os::raw::c_int,
        memsavepriority: ::std::os::raw::c_int,
        nodeselcopy: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, nodesel: *mut SCIP_NODESEL) -> SCIP_RETCODE,
        >,
        nodeselfree: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, nodesel: *mut SCIP_NODESEL) -> SCIP_RETCODE,
        >,
        nodeselinit: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, nodesel: *mut SCIP_NODESEL) -> SCIP_RETCODE,
        >,
        nodeselexit: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, nodesel: *mut SCIP_NODESEL) -> SCIP_RETCODE,
        >,
        nodeselinitsol: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, nodesel: *mut SCIP_NODESEL) -> SCIP_RETCODE,
        >,
        nodeselexitsol: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, nodesel: *mut SCIP_NODESEL) -> SCIP_RETCODE,
        >,
        nodeselselect: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                nodesel: *mut SCIP_NODESEL,
                selnode: *mut *mut SCIP_NODE,
            ) -> SCIP_RETCODE,
        >,
        nodeselcomp: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                nodesel: *mut SCIP_NODESEL,
                node1: *mut SCIP_NODE,
                node2: *mut SCIP_NODE,
            ) -> ::std::os::raw::c_int,
        >,
        nodeseldata: *mut SCIP_NODESELDATA,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " Creates a node selector and includes it in SCIP with its most fundamental callbacks. All non-fundamental\n  (or optional) callbacks as, e.g., init and exit callbacks, will be set to NULL.\n  Optional callbacks can be set via specific setter functions, see SCIPsetNodeselCopy(), SCIPsetNodeselFree(),\n  SCIPsetNodeselInit(), SCIPsetNodeselExit(), SCIPsetNodeselInitsol(), and SCIPsetNodeselExitsol()\n\n  @note if you want to set all callbacks with a single method call, consider using SCIPincludeNodesel() instead"]
    pub fn SCIPincludeNodeselBasic(
        scip: *mut SCIP,
        nodesel: *mut *mut SCIP_NODESEL,
        name: *const ::std::os::raw::c_char,
        desc: *const ::std::os::raw::c_char,
        stdpriority: ::std::os::raw::c_int,
        memsavepriority: ::std::os::raw::c_int,
        nodeselselect: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                nodesel: *mut SCIP_NODESEL,
                selnode: *mut *mut SCIP_NODE,
            ) -> SCIP_RETCODE,
        >,
        nodeselcomp: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                nodesel: *mut SCIP_NODESEL,
                node1: *mut SCIP_NODE,
                node2: *mut SCIP_NODE,
            ) -> ::std::os::raw::c_int,
        >,
        nodeseldata: *mut SCIP_NODESELDATA,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " sets copy method of node selector"]
    pub fn SCIPsetNodeselCopy(
        scip: *mut SCIP,
        nodesel: *mut SCIP_NODESEL,
        nodeselcopy: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, nodesel: *mut SCIP_NODESEL) -> SCIP_RETCODE,
        >,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " sets destructor method of node selector"]
    pub fn SCIPsetNodeselFree(
        scip: *mut SCIP,
        nodesel: *mut SCIP_NODESEL,
        nodeselfree: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, nodesel: *mut SCIP_NODESEL) -> SCIP_RETCODE,
        >,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " sets initialization method of node selector"]
    pub fn SCIPsetNodeselInit(
        scip: *mut SCIP,
        nodesel: *mut SCIP_NODESEL,
        nodeselinit: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, nodesel: *mut SCIP_NODESEL) -> SCIP_RETCODE,
        >,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " sets deinitialization method of node selector"]
    pub fn SCIPsetNodeselExit(
        scip: *mut SCIP,
        nodesel: *mut SCIP_NODESEL,
        nodeselexit: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, nodesel: *mut SCIP_NODESEL) -> SCIP_RETCODE,
        >,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " sets solving process initialization method of node selector"]
    pub fn SCIPsetNodeselInitsol(
        scip: *mut SCIP,
        nodesel: *mut SCIP_NODESEL,
        nodeselinitsol: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, nodesel: *mut SCIP_NODESEL) -> SCIP_RETCODE,
        >,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " sets solving process deinitialization method of node selector"]
    pub fn SCIPsetNodeselExitsol(
        scip: *mut SCIP,
        nodesel: *mut SCIP_NODESEL,
        nodeselexitsol: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, nodesel: *mut SCIP_NODESEL) -> SCIP_RETCODE,
        >,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " returns the node selector of the given name, or NULL if not existing"]
    pub fn SCIPfindNodesel(
        scip: *mut SCIP,
        name: *const ::std::os::raw::c_char,
    ) -> *mut SCIP_NODESEL;
}
extern "C" {
    #[doc = " returns the array of currently available node selectors"]
    pub fn SCIPgetNodesels(scip: *mut SCIP) -> *mut *mut SCIP_NODESEL;
}
extern "C" {
    #[doc = " returns the number of currently available node selectors"]
    pub fn SCIPgetNNodesels(scip: *mut SCIP) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " sets the priority of a node selector in standard mode"]
    pub fn SCIPsetNodeselStdPriority(
        scip: *mut SCIP,
        nodesel: *mut SCIP_NODESEL,
        priority: ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " sets the priority of a node selector in memory saving mode"]
    pub fn SCIPsetNodeselMemsavePriority(
        scip: *mut SCIP,
        nodesel: *mut SCIP_NODESEL,
        priority: ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " returns the currently used node selector"]
    pub fn SCIPgetNodesel(scip: *mut SCIP) -> *mut SCIP_NODESEL;
}
extern "C" {
    #[doc = " returns value treated as zero\n\n  @return value treated as zero"]
    pub fn SCIPepsilon(scip: *mut SCIP) -> f64;
}
extern "C" {
    #[doc = " returns value treated as zero for sums of floating point values\n\n  @return value treated as zero for sums of floating point values"]
    pub fn SCIPsumepsilon(scip: *mut SCIP) -> f64;
}
extern "C" {
    pub fn SCIPfeastol(scip: *mut SCIP) -> f64;
}
extern "C" {
    #[doc = " returns primal feasibility tolerance of LP solver\n\n  @deprecated Please use SCIPgetLPFeastol().\n\n  @return primal feasibility tolerance of LP solver"]
    pub fn SCIPlpfeastol(scip: *mut SCIP) -> f64;
}
extern "C" {
    pub fn SCIPdualfeastol(scip: *mut SCIP) -> f64;
}
extern "C" {
    #[doc = " returns convergence tolerance used in barrier algorithm\n\n  @return convergence tolerance used in barrier algorithm"]
    pub fn SCIPbarrierconvtol(scip: *mut SCIP) -> f64;
}
extern "C" {
    #[doc = " return the cutoff bound delta\n\n  @return cutoff bound data"]
    pub fn SCIPcutoffbounddelta(scip: *mut SCIP) -> f64;
}
extern "C" {
    #[doc = " return the relaxation primal feasibility tolerance\n\n  @see SCIPchgRelaxfeastol\n  @return relaxfeastol"]
    pub fn SCIPrelaxfeastol(scip: *mut SCIP) -> f64;
}
extern "C" {
    #[doc = " sets the feasibility tolerance for constraints\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    pub fn SCIPchgFeastol(scip: *mut SCIP, feastol: f64) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " sets the primal feasibility tolerance of LP solver\n\n  @deprecated Please use SCIPsetLPFeastol().\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    pub fn SCIPchgLpfeastol(
        scip: *mut SCIP,
        lpfeastol: f64,
        printnewvalue: ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " sets the feasibility tolerance for reduced costs\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    pub fn SCIPchgDualfeastol(scip: *mut SCIP, dualfeastol: f64) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " sets the convergence tolerance used in barrier algorithm\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    pub fn SCIPchgBarrierconvtol(scip: *mut SCIP, barrierconvtol: f64) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " sets the primal feasibility tolerance of relaxations\n\n This tolerance value is used by the SCIP core and plugins to tighten then feasibility tolerance on relaxations\n (especially the LP relaxation) during a solve. It is set to SCIP_INVALID initially, which means that only the\n feasibility tolerance of the particular relaxation is taken into account. If set to a valid value, however,\n then this value should be used to reduce the primal feasibility tolerance of a relaxation (thus, use the\n minimum of relaxfeastol and the relaxations primal feastol).\n\n @pre The value of relaxfeastol is reset to SCIP_INVALID when initializing the solve (INITSOL).\n Therefore, this method can only be called in one of the following stages of the SCIP solving process:\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n\n @return previous value of relaxfeastol"]
    pub fn SCIPchgRelaxfeastol(scip: *mut SCIP, relaxfeastol: f64) -> f64;
}
extern "C" {
    #[doc = " marks that some limit parameter was changed"]
    pub fn SCIPmarkLimitChanged(scip: *mut SCIP);
}
extern "C" {
    #[doc = " returns value treated as infinity"]
    pub fn SCIPinfinity(scip: *mut SCIP) -> f64;
}
extern "C" {
    #[doc = " returns the minimum value that is regarded as huge and should be handled separately (e.g., in activity\n  computation)"]
    pub fn SCIPgetHugeValue(scip: *mut SCIP) -> f64;
}
extern "C" {
    #[doc = " checks, if values are in range of epsilon"]
    pub fn SCIPisEQ(scip: *mut SCIP, val1: f64, val2: f64) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " checks, if val1 is (more than epsilon) lower than val2"]
    pub fn SCIPisLT(scip: *mut SCIP, val1: f64, val2: f64) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " checks, if val1 is not (more than epsilon) greater than val2"]
    pub fn SCIPisLE(scip: *mut SCIP, val1: f64, val2: f64) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " checks, if val1 is (more than epsilon) greater than val2"]
    pub fn SCIPisGT(scip: *mut SCIP, val1: f64, val2: f64) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " checks, if val1 is not (more than epsilon) lower than val2"]
    pub fn SCIPisGE(scip: *mut SCIP, val1: f64, val2: f64) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " checks, if value is (positive) infinite"]
    pub fn SCIPisInfinity(scip: *mut SCIP, val: f64) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " checks, if value is huge and should be handled separately (e.g., in activity computation)"]
    pub fn SCIPisHugeValue(scip: *mut SCIP, val: f64) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " checks, if value is in range epsilon of 0.0"]
    pub fn SCIPisZero(scip: *mut SCIP, val: f64) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " checks, if value is greater than epsilon"]
    pub fn SCIPisPositive(scip: *mut SCIP, val: f64) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " checks, if value is lower than -epsilon"]
    pub fn SCIPisNegative(scip: *mut SCIP, val: f64) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " checks, if value is integral within epsilon"]
    pub fn SCIPisIntegral(scip: *mut SCIP, val: f64) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " checks whether the product val * scalar is integral in epsilon scaled by scalar"]
    pub fn SCIPisScalingIntegral(scip: *mut SCIP, val: f64, scalar: f64) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " checks, if given fractional part is smaller than epsilon"]
    pub fn SCIPisFracIntegral(scip: *mut SCIP, val: f64) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " rounds value + epsilon down to the next integer"]
    pub fn SCIPfloor(scip: *mut SCIP, val: f64) -> f64;
}
extern "C" {
    #[doc = " rounds value - epsilon up to the next integer"]
    pub fn SCIPceil(scip: *mut SCIP, val: f64) -> f64;
}
extern "C" {
    #[doc = " rounds value to the nearest integer with epsilon tolerance"]
    pub fn SCIPround(scip: *mut SCIP, val: f64) -> f64;
}
extern "C" {
    #[doc = " returns fractional part of value, i.e. x - floor(x) in epsilon tolerance"]
    pub fn SCIPfrac(scip: *mut SCIP, val: f64) -> f64;
}
extern "C" {
    #[doc = " checks, if values are in range of sumepsilon"]
    pub fn SCIPisSumEQ(scip: *mut SCIP, val1: f64, val2: f64) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " checks, if val1 is (more than sumepsilon) lower than val2"]
    pub fn SCIPisSumLT(scip: *mut SCIP, val1: f64, val2: f64) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " checks, if val1 is not (more than sumepsilon) greater than val2"]
    pub fn SCIPisSumLE(scip: *mut SCIP, val1: f64, val2: f64) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " checks, if val1 is (more than sumepsilon) greater than val2"]
    pub fn SCIPisSumGT(scip: *mut SCIP, val1: f64, val2: f64) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " checks, if val1 is not (more than sumepsilon) lower than val2"]
    pub fn SCIPisSumGE(scip: *mut SCIP, val1: f64, val2: f64) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " checks, if value is in range sumepsilon of 0.0"]
    pub fn SCIPisSumZero(scip: *mut SCIP, val: f64) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " checks, if value is greater than sumepsilon"]
    pub fn SCIPisSumPositive(scip: *mut SCIP, val: f64) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " checks, if value is lower than -sumepsilon"]
    pub fn SCIPisSumNegative(scip: *mut SCIP, val: f64) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " checks, if relative difference of values is in range of feasibility tolerance"]
    pub fn SCIPisFeasEQ(scip: *mut SCIP, val1: f64, val2: f64) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " checks, if relative difference val1 and val2 is lower than feasibility tolerance"]
    pub fn SCIPisFeasLT(scip: *mut SCIP, val1: f64, val2: f64) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " checks, if relative difference of val1 and val2 is not greater than feasibility tolerance"]
    pub fn SCIPisFeasLE(scip: *mut SCIP, val1: f64, val2: f64) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " checks, if relative difference of val1 and val2 is greater than feastol"]
    pub fn SCIPisFeasGT(scip: *mut SCIP, val1: f64, val2: f64) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " checks, if relative difference of val1 and val2 is not lower than -feastol"]
    pub fn SCIPisFeasGE(scip: *mut SCIP, val1: f64, val2: f64) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " checks, if value is in range feasibility tolerance of 0.0"]
    pub fn SCIPisFeasZero(scip: *mut SCIP, val: f64) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " checks, if value is greater than feasibility tolerance"]
    pub fn SCIPisFeasPositive(scip: *mut SCIP, val: f64) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " checks, if value is lower than -feasibility tolerance"]
    pub fn SCIPisFeasNegative(scip: *mut SCIP, val: f64) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " checks, if value is integral within the LP feasibility bounds"]
    pub fn SCIPisFeasIntegral(scip: *mut SCIP, val: f64) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " checks, if given fractional part is smaller than feastol"]
    pub fn SCIPisFeasFracIntegral(scip: *mut SCIP, val: f64) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " rounds value + feasibility tolerance down to the next integer"]
    pub fn SCIPfeasFloor(scip: *mut SCIP, val: f64) -> f64;
}
extern "C" {
    #[doc = " rounds value - feasibility tolerance up to the next integer"]
    pub fn SCIPfeasCeil(scip: *mut SCIP, val: f64) -> f64;
}
extern "C" {
    #[doc = " rounds value to the nearest integer in feasibility tolerance"]
    pub fn SCIPfeasRound(scip: *mut SCIP, val: f64) -> f64;
}
extern "C" {
    #[doc = " returns fractional part of value, i.e. x - floor(x)"]
    pub fn SCIPfeasFrac(scip: *mut SCIP, val: f64) -> f64;
}
extern "C" {
    #[doc = " checks, if relative difference of values is in range of dual feasibility tolerance"]
    pub fn SCIPisDualfeasEQ(scip: *mut SCIP, val1: f64, val2: f64) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " checks, if relative difference val1 and val2 is lower than dual feasibility tolerance"]
    pub fn SCIPisDualfeasLT(scip: *mut SCIP, val1: f64, val2: f64) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " checks, if relative difference of val1 and val2 is not greater than dual feasibility tolerance"]
    pub fn SCIPisDualfeasLE(scip: *mut SCIP, val1: f64, val2: f64) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " checks, if relative difference of val1 and val2 is greater than dual feasibility tolerance"]
    pub fn SCIPisDualfeasGT(scip: *mut SCIP, val1: f64, val2: f64) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " checks, if relative difference of val1 and val2 is not lower than -dual feasibility tolerance"]
    pub fn SCIPisDualfeasGE(scip: *mut SCIP, val1: f64, val2: f64) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " checks, if value is in range dual feasibility tolerance of 0.0"]
    pub fn SCIPisDualfeasZero(scip: *mut SCIP, val: f64) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " checks, if value is greater than dual feasibility tolerance"]
    pub fn SCIPisDualfeasPositive(scip: *mut SCIP, val: f64) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " checks, if value is lower than -dual feasibility tolerance"]
    pub fn SCIPisDualfeasNegative(scip: *mut SCIP, val: f64) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " checks, if value is integral within the LP dual feasibility tolerance"]
    pub fn SCIPisDualfeasIntegral(scip: *mut SCIP, val: f64) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " checks, if given fractional part is smaller than dual feasibility tolerance"]
    pub fn SCIPisDualfeasFracIntegral(scip: *mut SCIP, val: f64) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " rounds value + dual feasibility tolerance down to the next integer"]
    pub fn SCIPdualfeasFloor(scip: *mut SCIP, val: f64) -> f64;
}
extern "C" {
    #[doc = " rounds value - dual feasibility tolerance up to the next integer"]
    pub fn SCIPdualfeasCeil(scip: *mut SCIP, val: f64) -> f64;
}
extern "C" {
    #[doc = " rounds value to the nearest integer in dual feasibility tolerance"]
    pub fn SCIPdualfeasRound(scip: *mut SCIP, val: f64) -> f64;
}
extern "C" {
    #[doc = " returns fractional part of value, i.e. x - floor(x) in dual feasibility tolerance"]
    pub fn SCIPdualfeasFrac(scip: *mut SCIP, val: f64) -> f64;
}
extern "C" {
    #[doc = " checks, if the given new lower bound is tighter (w.r.t. bound strengthening epsilon) than the old one"]
    pub fn SCIPisLbBetter(
        scip: *mut SCIP,
        newlb: f64,
        oldlb: f64,
        oldub: f64,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " checks, if the given new upper bound is tighter (w.r.t. bound strengthening epsilon) than the old one"]
    pub fn SCIPisUbBetter(
        scip: *mut SCIP,
        newub: f64,
        oldlb: f64,
        oldub: f64,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " checks, if relative difference of values is in range of epsilon"]
    pub fn SCIPisRelEQ(scip: *mut SCIP, val1: f64, val2: f64) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " checks, if relative difference of val1 and val2 is lower than epsilon"]
    pub fn SCIPisRelLT(scip: *mut SCIP, val1: f64, val2: f64) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " checks, if relative difference of val1 and val2 is not greater than epsilon"]
    pub fn SCIPisRelLE(scip: *mut SCIP, val1: f64, val2: f64) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " checks, if relative difference of val1 and val2 is greater than epsilon"]
    pub fn SCIPisRelGT(scip: *mut SCIP, val1: f64, val2: f64) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " checks, if relative difference of val1 and val2 is not lower than -epsilon"]
    pub fn SCIPisRelGE(scip: *mut SCIP, val1: f64, val2: f64) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " checks, if relative difference of values is in range of sumepsilon"]
    pub fn SCIPisSumRelEQ(scip: *mut SCIP, val1: f64, val2: f64) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " checks, if relative difference of val1 and val2 is lower than sumepsilon"]
    pub fn SCIPisSumRelLT(scip: *mut SCIP, val1: f64, val2: f64) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " checks, if relative difference of val1 and val2 is not greater than sumepsilon"]
    pub fn SCIPisSumRelLE(scip: *mut SCIP, val1: f64, val2: f64) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " checks, if relative difference of val1 and val2 is greater than sumepsilon"]
    pub fn SCIPisSumRelGT(scip: *mut SCIP, val1: f64, val2: f64) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " checks, if relative difference of val1 and val2 is not lower than -sumepsilon"]
    pub fn SCIPisSumRelGE(scip: *mut SCIP, val1: f64, val2: f64) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " converts the given real number representing an integer to an int; in optimized mode the function gets inlined for\n  performance; in debug mode we check some additional conditions"]
    pub fn SCIPconvertRealToInt(scip: *mut SCIP, real: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " converts the given real number representing an integer to a long integer; in optimized mode the function gets inlined for\n  performance; in debug mode we check some additional conditions"]
    pub fn SCIPconvertRealToLongint(scip: *mut SCIP, real: f64) -> ::std::os::raw::c_longlong;
}
extern "C" {
    #[doc = " Checks, if an iteratively updated value is reliable or should be recomputed from scratch.\n  This is useful, if the value, e.g., the activity of a linear constraint or the pseudo objective value, gets a high\n  absolute value during the optimization process which is later reduced significantly. In this case, the last digits\n  were canceled out when increasing the value and are random after decreasing it.\n  We do not consider the cancellations which can occur during increasing the absolute value because they just cannot\n  be expressed using fixed precision floating point arithmetic, anymore.\n  In order to get more reliable values, the idea is to always store the last reliable value, where increasing the\n  absolute of the value is viewed as preserving reliability. Then, after each update, the new absolute value can be\n  compared against the last reliable one with this method, checking whether it was decreased by a factor of at least\n  \"lp/recompfac\" and should be recomputed."]
    pub fn SCIPisUpdateUnreliable(
        scip: *mut SCIP,
        newvalue: f64,
        oldvalue: f64,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " outputs a real number, or \"+infinity\", or \"-infinity\" to a file"]
    pub fn SCIPprintReal(
        scip: *mut SCIP,
        file: *mut FILE,
        val: f64,
        width: ::std::os::raw::c_int,
        precision: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " parse a real value that was written with SCIPprintReal()"]
    pub fn SCIPparseReal(
        scip: *mut SCIP,
        str_: *const ::std::os::raw::c_char,
        value: *mut f64,
        endptr: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " creates a SCIP_Bool parameter, sets it to its default value, and adds it to the parameter set\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    pub fn SCIPaddBoolParam(
        scip: *mut SCIP,
        name: *const ::std::os::raw::c_char,
        desc: *const ::std::os::raw::c_char,
        valueptr: *mut ::std::os::raw::c_uint,
        isadvanced: ::std::os::raw::c_uint,
        defaultvalue: ::std::os::raw::c_uint,
        paramchgd: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, param: *mut SCIP_PARAM) -> SCIP_RETCODE,
        >,
        paramdata: *mut SCIP_PARAMDATA,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " creates a int parameter, sets it to its default value, and adds it to the parameter set\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    pub fn SCIPaddIntParam(
        scip: *mut SCIP,
        name: *const ::std::os::raw::c_char,
        desc: *const ::std::os::raw::c_char,
        valueptr: *mut ::std::os::raw::c_int,
        isadvanced: ::std::os::raw::c_uint,
        defaultvalue: ::std::os::raw::c_int,
        minvalue: ::std::os::raw::c_int,
        maxvalue: ::std::os::raw::c_int,
        paramchgd: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, param: *mut SCIP_PARAM) -> SCIP_RETCODE,
        >,
        paramdata: *mut SCIP_PARAMDATA,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " creates a SCIP_Longint parameter, sets it to its default value, and adds it to the parameter set\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    pub fn SCIPaddLongintParam(
        scip: *mut SCIP,
        name: *const ::std::os::raw::c_char,
        desc: *const ::std::os::raw::c_char,
        valueptr: *mut ::std::os::raw::c_longlong,
        isadvanced: ::std::os::raw::c_uint,
        defaultvalue: ::std::os::raw::c_longlong,
        minvalue: ::std::os::raw::c_longlong,
        maxvalue: ::std::os::raw::c_longlong,
        paramchgd: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, param: *mut SCIP_PARAM) -> SCIP_RETCODE,
        >,
        paramdata: *mut SCIP_PARAMDATA,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " creates a SCIP_Real parameter, sets it to its default value, and adds it to the parameter set\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    pub fn SCIPaddRealParam(
        scip: *mut SCIP,
        name: *const ::std::os::raw::c_char,
        desc: *const ::std::os::raw::c_char,
        valueptr: *mut f64,
        isadvanced: ::std::os::raw::c_uint,
        defaultvalue: f64,
        minvalue: f64,
        maxvalue: f64,
        paramchgd: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, param: *mut SCIP_PARAM) -> SCIP_RETCODE,
        >,
        paramdata: *mut SCIP_PARAMDATA,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " creates a char parameter, sets it to its default value, and adds it to the parameter set\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    pub fn SCIPaddCharParam(
        scip: *mut SCIP,
        name: *const ::std::os::raw::c_char,
        desc: *const ::std::os::raw::c_char,
        valueptr: *mut ::std::os::raw::c_char,
        isadvanced: ::std::os::raw::c_uint,
        defaultvalue: ::std::os::raw::c_char,
        allowedvalues: *const ::std::os::raw::c_char,
        paramchgd: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, param: *mut SCIP_PARAM) -> SCIP_RETCODE,
        >,
        paramdata: *mut SCIP_PARAMDATA,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " creates a string(char*) parameter, sets it to its default value, and adds it to the parameter set\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    pub fn SCIPaddStringParam(
        scip: *mut SCIP,
        name: *const ::std::os::raw::c_char,
        desc: *const ::std::os::raw::c_char,
        valueptr: *mut *mut ::std::os::raw::c_char,
        isadvanced: ::std::os::raw::c_uint,
        defaultvalue: *const ::std::os::raw::c_char,
        paramchgd: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, param: *mut SCIP_PARAM) -> SCIP_RETCODE,
        >,
        paramdata: *mut SCIP_PARAMDATA,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " gets the fixing status of an existing parameter\n\n  @return TRUE if the parameter is fixed to a value, otherwise FALSE."]
    pub fn SCIPisParamFixed(
        scip: *mut SCIP,
        name: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " returns the pointer to the SCIP parameter with the given name\n\n  @return pointer to the parameter with the given name"]
    pub fn SCIPgetParam(scip: *mut SCIP, name: *const ::std::os::raw::c_char) -> *mut SCIP_PARAM;
}
extern "C" {
    #[doc = " gets the value of an existing SCIP_Bool parameter\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    pub fn SCIPgetBoolParam(
        scip: *mut SCIP,
        name: *const ::std::os::raw::c_char,
        value: *mut ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " gets the value of an existing int parameter\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    pub fn SCIPgetIntParam(
        scip: *mut SCIP,
        name: *const ::std::os::raw::c_char,
        value: *mut ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " gets the value of an existing SCIP_Longint parameter\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    pub fn SCIPgetLongintParam(
        scip: *mut SCIP,
        name: *const ::std::os::raw::c_char,
        value: *mut ::std::os::raw::c_longlong,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " gets the value of an existing SCIP_Real parameter\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    pub fn SCIPgetRealParam(
        scip: *mut SCIP,
        name: *const ::std::os::raw::c_char,
        value: *mut f64,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " gets the value of an existing char parameter\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    pub fn SCIPgetCharParam(
        scip: *mut SCIP,
        name: *const ::std::os::raw::c_char,
        value: *mut ::std::os::raw::c_char,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " gets the value of an existing string(char*) parameter\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    pub fn SCIPgetStringParam(
        scip: *mut SCIP,
        name: *const ::std::os::raw::c_char,
        value: *mut *mut ::std::os::raw::c_char,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " fixes the value of an existing parameter\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @note: Be careful with this method! Some general settings, e.g., the time or node limit, should not be fixed because\n         they have to be changed for sub-SCIPs."]
    pub fn SCIPfixParam(scip: *mut SCIP, name: *const ::std::os::raw::c_char) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " unfixes the value of an existing parameter\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    pub fn SCIPunfixParam(scip: *mut SCIP, name: *const ::std::os::raw::c_char) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " changes the value of an existing SCIP_Bool parameter\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    pub fn SCIPchgBoolParam(
        scip: *mut SCIP,
        param: *mut SCIP_PARAM,
        value: ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " changes the value of an existing SCIP_Bool parameter\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    pub fn SCIPsetBoolParam(
        scip: *mut SCIP,
        name: *const ::std::os::raw::c_char,
        value: ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " checks whether the value of an existing SCIP_Bool parameter is valid"]
    pub fn SCIPisBoolParamValid(
        scip: *mut SCIP,
        param: *mut SCIP_PARAM,
        value: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " changes the value of an existing int parameter\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    pub fn SCIPchgIntParam(
        scip: *mut SCIP,
        param: *mut SCIP_PARAM,
        value: ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " changes the value of an existing int parameter\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    pub fn SCIPsetIntParam(
        scip: *mut SCIP,
        name: *const ::std::os::raw::c_char,
        value: ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " checks whether the value of an existing int parameter is valid"]
    pub fn SCIPisIntParamValid(
        scip: *mut SCIP,
        param: *mut SCIP_PARAM,
        value: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " changes the value of an existing SCIP_Longint parameter\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    pub fn SCIPchgLongintParam(
        scip: *mut SCIP,
        param: *mut SCIP_PARAM,
        value: ::std::os::raw::c_longlong,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " changes the value of an existing SCIP_Longint parameter\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    pub fn SCIPsetLongintParam(
        scip: *mut SCIP,
        name: *const ::std::os::raw::c_char,
        value: ::std::os::raw::c_longlong,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " checks whether parameter value of an existing SCIP_Longint paramter is valid"]
    pub fn SCIPisLongintParamValid(
        scip: *mut SCIP,
        param: *mut SCIP_PARAM,
        value: ::std::os::raw::c_longlong,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " changes the value of an existing SCIP_Real parameter\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    pub fn SCIPchgRealParam(scip: *mut SCIP, param: *mut SCIP_PARAM, value: f64) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " changes the value of an existing SCIP_Real parameter\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    pub fn SCIPsetRealParam(
        scip: *mut SCIP,
        name: *const ::std::os::raw::c_char,
        value: f64,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " checks whether parameter value of an existing SCIP_Real paramter is valid"]
    pub fn SCIPisRealParamValid(
        scip: *mut SCIP,
        param: *mut SCIP_PARAM,
        value: f64,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " changes the value of an existing char parameter\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    pub fn SCIPchgCharParam(
        scip: *mut SCIP,
        param: *mut SCIP_PARAM,
        value: ::std::os::raw::c_char,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " changes the value of an existing char parameter\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    pub fn SCIPsetCharParam(
        scip: *mut SCIP,
        name: *const ::std::os::raw::c_char,
        value: ::std::os::raw::c_char,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " checks whether parameter value for a given SCIP_Real parameter is valid"]
    pub fn SCIPisCharParamValid(
        scip: *mut SCIP,
        param: *mut SCIP_PARAM,
        value: ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " changes the value of an existing string(char*) parameter\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    pub fn SCIPchgStringParam(
        scip: *mut SCIP,
        param: *mut SCIP_PARAM,
        value: *const ::std::os::raw::c_char,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " changes the value of an existing string(char*) parameter\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    pub fn SCIPsetStringParam(
        scip: *mut SCIP,
        name: *const ::std::os::raw::c_char,
        value: *const ::std::os::raw::c_char,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " checks whether parameter value for a given string parameter is valid"]
    pub fn SCIPisStringParamValid(
        scip: *mut SCIP,
        param: *mut SCIP_PARAM,
        value: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " changes the value of an existing parameter\n\n  The parameter type is checked and conversion of the given value to this type is attempted.\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    pub fn SCIPsetParam(
        scip: *mut SCIP,
        name: *const ::std::os::raw::c_char,
        value: *const ::std::os::raw::c_char,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " reads parameters from a file\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    pub fn SCIPreadParams(scip: *mut SCIP, filename: *const ::std::os::raw::c_char)
        -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " writes a single parameter to a file\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    pub fn SCIPwriteParam(
        scip: *mut SCIP,
        param: *mut SCIP_PARAM,
        filename: *const ::std::os::raw::c_char,
        comments: ::std::os::raw::c_uint,
        onlychanged: ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " writes all parameters in the parameter set to a file\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    pub fn SCIPwriteParams(
        scip: *mut SCIP,
        filename: *const ::std::os::raw::c_char,
        comments: ::std::os::raw::c_uint,
        onlychanged: ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " resets a single parameter to its default value\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    pub fn SCIPresetParam(scip: *mut SCIP, name: *const ::std::os::raw::c_char) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " resets all parameters to their default values\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    pub fn SCIPresetParams(scip: *mut SCIP) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " sets parameters to\n\n  - \\ref SCIP_PARAMEMPHASIS_DEFAULT to use default values (see also SCIPresetParams())\n  - \\ref SCIP_PARAMEMPHASIS_COUNTER to get feasible and \"fast\" counting process\n  - \\ref SCIP_PARAMEMPHASIS_CPSOLVER to get CP like search (e.g. no LP relaxation)\n  - \\ref SCIP_PARAMEMPHASIS_EASYCIP to solve easy problems fast\n  - \\ref SCIP_PARAMEMPHASIS_FEASIBILITY to detect feasibility fast\n  - \\ref SCIP_PARAMEMPHASIS_HARDLP to be capable to handle hard LPs\n  - \\ref SCIP_PARAMEMPHASIS_OPTIMALITY to prove optimality fast\n  - \\ref SCIP_PARAMEMPHASIS_PHASEFEAS to find feasible solutions during a 3 phase solution process\n  - \\ref SCIP_PARAMEMPHASIS_PHASEIMPROVE to find improved solutions during a 3 phase solution process\n  - \\ref SCIP_PARAMEMPHASIS_PHASEPROOF to proof optimality during a 3 phase solution process\n  - \\ref SCIP_PARAMEMPHASIS_NUMERICS to solve problems which cause numerical issues\n\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    pub fn SCIPsetEmphasis(
        scip: *mut SCIP,
        paramemphasis: SCIP_PARAMEMPHASIS,
        quiet: ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " sets parameters to deactivate separators and heuristics that use auxiliary SCIP instances; should be called for\n  auxiliary SCIP instances to avoid recursion\n\n  @note only deactivates plugins which could cause recursion, some plugins which use sub-SCIPs stay activated\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    pub fn SCIPsetSubscipsOff(scip: *mut SCIP, quiet: ::std::os::raw::c_uint) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " sets heuristic parameters values to\n\n  - SCIP_PARAMSETTING_DEFAULT which are the default values of all heuristic parameters\n  - SCIP_PARAMSETTING_FAST such that the time spend for heuristic is decreased\n  - SCIP_PARAMSETTING_AGGRESSIVE such that the heuristic are called more aggregative\n  - SCIP_PARAMSETTING_OFF which turn off all heuristics\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    pub fn SCIPsetHeuristics(
        scip: *mut SCIP,
        paramsetting: SCIP_PARAMSETTING,
        quiet: ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " sets presolving parameters to\n\n  - SCIP_PARAMSETTING_DEFAULT which are the default values of all presolving parameters\n  - SCIP_PARAMSETTING_FAST such that the time spend for presolving is decreased\n  - SCIP_PARAMSETTING_AGGRESSIVE such that the presolving is more aggregative\n  - SCIP_PARAMSETTING_OFF which turn off all presolving\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    pub fn SCIPsetPresolving(
        scip: *mut SCIP,
        paramsetting: SCIP_PARAMSETTING,
        quiet: ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " sets separating parameters to\n\n  - SCIP_PARAMSETTING_DEFAULT which are the default values of all separating parameters\n  - SCIP_PARAMSETTING_FAST such that the time spend for separating is decreased\n  - SCIP_PARAMSETTING_AGGRESSIVE such that the separating is done more aggregative\n  - SCIP_PARAMSETTING_OFF which turn off all separating\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    pub fn SCIPsetSeparating(
        scip: *mut SCIP,
        paramsetting: SCIP_PARAMSETTING,
        quiet: ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " returns the array of all available SCIP parameters\n\n  @return SCIP_PARAM* array, containing all SCIP parameters."]
    pub fn SCIPgetParams(scip: *mut SCIP) -> *mut *mut SCIP_PARAM;
}
extern "C" {
    #[doc = " returns the total number of all available SCIP parameters\n\n  @return number of all SCIP parameters."]
    pub fn SCIPgetNParams(scip: *mut SCIP) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " returns whether plugins with sub-SCIPs that could cause recursion have been disabled\n\n  @return the value of the variable set->subscipsoff"]
    pub fn SCIPgetSubscipsOff(scip: *mut SCIP) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " creates a presolver and includes it in SCIP\n\n  @note method has all presolver callbacks as arguments and is thus changed every time a new\n        callback is added\n        in future releases; consider using SCIPincludePresolBasic() and setter functions\n        if you seek for a method which is less likely to change in future releases"]
    pub fn SCIPincludePresol(
        scip: *mut SCIP,
        name: *const ::std::os::raw::c_char,
        desc: *const ::std::os::raw::c_char,
        priority: ::std::os::raw::c_int,
        maxrounds: ::std::os::raw::c_int,
        timing: SCIP_PRESOLTIMING,
        presolcopy: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, presol: *mut SCIP_PRESOL) -> SCIP_RETCODE,
        >,
        presolfree: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, presol: *mut SCIP_PRESOL) -> SCIP_RETCODE,
        >,
        presolinit: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, presol: *mut SCIP_PRESOL) -> SCIP_RETCODE,
        >,
        presolexit: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, presol: *mut SCIP_PRESOL) -> SCIP_RETCODE,
        >,
        presolinitpre: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, presol: *mut SCIP_PRESOL) -> SCIP_RETCODE,
        >,
        presolexitpre: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, presol: *mut SCIP_PRESOL) -> SCIP_RETCODE,
        >,
        presolexec: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                presol: *mut SCIP_PRESOL,
                nrounds: ::std::os::raw::c_int,
                presoltiming: SCIP_PRESOLTIMING,
                nnewfixedvars: ::std::os::raw::c_int,
                nnewaggrvars: ::std::os::raw::c_int,
                nnewchgvartypes: ::std::os::raw::c_int,
                nnewchgbds: ::std::os::raw::c_int,
                nnewholes: ::std::os::raw::c_int,
                nnewdelconss: ::std::os::raw::c_int,
                nnewaddconss: ::std::os::raw::c_int,
                nnewupgdconss: ::std::os::raw::c_int,
                nnewchgcoefs: ::std::os::raw::c_int,
                nnewchgsides: ::std::os::raw::c_int,
                nfixedvars: *mut ::std::os::raw::c_int,
                naggrvars: *mut ::std::os::raw::c_int,
                nchgvartypes: *mut ::std::os::raw::c_int,
                nchgbds: *mut ::std::os::raw::c_int,
                naddholes: *mut ::std::os::raw::c_int,
                ndelconss: *mut ::std::os::raw::c_int,
                naddconss: *mut ::std::os::raw::c_int,
                nupgdconss: *mut ::std::os::raw::c_int,
                nchgcoefs: *mut ::std::os::raw::c_int,
                nchgsides: *mut ::std::os::raw::c_int,
                result: *mut SCIP_RESULT,
            ) -> SCIP_RETCODE,
        >,
        presoldata: *mut SCIP_PRESOLDATA,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " Creates a presolver and includes it in SCIP with its fundamental callback. All non-fundamental (or optional)\n  callbacks as, e.g., init and exit callbacks, will be set to NULL. Optional callbacks can be set via specific setter\n  functions. These are SCIPsetPresolCopy(), SCIPsetPresolFree(), SCIPsetPresolInit(), SCIPsetPresolExit(),\n  SCIPsetPresolInitpre(), and SCIPsetPresolExitPre().\n\n  @note if you want to set all callbacks with a single method call, consider using SCIPincludePresol() instead"]
    pub fn SCIPincludePresolBasic(
        scip: *mut SCIP,
        presolptr: *mut *mut SCIP_PRESOL,
        name: *const ::std::os::raw::c_char,
        desc: *const ::std::os::raw::c_char,
        priority: ::std::os::raw::c_int,
        maxrounds: ::std::os::raw::c_int,
        timing: SCIP_PRESOLTIMING,
        presolexec: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                presol: *mut SCIP_PRESOL,
                nrounds: ::std::os::raw::c_int,
                presoltiming: SCIP_PRESOLTIMING,
                nnewfixedvars: ::std::os::raw::c_int,
                nnewaggrvars: ::std::os::raw::c_int,
                nnewchgvartypes: ::std::os::raw::c_int,
                nnewchgbds: ::std::os::raw::c_int,
                nnewholes: ::std::os::raw::c_int,
                nnewdelconss: ::std::os::raw::c_int,
                nnewaddconss: ::std::os::raw::c_int,
                nnewupgdconss: ::std::os::raw::c_int,
                nnewchgcoefs: ::std::os::raw::c_int,
                nnewchgsides: ::std::os::raw::c_int,
                nfixedvars: *mut ::std::os::raw::c_int,
                naggrvars: *mut ::std::os::raw::c_int,
                nchgvartypes: *mut ::std::os::raw::c_int,
                nchgbds: *mut ::std::os::raw::c_int,
                naddholes: *mut ::std::os::raw::c_int,
                ndelconss: *mut ::std::os::raw::c_int,
                naddconss: *mut ::std::os::raw::c_int,
                nupgdconss: *mut ::std::os::raw::c_int,
                nchgcoefs: *mut ::std::os::raw::c_int,
                nchgsides: *mut ::std::os::raw::c_int,
                result: *mut SCIP_RESULT,
            ) -> SCIP_RETCODE,
        >,
        presoldata: *mut SCIP_PRESOLDATA,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " sets copy method of presolver"]
    pub fn SCIPsetPresolCopy(
        scip: *mut SCIP,
        presol: *mut SCIP_PRESOL,
        presolcopy: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, presol: *mut SCIP_PRESOL) -> SCIP_RETCODE,
        >,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " sets destructor method of presolver"]
    pub fn SCIPsetPresolFree(
        scip: *mut SCIP,
        presol: *mut SCIP_PRESOL,
        presolfree: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, presol: *mut SCIP_PRESOL) -> SCIP_RETCODE,
        >,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " sets initialization method of presolver"]
    pub fn SCIPsetPresolInit(
        scip: *mut SCIP,
        presol: *mut SCIP_PRESOL,
        presolinit: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, presol: *mut SCIP_PRESOL) -> SCIP_RETCODE,
        >,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " sets deinitialization method of presolver"]
    pub fn SCIPsetPresolExit(
        scip: *mut SCIP,
        presol: *mut SCIP_PRESOL,
        presolexit: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, presol: *mut SCIP_PRESOL) -> SCIP_RETCODE,
        >,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " sets solving process initialization method of presolver"]
    pub fn SCIPsetPresolInitpre(
        scip: *mut SCIP,
        presol: *mut SCIP_PRESOL,
        presolinitpre: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, presol: *mut SCIP_PRESOL) -> SCIP_RETCODE,
        >,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " sets solving process deinitialization method of presolver"]
    pub fn SCIPsetPresolExitpre(
        scip: *mut SCIP,
        presol: *mut SCIP_PRESOL,
        presolexitpre: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, presol: *mut SCIP_PRESOL) -> SCIP_RETCODE,
        >,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " returns the presolver of the given name, or NULL if not existing"]
    pub fn SCIPfindPresol(scip: *mut SCIP, name: *const ::std::os::raw::c_char)
        -> *mut SCIP_PRESOL;
}
extern "C" {
    #[doc = " returns the array of currently available presolvers"]
    pub fn SCIPgetPresols(scip: *mut SCIP) -> *mut *mut SCIP_PRESOL;
}
extern "C" {
    #[doc = " returns the number of currently available presolvers"]
    pub fn SCIPgetNPresols(scip: *mut SCIP) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " sets the priority of a presolver"]
    pub fn SCIPsetPresolPriority(
        scip: *mut SCIP,
        presol: *mut SCIP_PRESOL,
        priority: ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " returns the number of presolve rounds (current or last presolve)"]
    pub fn SCIPgetNPresolRounds(scip: *mut SCIP) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " creates a variable pricer and includes it in SCIP\n  To use the variable pricer for solving a problem, it first has to be activated with a call to SCIPactivatePricer().\n  This should be done during the problem creation stage.\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_INIT\n       - \\ref SCIP_STAGE_PROBLEM\n\n  @note method has all pricer callbacks as arguments and is thus changed every time a new callback is added\n        in future releases; consider using SCIPincludePricerBasic() and setter functions\n        if you seek for a method which is less likely to change in future releases"]
    pub fn SCIPincludePricer(
        scip: *mut SCIP,
        name: *const ::std::os::raw::c_char,
        desc: *const ::std::os::raw::c_char,
        priority: ::std::os::raw::c_int,
        delay: ::std::os::raw::c_uint,
        pricercopy: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                pricer: *mut SCIP_PRICER,
                valid: *mut ::std::os::raw::c_uint,
            ) -> SCIP_RETCODE,
        >,
        pricerfree: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, pricer: *mut SCIP_PRICER) -> SCIP_RETCODE,
        >,
        pricerinit: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, pricer: *mut SCIP_PRICER) -> SCIP_RETCODE,
        >,
        pricerexit: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, pricer: *mut SCIP_PRICER) -> SCIP_RETCODE,
        >,
        pricerinitsol: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, pricer: *mut SCIP_PRICER) -> SCIP_RETCODE,
        >,
        pricerexitsol: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, pricer: *mut SCIP_PRICER) -> SCIP_RETCODE,
        >,
        pricerredcost: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                pricer: *mut SCIP_PRICER,
                lowerbound: *mut f64,
                stopearly: *mut ::std::os::raw::c_uint,
                result: *mut SCIP_RESULT,
            ) -> SCIP_RETCODE,
        >,
        pricerfarkas: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                pricer: *mut SCIP_PRICER,
                result: *mut SCIP_RESULT,
            ) -> SCIP_RETCODE,
        >,
        pricerdata: *mut SCIP_PRICERDATA,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " creates a variable pricer and includes it in SCIP with all non-fundamental callbacks set to NULL;\n  if needed, these can be added afterwards via setter functions SCIPsetPricerCopy(), SCIPsetPricerFree(),\n  SCIPsetPricerInity(), SCIPsetPricerExit(), SCIPsetPricerInitsol(), SCIPsetPricerExitsol(),\n  SCIPsetPricerFarkas();\n\n  To use the variable pricer for solving a problem, it first has to be activated with a call to SCIPactivatePricer().\n  This should be done during the problem creation stage.\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_INIT\n       - \\ref SCIP_STAGE_PROBLEM\n\n  @note if you want to set all callbacks with a single method call, consider using SCIPincludePricer() instead"]
    pub fn SCIPincludePricerBasic(
        scip: *mut SCIP,
        pricerptr: *mut *mut SCIP_PRICER,
        name: *const ::std::os::raw::c_char,
        desc: *const ::std::os::raw::c_char,
        priority: ::std::os::raw::c_int,
        delay: ::std::os::raw::c_uint,
        pricerredcost: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                pricer: *mut SCIP_PRICER,
                lowerbound: *mut f64,
                stopearly: *mut ::std::os::raw::c_uint,
                result: *mut SCIP_RESULT,
            ) -> SCIP_RETCODE,
        >,
        pricerfarkas: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                pricer: *mut SCIP_PRICER,
                result: *mut SCIP_RESULT,
            ) -> SCIP_RETCODE,
        >,
        pricerdata: *mut SCIP_PRICERDATA,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " sets copy method of pricer\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_INIT\n       - \\ref SCIP_STAGE_PROBLEM"]
    pub fn SCIPsetPricerCopy(
        scip: *mut SCIP,
        pricer: *mut SCIP_PRICER,
        pricercopy: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                pricer: *mut SCIP_PRICER,
                valid: *mut ::std::os::raw::c_uint,
            ) -> SCIP_RETCODE,
        >,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " sets destructor method of pricer\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_INIT\n       - \\ref SCIP_STAGE_PROBLEM"]
    pub fn SCIPsetPricerFree(
        scip: *mut SCIP,
        pricer: *mut SCIP_PRICER,
        pricerfree: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, pricer: *mut SCIP_PRICER) -> SCIP_RETCODE,
        >,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " sets initialization method of pricer\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_INIT\n       - \\ref SCIP_STAGE_PROBLEM"]
    pub fn SCIPsetPricerInit(
        scip: *mut SCIP,
        pricer: *mut SCIP_PRICER,
        pricerinit: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, pricer: *mut SCIP_PRICER) -> SCIP_RETCODE,
        >,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " sets deinitialization method of pricer\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_INIT\n       - \\ref SCIP_STAGE_PROBLEM"]
    pub fn SCIPsetPricerExit(
        scip: *mut SCIP,
        pricer: *mut SCIP_PRICER,
        pricerexit: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, pricer: *mut SCIP_PRICER) -> SCIP_RETCODE,
        >,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " sets solving process initialization method of pricer\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_INIT\n       - \\ref SCIP_STAGE_PROBLEM"]
    pub fn SCIPsetPricerInitsol(
        scip: *mut SCIP,
        pricer: *mut SCIP_PRICER,
        pricerinitsol: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, pricer: *mut SCIP_PRICER) -> SCIP_RETCODE,
        >,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " sets solving process deinitialization method of pricer\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_INIT\n       - \\ref SCIP_STAGE_PROBLEM"]
    pub fn SCIPsetPricerExitsol(
        scip: *mut SCIP,
        pricer: *mut SCIP_PRICER,
        pricerexitsol: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, pricer: *mut SCIP_PRICER) -> SCIP_RETCODE,
        >,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " returns the variable pricer of the given name, or NULL if not existing"]
    pub fn SCIPfindPricer(scip: *mut SCIP, name: *const ::std::os::raw::c_char)
        -> *mut SCIP_PRICER;
}
extern "C" {
    #[doc = " returns the array of currently available variable pricers; active pricers are in the first slots of the array"]
    pub fn SCIPgetPricers(scip: *mut SCIP) -> *mut *mut SCIP_PRICER;
}
extern "C" {
    #[doc = " returns the number of currently available variable pricers"]
    pub fn SCIPgetNPricers(scip: *mut SCIP) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " returns the number of currently active variable pricers, that are used in the LP solving loop"]
    pub fn SCIPgetNActivePricers(scip: *mut SCIP) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " sets the priority of a variable pricer"]
    pub fn SCIPsetPricerPriority(
        scip: *mut SCIP,
        pricer: *mut SCIP_PRICER,
        priority: ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " activates pricer to be used for the current problem\n  This method should be called during the problem creation stage for all pricers that are necessary to solve\n  the problem model.\n  The pricers are automatically deactivated when the problem is freed.\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM"]
    pub fn SCIPactivatePricer(scip: *mut SCIP, pricer: *mut SCIP_PRICER) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " deactivates pricer\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_EXITSOLVE"]
    pub fn SCIPdeactivatePricer(scip: *mut SCIP, pricer: *mut SCIP_PRICER) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " creates empty problem and initializes all solving data structures (the objective sense is set to MINIMIZE)\n  If the problem type requires the use of variable pricers, these pricers should be added to the problem with calls\n  to SCIPactivatePricer(). These pricers are automatically deactivated, when the problem is freed.\n\n  @return \\ref SCIP_OKAY is returned if everything worked. otherwise a suitable error code is passed. see \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_INIT\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED\n       - \\ref SCIP_STAGE_FREE\n\n  @post After calling this method, \\SCIP reaches the following stage:\n        - \\ref SCIP_STAGE_PROBLEM"]
    pub fn SCIPcreateProb(
        scip: *mut SCIP,
        name: *const ::std::os::raw::c_char,
        probdelorig: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                probdata: *mut *mut SCIP_PROBDATA,
            ) -> SCIP_RETCODE,
        >,
        probtrans: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                sourcedata: *mut SCIP_PROBDATA,
                targetdata: *mut *mut SCIP_PROBDATA,
            ) -> SCIP_RETCODE,
        >,
        probdeltrans: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                probdata: *mut *mut SCIP_PROBDATA,
            ) -> SCIP_RETCODE,
        >,
        probinitsol: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, probdata: *mut SCIP_PROBDATA) -> SCIP_RETCODE,
        >,
        probexitsol: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                probdata: *mut SCIP_PROBDATA,
                restart: ::std::os::raw::c_uint,
            ) -> SCIP_RETCODE,
        >,
        probcopy: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                sourcescip: *mut SCIP,
                sourcedata: *mut SCIP_PROBDATA,
                varmap: *mut SCIP_HASHMAP,
                consmap: *mut SCIP_HASHMAP,
                targetdata: *mut *mut SCIP_PROBDATA,
                original: ::std::os::raw::c_uint,
                global: ::std::os::raw::c_uint,
                result: *mut SCIP_RESULT,
            ) -> SCIP_RETCODE,
        >,
        probdata: *mut SCIP_PROBDATA,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " creates empty problem and initializes all solving data structures (the objective sense is set to MINIMIZE)\n  all callback methods will be set to NULL and can be set afterwards, if needed, via SCIPsetProbDelorig(),\n  SCIPsetProbTrans(), SCIPsetProbDeltrans(), SCIPsetProbInitsol(), SCIPsetProbExitsol(), and\n  SCIPsetProbCopy()\n  If the problem type requires the use of variable pricers, these pricers should be added to the problem with calls\n  to SCIPactivatePricer(). These pricers are automatically deactivated, when the problem is freed.\n\n  @return \\ref SCIP_OKAY is returned if everything worked. otherwise a suitable error code is passed. see \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_INIT\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED\n       - \\ref SCIP_STAGE_FREE\n\n  @post After calling this method, \\SCIP reaches the following stage:\n        - \\ref SCIP_STAGE_PROBLEM"]
    pub fn SCIPcreateProbBasic(
        scip: *mut SCIP,
        name: *const ::std::os::raw::c_char,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " sets callback to free user data of original problem\n\n  @return \\ref SCIP_OKAY is returned if everything worked. otherwise a suitable error code is passed. see \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM"]
    pub fn SCIPsetProbDelorig(
        scip: *mut SCIP,
        probdelorig: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                probdata: *mut *mut SCIP_PROBDATA,
            ) -> SCIP_RETCODE,
        >,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " sets callback to create user data of transformed problem by transforming original user data\n\n  @return \\ref SCIP_OKAY is returned if everything worked. otherwise a suitable error code is passed. see \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM"]
    pub fn SCIPsetProbTrans(
        scip: *mut SCIP,
        probtrans: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                sourcedata: *mut SCIP_PROBDATA,
                targetdata: *mut *mut SCIP_PROBDATA,
            ) -> SCIP_RETCODE,
        >,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " sets callback to free user data of transformed problem\n\n  @return \\ref SCIP_OKAY is returned if everything worked. otherwise a suitable error code is passed. see \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM"]
    pub fn SCIPsetProbDeltrans(
        scip: *mut SCIP,
        probdeltrans: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                probdata: *mut *mut SCIP_PROBDATA,
            ) -> SCIP_RETCODE,
        >,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " sets solving process initialization callback of transformed data\n\n  @return \\ref SCIP_OKAY is returned if everything worked. otherwise a suitable error code is passed. see \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM"]
    pub fn SCIPsetProbInitsol(
        scip: *mut SCIP,
        probinitsol: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, probdata: *mut SCIP_PROBDATA) -> SCIP_RETCODE,
        >,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " sets solving process deinitialization callback of transformed data\n\n  @return \\ref SCIP_OKAY is returned if everything worked. otherwise a suitable error code is passed. see \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM"]
    pub fn SCIPsetProbExitsol(
        scip: *mut SCIP,
        probexitsol: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                probdata: *mut SCIP_PROBDATA,
                restart: ::std::os::raw::c_uint,
            ) -> SCIP_RETCODE,
        >,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " sets callback to copy user data to a subscip\n\n  @return \\ref SCIP_OKAY is returned if everything worked. otherwise a suitable error code is passed. see \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM"]
    pub fn SCIPsetProbCopy(
        scip: *mut SCIP,
        probcopy: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                sourcescip: *mut SCIP,
                sourcedata: *mut SCIP_PROBDATA,
                varmap: *mut SCIP_HASHMAP,
                consmap: *mut SCIP_HASHMAP,
                targetdata: *mut *mut SCIP_PROBDATA,
                original: ::std::os::raw::c_uint,
                global: ::std::os::raw::c_uint,
                result: *mut SCIP_RESULT,
            ) -> SCIP_RETCODE,
        >,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " reads problem from file and initializes all solving data structures\n\n  @return \\ref SCIP_OKAY is returned if everything worked. otherwise a suitable error code is passed. see \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_INIT\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_EXITSOLVE\n\n  @post After the method was called, \\SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_INIT if reading failed (usually, when a SCIP_READERROR occurs)\n       - \\ref SCIP_STAGE_PROBLEM if the problem file was successfully read"]
    pub fn SCIPreadProb(
        scip: *mut SCIP,
        filename: *const ::std::os::raw::c_char,
        extension: *const ::std::os::raw::c_char,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " writes original problem to file\n\n  @return \\ref SCIP_OKAY is returned if everything worked. otherwise a suitable error code is passed. see \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMING\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED\n       - \\ref SCIP_STAGE_EXITSOLVE\n       - \\ref SCIP_STAGE_FREETRANS"]
    pub fn SCIPwriteOrigProblem(
        scip: *mut SCIP,
        filename: *const ::std::os::raw::c_char,
        extension: *const ::std::os::raw::c_char,
        genericnames: ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " writes transformed problem which are valid in the current node to file\n\n  @return \\ref SCIP_OKAY is returned if everything worked. otherwise a suitable error code is passed. see \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED\n       - \\ref SCIP_STAGE_EXITSOLVE\n\n  @note If you want the write all constraints (including the once which are redundant for example), you need to set\n        the parameter <write/allconss> to TRUE"]
    pub fn SCIPwriteTransProblem(
        scip: *mut SCIP,
        filename: *const ::std::os::raw::c_char,
        extension: *const ::std::os::raw::c_char,
        genericnames: ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " frees problem and solution process data\n\n  @return \\ref SCIP_OKAY is returned if everything worked. otherwise a suitable error code is passed. see \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_INIT\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED\n       - \\ref SCIP_STAGE_FREE\n\n  @post After this method was called, SCIP is in the following stage:\n       - \\ref SCIP_STAGE_INIT"]
    pub fn SCIPfreeProb(scip: *mut SCIP) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " permutes parts of the problem data structure\n\n  @return \\ref SCIP_OKAY is returned if everything worked. otherwise a suitable error code is passed. see \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMED"]
    pub fn SCIPpermuteProb(
        scip: *mut SCIP,
        randseed: ::std::os::raw::c_uint,
        permuteconss: ::std::os::raw::c_uint,
        permutebinvars: ::std::os::raw::c_uint,
        permuteintvars: ::std::os::raw::c_uint,
        permuteimplvars: ::std::os::raw::c_uint,
        permutecontvars: ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " gets user problem data\n\n  @return a SCIP_PROBDATA pointer, or NULL if no problem data was allocated\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMING\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED\n       - \\ref SCIP_STAGE_EXITSOLVE\n       - \\ref SCIP_STAGE_FREETRANS"]
    pub fn SCIPgetProbData(scip: *mut SCIP) -> *mut SCIP_PROBDATA;
}
extern "C" {
    #[doc = " sets user problem data\n\n  @return \\ref SCIP_OKAY is returned if everything worked. otherwise a suitable error code is passed. see \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMING\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED\n       - \\ref SCIP_STAGE_EXITSOLVE\n       - \\ref SCIP_STAGE_FREETRANS"]
    pub fn SCIPsetProbData(scip: *mut SCIP, probdata: *mut SCIP_PROBDATA) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " returns name of the current problem instance\n\n  @return name of the current problem instance\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMING\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED\n       - \\ref SCIP_STAGE_EXITSOLVE\n       - \\ref SCIP_STAGE_FREETRANS"]
    pub fn SCIPgetProbName(scip: *mut SCIP) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " sets name of the current problem instance\n\n  @return \\ref SCIP_OKAY is returned if everything worked. otherwise a suitable error code is passed. see \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMING\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED\n       - \\ref SCIP_STAGE_EXITSOLVE\n       - \\ref SCIP_STAGE_FREETRANS"]
    pub fn SCIPsetProbName(scip: *mut SCIP, name: *const ::std::os::raw::c_char) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " changes the objective function\n\n  @return \\ref SCIP_OKAY is returned if everything worked. otherwise a suitable error code is passed. see \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_PRESOLVED\n\n  @note This method should be only used to change the objective function during two reoptimization runs and is only\n        recommended to an experienced user.\n\n  @note All variables not given in \\p vars array are assumed to have an objective coefficient of zero."]
    pub fn SCIPchgReoptObjective(
        scip: *mut SCIP,
        objsense: SCIP_OBJSENSE,
        vars: *mut *mut SCIP_VAR,
        coefs: *mut f64,
        nvars: ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " returns objective sense of original problem\n\n  @return objective sense of original problem\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMING\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED\n       - \\ref SCIP_STAGE_EXITSOLVE\n       - \\ref SCIP_STAGE_FREETRANS"]
    pub fn SCIPgetObjsense(scip: *mut SCIP) -> SCIP_OBJSENSE;
}
extern "C" {
    #[doc = " sets objective sense of problem\n\n  @return \\ref SCIP_OKAY is returned if everything worked. otherwise a suitable error code is passed. see \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM"]
    pub fn SCIPsetObjsense(scip: *mut SCIP, objsense: SCIP_OBJSENSE) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " adds offset of objective function\n\n  @return \\ref SCIP_OKAY is returned if everything worked. otherwise a suitable error code is passed. see \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_PRESOLVING"]
    pub fn SCIPaddObjoffset(scip: *mut SCIP, addval: f64) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " adds offset of objective function to original problem and to all existing solution in original space\n\n  @return \\ref SCIP_OKAY is returned if everything worked. otherwise a suitable error code is passed. see \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM"]
    pub fn SCIPaddOrigObjoffset(scip: *mut SCIP, addval: f64) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " returns the objective offset of the original problem\n\n  @return the objective offset of the original problem\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMING\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPgetOrigObjoffset(scip: *mut SCIP) -> f64;
}
extern "C" {
    #[doc = " returns the objective scale of the original problem\n\n  @return the objective scale of the original problem\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMING\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPgetOrigObjscale(scip: *mut SCIP) -> f64;
}
extern "C" {
    #[doc = " returns the objective offset of the transformed problem\n\n  @return the objective offset of the transformed problem\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPgetTransObjoffset(scip: *mut SCIP) -> f64;
}
extern "C" {
    #[doc = " returns the objective scale of the transformed problem\n\n  @return the objective scale of the transformed problem\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPgetTransObjscale(scip: *mut SCIP) -> f64;
}
extern "C" {
    #[doc = " sets limit on objective function, such that only solutions better than this limit are accepted\n\n  @note SCIP will only look for solutions with a strictly better objective value, thus, e.g., prune\n        all branch-and-bound nodes with dual bound equal or worse to the objective limit.\n        However, SCIP will also collect solutions with objective value worse than the objective limit and\n        use them to run improvement heuristics on them.\n  @note If SCIP can prove that there exists no solution with a strictly better objective value, the solving status\n        will normally be infeasible (the objective limit is interpreted as part of the problem).\n        The only exception is that by chance, SCIP found a solution with the same objective value and thus\n        proved the optimality of this solution, resulting in solution status optimal.\n\n  @return \\ref SCIP_OKAY is returned if everything worked. otherwise a suitable error code is passed. see \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPsetObjlimit(scip: *mut SCIP, objlimit: f64) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " returns current limit on objective function\n\n  @return the current objective limit of the original problem\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMING\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPgetObjlimit(scip: *mut SCIP) -> f64;
}
extern "C" {
    #[doc = " informs SCIP, that the objective value is always integral in every feasible solution\n\n  @return \\ref SCIP_OKAY is returned if everything worked. otherwise a suitable error code is passed. see \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMING\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_SOLVING\n\n  @note This function should be used to inform SCIP that the objective function is integral, helping to improve the\n        performance. This is useful when using column generation. If no column generation (pricing) is used, SCIP\n        automatically detects whether the objective function is integral or can be scaled to be integral. However, in\n        any case, the user has to make sure that no variable is added during the solving process that destroys this\n        property."]
    pub fn SCIPsetObjIntegral(scip: *mut SCIP) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " returns whether the objective value is known to be integral in every feasible solution\n\n  @return TRUE, if objective value is known to be always integral, otherwise FALSE\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMING\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_SOLVING\n\n  @note If no pricing is performed, SCIP automatically detects whether the objective function is integral or can be\n        scaled to be integral, helping to improve performance. This function returns the result. Otherwise\n        SCIPsetObjIntegral() can be used to inform SCIP. However, in any case, the user has to make sure that no\n        variable is added during the solving process that destroys this property."]
    pub fn SCIPisObjIntegral(scip: *mut SCIP) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " returns the Euclidean norm of the objective function vector (available only for transformed problem)\n\n  @return the Euclidean norm of the transformed objective function vector\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED\n       - \\ref SCIP_STAGE_EXITSOLVE"]
    pub fn SCIPgetObjNorm(scip: *mut SCIP) -> f64;
}
extern "C" {
    #[doc = " adds variable to the problem\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMING\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPaddVar(scip: *mut SCIP, var: *mut SCIP_VAR) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " adds variable to the problem and uses it as pricing candidate to enter the LP\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can only be called if @p scip is in stage \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPaddPricedVar(scip: *mut SCIP, var: *mut SCIP_VAR, score: f64) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " removes variable from the problem\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMING\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_FREETRANS"]
    pub fn SCIPdelVar(
        scip: *mut SCIP,
        var: *mut SCIP_VAR,
        deleted: *mut ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " gets variables of the problem along with the numbers of different variable types; data may become invalid after\n  calls to SCIPchgVarType(), SCIPfixVar(), SCIPaggregateVars(), and SCIPmultiaggregateVar()\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED\n       - \\ref SCIP_STAGE_EXITSOLVE\n\n  @note Variables in the vars array are ordered: binaries first, then integers, implicit integers and continuous last."]
    pub fn SCIPgetVarsData(
        scip: *mut SCIP,
        vars: *mut *mut *mut SCIP_VAR,
        nvars: *mut ::std::os::raw::c_int,
        nbinvars: *mut ::std::os::raw::c_int,
        nintvars: *mut ::std::os::raw::c_int,
        nimplvars: *mut ::std::os::raw::c_int,
        ncontvars: *mut ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " gets array with active problem variables\n\n  @return array with active problem variables\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED\n       - \\ref SCIP_STAGE_EXITSOLVE\n\n  @warning If your are using the methods which add or change bound of variables (e.g., SCIPchgVarType(), SCIPfixVar(),\n           SCIPaggregateVars(), and SCIPmultiaggregateVar()), it can happen that the internal variable array (which is\n           accessed via this method) gets resized and/or resorted. This can invalid the data pointer which is returned\n           by this method.\n\n  @note Variables in the array are ordered: binaries first, then integers, implicit integers and continuous last."]
    pub fn SCIPgetVars(scip: *mut SCIP) -> *mut *mut SCIP_VAR;
}
extern "C" {
    #[doc = " gets number of active problem variables\n\n  @return the number of active problem variables\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED\n       - \\ref SCIP_STAGE_EXITSOLVE"]
    pub fn SCIPgetNVars(scip: *mut SCIP) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " gets number of binary active problem variables\n\n  @return the number of binary active problem variables\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED\n       - \\ref SCIP_STAGE_EXITSOLVE"]
    pub fn SCIPgetNBinVars(scip: *mut SCIP) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " gets number of integer active problem variables\n\n  @return the number of integer active problem variables\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED\n       - \\ref SCIP_STAGE_EXITSOLVE"]
    pub fn SCIPgetNIntVars(scip: *mut SCIP) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " gets number of implicit integer active problem variables\n\n  @return the number of implicit integer active problem variables\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED\n       - \\ref SCIP_STAGE_EXITSOLVE"]
    pub fn SCIPgetNImplVars(scip: *mut SCIP) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " gets number of continuous active problem variables\n\n  @return the number of continuous active problem variables\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED\n       - \\ref SCIP_STAGE_EXITSOLVE"]
    pub fn SCIPgetNContVars(scip: *mut SCIP) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " gets number of active problem variables with a non-zero objective coefficient\n\n  @note In case of the original problem the number of variables is counted. In case of the transformed problem the\n        number of variables is just returned since it is stored internally\n\n  @return the number of active problem variables with a non-zero objective coefficient\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPgetNObjVars(scip: *mut SCIP) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " gets array with fixed and aggregated problem variables; data may become invalid after\n  calls to SCIPfixVar(), SCIPaggregateVars(), and SCIPmultiaggregateVar()\n\n  @return an array with fixed and aggregated problem variables; data may become invalid after\n          calls to SCIPfixVar(), SCIPaggregateVars(), and SCIPmultiaggregateVar()\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPgetFixedVars(scip: *mut SCIP) -> *mut *mut SCIP_VAR;
}
extern "C" {
    #[doc = " gets number of fixed or aggregated problem variables\n\n  @return the number of fixed or aggregated problem variables\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPgetNFixedVars(scip: *mut SCIP) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " gets variables of the original problem along with the numbers of different variable types; data may become invalid\n  after a call to SCIPchgVarType()\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMING\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED\n       - \\ref SCIP_STAGE_EXITSOLVE\n       - \\ref SCIP_STAGE_FREETRANS"]
    pub fn SCIPgetOrigVarsData(
        scip: *mut SCIP,
        vars: *mut *mut *mut SCIP_VAR,
        nvars: *mut ::std::os::raw::c_int,
        nbinvars: *mut ::std::os::raw::c_int,
        nintvars: *mut ::std::os::raw::c_int,
        nimplvars: *mut ::std::os::raw::c_int,
        ncontvars: *mut ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " gets array with original problem variables; data may become invalid after\n  a call to SCIPchgVarType()\n\n  @return an array with original problem variables; data may become invalid after\n          a call to SCIPchgVarType()\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMING\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED\n       - \\ref SCIP_STAGE_EXITSOLVE\n       - \\ref SCIP_STAGE_FREETRANS"]
    pub fn SCIPgetOrigVars(scip: *mut SCIP) -> *mut *mut SCIP_VAR;
}
extern "C" {
    #[doc = " gets number of original problem variables\n\n  @return the number of original problem variables\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMING\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED\n       - \\ref SCIP_STAGE_EXITSOLVE\n       - \\ref SCIP_STAGE_FREETRANS"]
    pub fn SCIPgetNOrigVars(scip: *mut SCIP) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " gets number of binary variables in the original problem\n\n  @return the number of binary variables in the original problem\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMING\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED\n       - \\ref SCIP_STAGE_EXITSOLVE\n       - \\ref SCIP_STAGE_FREETRANS"]
    pub fn SCIPgetNOrigBinVars(scip: *mut SCIP) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " gets the number of integer variables in the original problem\n\n  @return the number of integer variables in the original problem\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMING\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED\n       - \\ref SCIP_STAGE_EXITSOLVE\n       - \\ref SCIP_STAGE_FREETRANS"]
    pub fn SCIPgetNOrigIntVars(scip: *mut SCIP) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " gets number of implicit integer variables in the original problem\n\n  @return the number of implicit integer variables in the original problem\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMING\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED\n       - \\ref SCIP_STAGE_EXITSOLVE\n       - \\ref SCIP_STAGE_FREETRANS"]
    pub fn SCIPgetNOrigImplVars(scip: *mut SCIP) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " gets number of continuous variables in the original problem\n\n  @return the number of continuous variables in the original problem\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMING\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED\n       - \\ref SCIP_STAGE_EXITSOLVE\n       - \\ref SCIP_STAGE_FREETRANS"]
    pub fn SCIPgetNOrigContVars(scip: *mut SCIP) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " gets number of all problem variables created during creation and solving of problem;\n  this includes also variables that were deleted in the meantime\n\n  @return the number of all problem variables created during creation and solving of problem;\n          this includes also variables that were deleted in the meantime\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMING\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED\n       - \\ref SCIP_STAGE_EXITSOLVE\n       - \\ref SCIP_STAGE_FREETRANS"]
    pub fn SCIPgetNTotalVars(scip: *mut SCIP) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " gets variables of the original or transformed problem along with the numbers of different variable types;\n  the returned problem space (original or transformed) corresponds to the given solution;\n  data may become invalid after calls to SCIPchgVarType(), SCIPfixVar(), SCIPaggregateVars(), and\n  SCIPmultiaggregateVar()\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPgetSolVarsData(
        scip: *mut SCIP,
        sol: *mut SCIP_SOL,
        vars: *mut *mut *mut SCIP_VAR,
        nvars: *mut ::std::os::raw::c_int,
        nbinvars: *mut ::std::os::raw::c_int,
        nintvars: *mut ::std::os::raw::c_int,
        nimplvars: *mut ::std::os::raw::c_int,
        ncontvars: *mut ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " returns variable of given name in the problem, or NULL if not existing\n\n  @return variable of given name in the problem, or NULL if not existing\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMING\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED\n       - \\ref SCIP_STAGE_EXITSOLVE\n       - \\ref SCIP_STAGE_FREETRANS"]
    pub fn SCIPfindVar(scip: *mut SCIP, name: *const ::std::os::raw::c_char) -> *mut SCIP_VAR;
}
extern "C" {
    #[doc = " returns TRUE iff all potential variables exist in the problem, and FALSE, if there may be additional variables,\n  that will be added in pricing and improve the objective value\n\n  @return TRUE, if all potential variables exist in the problem; FALSE, otherwise\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_TRANSFORMING\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED\n       - \\ref SCIP_STAGE_EXITSOLVE\n       - \\ref SCIP_STAGE_FREETRANS"]
    pub fn SCIPallVarsInProb(scip: *mut SCIP) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " adds constraint to the problem; if constraint is only valid locally, it is added to the local subproblem of the\n  current node (and all of its subnodes); otherwise it is added to the global problem;\n  if a local constraint is added at the root node, it is automatically upgraded into a global constraint\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_EXITSOLVE"]
    pub fn SCIPaddCons(scip: *mut SCIP, cons: *mut SCIP_CONS) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " globally removes constraint from all subproblems; removes constraint from the constraint set change data of the\n  node, where it was added, or from the problem, if it was a problem constraint\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_EXITSOLVE"]
    pub fn SCIPdelCons(scip: *mut SCIP, cons: *mut SCIP_CONS) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " returns original constraint of given name in the problem, or NULL if not existing\n\n  @return original constraint of given name in the problem, or NULL if not existing\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMING\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED\n       - \\ref SCIP_STAGE_EXITSOLVE\n       - \\ref SCIP_STAGE_FREETRANS"]
    pub fn SCIPfindOrigCons(scip: *mut SCIP, name: *const ::std::os::raw::c_char)
        -> *mut SCIP_CONS;
}
extern "C" {
    #[doc = " returns constraint of given name in the problem, or NULL if not existing\n\n  @return constraint of given name in the problem, or NULL if not existing\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMING\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED\n       - \\ref SCIP_STAGE_EXITSOLVE\n       - \\ref SCIP_STAGE_FREETRANS"]
    pub fn SCIPfindCons(scip: *mut SCIP, name: *const ::std::os::raw::c_char) -> *mut SCIP_CONS;
}
extern "C" {
    #[doc = " gets number of upgraded constraints\n\n  @return number of upgraded constraints\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPgetNUpgrConss(scip: *mut SCIP) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " gets total number of globally valid constraints currently in the problem\n\n  @return total number of globally valid constraints currently in the problem\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPgetNConss(scip: *mut SCIP) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " gets array of globally valid constraints currently in the problem\n\n  @return array of globally valid constraints currently in the problem\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED\n\n  @warning If your are using the method SCIPaddCons(), it can happen that the internal constraint array (which is\n           accessed via this method) gets resized. This can invalid the pointer which is returned by this method."]
    pub fn SCIPgetConss(scip: *mut SCIP) -> *mut *mut SCIP_CONS;
}
extern "C" {
    #[doc = " gets total number of constraints in the original problem\n\n  @return total number of constraints in the original problem\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMING\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED\n       - \\ref SCIP_STAGE_EXITSOLVE\n       - \\ref SCIP_STAGE_FREETRANS"]
    pub fn SCIPgetNOrigConss(scip: *mut SCIP) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " gets array of constraints in the original problem\n\n  @return array of constraints in the original problem\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMING\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED\n       - \\ref SCIP_STAGE_EXITSOLVE\n       - \\ref SCIP_STAGE_FREETRANS"]
    pub fn SCIPgetOrigConss(scip: *mut SCIP) -> *mut *mut SCIP_CONS;
}
extern "C" {
    #[doc = " computes the number of check constraint in the current node (loop over all constraint handler and cumulates the\n  number of check constraints)\n\n  @return returns the number of check constraints\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPgetNCheckConss(scip: *mut SCIP) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " adds a conflict to a given node or globally to the problem if @p node == NULL.\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre this method can be called in one of the following stages of the SCIP solving process:\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_SOLVING\n\n  @note this method will release the constraint"]
    pub fn SCIPaddConflict(
        scip: *mut SCIP,
        node: *mut SCIP_NODE,
        cons: *mut SCIP_CONS,
        validnode: *mut SCIP_NODE,
        conftype: SCIP_CONFTYPE,
        iscutoffinvolved: ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " removes all conflicts depending on an old cutoff bound if the improvement of the incumbent is good enough\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre this method can be called in one of the following stages of the SCIP solving process:\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPclearConflictStore(scip: *mut SCIP, event: *mut SCIP_EVENT) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " adds constraint to the given node (and all of its subnodes), even if it is a global constraint;\n  It is sometimes desirable to add the constraint to a more local node (i.e., a node of larger depth) even if\n  the constraint is also valid higher in the tree, for example, if one wants to produce a constraint which is\n  only active in a small part of the tree although it is valid in a larger part.\n  In this case, one should pass the more global node where the constraint is valid as \"validnode\".\n  Note that the same constraint cannot be added twice to the branching tree with different \"validnode\" parameters.\n  If the constraint is valid at the same node as it is inserted (the usual case), one should pass NULL as \"validnode\".\n  If the \"validnode\" is the root node, it is automatically upgraded into a global constraint, but still only added to\n  the given node. If a local constraint is added to the root node, it is added to the global problem instead.\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre this method can be called in one of the following stages of the SCIP solving process:\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPaddConsNode(
        scip: *mut SCIP,
        node: *mut SCIP_NODE,
        cons: *mut SCIP_CONS,
        validnode: *mut SCIP_NODE,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " adds constraint locally to the current node (and all of its subnodes), even if it is a global constraint;\n  It is sometimes desirable to add the constraint to a more local node (i.e., a node of larger depth) even if\n  the constraint is also valid higher in the tree, for example, if one wants to produce a constraint which is\n  only active in a small part of the tree although it is valid in a larger part.\n\n  If the constraint is valid at the same node as it is inserted (the usual case), one should pass NULL as \"validnode\".\n  If the \"validnode\" is the root node, it is automatically upgraded into a global constraint, but still only added to\n  the given node. If a local constraint is added to the root node, it is added to the global problem instead.\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre this method can be called in one of the following stages of the SCIP solving process:\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_SOLVING\n\n  @note The same constraint cannot be added twice to the branching tree with different \"validnode\" parameters. This is\n        the case due internal data structures and performance issues. In such a case you should try to realize your\n        issue using the method SCIPdisableCons() and SCIPenableCons() and control these via the event system of SCIP."]
    pub fn SCIPaddConsLocal(
        scip: *mut SCIP,
        cons: *mut SCIP_CONS,
        validnode: *mut SCIP_NODE,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " disables constraint's separation, enforcing, and propagation capabilities at the given node (and all subnodes);\n  if the method is called at the root node, the constraint is globally deleted from the problem;\n  the constraint deletion is being remembered at the given node, s.t. after leaving the node's subtree, the constraint\n  is automatically enabled again, and after entering the node's subtree, it is automatically disabled;\n  this may improve performance because redundant checks on this constraint are avoided, but it consumes memory;\n  alternatively, use SCIPdisableCons()\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre this method can be called in one of the following stages of the SCIP solving process:\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPdelConsNode(
        scip: *mut SCIP,
        node: *mut SCIP_NODE,
        cons: *mut SCIP_CONS,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " disables constraint's separation, enforcing, and propagation capabilities at the current node (and all subnodes);\n  if the method is called during problem modification or at the root node, the constraint is globally deleted from\n  the problem;\n  the constraint deletion is being remembered at the current node, s.t. after leaving the current subtree, the\n  constraint is automatically enabled again, and after reentering the current node's subtree, it is automatically\n  disabled again;\n  this may improve performance because redundant checks on this constraint are avoided, but it consumes memory;\n  alternatively, use SCIPdisableCons()\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre this method can be called in one of the following stages of the SCIP solving process:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPdelConsLocal(scip: *mut SCIP, cons: *mut SCIP_CONS) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " gets estimate of best primal solution w.r.t. original problem contained in current subtree\n\n  @return estimate of best primal solution w.r.t. original problem contained in current subtree\n\n  @pre this method can be called in one of the following stages of the SCIP solving process:\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPgetLocalOrigEstimate(scip: *mut SCIP) -> f64;
}
extern "C" {
    #[doc = " gets estimate of best primal solution w.r.t. transformed problem contained in current subtree\n\n  @return estimate of best primal solution w.r.t. transformed problem contained in current subtree\n\n  @pre this method can be called in one of the following stages of the SCIP solving process:\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPgetLocalTransEstimate(scip: *mut SCIP) -> f64;
}
extern "C" {
    #[doc = " gets dual bound of current node\n\n  @return dual bound of current node\n\n  @pre this method can be called in one of the following stages of the SCIP solving process:\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPgetLocalDualbound(scip: *mut SCIP) -> f64;
}
extern "C" {
    #[doc = " gets lower bound of current node in transformed problem\n\n  @return lower bound  of current node in transformed problem\n\n  @pre this method can be called in one of the following stages of the SCIP solving process:\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPgetLocalLowerbound(scip: *mut SCIP) -> f64;
}
extern "C" {
    #[doc = " gets dual bound of given node\n\n  @return dual bound of a given node\n\n  @pre this method can be called in one of the following stages of the SCIP solving process:\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPgetNodeDualbound(scip: *mut SCIP, node: *mut SCIP_NODE) -> f64;
}
extern "C" {
    #[doc = " gets lower bound of given node in transformed problem\n\n  @return lower bound  of given node in transformed problem\n\n  @pre this method can be called in one of the following stages of the SCIP solving process:\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPgetNodeLowerbound(scip: *mut SCIP, node: *mut SCIP_NODE) -> f64;
}
extern "C" {
    #[doc = " if given value is tighter (larger for minimization, smaller for maximization) than the current node's dual bound (in\n  original problem space), sets the current node's dual bound to the new value\n\n  @note the given new bound has to be a dual bound, i.e., it has to be valid for the original problem.\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre this method can be called in one of the following stages of the SCIP solving process:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPupdateLocalDualbound(scip: *mut SCIP, newbound: f64) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " if given value is larger than the current node's lower bound (in transformed problem), sets the current node's\n  lower bound to the new value\n\n  @note the given new bound has to be a lower bound, i.e., it has to be valid for the transformed problem.\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre this method can be called in one of the following stages of the SCIP solving process:\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPupdateLocalLowerbound(scip: *mut SCIP, newbound: f64) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " if given value is tighter (larger for minimization, smaller for maximization) than the node's dual bound,\n  sets the node's dual bound to the new value\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre this method can be called in one of the following stages of the SCIP solving process:\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPupdateNodeDualbound(
        scip: *mut SCIP,
        node: *mut SCIP_NODE,
        newbound: f64,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " if given value is larger than the node's lower bound (in transformed problem), sets the node's lower bound\n  to the new value\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre this method can be called in one of the following stages of the SCIP solving process:\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPupdateNodeLowerbound(
        scip: *mut SCIP,
        node: *mut SCIP_NODE,
        newbound: f64,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " change the node selection priority of the given child\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre this method can be called in one of the following stages of the SCIP solving process:\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPchgChildPrio(scip: *mut SCIP, child: *mut SCIP_NODE, priority: f64) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " returns whether we are in probing mode; probing mode is activated via SCIPstartProbing() and stopped\n  via SCIPendProbing()\n\n  @return TRUE, if SCIP is currently in probing mode, otherwise FALSE\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED\n       - \\ref SCIP_STAGE_EXITSOLVE"]
    pub fn SCIPinProbing(scip: *mut SCIP) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " initiates probing, making methods SCIPnewProbingNode(), SCIPbacktrackProbing(), SCIPchgVarLbProbing(),\n  SCIPchgVarUbProbing(), SCIPfixVarProbing(), SCIPpropagateProbing(), and SCIPsolveProbingLP() available\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_SOLVING\n\n  @note The collection of variable statistics is turned off during probing. If these statistics should be collected\n        during probing use the method SCIPenableVarHistory() to turn the collection explicitly on."]
    pub fn SCIPstartProbing(scip: *mut SCIP) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " creates a new probing sub node, whose changes can be undone by backtracking to a higher node in the probing path\n  with a call to SCIPbacktrackProbing();\n  using a sub node for each set of probing bound changes can improve conflict analysis\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPnewProbingNode(scip: *mut SCIP) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " returns the current probing depth\n\n  @return the probing depth, i.e. the number of probing sub nodes existing in the probing path\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPgetProbingDepth(scip: *mut SCIP) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " undoes all changes to the problem applied in probing up to the given probing depth;\n  the changes of the probing node of the given probing depth are the last ones that remain active;\n  changes that were applied before calling SCIPnewProbingNode() cannot be undone\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPbacktrackProbing(
        scip: *mut SCIP,
        probingdepth: ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " quits probing and resets bounds and constraints to the focus node's environment\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPendProbing(scip: *mut SCIP) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " injects a change of variable's lower bound into current probing node; the same can also be achieved with a call to\n  SCIPchgVarLb(), but in this case, the bound change would be treated like a deduction instead of a branching decision\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPchgVarLbProbing(scip: *mut SCIP, var: *mut SCIP_VAR, newbound: f64) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " injects a change of variable's upper bound into current probing node; the same can also be achieved with a call to\n  SCIPchgVarUb(), but in this case, the bound change would be treated like a deduction instead of a branching decision\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPchgVarUbProbing(scip: *mut SCIP, var: *mut SCIP_VAR, newbound: f64) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " gets variable's objective value in current probing\n\n  @return the variable's objective value in current probing.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_SOLVING\n\n  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPgetVarObjProbing(scip: *mut SCIP, var: *mut SCIP_VAR) -> f64;
}
extern "C" {
    #[doc = " injects a change of variable's bounds into current probing node to fix the variable to the specified value;\n  the same can also be achieved with a call to SCIPfixVar(), but in this case, the bound changes would be treated\n  like deductions instead of branching decisions\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPfixVarProbing(scip: *mut SCIP, var: *mut SCIP_VAR, fixedval: f64) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " changes (column) variable's objective value during probing mode\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_SOLVING\n\n  @pre The variable needs to be a column variable."]
    pub fn SCIPchgVarObjProbing(scip: *mut SCIP, var: *mut SCIP_VAR, newobj: f64) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " returns whether the objective function has changed during probing mode\n\n  @return \\ref TRUE if objective has changed, \\ref FALSE otherwise\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED\n       - \\ref SCIP_STAGE_EXITSOLVE"]
    pub fn SCIPisObjChangedProbing(scip: *mut SCIP) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " applies domain propagation on the probing sub problem, that was changed after SCIPstartProbing() was called;\n  the propagated domains of the variables can be accessed with the usual bound accessing calls SCIPvarGetLbLocal()\n  and SCIPvarGetUbLocal(); the propagation is only valid locally, i.e. the local bounds as well as the changed\n  bounds due to SCIPchgVarLbProbing(), SCIPchgVarUbProbing(), and SCIPfixVarProbing() are used for propagation\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPpropagateProbing(
        scip: *mut SCIP,
        maxproprounds: ::std::os::raw::c_int,
        cutoff: *mut ::std::os::raw::c_uint,
        ndomredsfound: *mut ::std::os::raw::c_longlong,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " applies domain propagation on the probing sub problem, that was changed after SCIPstartProbing() was called;\n  only propagations of the binary variables fixed at the current probing node that are triggered by the implication\n  graph and the clique table are applied;\n  the propagated domains of the variables can be accessed with the usual bound accessing calls SCIPvarGetLbLocal()\n  and SCIPvarGetUbLocal(); the propagation is only valid locally, i.e. the local bounds as well as the changed\n  bounds due to SCIPchgVarLbProbing(), SCIPchgVarUbProbing(), and SCIPfixVarProbing() are used for propagation\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPpropagateProbingImplications(
        scip: *mut SCIP,
        cutoff: *mut ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " solves the LP at the current probing node (cannot be applied at preprocessing stage);\n  no separation or pricing is applied\n\n  The LP has to be constructed before (you can use SCIPisLPConstructed() or SCIPconstructLP()).\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPsolveProbingLP(
        scip: *mut SCIP,
        itlim: ::std::os::raw::c_int,
        lperror: *mut ::std::os::raw::c_uint,
        cutoff: *mut ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " solves the LP at the current probing node (cannot be applied at preprocessing stage) and applies pricing\n  until the LP is solved to optimality; no separation is applied\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed . See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPsolveProbingLPWithPricing(
        scip: *mut SCIP,
        pretendroot: ::std::os::raw::c_uint,
        displayinfo: ::std::os::raw::c_uint,
        maxpricerounds: ::std::os::raw::c_int,
        lperror: *mut ::std::os::raw::c_uint,
        cutoff: *mut ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " sets the LP state for the current probing node\n\n  @note state and norms are stored at the node and later released by SCIP; therefore, the pointers are set\n        to NULL by the method\n\n  @note the pointers to state and norms must not be NULL; however, they may point to a NULL pointer if the\n        respective information should not be set\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPsetProbingLPState(
        scip: *mut SCIP,
        lpistate: *mut *mut SCIP_LPISTATE,
        lpinorms: *mut *mut SCIP_LPINORMS,
        primalfeas: ::std::os::raw::c_uint,
        dualfeas: ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " adds a row to the LP in the current probing node\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_SOLVING\n\n  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPaddRowProbing(scip: *mut SCIP, row: *mut SCIP_ROW) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " applies the cuts in the separation storage to the LP and clears the storage afterwards;\n  this method can only be applied during probing; the user should resolve the probing LP afterwards\n  in order to get a new solution\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPapplyCutsProbing(
        scip: *mut SCIP,
        cutoff: *mut ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " solves relaxation(s) at the current probing node (cannot be applied at preprocessing stage);\n  no separation or pricing is applied\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPsolveProbingRelax(
        scip: *mut SCIP,
        cutoff: *mut ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " print statistics of probing"]
    pub fn SCIPsnprintfProbingStats(
        scip: *mut SCIP,
        strbuf: *mut ::std::os::raw::c_char,
        len: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " stores the candidate score and preferred rounding direction for a candidate variable"]
    pub fn SCIPgetDivesetScore(
        scip: *mut SCIP,
        diveset: *mut SCIP_DIVESET,
        divetype: SCIP_DIVETYPE,
        divecand: *mut SCIP_VAR,
        divecandsol: f64,
        divecandfrac: f64,
        candscore: *mut f64,
        roundup: *mut ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " update diveset LP statistics, should be called after every LP solved by this diving heuristic"]
    pub fn SCIPupdateDivesetLPStats(
        scip: *mut SCIP,
        diveset: *mut SCIP_DIVESET,
        niterstoadd: ::std::os::raw::c_longlong,
        divecontext: SCIP_DIVECONTEXT,
    );
}
extern "C" {
    #[doc = " update diveset statistics and global diveset statistics"]
    pub fn SCIPupdateDivesetStats(
        scip: *mut SCIP,
        diveset: *mut SCIP_DIVESET,
        nprobingnodes: ::std::os::raw::c_int,
        nbacktracks: ::std::os::raw::c_int,
        nsolsfound: ::std::os::raw::c_longlong,
        nbestsolsfound: ::std::os::raw::c_longlong,
        nconflictsfound: ::std::os::raw::c_longlong,
        leavewassol: ::std::os::raw::c_uint,
        divecontext: SCIP_DIVECONTEXT,
    );
}
extern "C" {
    #[doc = " enforces a probing/diving solution by suggesting bound changes that maximize the score w.r.t. the current diving settings\n\n  the process is guided by the enforcement priorities of the constraint handlers and the scoring mechanism provided by\n  the dive set.\n  Constraint handlers may suggest diving bound changes in decreasing order of their enforcement priority, based on the\n  solution values in the solution @p sol and the current local bounds of the variables. A diving bound change\n  is a triple (variable,branching direction,value) and is used inside SCIPperformGenericDivingAlgorithm().\n\n  After a successful call, SCIP holds two arrays of suggested dive bound changes, one for the preferred child\n  and one for the alternative.\n\n  @see SCIPgetDiveBoundChangeData() for retrieving the dive bound change suggestions.\n\n  The method stops after the first constraint handler was successful\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_SOLVING\n\n  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPgetDiveBoundChanges(
        scip: *mut SCIP,
        diveset: *mut SCIP_DIVESET,
        sol: *mut SCIP_SOL,
        success: *mut ::std::os::raw::c_uint,
        infeasible: *mut ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " adds a diving bound change to the diving bound change storage of SCIP together with the information if this is a\n  bound change for the preferred direction or not\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_SOLVING\n\n  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPaddDiveBoundChange(
        scip: *mut SCIP,
        var: *mut SCIP_VAR,
        dir: SCIP_BRANCHDIR,
        value: f64,
        preferred: ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " get the dive bound change data for the preferred or the alternative direction\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_SOLVING\n\n  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPgetDiveBoundChangeData(
        scip: *mut SCIP,
        variables: *mut *mut *mut SCIP_VAR,
        directions: *mut *mut SCIP_BRANCHDIR,
        values: *mut *mut f64,
        ndivebdchgs: *mut ::std::os::raw::c_int,
        preferred: ::std::os::raw::c_uint,
    );
}
extern "C" {
    #[doc = " clear the dive bound change data structures\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_SOLVING\n\n  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPclearDiveBoundChanges(scip: *mut SCIP);
}
extern "C" {
    #[doc = " creates a propagator and includes it in SCIP.\n\n\n  @note method has all propagator callbacks as arguments and is thus changed every time a new\n        callback is added in future releases; consider using SCIPincludePropBasic() and setter functions\n        if you seek for a method which is less likely to change in future releases"]
    pub fn SCIPincludeProp(
        scip: *mut SCIP,
        name: *const ::std::os::raw::c_char,
        desc: *const ::std::os::raw::c_char,
        priority: ::std::os::raw::c_int,
        freq: ::std::os::raw::c_int,
        delay: ::std::os::raw::c_uint,
        timingmask: SCIP_PROPTIMING,
        presolpriority: ::std::os::raw::c_int,
        presolmaxrounds: ::std::os::raw::c_int,
        presoltiming: SCIP_PRESOLTIMING,
        propcopy: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, prop: *mut SCIP_PROP) -> SCIP_RETCODE,
        >,
        propfree: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, prop: *mut SCIP_PROP) -> SCIP_RETCODE,
        >,
        propinit: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, prop: *mut SCIP_PROP) -> SCIP_RETCODE,
        >,
        propexit: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, prop: *mut SCIP_PROP) -> SCIP_RETCODE,
        >,
        propinitpre: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, prop: *mut SCIP_PROP) -> SCIP_RETCODE,
        >,
        propexitpre: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, prop: *mut SCIP_PROP) -> SCIP_RETCODE,
        >,
        propinitsol: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, prop: *mut SCIP_PROP) -> SCIP_RETCODE,
        >,
        propexitsol: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                prop: *mut SCIP_PROP,
                restart: ::std::os::raw::c_uint,
            ) -> SCIP_RETCODE,
        >,
        proppresol: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                prop: *mut SCIP_PROP,
                nrounds: ::std::os::raw::c_int,
                presoltiming: SCIP_PRESOLTIMING,
                nnewfixedvars: ::std::os::raw::c_int,
                nnewaggrvars: ::std::os::raw::c_int,
                nnewchgvartypes: ::std::os::raw::c_int,
                nnewchgbds: ::std::os::raw::c_int,
                nnewholes: ::std::os::raw::c_int,
                nnewdelconss: ::std::os::raw::c_int,
                nnewaddconss: ::std::os::raw::c_int,
                nnewupgdconss: ::std::os::raw::c_int,
                nnewchgcoefs: ::std::os::raw::c_int,
                nnewchgsides: ::std::os::raw::c_int,
                nfixedvars: *mut ::std::os::raw::c_int,
                naggrvars: *mut ::std::os::raw::c_int,
                nchgvartypes: *mut ::std::os::raw::c_int,
                nchgbds: *mut ::std::os::raw::c_int,
                naddholes: *mut ::std::os::raw::c_int,
                ndelconss: *mut ::std::os::raw::c_int,
                naddconss: *mut ::std::os::raw::c_int,
                nupgdconss: *mut ::std::os::raw::c_int,
                nchgcoefs: *mut ::std::os::raw::c_int,
                nchgsides: *mut ::std::os::raw::c_int,
                result: *mut SCIP_RESULT,
            ) -> SCIP_RETCODE,
        >,
        propexec: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                prop: *mut SCIP_PROP,
                proptiming: SCIP_PROPTIMING,
                result: *mut SCIP_RESULT,
            ) -> SCIP_RETCODE,
        >,
        propresprop: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                prop: *mut SCIP_PROP,
                infervar: *mut SCIP_VAR,
                inferinfo: ::std::os::raw::c_int,
                boundtype: SCIP_BOUNDTYPE,
                bdchgidx: *mut SCIP_BDCHGIDX,
                relaxedbd: f64,
                result: *mut SCIP_RESULT,
            ) -> SCIP_RETCODE,
        >,
        propdata: *mut SCIP_PROPDATA,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " creates a propagator and includes it in SCIP. All non-fundamental (or optional) callbacks will be set to NULL.\n  Optional callbacks can be set via specific setter functions, see SCIPsetPropInit(), SCIPsetPropExit(),\n  SCIPsetPropCopy(), SCIPsetPropFree(), SCIPsetPropInitsol(), SCIPsetPropExitsol(),\n  SCIPsetPropInitpre(), SCIPsetPropExitpre(), SCIPsetPropPresol(), and SCIPsetPropResprop().\n\n  @note if you want to set all callbacks with a single method call, consider using SCIPincludeProp() instead"]
    pub fn SCIPincludePropBasic(
        scip: *mut SCIP,
        propptr: *mut *mut SCIP_PROP,
        name: *const ::std::os::raw::c_char,
        desc: *const ::std::os::raw::c_char,
        priority: ::std::os::raw::c_int,
        freq: ::std::os::raw::c_int,
        delay: ::std::os::raw::c_uint,
        timingmask: SCIP_PROPTIMING,
        propexec: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                prop: *mut SCIP_PROP,
                proptiming: SCIP_PROPTIMING,
                result: *mut SCIP_RESULT,
            ) -> SCIP_RETCODE,
        >,
        propdata: *mut SCIP_PROPDATA,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " sets copy method of propagator"]
    pub fn SCIPsetPropCopy(
        scip: *mut SCIP,
        prop: *mut SCIP_PROP,
        propcopy: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, prop: *mut SCIP_PROP) -> SCIP_RETCODE,
        >,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " sets destructor method of propagator"]
    pub fn SCIPsetPropFree(
        scip: *mut SCIP,
        prop: *mut SCIP_PROP,
        propfree: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, prop: *mut SCIP_PROP) -> SCIP_RETCODE,
        >,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " sets initialization method of propagator"]
    pub fn SCIPsetPropInit(
        scip: *mut SCIP,
        prop: *mut SCIP_PROP,
        propinit: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, prop: *mut SCIP_PROP) -> SCIP_RETCODE,
        >,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " sets deinitialization method of propagator"]
    pub fn SCIPsetPropExit(
        scip: *mut SCIP,
        prop: *mut SCIP_PROP,
        propexit: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, prop: *mut SCIP_PROP) -> SCIP_RETCODE,
        >,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " sets solving process initialization method of propagator"]
    pub fn SCIPsetPropInitsol(
        scip: *mut SCIP,
        prop: *mut SCIP_PROP,
        propinitsol: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, prop: *mut SCIP_PROP) -> SCIP_RETCODE,
        >,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " sets solving process deinitialization method of propagator"]
    pub fn SCIPsetPropExitsol(
        scip: *mut SCIP,
        prop: *mut SCIP_PROP,
        propexitsol: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                prop: *mut SCIP_PROP,
                restart: ::std::os::raw::c_uint,
            ) -> SCIP_RETCODE,
        >,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " sets preprocessing initialization method of propagator"]
    pub fn SCIPsetPropInitpre(
        scip: *mut SCIP,
        prop: *mut SCIP_PROP,
        propinitpre: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, prop: *mut SCIP_PROP) -> SCIP_RETCODE,
        >,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " sets preprocessing deinitialization method of propagator"]
    pub fn SCIPsetPropExitpre(
        scip: *mut SCIP,
        prop: *mut SCIP_PROP,
        propexitpre: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, prop: *mut SCIP_PROP) -> SCIP_RETCODE,
        >,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " sets presolving method of propagator"]
    pub fn SCIPsetPropPresol(
        scip: *mut SCIP,
        prop: *mut SCIP_PROP,
        proppresol: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                prop: *mut SCIP_PROP,
                nrounds: ::std::os::raw::c_int,
                presoltiming: SCIP_PRESOLTIMING,
                nnewfixedvars: ::std::os::raw::c_int,
                nnewaggrvars: ::std::os::raw::c_int,
                nnewchgvartypes: ::std::os::raw::c_int,
                nnewchgbds: ::std::os::raw::c_int,
                nnewholes: ::std::os::raw::c_int,
                nnewdelconss: ::std::os::raw::c_int,
                nnewaddconss: ::std::os::raw::c_int,
                nnewupgdconss: ::std::os::raw::c_int,
                nnewchgcoefs: ::std::os::raw::c_int,
                nnewchgsides: ::std::os::raw::c_int,
                nfixedvars: *mut ::std::os::raw::c_int,
                naggrvars: *mut ::std::os::raw::c_int,
                nchgvartypes: *mut ::std::os::raw::c_int,
                nchgbds: *mut ::std::os::raw::c_int,
                naddholes: *mut ::std::os::raw::c_int,
                ndelconss: *mut ::std::os::raw::c_int,
                naddconss: *mut ::std::os::raw::c_int,
                nupgdconss: *mut ::std::os::raw::c_int,
                nchgcoefs: *mut ::std::os::raw::c_int,
                nchgsides: *mut ::std::os::raw::c_int,
                result: *mut SCIP_RESULT,
            ) -> SCIP_RETCODE,
        >,
        presolpriority: ::std::os::raw::c_int,
        presolmaxrounds: ::std::os::raw::c_int,
        presoltiming: SCIP_PRESOLTIMING,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " sets propagation conflict resolving callback of propagator"]
    pub fn SCIPsetPropResprop(
        scip: *mut SCIP,
        prop: *mut SCIP_PROP,
        propresprop: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                prop: *mut SCIP_PROP,
                infervar: *mut SCIP_VAR,
                inferinfo: ::std::os::raw::c_int,
                boundtype: SCIP_BOUNDTYPE,
                bdchgidx: *mut SCIP_BDCHGIDX,
                relaxedbd: f64,
                result: *mut SCIP_RESULT,
            ) -> SCIP_RETCODE,
        >,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " returns the propagator of the given name, or NULL if not existing"]
    pub fn SCIPfindProp(scip: *mut SCIP, name: *const ::std::os::raw::c_char) -> *mut SCIP_PROP;
}
extern "C" {
    #[doc = " returns the array of currently available propagators"]
    pub fn SCIPgetProps(scip: *mut SCIP) -> *mut *mut SCIP_PROP;
}
extern "C" {
    #[doc = " returns the number of currently available propagators"]
    pub fn SCIPgetNProps(scip: *mut SCIP) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " sets the priority of a propagator"]
    pub fn SCIPsetPropPriority(
        scip: *mut SCIP,
        prop: *mut SCIP_PROP,
        priority: ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " sets the presolving priority of a propagator"]
    pub fn SCIPsetPropPresolPriority(
        scip: *mut SCIP,
        prop: *mut SCIP_PROP,
        presolpriority: ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " creates and initializes a random number generator\n\n  @note The initial seed is changed using SCIPinitializeRandomSeed()"]
    pub fn SCIPcreateRandom(
        scip: *mut SCIP,
        randnumgen: *mut *mut SCIP_RANDNUMGEN,
        initialseed: ::std::os::raw::c_uint,
        useglobalseed: ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " frees a random number generator"]
    pub fn SCIPfreeRandom(scip: *mut SCIP, randnumgen: *mut *mut SCIP_RANDNUMGEN);
}
extern "C" {
    #[doc = " initializes a random number generator with a given seed\n\n  @note The seed is changed using SCIPinitializeRandomSeed()"]
    pub fn SCIPsetRandomSeed(
        scip: *mut SCIP,
        randnumgen: *mut SCIP_RANDNUMGEN,
        seed: ::std::os::raw::c_uint,
    );
}
extern "C" {
    #[doc = " modifies an initial seed value with the global shift of random seeds"]
    pub fn SCIPinitializeRandomSeed(
        scip: *mut SCIP,
        initialseedvalue: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " creates a reader and includes it in SCIP\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_INIT\n       - \\ref SCIP_STAGE_PROBLEM\n\n  @note method has all reader callbacks as arguments and is thus changed every time a new callback is added\n        in future releases; consider using SCIPincludeReaderBasic() and setter functions\n        if you seek for a method which is less likely to change in future releases"]
    pub fn SCIPincludeReader(
        scip: *mut SCIP,
        name: *const ::std::os::raw::c_char,
        desc: *const ::std::os::raw::c_char,
        extension: *const ::std::os::raw::c_char,
        readercopy: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, reader: *mut SCIP_READER) -> SCIP_RETCODE,
        >,
        readerfree: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, reader: *mut SCIP_READER) -> SCIP_RETCODE,
        >,
        readerread: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                reader: *mut SCIP_READER,
                filename: *const ::std::os::raw::c_char,
                result: *mut SCIP_RESULT,
            ) -> SCIP_RETCODE,
        >,
        readerwrite: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                reader: *mut SCIP_READER,
                file: *mut FILE,
                name: *const ::std::os::raw::c_char,
                probdata: *mut SCIP_PROBDATA,
                transformed: ::std::os::raw::c_uint,
                objsense: SCIP_OBJSENSE,
                objscale: f64,
                objoffset: f64,
                vars: *mut *mut SCIP_VAR,
                nvars: ::std::os::raw::c_int,
                nbinvars: ::std::os::raw::c_int,
                nintvars: ::std::os::raw::c_int,
                nimplvars: ::std::os::raw::c_int,
                ncontvars: ::std::os::raw::c_int,
                fixedvars: *mut *mut SCIP_VAR,
                nfixedvars: ::std::os::raw::c_int,
                startnvars: ::std::os::raw::c_int,
                conss: *mut *mut SCIP_CONS,
                nconss: ::std::os::raw::c_int,
                maxnconss: ::std::os::raw::c_int,
                startnconss: ::std::os::raw::c_int,
                genericnames: ::std::os::raw::c_uint,
                result: *mut SCIP_RESULT,
            ) -> SCIP_RETCODE,
        >,
        readerdata: *mut SCIP_READERDATA,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " creates a reader and includes it in SCIP. All non-fundamental (or optional) callbacks will be set to NULL.\n  Optional callbacks can be set via specific setter functions, see\n  SCIPsetReaderCopy(), SCIPsetReaderFree(), SCIPsetReaderRead(), SCIPsetReaderWrite().\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_INIT\n       - \\ref SCIP_STAGE_PROBLEM\n\n  @note if you want to set all callbacks with a single method call, consider using SCIPincludeReader() instead"]
    pub fn SCIPincludeReaderBasic(
        scip: *mut SCIP,
        readerptr: *mut *mut SCIP_READER,
        name: *const ::std::os::raw::c_char,
        desc: *const ::std::os::raw::c_char,
        extension: *const ::std::os::raw::c_char,
        readerdata: *mut SCIP_READERDATA,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " set copy method of reader\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_INIT\n       - \\ref SCIP_STAGE_PROBLEM"]
    pub fn SCIPsetReaderCopy(
        scip: *mut SCIP,
        reader: *mut SCIP_READER,
        readercopy: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, reader: *mut SCIP_READER) -> SCIP_RETCODE,
        >,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " set deinitialization method of reader\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_INIT\n       - \\ref SCIP_STAGE_PROBLEM"]
    pub fn SCIPsetReaderFree(
        scip: *mut SCIP,
        reader: *mut SCIP_READER,
        readerfree: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, reader: *mut SCIP_READER) -> SCIP_RETCODE,
        >,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " set read method of reader\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_INIT\n       - \\ref SCIP_STAGE_PROBLEM"]
    pub fn SCIPsetReaderRead(
        scip: *mut SCIP,
        reader: *mut SCIP_READER,
        readerread: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                reader: *mut SCIP_READER,
                filename: *const ::std::os::raw::c_char,
                result: *mut SCIP_RESULT,
            ) -> SCIP_RETCODE,
        >,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " set write method of reader\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_INIT\n       - \\ref SCIP_STAGE_PROBLEM"]
    pub fn SCIPsetReaderWrite(
        scip: *mut SCIP,
        reader: *mut SCIP_READER,
        readerwrite: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                reader: *mut SCIP_READER,
                file: *mut FILE,
                name: *const ::std::os::raw::c_char,
                probdata: *mut SCIP_PROBDATA,
                transformed: ::std::os::raw::c_uint,
                objsense: SCIP_OBJSENSE,
                objscale: f64,
                objoffset: f64,
                vars: *mut *mut SCIP_VAR,
                nvars: ::std::os::raw::c_int,
                nbinvars: ::std::os::raw::c_int,
                nintvars: ::std::os::raw::c_int,
                nimplvars: ::std::os::raw::c_int,
                ncontvars: ::std::os::raw::c_int,
                fixedvars: *mut *mut SCIP_VAR,
                nfixedvars: ::std::os::raw::c_int,
                startnvars: ::std::os::raw::c_int,
                conss: *mut *mut SCIP_CONS,
                nconss: ::std::os::raw::c_int,
                maxnconss: ::std::os::raw::c_int,
                startnconss: ::std::os::raw::c_int,
                genericnames: ::std::os::raw::c_uint,
                result: *mut SCIP_RESULT,
            ) -> SCIP_RETCODE,
        >,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " returns the reader of the given name, or NULL if not existing"]
    pub fn SCIPfindReader(scip: *mut SCIP, name: *const ::std::os::raw::c_char)
        -> *mut SCIP_READER;
}
extern "C" {
    #[doc = " returns the array of currently available readers"]
    pub fn SCIPgetReaders(scip: *mut SCIP) -> *mut *mut SCIP_READER;
}
extern "C" {
    #[doc = " returns the number of currently available readers"]
    pub fn SCIPgetNReaders(scip: *mut SCIP) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " creates a relaxation handler and includes it in SCIP\n\n  @note method has all relaxation handler callbacks as arguments and is thus changed every time a new\n        callback is added\n        in future releases; consider using SCIPincludeRelaxBasic() and setter functions\n        if you seek for a method which is less likely to change in future releases"]
    pub fn SCIPincludeRelax(
        scip: *mut SCIP,
        name: *const ::std::os::raw::c_char,
        desc: *const ::std::os::raw::c_char,
        priority: ::std::os::raw::c_int,
        freq: ::std::os::raw::c_int,
        relaxcopy: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, relax: *mut SCIP_RELAX) -> SCIP_RETCODE,
        >,
        relaxfree: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, relax: *mut SCIP_RELAX) -> SCIP_RETCODE,
        >,
        relaxinit: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, relax: *mut SCIP_RELAX) -> SCIP_RETCODE,
        >,
        relaxexit: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, relax: *mut SCIP_RELAX) -> SCIP_RETCODE,
        >,
        relaxinitsol: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, relax: *mut SCIP_RELAX) -> SCIP_RETCODE,
        >,
        relaxexitsol: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, relax: *mut SCIP_RELAX) -> SCIP_RETCODE,
        >,
        relaxexec: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                relax: *mut SCIP_RELAX,
                lowerbound: *mut f64,
                result: *mut SCIP_RESULT,
            ) -> SCIP_RETCODE,
        >,
        relaxdata: *mut SCIP_RELAXDATA,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " creates a relaxation handler and includes it in SCIP. All non fundamental\n  (or optional) callbacks as, e.g., init and exit callbacks, will be set to NULL.\n  Optional callbacks can be set via specific setter functions, see SCIPsetRelaxInit(), SCIPsetRelaxExit(),\n  SCIPsetRelaxCopy(), SCIPsetRelaxFree(), SCIPsetRelaxInitsol(), and SCIPsetRelaxExitsol()\n\n  @note if you want to set all callbacks with a single method call, consider using SCIPincludeRelax() instead"]
    pub fn SCIPincludeRelaxBasic(
        scip: *mut SCIP,
        relaxptr: *mut *mut SCIP_RELAX,
        name: *const ::std::os::raw::c_char,
        desc: *const ::std::os::raw::c_char,
        priority: ::std::os::raw::c_int,
        freq: ::std::os::raw::c_int,
        relaxexec: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                relax: *mut SCIP_RELAX,
                lowerbound: *mut f64,
                result: *mut SCIP_RESULT,
            ) -> SCIP_RETCODE,
        >,
        relaxdata: *mut SCIP_RELAXDATA,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " sets copy method of relaxation handler"]
    pub fn SCIPsetRelaxCopy(
        scip: *mut SCIP,
        relax: *mut SCIP_RELAX,
        relaxcopy: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, relax: *mut SCIP_RELAX) -> SCIP_RETCODE,
        >,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " sets destructor method of relaxation handler"]
    pub fn SCIPsetRelaxFree(
        scip: *mut SCIP,
        relax: *mut SCIP_RELAX,
        relaxfree: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, relax: *mut SCIP_RELAX) -> SCIP_RETCODE,
        >,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " sets initialization method of relaxation handler"]
    pub fn SCIPsetRelaxInit(
        scip: *mut SCIP,
        relax: *mut SCIP_RELAX,
        relaxinit: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, relax: *mut SCIP_RELAX) -> SCIP_RETCODE,
        >,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " sets deinitialization method of relaxation handler"]
    pub fn SCIPsetRelaxExit(
        scip: *mut SCIP,
        relax: *mut SCIP_RELAX,
        relaxexit: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, relax: *mut SCIP_RELAX) -> SCIP_RETCODE,
        >,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " sets solving process initialization method of relaxation handler"]
    pub fn SCIPsetRelaxInitsol(
        scip: *mut SCIP,
        relax: *mut SCIP_RELAX,
        relaxinitsol: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, relax: *mut SCIP_RELAX) -> SCIP_RETCODE,
        >,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " sets solving process deinitialization method of relaxation handler"]
    pub fn SCIPsetRelaxExitsol(
        scip: *mut SCIP,
        relax: *mut SCIP_RELAX,
        relaxexitsol: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, relax: *mut SCIP_RELAX) -> SCIP_RETCODE,
        >,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " returns the relaxation handler of the given name, or NULL if not existing"]
    pub fn SCIPfindRelax(scip: *mut SCIP, name: *const ::std::os::raw::c_char) -> *mut SCIP_RELAX;
}
extern "C" {
    #[doc = " returns the array of currently available relaxation handlers"]
    pub fn SCIPgetRelaxs(scip: *mut SCIP) -> *mut *mut SCIP_RELAX;
}
extern "C" {
    #[doc = " returns the number of currently available relaxation handlers"]
    pub fn SCIPgetNRelaxs(scip: *mut SCIP) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " sets the priority of a relaxation handler"]
    pub fn SCIPsetRelaxPriority(
        scip: *mut SCIP,
        relax: *mut SCIP_RELAX,
        priority: ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " return the ids of child nodes stored in the reoptimization tree\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPgetReoptChildIDs(
        scip: *mut SCIP,
        node: *mut SCIP_NODE,
        ids: *mut ::std::os::raw::c_uint,
        mem: ::std::os::raw::c_int,
        nids: *mut ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " return the ids of all leave nodes store in the reoptimization tree induced by the given node\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPgetReoptLeaveIDs(
        scip: *mut SCIP,
        node: *mut SCIP_NODE,
        ids: *mut ::std::os::raw::c_uint,
        mem: ::std::os::raw::c_int,
        nids: *mut ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " returns the number of nodes in the reoptimization tree induced by @p node; if @p node == NULL, the method\n  returns the number of nodes of the whole reoptimization tree."]
    pub fn SCIPgetNReoptnodes(scip: *mut SCIP, node: *mut SCIP_NODE) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " returns the number of leave nodes of the subtree induced by @p node; if @p node == NULL, the method\n  returns the number of leaf nodes of the whole reoptimization tree."]
    pub fn SCIPgetNReoptLeaves(scip: *mut SCIP, node: *mut SCIP_NODE) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " gets the node of the reoptimization tree corresponding to the unique @p id"]
    pub fn SCIPgetReoptnode(scip: *mut SCIP, id: ::std::os::raw::c_uint) -> *mut SCIP_REOPTNODE;
}
extern "C" {
    #[doc = " add a variable bound change to a given reoptnode\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPaddReoptnodeBndchg(
        scip: *mut SCIP,
        reoptnode: *mut SCIP_REOPTNODE,
        var: *mut SCIP_VAR,
        bound: f64,
        boundtype: SCIP_BOUNDTYPE,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " set the @p representation as the new search frontier\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_PRESOLVED"]
    pub fn SCIPsetReoptCompression(
        scip: *mut SCIP,
        representation: *mut *mut SCIP_REOPTNODE,
        nrepresentatives: ::std::os::raw::c_int,
        success: *mut ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " add stored constraint to a reoptimization node\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_PRESOLVED"]
    pub fn SCIPaddReoptnodeCons(
        scip: *mut SCIP,
        reoptnode: *mut SCIP_REOPTNODE,
        vars: *mut *mut SCIP_VAR,
        vals: *mut f64,
        boundtypes: *mut SCIP_BOUNDTYPE,
        lhs: f64,
        rhs: f64,
        nvars: ::std::os::raw::c_int,
        constype: REOPT_CONSTYPE,
        linear: ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " return the branching path stored in the reoptree at ID id"]
    pub fn SCIPgetReoptnodePath(
        scip: *mut SCIP,
        reoptnode: *mut SCIP_REOPTNODE,
        vars: *mut *mut SCIP_VAR,
        vals: *mut f64,
        boundtypes: *mut SCIP_BOUNDTYPE,
        mem: ::std::os::raw::c_int,
        nvars: *mut ::std::os::raw::c_int,
        nafterdualvars: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " initialize a set of empty reoptimization nodes\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_PRESOLVED"]
    pub fn SCIPinitRepresentation(
        scip: *mut SCIP,
        representatives: *mut *mut SCIP_REOPTNODE,
        nrepresentatives: ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " reset a set of initialized reoptimization nodes\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_PRESOLVED"]
    pub fn SCIPresetRepresentation(
        scip: *mut SCIP,
        representatives: *mut *mut SCIP_REOPTNODE,
        nrepresentatives: ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " free a set of initialized reoptimization nodes\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_PRESOLVED"]
    pub fn SCIPfreeRepresentation(
        scip: *mut SCIP,
        representatives: *mut *mut SCIP_REOPTNODE,
        nrepresentatives: ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " reactivate the given @p reoptnode and split them into several nodes if necessary\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPapplyReopt(
        scip: *mut SCIP,
        reoptnode: *mut SCIP_REOPTNODE,
        id: ::std::os::raw::c_uint,
        estimate: f64,
        childnodes: *mut *mut SCIP_NODE,
        ncreatedchilds: *mut ::std::os::raw::c_int,
        naddedconss: *mut ::std::os::raw::c_int,
        childnodessize: ::std::os::raw::c_int,
        success: *mut ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " remove the stored information about bound changes based in dual information\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPresetReoptnodeDualcons(scip: *mut SCIP, node: *mut SCIP_NODE) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " splits the root into several nodes and moves the child nodes of the root to one of the created nodes\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPsplitReoptRoot(
        scip: *mut SCIP,
        ncreatedchilds: *mut ::std::os::raw::c_int,
        naddedconss: *mut ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " returns if a node should be reoptimized"]
    pub fn SCIPreoptimizeNode(scip: *mut SCIP, node: *mut SCIP_NODE) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " deletes the given reoptimization node\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPdeleteReoptnode(
        scip: *mut SCIP,
        reoptnode: *mut *mut SCIP_REOPTNODE,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " return the similarity between two objective functions"]
    pub fn SCIPgetReoptSimilarity(
        scip: *mut SCIP,
        run1: ::std::os::raw::c_int,
        run2: ::std::os::raw::c_int,
    ) -> f64;
}
extern "C" {
    #[doc = " check the changes of the variable coefficient in the objective function"]
    pub fn SCIPgetVarCoefChg(
        scip: *mut SCIP,
        varidx: ::std::os::raw::c_int,
        negated: *mut ::std::os::raw::c_uint,
        entering: *mut ::std::os::raw::c_uint,
        leaving: *mut ::std::os::raw::c_uint,
    );
}
extern "C" {
    #[doc = " creates a separator and includes it in SCIP.\n\n  @note method has all separator callbacks as arguments and is thus changed every time a new\n        callback is added\n        in future releases; consider using SCIPincludeSepaBasic() and setter functions\n        if you seek for a method which is less likely to change in future releases"]
    pub fn SCIPincludeSepa(
        scip: *mut SCIP,
        name: *const ::std::os::raw::c_char,
        desc: *const ::std::os::raw::c_char,
        priority: ::std::os::raw::c_int,
        freq: ::std::os::raw::c_int,
        maxbounddist: f64,
        usessubscip: ::std::os::raw::c_uint,
        delay: ::std::os::raw::c_uint,
        sepacopy: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, sepa: *mut SCIP_SEPA) -> SCIP_RETCODE,
        >,
        sepafree: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, sepa: *mut SCIP_SEPA) -> SCIP_RETCODE,
        >,
        sepainit: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, sepa: *mut SCIP_SEPA) -> SCIP_RETCODE,
        >,
        sepaexit: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, sepa: *mut SCIP_SEPA) -> SCIP_RETCODE,
        >,
        sepainitsol: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, sepa: *mut SCIP_SEPA) -> SCIP_RETCODE,
        >,
        sepaexitsol: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, sepa: *mut SCIP_SEPA) -> SCIP_RETCODE,
        >,
        sepaexeclp: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                sepa: *mut SCIP_SEPA,
                result: *mut SCIP_RESULT,
                allowlocal: ::std::os::raw::c_uint,
                depth: ::std::os::raw::c_int,
            ) -> SCIP_RETCODE,
        >,
        sepaexecsol: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                sepa: *mut SCIP_SEPA,
                sol: *mut SCIP_SOL,
                result: *mut SCIP_RESULT,
                allowlocal: ::std::os::raw::c_uint,
                depth: ::std::os::raw::c_int,
            ) -> SCIP_RETCODE,
        >,
        sepadata: *mut SCIP_SEPADATA,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " creates a separator and includes it in SCIP with its most fundamental callbacks. All non-fundamental\n  (or optional) callbacks as, e.g., init and exit callbacks, will be set to NULL.\n  Optional callbacks can be set via specific setter functions, see SCIPsetSepaInit(), SCIPsetSepaFree(),\n  SCIPsetSepaInitsol(), SCIPsetSepaExitsol(), SCIPsetSepaCopy(), SCIPsetExit().\n\n  @note if you want to set all callbacks with a single method call, consider using SCIPincludeSepa() instead"]
    pub fn SCIPincludeSepaBasic(
        scip: *mut SCIP,
        sepa: *mut *mut SCIP_SEPA,
        name: *const ::std::os::raw::c_char,
        desc: *const ::std::os::raw::c_char,
        priority: ::std::os::raw::c_int,
        freq: ::std::os::raw::c_int,
        maxbounddist: f64,
        usessubscip: ::std::os::raw::c_uint,
        delay: ::std::os::raw::c_uint,
        sepaexeclp: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                sepa: *mut SCIP_SEPA,
                result: *mut SCIP_RESULT,
                allowlocal: ::std::os::raw::c_uint,
                depth: ::std::os::raw::c_int,
            ) -> SCIP_RETCODE,
        >,
        sepaexecsol: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                sepa: *mut SCIP_SEPA,
                sol: *mut SCIP_SOL,
                result: *mut SCIP_RESULT,
                allowlocal: ::std::os::raw::c_uint,
                depth: ::std::os::raw::c_int,
            ) -> SCIP_RETCODE,
        >,
        sepadata: *mut SCIP_SEPADATA,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " sets copy method of separator"]
    pub fn SCIPsetSepaCopy(
        scip: *mut SCIP,
        sepa: *mut SCIP_SEPA,
        sepacopy: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, sepa: *mut SCIP_SEPA) -> SCIP_RETCODE,
        >,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " sets destructor method of separator"]
    pub fn SCIPsetSepaFree(
        scip: *mut SCIP,
        sepa: *mut SCIP_SEPA,
        sepafree: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, sepa: *mut SCIP_SEPA) -> SCIP_RETCODE,
        >,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " sets initialization method of separator"]
    pub fn SCIPsetSepaInit(
        scip: *mut SCIP,
        sepa: *mut SCIP_SEPA,
        sepainit: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, sepa: *mut SCIP_SEPA) -> SCIP_RETCODE,
        >,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " sets deinitialization method of separator"]
    pub fn SCIPsetSepaExit(
        scip: *mut SCIP,
        sepa: *mut SCIP_SEPA,
        sepaexit: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, sepa: *mut SCIP_SEPA) -> SCIP_RETCODE,
        >,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " sets solving process initialization method of separator"]
    pub fn SCIPsetSepaInitsol(
        scip: *mut SCIP,
        sepa: *mut SCIP_SEPA,
        sepainitsol: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, sepa: *mut SCIP_SEPA) -> SCIP_RETCODE,
        >,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " sets solving process deinitialization method of separator"]
    pub fn SCIPsetSepaExitsol(
        scip: *mut SCIP,
        sepa: *mut SCIP_SEPA,
        sepaexitsol: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, sepa: *mut SCIP_SEPA) -> SCIP_RETCODE,
        >,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " returns the separator of the given name, or NULL if not existing"]
    pub fn SCIPfindSepa(scip: *mut SCIP, name: *const ::std::os::raw::c_char) -> *mut SCIP_SEPA;
}
extern "C" {
    #[doc = " returns the array of currently available separators"]
    pub fn SCIPgetSepas(scip: *mut SCIP) -> *mut *mut SCIP_SEPA;
}
extern "C" {
    #[doc = " returns the number of currently available separators"]
    pub fn SCIPgetNSepas(scip: *mut SCIP) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " sets the priority of a separator"]
    pub fn SCIPsetSepaPriority(
        scip: *mut SCIP,
        sepa: *mut SCIP_SEPA,
        priority: ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " declares separator to be a parent separator\n\n  Parent separators generate cuts of several types. To distinguish these cuts, they create child separators, which are\n  only needed to detect which cuts are applied."]
    pub fn SCIPsetSepaIsParentsepa(scip: *mut SCIP, sepa: *mut SCIP_SEPA);
}
extern "C" {
    #[doc = " sets the parent separator\n\n  Informs SCIP that the separator @p sepa depends on the parent separator @p parentsepa."]
    pub fn SCIPsetSepaParentsepa(scip: *mut SCIP, sepa: *mut SCIP_SEPA, parentsepa: *mut SCIP_SEPA);
}
extern "C" {
    #[doc = " gets value of minimal efficacy for a cut to enter the LP\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_SOLVING\n\n  @return value of \"separating/minefficacyroot\" if at root node, otherwise value of \"separating/minefficacy\""]
    pub fn SCIPgetSepaMinEfficacy(scip: *mut SCIP) -> f64;
}
extern "C" {
    #[doc = " creates a cut selector and includes it in SCIP\n\n  @note this method has all cut selector callbacks as arguments and is thus changed every time a new\n        callback is added in future releases; consider using SCIPincludeCutselBasic() and setter functions\n        if you seek for a method which is less likely to change in future releases"]
    pub fn SCIPincludeCutsel(
        scip: *mut SCIP,
        name: *const ::std::os::raw::c_char,
        desc: *const ::std::os::raw::c_char,
        priority: ::std::os::raw::c_int,
        cutselcopy: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, cutsel: *mut SCIP_CUTSEL) -> SCIP_RETCODE,
        >,
        cutselfree: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, cutsel: *mut SCIP_CUTSEL) -> SCIP_RETCODE,
        >,
        cutselinit: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, cutsel: *mut SCIP_CUTSEL) -> SCIP_RETCODE,
        >,
        cutselexit: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, cutsel: *mut SCIP_CUTSEL) -> SCIP_RETCODE,
        >,
        cutselinitsol: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, cutsel: *mut SCIP_CUTSEL) -> SCIP_RETCODE,
        >,
        cutselexitsol: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, cutsel: *mut SCIP_CUTSEL) -> SCIP_RETCODE,
        >,
        cutselselect: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                cutsel: *mut SCIP_CUTSEL,
                cuts: *mut *mut SCIP_ROW,
                ncuts: ::std::os::raw::c_int,
                forcedcuts: *mut *mut SCIP_ROW,
                nforcedcuts: ::std::os::raw::c_int,
                root: ::std::os::raw::c_uint,
                maxnselectedcuts: ::std::os::raw::c_int,
                nselectedcuts: *mut ::std::os::raw::c_int,
                result: *mut SCIP_RESULT,
            ) -> SCIP_RETCODE,
        >,
        cutseldata: *mut SCIP_CUTSELDATA,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " Creates a cut selector and includes it in SCIP with its most fundamental callbacks.\n\n  All non-fundamental (or optional) callbacks as, e.g., init and exit callbacks, will be set to NULL. Optional\n  callbacks can be set via specific setter functions, see SCIPsetCutselCopy(), SCIPsetCutselFree(),\n  SCIPsetCutselInit(), SCIPsetCutselExit(), SCIPsetCutselInitsol(), and SCIPsetCutselExitsol()\n\n  @note if you want to set all callbacks with a single method call, consider using SCIPincludeCutsel() instead"]
    pub fn SCIPincludeCutselBasic(
        scip: *mut SCIP,
        cutsel: *mut *mut SCIP_CUTSEL,
        name: *const ::std::os::raw::c_char,
        desc: *const ::std::os::raw::c_char,
        priority: ::std::os::raw::c_int,
        cutselselect: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                cutsel: *mut SCIP_CUTSEL,
                cuts: *mut *mut SCIP_ROW,
                ncuts: ::std::os::raw::c_int,
                forcedcuts: *mut *mut SCIP_ROW,
                nforcedcuts: ::std::os::raw::c_int,
                root: ::std::os::raw::c_uint,
                maxnselectedcuts: ::std::os::raw::c_int,
                nselectedcuts: *mut ::std::os::raw::c_int,
                result: *mut SCIP_RESULT,
            ) -> SCIP_RETCODE,
        >,
        cutseldata: *mut SCIP_CUTSELDATA,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " sets copy method of cut selector"]
    pub fn SCIPsetCutselCopy(
        scip: *mut SCIP,
        cutsel: *mut SCIP_CUTSEL,
        cutselcopy: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, cutsel: *mut SCIP_CUTSEL) -> SCIP_RETCODE,
        >,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " sets destructor method of cut selector"]
    pub fn SCIPsetCutselFree(
        scip: *mut SCIP,
        cutsel: *mut SCIP_CUTSEL,
        cutselfree: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, cutsel: *mut SCIP_CUTSEL) -> SCIP_RETCODE,
        >,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " sets initialization method of cut selector"]
    pub fn SCIPsetCutselInit(
        scip: *mut SCIP,
        cutsel: *mut SCIP_CUTSEL,
        cutselinit: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, cutsel: *mut SCIP_CUTSEL) -> SCIP_RETCODE,
        >,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " sets deinitialization method of cut selector"]
    pub fn SCIPsetCutselExit(
        scip: *mut SCIP,
        cutsel: *mut SCIP_CUTSEL,
        cutselexit: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, cutsel: *mut SCIP_CUTSEL) -> SCIP_RETCODE,
        >,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " sets solving process initialization method of cut selector"]
    pub fn SCIPsetCutselInitsol(
        scip: *mut SCIP,
        cutsel: *mut SCIP_CUTSEL,
        cutselinitsol: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, cutsel: *mut SCIP_CUTSEL) -> SCIP_RETCODE,
        >,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " sets solving process deinitialization method of cut selector"]
    pub fn SCIPsetCutselExitsol(
        scip: *mut SCIP,
        cutsel: *mut SCIP_CUTSEL,
        cutselexitsol: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, cutsel: *mut SCIP_CUTSEL) -> SCIP_RETCODE,
        >,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " returns the cut selector of the given name, or NULL if not existing"]
    pub fn SCIPfindCutsel(scip: *mut SCIP, name: *const ::std::os::raw::c_char)
        -> *mut SCIP_CUTSEL;
}
extern "C" {
    #[doc = " returns the array of currently available cut selectors"]
    pub fn SCIPgetCutsels(scip: *mut SCIP) -> *mut *mut SCIP_CUTSEL;
}
extern "C" {
    #[doc = " returns the number of currently available cut selectors"]
    pub fn SCIPgetNCutsels(scip: *mut SCIP) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " sets the priority of a cut selector"]
    pub fn SCIPsetCutselPriority(
        scip: *mut SCIP,
        cutsel: *mut SCIP_CUTSEL,
        priority: ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " creates a primal solution, initialized to zero\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMING\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPcreateSol(
        scip: *mut SCIP,
        sol: *mut *mut SCIP_SOL,
        heur: *mut SCIP_HEUR,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " creates a primal solution, initialized to the current LP solution\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPcreateLPSol(
        scip: *mut SCIP,
        sol: *mut *mut SCIP_SOL,
        heur: *mut SCIP_HEUR,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " creates a primal solution, initialized to the current NLP solution\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPcreateNLPSol(
        scip: *mut SCIP,
        sol: *mut *mut SCIP_SOL,
        heur: *mut SCIP_HEUR,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " creates a primal solution, initialized to the current relaxation solution\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPcreateRelaxSol(
        scip: *mut SCIP,
        sol: *mut *mut SCIP_SOL,
        heur: *mut SCIP_HEUR,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " creates a primal solution, initialized to the current pseudo solution\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPcreatePseudoSol(
        scip: *mut SCIP,
        sol: *mut *mut SCIP_SOL,
        heur: *mut SCIP_HEUR,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " creates a primal solution, initialized to the current LP or pseudo solution, depending on whether the LP was solved\n  at the current node\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPcreateCurrentSol(
        scip: *mut SCIP,
        sol: *mut *mut SCIP_SOL,
        heur: *mut SCIP_HEUR,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " creates a partial primal solution, initialized to unknown values\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM"]
    pub fn SCIPcreatePartialSol(
        scip: *mut SCIP,
        sol: *mut *mut SCIP_SOL,
        heur: *mut SCIP_HEUR,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " creates a primal solution, initialized to unknown values\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_TRANSFORMING\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPcreateUnknownSol(
        scip: *mut SCIP,
        sol: *mut *mut SCIP_SOL,
        heur: *mut SCIP_HEUR,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " creates a primal solution living in the original problem space, initialized to zero;\n  a solution in original space allows to set original variables to values that would be invalid in the\n  transformed problem due to preprocessing fixings or aggregations\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMING\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPcreateOrigSol(
        scip: *mut SCIP,
        sol: *mut *mut SCIP_SOL,
        heur: *mut SCIP_HEUR,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " creates a copy of a primal solution; note that a copy of a linked solution is also linked and needs to be unlinked\n  if it should stay unaffected from changes in the LP or pseudo solution\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMING\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPcreateSolCopy(
        scip: *mut SCIP,
        sol: *mut *mut SCIP_SOL,
        sourcesol: *mut SCIP_SOL,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " creates a copy of a solution in the original primal solution space\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMING\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED\n       - \\ref SCIP_STAGE_EXITSOLVE\n       - \\ref SCIP_STAGE_FREETRANS"]
    pub fn SCIPcreateSolCopyOrig(
        scip: *mut SCIP,
        sol: *mut *mut SCIP_SOL,
        sourcesol: *mut SCIP_SOL,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " creates a copy of a primal solution, thereby replacing infinite fixings of variables by finite values;\n  the copy is always defined in the original variable space;\n  success indicates whether the objective value of the solution was changed by removing infinite values\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMING\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED\n       - \\ref SCIP_STAGE_EXITSOLVE"]
    pub fn SCIPcreateFiniteSolCopy(
        scip: *mut SCIP,
        sol: *mut *mut SCIP_SOL,
        sourcesol: *mut SCIP_SOL,
        success: *mut ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " frees primal CIP solution\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMING\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED\n       - \\ref SCIP_STAGE_EXITSOLVE\n       - \\ref SCIP_STAGE_FREETRANS"]
    pub fn SCIPfreeSol(scip: *mut SCIP, sol: *mut *mut SCIP_SOL) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " links a primal solution to the current LP solution\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPlinkLPSol(scip: *mut SCIP, sol: *mut SCIP_SOL) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " links a primal solution to the current NLP solution\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPlinkNLPSol(scip: *mut SCIP, sol: *mut SCIP_SOL) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " links a primal solution to the current relaxation solution\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPlinkRelaxSol(scip: *mut SCIP, sol: *mut SCIP_SOL) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " links a primal solution to the current pseudo solution\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPlinkPseudoSol(scip: *mut SCIP, sol: *mut SCIP_SOL) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " links a primal solution to the current LP or pseudo solution\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPlinkCurrentSol(scip: *mut SCIP, sol: *mut SCIP_SOL) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " clears a primal solution\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMING\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED\n       - \\ref SCIP_STAGE_EXITSOLVE\n       - \\ref SCIP_STAGE_FREETRANS"]
    pub fn SCIPclearSol(scip: *mut SCIP, sol: *mut SCIP_SOL) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " stores solution values of variables in solution's own array\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_TRANSFORMING\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED\n       - \\ref SCIP_STAGE_EXITSOLVE\n       - \\ref SCIP_STAGE_FREETRANS"]
    pub fn SCIPunlinkSol(scip: *mut SCIP, sol: *mut SCIP_SOL) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " sets value of variable in primal CIP solution\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMING\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED\n       - \\ref SCIP_STAGE_EXITSOLVE\n       - \\ref SCIP_STAGE_FREETRANS"]
    pub fn SCIPsetSolVal(
        scip: *mut SCIP,
        sol: *mut SCIP_SOL,
        var: *mut SCIP_VAR,
        val: f64,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " sets values of multiple variables in primal CIP solution\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMING\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED\n       - \\ref SCIP_STAGE_EXITSOLVE\n       - \\ref SCIP_STAGE_FREETRANS"]
    pub fn SCIPsetSolVals(
        scip: *mut SCIP,
        sol: *mut SCIP_SOL,
        nvars: ::std::os::raw::c_int,
        vars: *mut *mut SCIP_VAR,
        vals: *mut f64,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " increases value of variable in primal CIP solution\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMING\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED\n       - \\ref SCIP_STAGE_EXITSOLVE\n       - \\ref SCIP_STAGE_FREETRANS"]
    pub fn SCIPincSolVal(
        scip: *mut SCIP,
        sol: *mut SCIP_SOL,
        var: *mut SCIP_VAR,
        incval: f64,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " returns value of variable in primal CIP solution, or in current LP/pseudo solution\n\n  @return value of variable in primal CIP solution, or in current LP/pseudo solution\n\n  @pre In case the solution pointer @p sol is @b NULL, that means it is asked for the LP or pseudo solution, this method\n       can only be called if @p scip is in the solving stage \\ref SCIP_STAGE_SOLVING. In any other case, this method\n       can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMING\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED\n       - \\ref SCIP_STAGE_EXITSOLVE\n       - \\ref SCIP_STAGE_FREETRANS"]
    pub fn SCIPgetSolVal(scip: *mut SCIP, sol: *mut SCIP_SOL, var: *mut SCIP_VAR) -> f64;
}
extern "C" {
    #[doc = " gets values of multiple variables in primal CIP solution\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMING\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED\n       - \\ref SCIP_STAGE_EXITSOLVE\n       - \\ref SCIP_STAGE_FREETRANS"]
    pub fn SCIPgetSolVals(
        scip: *mut SCIP,
        sol: *mut SCIP_SOL,
        nvars: ::std::os::raw::c_int,
        vars: *mut *mut SCIP_VAR,
        vals: *mut f64,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " returns objective value of primal CIP solution w.r.t. original problem, or current LP/pseudo objective value\n\n  @return objective value of primal CIP solution w.r.t. original problem, or current LP/pseudo objective value\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMING\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED\n       - \\ref SCIP_STAGE_EXITSOLVE\n       - \\ref SCIP_STAGE_FREETRANS"]
    pub fn SCIPgetSolOrigObj(scip: *mut SCIP, sol: *mut SCIP_SOL) -> f64;
}
extern "C" {
    #[doc = " returns transformed objective value of primal CIP solution, or transformed current LP/pseudo objective value\n\n  @return transformed objective value of primal CIP solution, or transformed current LP/pseudo objective value\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_TRANSFORMING\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED\n       - \\ref SCIP_STAGE_EXITSOLVE\n       - \\ref SCIP_STAGE_FREETRANS"]
    pub fn SCIPgetSolTransObj(scip: *mut SCIP, sol: *mut SCIP_SOL) -> f64;
}
extern "C" {
    #[doc = " recomputes the objective value of an original solution, e.g., when transferring solutions\n  from the solution pool (objective coefficients might have changed in the meantime)\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_SOLVING\n"]
    pub fn SCIPrecomputeSolObj(scip: *mut SCIP, sol: *mut SCIP_SOL) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " maps original space objective value into transformed objective value\n\n  @return transformed objective value\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_TRANSFORMING\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPtransformObj(scip: *mut SCIP, obj: f64) -> f64;
}
extern "C" {
    #[doc = " maps transformed objective value into original space\n\n  @return objective value into original space\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_TRANSFORMING\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPretransformObj(scip: *mut SCIP, obj: f64) -> f64;
}
extern "C" {
    #[doc = " gets clock time, when this solution was found\n\n  @return clock time, when this solution was found\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_TRANSFORMING\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED\n       - \\ref SCIP_STAGE_EXITSOLVE\n       - \\ref SCIP_STAGE_FREETRANS"]
    pub fn SCIPgetSolTime(scip: *mut SCIP, sol: *mut SCIP_SOL) -> f64;
}
extern "C" {
    #[doc = " gets branch and bound run number, where this solution was found\n\n  @return branch and bound run number, where this solution was found\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_TRANSFORMING\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED\n       - \\ref SCIP_STAGE_EXITSOLVE\n       - \\ref SCIP_STAGE_FREETRANS"]
    pub fn SCIPgetSolRunnum(scip: *mut SCIP, sol: *mut SCIP_SOL) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " gets node number of the specific branch and bound run, where this solution was found\n\n  @return node number of the specific branch and bound run, where this solution was found\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_TRANSFORMING\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED\n       - \\ref SCIP_STAGE_EXITSOLVE\n       - \\ref SCIP_STAGE_FREETRANS"]
    pub fn SCIPgetSolNodenum(scip: *mut SCIP, sol: *mut SCIP_SOL) -> ::std::os::raw::c_longlong;
}
extern "C" {
    #[doc = " gets heuristic, that found this solution (or NULL if it's from the tree)\n\n  @return heuristic, that found this solution (or NULL if it's from the tree)\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_TRANSFORMING\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED\n       - \\ref SCIP_STAGE_EXITSOLVE\n       - \\ref SCIP_STAGE_FREETRANS"]
    pub fn SCIPgetSolHeur(scip: *mut SCIP, sol: *mut SCIP_SOL) -> *mut SCIP_HEUR;
}
extern "C" {
    #[doc = " returns whether two given solutions are exactly equal\n\n  @return returns whether two given solutions are exactly equal\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMING\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED\n       - \\ref SCIP_STAGE_EXITSOLVE\n       - \\ref SCIP_STAGE_FREETRANS"]
    pub fn SCIPareSolsEqual(
        scip: *mut SCIP,
        sol1: *mut SCIP_SOL,
        sol2: *mut SCIP_SOL,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " adjusts solution values of implicit integer variables in handed solution. Solution objective value is not\n  deteriorated by this method.\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPadjustImplicitSolVals(
        scip: *mut SCIP,
        sol: *mut SCIP_SOL,
        uselprows: ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " outputs non-zero variables of solution in original problem space to the given file stream\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre In case the solution pointer @p sol is NULL (askinking for the current LP/pseudo solution), this method can be\n       called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED\n       - \\ref SCIP_STAGE_EXITSOLVE\n\n  @pre In case the solution pointer @p sol is @b not NULL, this method can be called if @p scip is in one of the\n       following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED\n       - \\ref SCIP_STAGE_EXITSOLVE"]
    pub fn SCIPprintSol(
        scip: *mut SCIP,
        sol: *mut SCIP_SOL,
        file: *mut FILE,
        printzeros: ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " outputs non-zero variables of solution in transformed problem space to file stream\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED\n       - \\ref SCIP_STAGE_EXITSOLVE"]
    pub fn SCIPprintTransSol(
        scip: *mut SCIP,
        sol: *mut SCIP_SOL,
        file: *mut FILE,
        printzeros: ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " outputs discrete variables of solution in original problem space to the given file stream\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED\n       - \\ref SCIP_STAGE_EXITSOLVE"]
    pub fn SCIPprintMIPStart(scip: *mut SCIP, sol: *mut SCIP_SOL, file: *mut FILE) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " returns dual solution value of a constraint"]
    pub fn SCIPgetDualSolVal(
        scip: *mut SCIP,
        cons: *mut SCIP_CONS,
        dualsolval: *mut f64,
        boundconstraint: *mut ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " check whether the dual solution is available\n\n @note This is used when calling \\ref SCIPprintDualSol()\n\n @return is dual solution available?\n\n @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPisDualSolAvailable(
        scip: *mut SCIP,
        printreason: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " outputs dual solution from LP solver to file stream\n\n  @note This only works if no presolving has been performed, which can be checked by calling method \\ref\n        SCIPhasPerformedPresolve().\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPprintDualSol(
        scip: *mut SCIP,
        file: *mut FILE,
        printzeros: ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " outputs non-zero variables of solution representing a ray in original problem space to file stream\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED\n       - \\ref SCIP_STAGE_EXITSOLVE"]
    pub fn SCIPprintRay(
        scip: *mut SCIP,
        sol: *mut SCIP_SOL,
        file: *mut FILE,
        printzeros: ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " gets number of feasible primal solutions stored in the solution storage in case the problem is transformed;\n  in case the problem stage is SCIP_STAGE_PROBLEM, the number of solution in the original solution candidate\n  storage is returned\n\n  @return number of feasible primal solutions stored in the solution storage in case the problem is transformed; or\n          number of solution in the original solution candidate storage if the problem stage is SCIP_STAGE_PROBLEM\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED\n       - \\ref SCIP_STAGE_EXITSOLVE"]
    pub fn SCIPgetNSols(scip: *mut SCIP) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " gets array of feasible primal solutions stored in the solution storage in case the problem is transformed; in case\n  if the problem stage is in SCIP_STAGE_PROBLEM, it returns the number array of solution candidate stored\n\n  @return array of feasible primal solutions\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED\n       - \\ref SCIP_STAGE_EXITSOLVE"]
    pub fn SCIPgetSols(scip: *mut SCIP) -> *mut *mut SCIP_SOL;
}
extern "C" {
    #[doc = " gets best feasible primal solution found so far if the problem is transformed; in case the problem is in\n  SCIP_STAGE_PROBLEM it returns the best solution candidate, or NULL if no solution has been found or the candidate\n  store is empty;\n\n  @return best feasible primal solution so far\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED\n       - \\ref SCIP_STAGE_EXITSOLVE"]
    pub fn SCIPgetBestSol(scip: *mut SCIP) -> *mut SCIP_SOL;
}
extern "C" {
    #[doc = " outputs best feasible primal solution found so far to file stream\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_INIT\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMING\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED\n       - \\ref SCIP_STAGE_EXITSOLVE\n       - \\ref SCIP_STAGE_FREE"]
    pub fn SCIPprintBestSol(
        scip: *mut SCIP,
        file: *mut FILE,
        printzeros: ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " outputs best feasible primal solution found so far in transformed variables to file stream\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_INIT\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMING\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED\n       - \\ref SCIP_STAGE_EXITSOLVE\n       - \\ref SCIP_STAGE_FREE"]
    pub fn SCIPprintBestTransSol(
        scip: *mut SCIP,
        file: *mut FILE,
        printzeros: ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " try to round given solution\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIProundSol(
        scip: *mut SCIP,
        sol: *mut SCIP_SOL,
        success: *mut ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " retransforms solution to original problem space\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMING\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED\n       - \\ref SCIP_STAGE_EXITSOLVE\n       - \\ref SCIP_STAGE_FREETRANS"]
    pub fn SCIPretransformSol(scip: *mut SCIP, sol: *mut SCIP_SOL) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " reads a given solution file\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPreadSol(scip: *mut SCIP, filename: *const ::std::os::raw::c_char) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " reads a given solution file and store the solution values in the given solution pointer\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPreadSolFile(
        scip: *mut SCIP,
        filename: *const ::std::os::raw::c_char,
        sol: *mut SCIP_SOL,
        xml: ::std::os::raw::c_uint,
        partial: *mut ::std::os::raw::c_uint,
        error: *mut ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " adds feasible primal solution to solution storage by copying it\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_FREETRANS\n\n  @note Do not call during propagation, use heur_trysol instead."]
    pub fn SCIPaddSol(
        scip: *mut SCIP,
        sol: *mut SCIP_SOL,
        stored: *mut ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " adds primal solution to solution storage, frees the solution afterwards\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_FREETRANS\n\n  @note Do not call during propagation, use heur_trysol instead."]
    pub fn SCIPaddSolFree(
        scip: *mut SCIP,
        sol: *mut *mut SCIP_SOL,
        stored: *mut ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " adds current LP/pseudo solution to solution storage\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPaddCurrentSol(
        scip: *mut SCIP,
        heur: *mut SCIP_HEUR,
        stored: *mut ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " checks solution for feasibility; if possible, adds it to storage by copying\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_SOLVING\n\n  @note Do not call during propagation, use heur_trysol instead."]
    pub fn SCIPtrySol(
        scip: *mut SCIP,
        sol: *mut SCIP_SOL,
        printreason: ::std::os::raw::c_uint,
        completely: ::std::os::raw::c_uint,
        checkbounds: ::std::os::raw::c_uint,
        checkintegrality: ::std::os::raw::c_uint,
        checklprows: ::std::os::raw::c_uint,
        stored: *mut ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " checks primal solution; if feasible, adds it to storage; solution is freed afterwards\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_SOLVING\n\n  @note Do not call during propagation, use heur_trysol instead."]
    pub fn SCIPtrySolFree(
        scip: *mut SCIP,
        sol: *mut *mut SCIP_SOL,
        printreason: ::std::os::raw::c_uint,
        completely: ::std::os::raw::c_uint,
        checkbounds: ::std::os::raw::c_uint,
        checkintegrality: ::std::os::raw::c_uint,
        checklprows: ::std::os::raw::c_uint,
        stored: *mut ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " checks current LP/pseudo solution for feasibility; if possible, adds it to storage\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPtryCurrentSol(
        scip: *mut SCIP,
        heur: *mut SCIP_HEUR,
        printreason: ::std::os::raw::c_uint,
        completely: ::std::os::raw::c_uint,
        checkintegrality: ::std::os::raw::c_uint,
        checklprows: ::std::os::raw::c_uint,
        stored: *mut ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " returns all partial solutions\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPgetPartialSols(scip: *mut SCIP) -> *mut *mut SCIP_SOL;
}
extern "C" {
    #[doc = " returns number of partial solutions\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPgetNPartialSols(scip: *mut SCIP) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " checks solution for feasibility without adding it to the solution store\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPcheckSol(
        scip: *mut SCIP,
        sol: *mut SCIP_SOL,
        printreason: ::std::os::raw::c_uint,
        completely: ::std::os::raw::c_uint,
        checkbounds: ::std::os::raw::c_uint,
        checkintegrality: ::std::os::raw::c_uint,
        checklprows: ::std::os::raw::c_uint,
        feasible: *mut ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " checks solution for feasibility in original problem without adding it to the solution store;\n  this method is used to double check a solution in order to validate the presolving process\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPcheckSolOrig(
        scip: *mut SCIP,
        sol: *mut SCIP_SOL,
        feasible: *mut ::std::os::raw::c_uint,
        printreason: ::std::os::raw::c_uint,
        completely: ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " update integrality violation of a solution"]
    pub fn SCIPupdateSolIntegralityViolation(scip: *mut SCIP, sol: *mut SCIP_SOL, absviol: f64);
}
extern "C" {
    #[doc = " update bound violation of a solution"]
    pub fn SCIPupdateSolBoundViolation(
        scip: *mut SCIP,
        sol: *mut SCIP_SOL,
        absviol: f64,
        relviol: f64,
    );
}
extern "C" {
    #[doc = " update LP row violation of a solution"]
    pub fn SCIPupdateSolLPRowViolation(
        scip: *mut SCIP,
        sol: *mut SCIP_SOL,
        absviol: f64,
        relviol: f64,
    );
}
extern "C" {
    #[doc = " update constraint violation of a solution"]
    pub fn SCIPupdateSolConsViolation(
        scip: *mut SCIP,
        sol: *mut SCIP_SOL,
        absviol: f64,
        relviol: f64,
    );
}
extern "C" {
    #[doc = " update LP row and constraint violations of a solution"]
    pub fn SCIPupdateSolLPConsViolation(
        scip: *mut SCIP,
        sol: *mut SCIP_SOL,
        absviol: f64,
        relviol: f64,
    );
}
extern "C" {
    #[doc = " allow violation updates"]
    pub fn SCIPactivateSolViolationUpdates(scip: *mut SCIP);
}
extern "C" {
    #[doc = " disallow violation updates"]
    pub fn SCIPdeactivateSolViolationUpdates(scip: *mut SCIP);
}
extern "C" {
    #[doc = " return whether a primal ray is stored that proves unboundedness of the LP relaxation\n\n  @return return whether a primal ray is stored that proves unboundedness of the LP relaxation\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPhasPrimalRay(scip: *mut SCIP) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " gets value of given variable in primal ray causing unboundedness of the LP relaxation;\n  should only be called if such a ray is stored (check with SCIPhasPrimalRay())\n\n  @return value of given variable in primal ray causing unboundedness of the LP relaxation\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPgetPrimalRayVal(scip: *mut SCIP, var: *mut SCIP_VAR) -> f64;
}
extern "C" {
    #[doc = " updates the primal ray thats proves unboundedness\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED\n\n  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPupdatePrimalRay(scip: *mut SCIP, primalray: *mut SCIP_SOL) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " initializes solving data structures and transforms problem\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED\n       - \\ref SCIP_STAGE_EXITSOLVE\n       - \\ref SCIP_STAGE_FREETRANS\n       - \\ref SCIP_STAGE_FREE\n\n  @post When calling this method in the \\ref SCIP_STAGE_PROBLEM stage, the \\SCIP stage is changed to \\ref\n        SCIP_STAGE_TRANSFORMED; otherwise, the stage is not changed\n\n  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPtransformProb(scip: *mut SCIP) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " transforms and presolves problem\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_SOLVED\n\n  @post After calling this method \\SCIP reaches one of the following stages:\n        - \\ref SCIP_STAGE_PRESOLVING if the presolving process was interrupted\n        - \\ref SCIP_STAGE_PRESOLVED if the presolving process was finished and did not solve the problem\n        - \\ref SCIP_STAGE_SOLVED if the problem was solved during presolving\n\n  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPpresolve(scip: *mut SCIP) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " transforms, presolves, and solves problem\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED\n\n  @post After calling this method \\SCIP reaches one of the following stages depending on if and when the solution\n        process was interrupted:\n\n        - \\ref SCIP_STAGE_PRESOLVING if the solution process was interrupted during presolving\n        - \\ref SCIP_STAGE_SOLVING if the solution process was interrupted during the tree search\n        - \\ref SCIP_STAGE_SOLVED if the solving process was not interrupted\n\n  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPsolve(scip: *mut SCIP) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " transforms, presolves, and solves problem using additional solvers which emphasize on\n  finding solutions.\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED\n\n  @post After calling this method \\SCIP reaches one of the following stages depending on if and when the solution\n        process was interrupted:\n        - \\ref SCIP_STAGE_PRESOLVING if the solution process was interrupted during presolving\n        - \\ref SCIP_STAGE_SOLVING if the solution process was interrupted during the tree search\n        - \\ref SCIP_STAGE_SOLVED if the solving process was not interrupted\n\n  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages.\n\n  @deprecated Please use SCIPsolveConcurrent() instead."]
    pub fn SCIPsolveParallel(scip: *mut SCIP) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " transforms, presolves, and solves problem using additional solvers which emphasize on\n  finding solutions.\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED\n\n  @post After calling this method \\SCIP reaches one of the following stages depending on if and when the solution\n        process was interrupted:\n        - \\ref SCIP_STAGE_PRESOLVING if the solution process was interrupted during presolving\n        - \\ref SCIP_STAGE_SOLVING if the solution process was interrupted during the tree search\n        - \\ref SCIP_STAGE_SOLVED if the solving process was not interrupted\n\n  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPsolveConcurrent(scip: *mut SCIP) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " frees branch and bound tree and all solution process data; statistics, presolving data and transformed problem is\n  preserved\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_INIT\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED\n\n  @post If this method is called in \\SCIP stage \\ref SCIP_STAGE_INIT or \\ref SCIP_STAGE_PROBLEM, the stage of\n        \\SCIP is not changed; otherwise, the \\SCIP stage is changed to \\ref SCIP_STAGE_TRANSFORMED\n\n  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPfreeSolve(scip: *mut SCIP, restart: ::std::os::raw::c_uint) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " frees all solution process data including presolving and transformed problem, only original problem is kept\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_INIT\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED\n\n  @post After calling this method \\SCIP reaches one of the following stages:\n        - \\ref SCIP_STAGE_INIT if the method was called from \\SCIP stage \\ref SCIP_STAGE_INIT\n        - \\ref SCIP_STAGE_PROBLEM if the method was called from any other of the allowed stages\n\n  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPfreeTransform(scip: *mut SCIP) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " informs \\SCIP that the solving process should be interrupted as soon as possible (e.g., after the current node has\n   been solved)\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMING\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED\n       - \\ref SCIP_STAGE_EXITSOLVE\n       - \\ref SCIP_STAGE_FREETRANS\n\n  @note the \\SCIP stage does not get changed"]
    pub fn SCIPinterruptSolve(scip: *mut SCIP) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " indicates whether \\SCIP has been informed that the solving process should be interrupted as soon as possible\n\n  This function returns whether SCIPinterruptSolve() has been called, which is different from SCIPinterrupted(),\n  which returns whether a SIGINT signal has been received by the SCIP signal handler.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMING\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED\n       - \\ref SCIP_STAGE_EXITSOLVE\n       - \\ref SCIP_STAGE_FREETRANS\n\n  @note the \\SCIP stage does not get changed"]
    pub fn SCIPisSolveInterrupted(scip: *mut SCIP) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " informs SCIP that the solving process should be restarted as soon as possible (e.g., after the current node has\n  been solved)\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_SOLVING\n\n  @note the \\SCIP stage does not get changed"]
    pub fn SCIPrestartSolve(scip: *mut SCIP) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " returns whether we are in the restarting phase\n\n  @return TRUE, if we are in the restarting phase; FALSE, otherwise\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED\n       - \\ref SCIP_STAGE_EXITSOLVE\n       - \\ref SCIP_STAGE_FREETRANS"]
    pub fn SCIPisInRestart(scip: *mut SCIP) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " frees branch and bound tree and all solution process data; statistics, presolving data and transformed problem is\n  preserved\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_INIT\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED\n\n  @post If this method is called in \\SCIP stage \\ref SCIP_STAGE_INIT or \\ref SCIP_STAGE_PROBLEM, the stage of\n        \\SCIP is not changed; otherwise, the \\SCIP stage is changed to \\ref SCIP_STAGE_PRESOLVED.\n\n  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPfreeReoptSolve(scip: *mut SCIP) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " include specific heuristics and branching rules for reoptimization\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM"]
    pub fn SCIPenableReoptimization(
        scip: *mut SCIP,
        enable: ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " returns whether reoptimization is enabled or not"]
    pub fn SCIPisReoptEnabled(scip: *mut SCIP) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " returns the stored solutions corresponding to a given run"]
    pub fn SCIPgetReoptSolsRun(
        scip: *mut SCIP,
        run: ::std::os::raw::c_int,
        sols: *mut *mut SCIP_SOL,
        allocmem: ::std::os::raw::c_int,
        nsols: *mut ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " mark all stored solutions as not updated"]
    pub fn SCIPresetReoptSolMarks(scip: *mut SCIP);
}
extern "C" {
    #[doc = " check if the reoptimization process should be restarted\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPcheckReoptRestart(
        scip: *mut SCIP,
        node: *mut SCIP_NODE,
        restart: *mut ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " save bound change based on dual information in the reoptimization tree\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPaddReoptDualBndchg(
        scip: *mut SCIP,
        node: *mut SCIP_NODE,
        var: *mut SCIP_VAR,
        newbound: f64,
        oldbound: f64,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " returns the optimal solution of the last iteration or NULL of none exists"]
    pub fn SCIPgetReoptLastOptSol(scip: *mut SCIP) -> *mut SCIP_SOL;
}
extern "C" {
    #[doc = " returns the objective coefficent of a given variable in a previous iteration\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPgetReoptOldObjCoef(
        scip: *mut SCIP,
        var: *mut SCIP_VAR,
        run: ::std::os::raw::c_int,
        objcoef: *mut f64,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " gets number of branch and bound runs performed, including the current run\n\n  @return the number of branch and bound runs performed, including the current run\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMING\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED\n       - \\ref SCIP_STAGE_EXITSOLVE\n       - \\ref SCIP_STAGE_FREETRANS"]
    pub fn SCIPgetNRuns(scip: *mut SCIP) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " gets number of reoptimization runs performed, including the current run\n\n  @return the number of reoptimization runs performed, including the current run\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMING\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED\n       - \\ref SCIP_STAGE_EXITSOLVE\n       - \\ref SCIP_STAGE_FREETRANS"]
    pub fn SCIPgetNReoptRuns(scip: *mut SCIP) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " add given number to the number of processed nodes in current run and in all runs, including the focus node\n\n  @return the number of processed nodes in current run, including the focus node\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMING\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED\n       - \\ref SCIP_STAGE_EXITSOLVE\n       - \\ref SCIP_STAGE_FREETRANS"]
    pub fn SCIPaddNNodes(scip: *mut SCIP, nnodes: ::std::os::raw::c_longlong);
}
extern "C" {
    #[doc = " gets number of processed nodes in current run, including the focus node\n\n  @return the number of processed nodes in current run, including the focus node\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMING\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED\n       - \\ref SCIP_STAGE_EXITSOLVE\n       - \\ref SCIP_STAGE_FREETRANS"]
    pub fn SCIPgetNNodes(scip: *mut SCIP) -> ::std::os::raw::c_longlong;
}
extern "C" {
    #[doc = " gets total number of processed nodes in all runs, including the focus node\n\n  @return the total number of processed nodes in all runs, including the focus node\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMING\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED\n       - \\ref SCIP_STAGE_EXITSOLVE\n       - \\ref SCIP_STAGE_FREETRANS"]
    pub fn SCIPgetNTotalNodes(scip: *mut SCIP) -> ::std::os::raw::c_longlong;
}
extern "C" {
    #[doc = " gets number of leaf nodes processed with feasible relaxation solution\n\n @return number of leaf nodes processed with feasible relaxation solution\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMING\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED\n       - \\ref SCIP_STAGE_EXITSOLVE\n       - \\ref SCIP_STAGE_FREETRANS"]
    pub fn SCIPgetNFeasibleLeaves(scip: *mut SCIP) -> ::std::os::raw::c_longlong;
}
extern "C" {
    #[doc = " gets number of infeasible leaf nodes processed\n\n @return number of infeasible leaf nodes processed\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMING\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED\n       - \\ref SCIP_STAGE_EXITSOLVE\n       - \\ref SCIP_STAGE_FREETRANS"]
    pub fn SCIPgetNInfeasibleLeaves(scip: *mut SCIP) -> ::std::os::raw::c_longlong;
}
extern "C" {
    #[doc = " gets number of processed leaf nodes that hit LP objective limit\n\n @return number of processed leaf nodes that hit LP objective limit\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMING\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED\n       - \\ref SCIP_STAGE_EXITSOLVE\n       - \\ref SCIP_STAGE_FREETRANS"]
    pub fn SCIPgetNObjlimLeaves(scip: *mut SCIP) -> ::std::os::raw::c_longlong;
}
extern "C" {
    #[doc = " gets number of global bound changes\n\n @return number of global bound changes\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMING\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED\n       - \\ref SCIP_STAGE_EXITSOLVE\n       - \\ref SCIP_STAGE_FREETRANS"]
    pub fn SCIPgetNRootboundChgs(scip: *mut SCIP) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " gets number of global bound changes applied in the current run\n\n @return number of global bound changes\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMING\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED\n       - \\ref SCIP_STAGE_EXITSOLVE\n       - \\ref SCIP_STAGE_FREETRANS"]
    pub fn SCIPgetNRootboundChgsRun(scip: *mut SCIP) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " gets number of times a selected node was from a cut off subtree\n\n  @return number of times a selected node was from a cut off subtree\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMING\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED\n       - \\ref SCIP_STAGE_EXITSOLVE\n       - \\ref SCIP_STAGE_FREETRANS"]
    pub fn SCIPgetNDelayedCutoffs(scip: *mut SCIP) -> ::std::os::raw::c_longlong;
}
extern "C" {
    #[doc = " gets total number of LPs solved so far\n\n  @return the total number of LPs solved so far\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMING\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED\n       - \\ref SCIP_STAGE_EXITSOLVE\n       - \\ref SCIP_STAGE_FREETRANS"]
    pub fn SCIPgetNLPs(scip: *mut SCIP) -> ::std::os::raw::c_longlong;
}
extern "C" {
    #[doc = " gets total number of iterations used so far in primal and dual simplex and barrier algorithm\n\n  @return the total number of iterations used so far in primal and dual simplex and barrier algorithm\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPgetNLPIterations(scip: *mut SCIP) -> ::std::os::raw::c_longlong;
}
extern "C" {
    #[doc = " gets number of active non-zeros in the current transformed problem\n\n  @return the number of active non-zeros in the current transformed problem\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMING\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED\n       - \\ref SCIP_STAGE_EXITSOLVE"]
    pub fn SCIPgetNNZs(scip: *mut SCIP) -> ::std::os::raw::c_longlong;
}
extern "C" {
    #[doc = " gets total number of iterations used so far in primal and dual simplex and barrier algorithm for the root node\n\n  @return the total number of iterations used so far in primal and dual simplex and barrier algorithm for the root node\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPgetNRootLPIterations(scip: *mut SCIP) -> ::std::os::raw::c_longlong;
}
extern "C" {
    #[doc = " gets total number of iterations used in primal and dual simplex and barrier algorithm for the first LP at the root\n  node\n\n  @return the total number of iterations used in primal and dual simplex and barrier algorithm for the first root LP\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPgetNRootFirstLPIterations(scip: *mut SCIP) -> ::std::os::raw::c_longlong;
}
extern "C" {
    #[doc = " gets total number of primal LPs solved so far\n\n  @return the total number of primal LPs solved so far\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPgetNPrimalLPs(scip: *mut SCIP) -> ::std::os::raw::c_longlong;
}
extern "C" {
    #[doc = " gets total number of iterations used so far in primal simplex\n\n  @return total number of iterations used so far in primal simplex\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPgetNPrimalLPIterations(scip: *mut SCIP) -> ::std::os::raw::c_longlong;
}
extern "C" {
    #[doc = " gets total number of dual LPs solved so far\n\n  @return the total number of dual LPs solved so far\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPgetNDualLPs(scip: *mut SCIP) -> ::std::os::raw::c_longlong;
}
extern "C" {
    #[doc = " gets total number of iterations used so far in dual simplex\n\n  @return the total number of iterations used so far in dual simplex\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPgetNDualLPIterations(scip: *mut SCIP) -> ::std::os::raw::c_longlong;
}
extern "C" {
    #[doc = " gets total number of barrier LPs solved so far\n\n  @return the total number of barrier LPs solved so far\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPgetNBarrierLPs(scip: *mut SCIP) -> ::std::os::raw::c_longlong;
}
extern "C" {
    #[doc = " gets total number of iterations used so far in barrier algorithm\n\n  @return the total number of iterations used so far in barrier algorithm\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPgetNBarrierLPIterations(scip: *mut SCIP) -> ::std::os::raw::c_longlong;
}
extern "C" {
    #[doc = " gets total number of LPs solved so far that were resolved from an advanced start basis\n\n  @return the total number of LPs solved so far that were resolved from an advanced start basis\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPgetNResolveLPs(scip: *mut SCIP) -> ::std::os::raw::c_longlong;
}
extern "C" {
    #[doc = " gets total number of simplex iterations used so far in primal and dual simplex calls where an advanced start basis\n  was available\n\n  @return the total number of simplex iterations used so far in primal and dual simplex calls where an advanced start\n          basis was available\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPgetNResolveLPIterations(scip: *mut SCIP) -> ::std::os::raw::c_longlong;
}
extern "C" {
    #[doc = " gets total number of primal LPs solved so far that were resolved from an advanced start basis\n\n  @return the total number of primal LPs solved so far that were resolved from an advanced start basis\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPgetNPrimalResolveLPs(scip: *mut SCIP) -> ::std::os::raw::c_longlong;
}
extern "C" {
    #[doc = " gets total number of simplex iterations used so far in primal simplex calls where an advanced start basis\n  was available\n\n  @return the total number of simplex iterations used so far in primal simplex calls where an advanced start\n          basis was available\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPgetNPrimalResolveLPIterations(scip: *mut SCIP) -> ::std::os::raw::c_longlong;
}
extern "C" {
    #[doc = " gets total number of dual LPs solved so far that were resolved from an advanced start basis\n\n  @return the total number of dual LPs solved so far that were resolved from an advanced start basis\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPgetNDualResolveLPs(scip: *mut SCIP) -> ::std::os::raw::c_longlong;
}
extern "C" {
    #[doc = " gets total number of simplex iterations used so far in dual simplex calls where an advanced start basis\n  was available\n\n  @return the total number of simplex iterations used so far in dual simplex calls where an advanced start\n          basis was available\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPgetNDualResolveLPIterations(scip: *mut SCIP) -> ::std::os::raw::c_longlong;
}
extern "C" {
    #[doc = " gets total number of LPs solved so far for node relaxations\n\n  @return the total number of LPs solved so far for node relaxations\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPgetNNodeLPs(scip: *mut SCIP) -> ::std::os::raw::c_longlong;
}
extern "C" {
    #[doc = " gets total number of LPs solved in 0 iterations for node relaxations\n\n  @return the total number of LPs solved with 0 iteratins for node relaxations\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPgetNNodeZeroIterationLPs(scip: *mut SCIP) -> ::std::os::raw::c_longlong;
}
extern "C" {
    #[doc = " gets total number of simplex iterations used so far for node relaxations\n\n  @return the total number of simplex iterations used so far for node relaxations\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPgetNNodeLPIterations(scip: *mut SCIP) -> ::std::os::raw::c_longlong;
}
extern "C" {
    #[doc = " gets total number of LPs solved so far for initial LP in node relaxations\n\n  @return the total number of LPs solved so far for initial LP in node relaxations\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPgetNNodeInitLPs(scip: *mut SCIP) -> ::std::os::raw::c_longlong;
}
extern "C" {
    #[doc = " gets total number of simplex iterations used so far for initial LP in node relaxations\n\n  @return the total number of simplex iterations used so far for initial LP in node relaxations\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPgetNNodeInitLPIterations(scip: *mut SCIP) -> ::std::os::raw::c_longlong;
}
extern "C" {
    #[doc = " gets total number of LPs solved so far during diving and probing\n\n  @return total number of LPs solved so far during diving and probing\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPgetNDivingLPs(scip: *mut SCIP) -> ::std::os::raw::c_longlong;
}
extern "C" {
    #[doc = " gets total number of simplex iterations used so far during diving and probing\n\n  @return the total number of simplex iterations used so far during diving and probing\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPgetNDivingLPIterations(scip: *mut SCIP) -> ::std::os::raw::c_longlong;
}
extern "C" {
    #[doc = " gets total number of times, strong branching was called (each call represents solving two LPs)\n\n  @return the total number of times, strong branching was called (each call represents solving two LPs)\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPgetNStrongbranchs(scip: *mut SCIP) -> ::std::os::raw::c_longlong;
}
extern "C" {
    #[doc = " gets total number of simplex iterations used so far in strong branching\n\n  @return the total number of simplex iterations used so far in strong branching\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPgetNStrongbranchLPIterations(scip: *mut SCIP) -> ::std::os::raw::c_longlong;
}
extern "C" {
    #[doc = " gets total number of times, strong branching was called at the root node (each call represents solving two LPs)\n\n  @return the total number of times, strong branching was called at the root node (each call represents solving two LPs)\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPgetNRootStrongbranchs(scip: *mut SCIP) -> ::std::os::raw::c_longlong;
}
extern "C" {
    #[doc = " gets total number of simplex iterations used so far in strong branching at the root node\n\n  @return the total number of simplex iterations used so far in strong branching at the root node\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPgetNRootStrongbranchLPIterations(scip: *mut SCIP) -> ::std::os::raw::c_longlong;
}
extern "C" {
    #[doc = " gets number of pricing rounds performed so far at the current node\n\n  @return the number of pricing rounds performed so far at the current node\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPgetNPriceRounds(scip: *mut SCIP) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " get current number of variables in the pricing store\n\n  @return the current number of variables in the pricing store\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPgetNPricevars(scip: *mut SCIP) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " get total number of pricing variables found so far\n\n  @return the total number of pricing variables found so far\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPgetNPricevarsFound(scip: *mut SCIP) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " get total number of pricing variables applied to the LPs\n\n  @return the total number of pricing variables applied to the LPs\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPgetNPricevarsApplied(scip: *mut SCIP) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " gets number of separation rounds performed so far at the current node\n\n  @return the number of separation rounds performed so far at the current node\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPgetNSepaRounds(scip: *mut SCIP) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " get total number of cuts found so far; this includes global cuts from the cut pool as often as they are separated\n\n  @return the total number of cuts found so far\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPgetNCutsFound(scip: *mut SCIP) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " get number of cuts found so far in current separation round\n\n  @return the number of cuts found so far in current separation round\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPgetNCutsFoundRound(scip: *mut SCIP) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " get total number of cuts applied to the LPs\n\n  @return the total number of cuts applied to the LPs\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPgetNCutsApplied(scip: *mut SCIP) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " get total number of constraints found in conflict analysis (conflict and reconvergence constraints)\n\n  @return the total number of constraints found in conflict analysis (conflict and reconvergence constraints)\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED\n       - \\ref SCIP_STAGE_EXITSOLVE"]
    pub fn SCIPgetNConflictConssFound(scip: *mut SCIP) -> ::std::os::raw::c_longlong;
}
extern "C" {
    #[doc = " get number of conflict constraints found so far at the current node\n\n  @return the number of conflict constraints found so far at the current node\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED\n       - \\ref SCIP_STAGE_EXITSOLVE"]
    pub fn SCIPgetNConflictConssFoundNode(scip: *mut SCIP) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " get total number of conflict constraints added to the problem\n\n  @return the total number of conflict constraints added to the problem\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED\n       - \\ref SCIP_STAGE_EXITSOLVE"]
    pub fn SCIPgetNConflictConssApplied(scip: *mut SCIP) -> ::std::os::raw::c_longlong;
}
extern "C" {
    #[doc = " get total number of dual proof constraints added to the problem\n\n  @return the total number of dual proof constraints added to the problem\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED\n       - \\ref SCIP_STAGE_EXITSOLVE"]
    pub fn SCIPgetNConflictDualproofsApplied(scip: *mut SCIP) -> ::std::os::raw::c_longlong;
}
extern "C" {
    #[doc = " gets maximal depth of all processed nodes in current branch and bound run (excluding probing nodes)\n\n  @return the maximal depth of all processed nodes in current branch and bound run (excluding probing nodes)\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED\n       - \\ref SCIP_STAGE_EXITSOLVE"]
    pub fn SCIPgetMaxDepth(scip: *mut SCIP) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " gets maximal depth of all processed nodes over all branch and bound runs\n\n  @return the maximal depth of all processed nodes over all branch and bound runs\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED\n       - \\ref SCIP_STAGE_EXITSOLVE"]
    pub fn SCIPgetMaxTotalDepth(scip: *mut SCIP) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " gets total number of backtracks, i.e. number of times, the new node was selected from the leaves queue\n\n  @return the total number of backtracks, i.e. number of times, the new node was selected from the leaves queue\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED\n       - \\ref SCIP_STAGE_EXITSOLVE"]
    pub fn SCIPgetNBacktracks(scip: *mut SCIP) -> ::std::os::raw::c_longlong;
}
extern "C" {
    #[doc = " gets total number of active constraints at the current node\n\n  @return the total number of active constraints at the current node\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPgetNActiveConss(scip: *mut SCIP) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " gets total number of enabled constraints at the current node\n\n  @return the total number of enabled constraints at the current node\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPgetNEnabledConss(scip: *mut SCIP) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " gets average dual bound of all unprocessed nodes for original problem"]
    pub fn SCIPgetAvgDualbound(scip: *mut SCIP) -> f64;
}
extern "C" {
    #[doc = " gets average lower (dual) bound of all unprocessed nodes in transformed problem\n\n  @return the average lower (dual) bound of all unprocessed nodes in transformed problem\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPgetAvgLowerbound(scip: *mut SCIP) -> f64;
}
extern "C" {
    #[doc = " gets global dual bound\n\n  @return the global dual bound\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPgetDualbound(scip: *mut SCIP) -> f64;
}
extern "C" {
    #[doc = " gets global lower (dual) bound in transformed problem\n\n  @return the global lower (dual) bound in transformed problem\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPgetLowerbound(scip: *mut SCIP) -> f64;
}
extern "C" {
    #[doc = " gets dual bound of the root node for the original problem\n\n  @return the dual bound of the root node for the original problem\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPgetDualboundRoot(scip: *mut SCIP) -> f64;
}
extern "C" {
    #[doc = " gets lower (dual) bound in transformed problem of the root node\n\n  @return the lower (dual) bound in transformed problem of the root node\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPgetLowerboundRoot(scip: *mut SCIP) -> f64;
}
extern "C" {
    #[doc = " gets dual bound for the original problem obtained by the first LP solve at the root node\n\n  @return the dual bound for the original problem of the first LP solve at the root node\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPgetFirstLPDualboundRoot(scip: *mut SCIP) -> f64;
}
extern "C" {
    #[doc = " gets lower (dual) bound in transformed problem obtained by the first LP solve at the root node\n\n  @return the lower (dual) bound in transformed problem obtained by first LP solve at the root node\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPgetFirstLPLowerboundRoot(scip: *mut SCIP) -> f64;
}
extern "C" {
    #[doc = " the primal bound of the very first solution"]
    pub fn SCIPgetFirstPrimalBound(scip: *mut SCIP) -> f64;
}
extern "C" {
    #[doc = " gets global primal bound (objective value of best solution or user objective limit) for the original problem\n\n  @return the global primal bound (objective value of best solution or user objective limit) for the original problem\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED\n       - \\ref SCIP_STAGE_EXITSOLVE"]
    pub fn SCIPgetPrimalbound(scip: *mut SCIP) -> f64;
}
extern "C" {
    #[doc = " gets global upper (primal) bound in transformed problem (objective value of best solution or user objective limit)\n\n  @return the global upper (primal) bound in transformed problem (objective value of best solution or user objective limit)\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED\n       - \\ref SCIP_STAGE_EXITSOLVE"]
    pub fn SCIPgetUpperbound(scip: *mut SCIP) -> f64;
}
extern "C" {
    #[doc = " gets global cutoff bound in transformed problem: a sub problem with lower bound larger than the cutoff\n  cannot contain a better feasible solution; usually, this bound is equal to the upper bound, but if the\n  objective value is always integral, the cutoff bound is (nearly) one less than the upper bound;\n  additionally, due to objective function domain propagation, the cutoff bound can be further reduced\n\n  @return global cutoff bound in transformed problem\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED\n       - \\ref SCIP_STAGE_EXITSOLVE"]
    pub fn SCIPgetCutoffbound(scip: *mut SCIP) -> f64;
}
extern "C" {
    #[doc = " updates the cutoff bound\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @note using this method in the solving stage can lead to an erroneous SCIP solving status; in particular,\n        if a solution not respecting the cutoff bound was found before installing a cutoff bound which\n        renders the remaining problem infeasible, this solution may be reported as optimal\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n\n  @note the given cutoff bound has to better or equal to known one (SCIPgetCutoffbound())"]
    pub fn SCIPupdateCutoffbound(scip: *mut SCIP, cutoffbound: f64) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " returns whether the current primal bound is justified with a feasible primal solution; if not, the primal bound\n  was set from the user as objective limit\n\n  @return TRUE if the current primal bound is justified with a feasible primal solution, otherwise FALSE\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED\n       - \\ref SCIP_STAGE_EXITSOLVE"]
    pub fn SCIPisPrimalboundSol(scip: *mut SCIP) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " gets current gap |(primalbound - dualbound)/min(|primalbound|,|dualbound|)| if both bounds have same sign,\n  or infinity, if they have opposite sign\n\n  @return the current gap |(primalbound - dualbound)/min(|primalbound|,|dualbound|)| if both bounds have same sign,\n  or infinity, if they have opposite sign\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPgetGap(scip: *mut SCIP) -> f64;
}
extern "C" {
    #[doc = " gets current gap |(upperbound - lowerbound)/min(|upperbound|,|lowerbound|)| in transformed problem if both bounds\n  have same sign, or infinity, if they have opposite sign\n\n  @return current gap |(upperbound - lowerbound)/min(|upperbound|,|lowerbound|)| in transformed problem if both bounds\n  have same sign, or infinity, if they have opposite sign\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPgetTransGap(scip: *mut SCIP) -> f64;
}
extern "C" {
    #[doc = " gets number of feasible primal solutions found so far\n\n  @return the number of feasible primal solutions found so far\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED\n       - \\ref SCIP_STAGE_EXITSOLVE"]
    pub fn SCIPgetNSolsFound(scip: *mut SCIP) -> ::std::os::raw::c_longlong;
}
extern "C" {
    #[doc = " gets number of feasible primal solutions respecting the objective limit found so far\n\n  @return the number of feasible primal solutions respecting the objective limit found so far\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_INIT\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMING\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED\n       - \\ref SCIP_STAGE_EXITSOLVE"]
    pub fn SCIPgetNLimSolsFound(scip: *mut SCIP) -> ::std::os::raw::c_longlong;
}
extern "C" {
    #[doc = " gets number of feasible primal solutions found so far, that improved the primal bound at the time they were found\n\n  @return the number of feasible primal solutions found so far, that improved the primal bound at the time they were found\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED\n       - \\ref SCIP_STAGE_EXITSOLVE"]
    pub fn SCIPgetNBestSolsFound(scip: *mut SCIP) -> ::std::os::raw::c_longlong;
}
extern "C" {
    #[doc = " gets the average pseudo cost value for the given direction over all variables\n\n  @return the average pseudo cost value for the given direction over all variables\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPgetAvgPseudocost(scip: *mut SCIP, solvaldelta: f64) -> f64;
}
extern "C" {
    #[doc = " gets the average pseudo cost value for the given direction over all variables,\n  only using the pseudo cost information of the current run\n\n  @return the average pseudo cost value for the given direction over all variables,\n  only using the pseudo cost information of the current run\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPgetAvgPseudocostCurrentRun(scip: *mut SCIP, solvaldelta: f64) -> f64;
}
extern "C" {
    #[doc = " gets the average number of pseudo cost updates for the given direction over all variables\n\n  @return the average number of pseudo cost updates for the given direction over all variables\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPgetAvgPseudocostCount(scip: *mut SCIP, dir: SCIP_BRANCHDIR) -> f64;
}
extern "C" {
    #[doc = " gets the average number of pseudo cost updates for the given direction over all variables,\n  only using the pseudo cost information of the current run\n\n  @return the average number of pseudo cost updates for the given direction over all variables,\n  only using the pseudo cost information of the current run\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPgetAvgPseudocostCountCurrentRun(scip: *mut SCIP, dir: SCIP_BRANCHDIR) -> f64;
}
extern "C" {
    #[doc = " gets the number of pseudo cost updates for the given direction over all variables\n\n  @return the number of pseudo cost updates for the given direction over all variables\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPgetPseudocostCount(
        scip: *mut SCIP,
        dir: SCIP_BRANCHDIR,
        onlycurrentrun: ::std::os::raw::c_uint,
    ) -> f64;
}
extern "C" {
    #[doc = " gets the average pseudo cost score value over all variables, assuming a fractionality of 0.5\n\n  @return the average pseudo cost score value over all variables, assuming a fractionality of 0.5\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPgetAvgPseudocostScore(scip: *mut SCIP) -> f64;
}
extern "C" {
    #[doc = " returns the variance of pseudo costs for all variables in the requested direction\n\n  @return the variance of pseudo costs for all variables in the requested direction\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPgetPseudocostVariance(
        scip: *mut SCIP,
        branchdir: SCIP_BRANCHDIR,
        onlycurrentrun: ::std::os::raw::c_uint,
    ) -> f64;
}
extern "C" {
    #[doc = " gets the average pseudo cost score value over all variables, assuming a fractionality of 0.5,\n  only using the pseudo cost information of the current run\n\n  @return the average pseudo cost score value over all variables, assuming a fractionality of 0.5,\n  only using the pseudo cost information of the current run\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPgetAvgPseudocostScoreCurrentRun(scip: *mut SCIP) -> f64;
}
extern "C" {
    #[doc = " gets the average conflict score value over all variables"]
    pub fn SCIPgetAvgConflictScore(scip: *mut SCIP) -> f64;
}
extern "C" {
    #[doc = " gets the average conflict score value over all variables, only using the conflict information of the current run\n\n  @return the average conflict score value over all variables, only using the conflict information of the current run\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPgetAvgConflictScoreCurrentRun(scip: *mut SCIP) -> f64;
}
extern "C" {
    #[doc = " gets the average inference score value over all variables\n\n  @return the average inference score value over all variables\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPgetAvgConflictlengthScore(scip: *mut SCIP) -> f64;
}
extern "C" {
    #[doc = " gets the average conflictlength score value over all variables, only using the conflictlength information of the\n  current run\n\n  @return the average conflictlength score value over all variables, only using the conflictlength information of the\n          current run\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPgetAvgConflictlengthScoreCurrentRun(scip: *mut SCIP) -> f64;
}
extern "C" {
    #[doc = " returns the average number of inferences found after branching in given direction over all variables\n\n  @return the average number of inferences found after branching in given direction over all variables\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPgetAvgInferences(scip: *mut SCIP, dir: SCIP_BRANCHDIR) -> f64;
}
extern "C" {
    #[doc = " returns the average number of inferences found after branching in given direction over all variables,\n  only using the inference information of the current run\n\n  @return the average number of inferences found after branching in given direction over all variables,\n          only using the inference information of the current run\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPgetAvgInferencesCurrentRun(scip: *mut SCIP, dir: SCIP_BRANCHDIR) -> f64;
}
extern "C" {
    #[doc = " gets the average inference score value over all variables\n\n  @return the average inference score value over all variables\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPgetAvgInferenceScore(scip: *mut SCIP) -> f64;
}
extern "C" {
    #[doc = " gets the average inference score value over all variables, only using the inference information of the\n  current run\n\n  @return the average inference score value over all variables, only using the inference information of the\n          current run\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPgetAvgInferenceScoreCurrentRun(scip: *mut SCIP) -> f64;
}
extern "C" {
    #[doc = " returns the average number of cutoffs found after branching in given direction over all variables\n\n  @return the average number of cutoffs found after branching in given direction over all variables\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPgetAvgCutoffs(scip: *mut SCIP, dir: SCIP_BRANCHDIR) -> f64;
}
extern "C" {
    #[doc = " returns the average number of cutoffs found after branching in given direction over all variables,\n  only using the cutoff information of the current run\n\n  @return the average number of cutoffs found after branching in given direction over all variables,\n          only using the cutoff information of the current run\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPgetAvgCutoffsCurrentRun(scip: *mut SCIP, dir: SCIP_BRANCHDIR) -> f64;
}
extern "C" {
    #[doc = " gets the average cutoff score value over all variables\n\n  @return the average cutoff score value over all variables\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPgetAvgCutoffScore(scip: *mut SCIP) -> f64;
}
extern "C" {
    #[doc = " gets the average cutoff score value over all variables, only using the cutoff information of the current run\n\n  @return the average cutoff score value over all variables, only using the cutoff information of the current run\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPgetAvgCutoffScoreCurrentRun(scip: *mut SCIP) -> f64;
}
extern "C" {
    #[doc = " returns the average normalized efficacy of a GMI cut over all variables\n\n  @return the average normalized efficacy of a GMI cut over all variables\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPgetAvgGMIeff(scip: *mut SCIP) -> f64;
}
extern "C" {
    #[doc = " returns the average normalized efficacy of a GMI cut over all variables\n\n  @return increases the average normalized efficacy of a GMI cut over all variables\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPincAvgGMIeff(scip: *mut SCIP, gmieff: f64);
}
extern "C" {
    #[doc = " gets deterministic time number of LPs solved so far\n\n  @return the total number of LPs solved so far\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPgetDeterministicTime(scip: *mut SCIP) -> f64;
}
extern "C" {
    #[doc = " outputs original problem to file stream\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMING\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED\n       - \\ref SCIP_STAGE_EXITSOLVE\n       - \\ref SCIP_STAGE_FREETRANS"]
    pub fn SCIPprintOrigProblem(
        scip: *mut SCIP,
        file: *mut FILE,
        extension: *const ::std::os::raw::c_char,
        genericnames: ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " outputs transformed problem of the current node to file stream\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED\n       - \\ref SCIP_STAGE_EXITSOLVE\n       - \\ref SCIP_STAGE_FREETRANS"]
    pub fn SCIPprintTransProblem(
        scip: *mut SCIP,
        file: *mut FILE,
        extension: *const ::std::os::raw::c_char,
        genericnames: ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " outputs status statistics\n\n  @note If limits have been changed between the solution and the call to this function, the status is recomputed and\n        thus may to correspond to the original status.\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_INIT\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPprintStatusStatistics(scip: *mut SCIP, file: *mut FILE);
}
extern "C" {
    #[doc = " outputs timing statistics\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPprintTimingStatistics(scip: *mut SCIP, file: *mut FILE);
}
extern "C" {
    #[doc = " outputs statistics for original problem\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPprintOrigProblemStatistics(scip: *mut SCIP, file: *mut FILE);
}
extern "C" {
    #[doc = " outputs statistics for transformed problem\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPprintTransProblemStatistics(scip: *mut SCIP, file: *mut FILE);
}
extern "C" {
    #[doc = " outputs presolver statistics\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPprintPresolverStatistics(scip: *mut SCIP, file: *mut FILE);
}
extern "C" {
    #[doc = " outputs constraint statistics\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPprintConstraintStatistics(scip: *mut SCIP, file: *mut FILE);
}
extern "C" {
    #[doc = " outputs constraint timing statistics\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPprintConstraintTimingStatistics(scip: *mut SCIP, file: *mut FILE);
}
extern "C" {
    #[doc = " outputs propagator statistics\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPprintPropagatorStatistics(scip: *mut SCIP, file: *mut FILE);
}
extern "C" {
    #[doc = " outputs conflict statistics\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPprintConflictStatistics(scip: *mut SCIP, file: *mut FILE);
}
extern "C" {
    #[doc = " outputs separator statistics\n\n  Columns:\n    - RootCalls: The number of calls that happened at the root.\n    - FoundCuts: The total number of cuts generated by the separators.\n      Note: Cutpool-FoundCuts \\f$= \\sum_{i=1}^nsepas ( Foundcuts_i - DirectAdd_i )\\f$.\n    - ViaPoolAdd: The total number of cuts added to the sepastore from the cutpool.\n    - DirectAdd: The total number of cuts added directly to the sepastore from the separator.\n    - Applied: The sum of all cuts from the separator that were applied to the LP.\n    - ViaPoolApp: The number of cuts that entered the sepastore from the cutpool that were applied to the LP.\n    - DirectApp: The number of cuts that entered the sepastore directly and were applied to the LP.\n\n  The number of cuts ViaPoolAdd + Directly should be equal to the number of cuts Filtered + Forced + Selected in the\n  cutselector statistics.\n\n  @note The following edge case may lead to over or undercounting of statistics: When SCIPapplyCutsProbing() is\n        called, cuts are counted for the cut selection statistics, but not for the separator statistics.  This\n        happens, e.g., in the default plugin prop_obbt.c.\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPprintSeparatorStatistics(scip: *mut SCIP, file: *mut FILE);
}
extern "C" {
    #[doc = " outputs cutselector statistics\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPprintCutselectorStatistics(scip: *mut SCIP, file: *mut FILE);
}
extern "C" {
    #[doc = " outputs pricer statistics\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPprintPricerStatistics(scip: *mut SCIP, file: *mut FILE);
}
extern "C" {
    #[doc = " outputs branching rule statistics\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPprintBranchruleStatistics(scip: *mut SCIP, file: *mut FILE);
}
extern "C" {
    #[doc = " outputs heuristics statistics\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPprintHeuristicStatistics(scip: *mut SCIP, file: *mut FILE);
}
extern "C" {
    #[doc = " outputs compression statistics\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPprintCompressionStatistics(scip: *mut SCIP, file: *mut FILE);
}
extern "C" {
    #[doc = " outputs LP statistics\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPprintLPStatistics(scip: *mut SCIP, file: *mut FILE);
}
extern "C" {
    #[doc = " outputs NLP statistics\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPprintNLPStatistics(scip: *mut SCIP, file: *mut FILE);
}
extern "C" {
    #[doc = " outputs relaxator statistics\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPprintRelaxatorStatistics(scip: *mut SCIP, file: *mut FILE);
}
extern "C" {
    #[doc = " outputs tree statistics\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPprintTreeStatistics(scip: *mut SCIP, file: *mut FILE);
}
extern "C" {
    #[doc = " outputs root statistics\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPprintRootStatistics(scip: *mut SCIP, file: *mut FILE);
}
extern "C" {
    #[doc = " outputs solution statistics\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPprintSolutionStatistics(scip: *mut SCIP, file: *mut FILE);
}
extern "C" {
    #[doc = " outputs concurrent solver statistics\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPprintConcsolverStatistics(scip: *mut SCIP, file: *mut FILE);
}
extern "C" {
    #[doc = " outputs Benders' decomposition statistics\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPprintBendersStatistics(scip: *mut SCIP, file: *mut FILE);
}
extern "C" {
    #[doc = " outputs expression handler statistics\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPprintExpressionHandlerStatistics(scip: *mut SCIP, file: *mut FILE);
}
extern "C" {
    #[doc = " outputs NLPI statistics\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPprintNLPIStatistics(scip: *mut SCIP, file: *mut FILE);
}
extern "C" {
    #[doc = " outputs solving statistics\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @note If limits have been changed between the solution and the call to this function, the status is recomputed and\n        thus may to correspond to the original status.\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_INIT\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPprintStatistics(scip: *mut SCIP, file: *mut FILE) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " outputs reoptimization statistics\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_INIT\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPprintReoptStatistics(scip: *mut SCIP, file: *mut FILE) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " outputs history statistics about branchings on variables\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_INIT\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPprintBranchingStatistics(scip: *mut SCIP, file: *mut FILE) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " outputs node information display line\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPprintDisplayLine(
        scip: *mut SCIP,
        file: *mut FILE,
        verblevel: SCIP_VERBLEVEL,
        endline: ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " gets total number of implications between variables that are stored in the implication graph\n\n  @return the total number of implications between variables that are stored in the implication graph\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPgetNImplications(scip: *mut SCIP) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " stores conflict graph of binary variables' implications into a file, which can be used as input for the DOT tool\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED\n       - \\ref SCIP_STAGE_EXITSOLVE\n\n  @deprecated because binary implications are now stored as cliques"]
    pub fn SCIPwriteImplicationConflictGraph(
        scip: *mut SCIP,
        filename: *const ::std::os::raw::c_char,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " update statistical information when a new solution was found"]
    pub fn SCIPstoreSolutionGap(scip: *mut SCIP);
}
extern "C" {
    #[doc = " recomputes and returns the primal dual gap stored in the stats"]
    pub fn SCIPgetPrimalDualIntegral(scip: *mut SCIP) -> f64;
}
extern "C" {
    #[doc = " creates a statistics table and includes it in SCIP"]
    pub fn SCIPincludeTable(
        scip: *mut SCIP,
        name: *const ::std::os::raw::c_char,
        desc: *const ::std::os::raw::c_char,
        active: ::std::os::raw::c_uint,
        tablecopy: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, table: *mut SCIP_TABLE) -> SCIP_RETCODE,
        >,
        tablefree: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, table: *mut SCIP_TABLE) -> SCIP_RETCODE,
        >,
        tableinit: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, table: *mut SCIP_TABLE) -> SCIP_RETCODE,
        >,
        tableexit: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, table: *mut SCIP_TABLE) -> SCIP_RETCODE,
        >,
        tableinitsol: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, table: *mut SCIP_TABLE) -> SCIP_RETCODE,
        >,
        tableexitsol: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, table: *mut SCIP_TABLE) -> SCIP_RETCODE,
        >,
        tableoutput: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                table: *mut SCIP_TABLE,
                file: *mut FILE,
            ) -> SCIP_RETCODE,
        >,
        tabledata: *mut SCIP_TABLEDATA,
        position: ::std::os::raw::c_int,
        earlieststage: SCIP_STAGE,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " returns the statistics table of the given name, or NULL if not existing"]
    pub fn SCIPfindTable(scip: *mut SCIP, name: *const ::std::os::raw::c_char) -> *mut SCIP_TABLE;
}
extern "C" {
    #[doc = " returns the array of currently available statistics tables"]
    pub fn SCIPgetTables(scip: *mut SCIP) -> *mut *mut SCIP_TABLE;
}
extern "C" {
    #[doc = " returns the number of currently available statistics tables"]
    pub fn SCIPgetNTables(scip: *mut SCIP) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " gets current time of day in seconds (standard time zone)\n\n  @return the current time of day in seconds (standard time zone)."]
    pub fn SCIPgetTimeOfDay(scip: *mut SCIP) -> f64;
}
extern "C" {
    #[doc = " creates a clock using the default clock type\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    pub fn SCIPcreateClock(scip: *mut SCIP, clck: *mut *mut SCIP_CLOCK) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " creates a clock counting the CPU user seconds\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    pub fn SCIPcreateCPUClock(scip: *mut SCIP, clck: *mut *mut SCIP_CLOCK) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " creates a clock counting the wall clock seconds\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    pub fn SCIPcreateWallClock(scip: *mut SCIP, clck: *mut *mut SCIP_CLOCK) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " frees a clock\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    pub fn SCIPfreeClock(scip: *mut SCIP, clck: *mut *mut SCIP_CLOCK) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " resets the time measurement of a clock to zero and completely stops the clock\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    pub fn SCIPresetClock(scip: *mut SCIP, clck: *mut SCIP_CLOCK) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " starts the time measurement of a clock\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    pub fn SCIPstartClock(scip: *mut SCIP, clck: *mut SCIP_CLOCK) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " stops the time measurement of a clock\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    pub fn SCIPstopClock(scip: *mut SCIP, clck: *mut SCIP_CLOCK) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " enables or disables \\p clck"]
    pub fn SCIPsetClockEnabled(clck: *mut SCIP_CLOCK, enable: ::std::os::raw::c_uint);
}
extern "C" {
    #[doc = " enables or disables all statistic clocks of SCIP concerning plugin statistics,\n  LP execution time, strong branching time, etc.\n\n  Method reads the value of the parameter timing/statistictiming. In order to disable statistic timing,\n  set the parameter to FALSE.\n\n  @note: The (pre-)solving time clocks which are relevant for the output during (pre-)solving\n         are not affected by this method\n\n  @see: For completely disabling all timing of SCIP, consider setting the parameter timing/enabled to FALSE\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMING\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED\n       - \\ref SCIP_STAGE_EXITSOLVE\n       - \\ref SCIP_STAGE_FREETRANS\n\n  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPenableOrDisableStatisticTiming(scip: *mut SCIP) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " starts the current solving time\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMING\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED\n       - \\ref SCIP_STAGE_EXITSOLVE\n       - \\ref SCIP_STAGE_FREETRANS\n\n  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPstartSolvingTime(scip: *mut SCIP) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " stops the current solving time in seconds\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMING\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED\n       - \\ref SCIP_STAGE_EXITSOLVE\n       - \\ref SCIP_STAGE_FREETRANS\n\n  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPstopSolvingTime(scip: *mut SCIP) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " gets the measured time of a clock in seconds\n\n  @return the measured time of a clock in seconds."]
    pub fn SCIPgetClockTime(scip: *mut SCIP, clck: *mut SCIP_CLOCK) -> f64;
}
extern "C" {
    #[doc = " sets the measured time of a clock to the given value in seconds\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    pub fn SCIPsetClockTime(scip: *mut SCIP, clck: *mut SCIP_CLOCK, sec: f64) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " gets the current total SCIP time in seconds, possibly accumulated over several problems.\n\n  @return the current total SCIP time in seconds, ie. the total time since the SCIP instance has been created"]
    pub fn SCIPgetTotalTime(scip: *mut SCIP) -> f64;
}
extern "C" {
    #[doc = " gets the current solving time in seconds\n\n  @return the current solving time in seconds.\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMING\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED\n\n  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPgetSolvingTime(scip: *mut SCIP) -> f64;
}
extern "C" {
    #[doc = " gets the current reading time in seconds\n\n  @return the current reading time in seconds.\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMING\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED\n\n  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPgetReadingTime(scip: *mut SCIP) -> f64;
}
extern "C" {
    #[doc = " gets the current presolving time in seconds\n\n  @return the current presolving time in seconds.\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED\n\n  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPgetPresolvingTime(scip: *mut SCIP) -> f64;
}
extern "C" {
    #[doc = " gets the time need to solve the first LP in the root node\n\n  @return the solving time for the first LP in the root node in seconds.\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_TRANSFORMING\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED\n\n  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPgetFirstLPTime(scip: *mut SCIP) -> f64;
}
extern "C" {
    #[doc = " gets focus node in the tree\n\n  if we are in probing/diving mode this method returns the node in the tree where the probing/diving mode was started.\n\n  @return the current node of the search tree\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPgetFocusNode(scip: *mut SCIP) -> *mut SCIP_NODE;
}
extern "C" {
    #[doc = " gets current node in the tree\n\n  @return the current node of the search tree\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPgetCurrentNode(scip: *mut SCIP) -> *mut SCIP_NODE;
}
extern "C" {
    #[doc = " gets depth of current node, or -1 if no current node exists; in probing, the current node is the last probing node,\n  such that the depth includes the probing path\n\n  @return the depth of current node, or -1 if no current node exists; in probing, the current node is the last probing node,\n  such that the depth includes the probing path\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED\n       - \\ref SCIP_STAGE_EXITSOLVE"]
    pub fn SCIPgetDepth(scip: *mut SCIP) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " gets depth of the focus node, or -1 if no focus node exists; the focus node is the currently processed node in the\n  branching tree, excluding the nodes of the probing path\n\n  @return the depth of the focus node, or -1 if no focus node exists; the focus node is the currently processed node in the\n  branching tree, excluding the nodes of the probing path\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED\n       - \\ref SCIP_STAGE_EXITSOLVE"]
    pub fn SCIPgetFocusDepth(scip: *mut SCIP) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " gets current plunging depth (successive times, a child was selected as next node)\n\n  @return the current plunging depth (successive times, a child was selected as next node)\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPgetPlungeDepth(scip: *mut SCIP) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " gets the root node of the tree\n\n  @return the root node of the search tree\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPgetRootNode(scip: *mut SCIP) -> *mut SCIP_NODE;
}
extern "C" {
    #[doc = " gets the effective root depth, i.e., the depth of the deepest node which is part of all paths from the root node\n  to the unprocessed nodes.\n\n  @return effective root depth\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPgetEffectiveRootDepth(scip: *mut SCIP) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " returns whether the current node is already solved and only propagated again\n\n  @return TRUE is returned if \\SCIP performance repropagation, otherwise FALSE.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPinRepropagation(scip: *mut SCIP) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " gets children of focus node along with the number of children\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPgetChildren(
        scip: *mut SCIP,
        children: *mut *mut *mut SCIP_NODE,
        nchildren: *mut ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " gets number of children of focus node\n\n  @return number of children of the focus node\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPgetNChildren(scip: *mut SCIP) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " gets siblings of focus node along with the number of siblings\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPgetSiblings(
        scip: *mut SCIP,
        siblings: *mut *mut *mut SCIP_NODE,
        nsiblings: *mut ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " gets number of siblings of focus node\n\n  @return the number of siblings of focus node\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPgetNSiblings(scip: *mut SCIP) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " gets leaves of the tree along with the number of leaves\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPgetLeaves(
        scip: *mut SCIP,
        leaves: *mut *mut *mut SCIP_NODE,
        nleaves: *mut ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " gets number of leaves in the tree\n\n  @return the number of leaves in the tree\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPgetNLeaves(scip: *mut SCIP) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " gets number of nodes left in the tree (children + siblings + leaves)\n\n  @return the number of nodes left in the tree (children + siblings + leaves)\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPgetNNodesLeft(scip: *mut SCIP) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " gets the best child of the focus node w.r.t. the node selection priority assigned by the branching rule\n\n  @return the best child of the focus node w.r.t. the node selection priority assigned by the branching rule\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPgetPrioChild(scip: *mut SCIP) -> *mut SCIP_NODE;
}
extern "C" {
    #[doc = " gets the best sibling of the focus node w.r.t. the node selection priority assigned by the branching rule\n\n  @return the best sibling of the focus node w.r.t. the node selection priority assigned by the branching rule\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPgetPrioSibling(scip: *mut SCIP) -> *mut SCIP_NODE;
}
extern "C" {
    #[doc = " gets the best child of the focus node w.r.t. the node selection strategy\n\n  @return the best child of the focus node w.r.t. the node selection strategy\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPgetBestChild(scip: *mut SCIP) -> *mut SCIP_NODE;
}
extern "C" {
    #[doc = " gets the best sibling of the focus node w.r.t. the node selection strategy\n\n  @return the best sibling of the focus node w.r.t. the node selection strategy\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPgetBestSibling(scip: *mut SCIP) -> *mut SCIP_NODE;
}
extern "C" {
    #[doc = " gets the best leaf from the node queue w.r.t. the node selection strategy\n\n  @return the best leaf from the node queue w.r.t. the node selection strategy\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPgetBestLeaf(scip: *mut SCIP) -> *mut SCIP_NODE;
}
extern "C" {
    #[doc = " gets the best node from the tree (child, sibling, or leaf) w.r.t. the node selection strategy\n\n  @return the best node from the tree (child, sibling, or leaf) w.r.t. the node selection strategy\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPgetBestNode(scip: *mut SCIP) -> *mut SCIP_NODE;
}
extern "C" {
    #[doc = " gets the node with smallest lower bound from the tree (child, sibling, or leaf)\n\n  @return the node with smallest lower bound from the tree (child, sibling, or leaf)\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPgetBestboundNode(scip: *mut SCIP) -> *mut SCIP_NODE;
}
extern "C" {
    #[doc = " access to all data of open nodes (leaves, children, and siblings)\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPgetOpenNodesData(
        scip: *mut SCIP,
        leaves: *mut *mut *mut SCIP_NODE,
        children: *mut *mut *mut SCIP_NODE,
        siblings: *mut *mut *mut SCIP_NODE,
        nleaves: *mut ::std::os::raw::c_int,
        nchildren: *mut ::std::os::raw::c_int,
        nsiblings: *mut ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " marks node and whole sub tree to be cut off from branch and bound tree\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPcutoffNode(scip: *mut SCIP, node: *mut SCIP_NODE) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " removes all nodes from branch and bound tree that were marked to be cut off via SCIPcutoffNode()\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_SOLVING\n\n  @note In diving mode, the removal of nodes is delayed until diving ends."]
    pub fn SCIPpruneTree(scip: *mut SCIP) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " marks the given node to be propagated again the next time a node of its subtree is processed\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPrepropagateNode(scip: *mut SCIP, node: *mut SCIP_NODE) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " returns depth of first node in active path that is marked being cutoff\n\n  @return depth of first node in active path that is marked being cutoff\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPgetCutoffdepth(scip: *mut SCIP) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " returns depth of first node in active path that has to be propagated again\n\n  @return depth of first node in active path that has to be propagated again\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPgetRepropdepth(scip: *mut SCIP) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " prints all branching decisions on variables from the root to the given node\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPprintNodeRootPath(
        scip: *mut SCIP,
        node: *mut SCIP_NODE,
        file: *mut FILE,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " sets whether the LP should be solved at the focus node\n\n  @note In order to have an effect, this method needs to be called after a node is focused but before the LP is\n        solved.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPsetFocusnodeLP(scip: *mut SCIP, solvelp: ::std::os::raw::c_uint);
}
extern "C" {
    #[doc = " query if node was the last parent of a branching of the tree\n\n  @return TRUE if node was the last parent of a branching of the tree\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPwasNodeLastBranchParent(
        scip: *mut SCIP,
        node: *mut SCIP_NODE,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " validate the result of the solve\n\n  the validation includes\n\n  - checking the feasibility of the incumbent solution in the original problem (using SCIPcheckSolOrig())\n\n  - checking if the objective bounds computed by SCIP agree with external primal and dual reference bounds.\n\n  All external reference bounds the original problem space and the original objective sense.\n\n  For infeasible problems, +/-SCIPinfinity() should be passed as reference bounds depending on the objective sense\n  of the original problem."]
    pub fn SCIPvalidateSolve(
        scip: *mut SCIP,
        primalreference: f64,
        dualreference: f64,
        reftol: f64,
        quiet: ::std::os::raw::c_uint,
        feasible: *mut ::std::os::raw::c_uint,
        primalboundcheck: *mut ::std::os::raw::c_uint,
        dualboundcheck: *mut ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " creates and captures problem variable; if variable is of integral type, fractional bounds are automatically rounded;\n  an integer variable with bounds zero and one is automatically converted into a binary variable;\n\n  @warning When doing column generation and the original problem is a maximization problem, notice that SCIP will\n           transform the problem into a minimization problem by multiplying the objective function by -1.  Thus, the\n           original objective function value of variables created during the solving process has to be multiplied by\n           -1, too.\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMING\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_SOLVING\n\n  @note the variable gets captured, hence at one point you have to release it using the method SCIPreleaseVar()"]
    pub fn SCIPcreateVar(
        scip: *mut SCIP,
        var: *mut *mut SCIP_VAR,
        name: *const ::std::os::raw::c_char,
        lb: f64,
        ub: f64,
        obj: f64,
        vartype: SCIP_VARTYPE,
        initial: ::std::os::raw::c_uint,
        removable: ::std::os::raw::c_uint,
        vardelorig: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                var: *mut SCIP_VAR,
                vardata: *mut *mut SCIP_VARDATA,
            ) -> SCIP_RETCODE,
        >,
        vartrans: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                sourcevar: *mut SCIP_VAR,
                sourcedata: *mut SCIP_VARDATA,
                targetvar: *mut SCIP_VAR,
                targetdata: *mut *mut SCIP_VARDATA,
            ) -> SCIP_RETCODE,
        >,
        vardeltrans: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                var: *mut SCIP_VAR,
                vardata: *mut *mut SCIP_VARDATA,
            ) -> SCIP_RETCODE,
        >,
        varcopy: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                sourcescip: *mut SCIP,
                sourcevar: *mut SCIP_VAR,
                sourcedata: *mut SCIP_VARDATA,
                varmap: *mut SCIP_HASHMAP,
                consmap: *mut SCIP_HASHMAP,
                targetvar: *mut SCIP_VAR,
                targetdata: *mut *mut SCIP_VARDATA,
                result: *mut SCIP_RESULT,
            ) -> SCIP_RETCODE,
        >,
        vardata: *mut SCIP_VARDATA,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " creates and captures problem variable with optional callbacks and variable data set to NULL, which can be set\n  afterwards using SCIPvarSetDelorigData(), SCIPvarSetTransData(),\n  SCIPvarSetDeltransData(), SCIPvarSetCopy(), and SCIPvarSetData(); sets variable flags initial=TRUE\n  and removable = FALSE, which can be adjusted by using SCIPvarSetInitial() and SCIPvarSetRemovable(), resp.;\n  if variable is of integral type, fractional bounds are automatically rounded;\n  an integer variable with bounds zero and one is automatically converted into a binary variable;\n\n  @warning When doing column generation and the original problem is a maximization problem, notice that SCIP will\n           transform the problem into a minimization problem by multiplying the objective function by -1.  Thus, the\n           original objective function value of variables created during the solving process has to be multiplied by\n           -1, too.\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMING\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_SOLVING\n\n  @note the variable gets captured, hence at one point you have to release it using the method SCIPreleaseVar()"]
    pub fn SCIPcreateVarBasic(
        scip: *mut SCIP,
        var: *mut *mut SCIP_VAR,
        name: *const ::std::os::raw::c_char,
        lb: f64,
        ub: f64,
        obj: f64,
        vartype: SCIP_VARTYPE,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " outputs the variable name to the file stream\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMING\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED\n       - \\ref SCIP_STAGE_EXITSOLVE\n       - \\ref SCIP_STAGE_FREETRANS"]
    pub fn SCIPwriteVarName(
        scip: *mut SCIP,
        file: *mut FILE,
        var: *mut SCIP_VAR,
        type_: ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " print the given list of variables to output stream separated by the given delimiter character;\n\n  i. e. the variables x1, x2, ..., xn with given delimiter ',' are written as: \\<x1\\>, \\<x2\\>, ..., \\<xn\\>;\n\n  the method SCIPparseVarsList() can parse such a string\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMING\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED\n       - \\ref SCIP_STAGE_EXITSOLVE\n       - \\ref SCIP_STAGE_FREETRANS\n\n  @note The printing process is done via the message handler system."]
    pub fn SCIPwriteVarsList(
        scip: *mut SCIP,
        file: *mut FILE,
        vars: *mut *mut SCIP_VAR,
        nvars: ::std::os::raw::c_int,
        type_: ::std::os::raw::c_uint,
        delimiter: ::std::os::raw::c_char,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " print the given variables and coefficients as linear sum in the following form\n  c1 \\<x1\\> + c2 \\<x2\\>   ... + cn \\<xn\\>\n\n  This string can be parsed by the method SCIPparseVarsLinearsum().\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMING\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED\n       - \\ref SCIP_STAGE_EXITSOLVE\n       - \\ref SCIP_STAGE_FREETRANS\n\n  @note The printing process is done via the message handler system."]
    pub fn SCIPwriteVarsLinearsum(
        scip: *mut SCIP,
        file: *mut FILE,
        vars: *mut *mut SCIP_VAR,
        vals: *mut f64,
        nvars: ::std::os::raw::c_int,
        type_: ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " print the given terms as signomial in the following form\n  c1 \\<x11\\>^e11 \\<x12\\>^e12 ... \\<x1n\\>^e1n + c2 \\<x21\\>^e21 \\<x22\\>^e22 ... + ... + cn \\<xn1\\>^en1 ...\n\n  This string can be parsed by the method SCIPparseVarsPolynomial().\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMING\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED\n       - \\ref SCIP_STAGE_EXITSOLVE\n       - \\ref SCIP_STAGE_FREETRANS\n\n  @note The printing process is done via the message handler system."]
    pub fn SCIPwriteVarsPolynomial(
        scip: *mut SCIP,
        file: *mut FILE,
        monomialvars: *mut *mut *mut SCIP_VAR,
        monomialexps: *mut *mut f64,
        monomialcoefs: *mut f64,
        monomialnvars: *mut ::std::os::raw::c_int,
        nmonomials: ::std::os::raw::c_int,
        type_: ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " parses variable information (in cip format) out of a string; if the parsing process was successful a variable is\n  created and captured; if variable is of integral type, fractional bounds are automatically rounded; an integer\n  variable with bounds zero and one is automatically converted into a binary variable\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMING\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPparseVar(
        scip: *mut SCIP,
        var: *mut *mut SCIP_VAR,
        str_: *const ::std::os::raw::c_char,
        initial: ::std::os::raw::c_uint,
        removable: ::std::os::raw::c_uint,
        varcopy: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                sourcescip: *mut SCIP,
                sourcevar: *mut SCIP_VAR,
                sourcedata: *mut SCIP_VARDATA,
                varmap: *mut SCIP_HASHMAP,
                consmap: *mut SCIP_HASHMAP,
                targetvar: *mut SCIP_VAR,
                targetdata: *mut *mut SCIP_VARDATA,
                result: *mut SCIP_RESULT,
            ) -> SCIP_RETCODE,
        >,
        vardelorig: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                var: *mut SCIP_VAR,
                vardata: *mut *mut SCIP_VARDATA,
            ) -> SCIP_RETCODE,
        >,
        vartrans: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                sourcevar: *mut SCIP_VAR,
                sourcedata: *mut SCIP_VARDATA,
                targetvar: *mut SCIP_VAR,
                targetdata: *mut *mut SCIP_VARDATA,
            ) -> SCIP_RETCODE,
        >,
        vardeltrans: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                var: *mut SCIP_VAR,
                vardata: *mut *mut SCIP_VARDATA,
            ) -> SCIP_RETCODE,
        >,
        vardata: *mut SCIP_VARDATA,
        endptr: *mut *mut ::std::os::raw::c_char,
        success: *mut ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " parses the given string for a variable name and stores the variable in the corresponding pointer if such a variable\n  exits and returns the position where the parsing stopped\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMING\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPparseVarName(
        scip: *mut SCIP,
        str_: *const ::std::os::raw::c_char,
        var: *mut *mut SCIP_VAR,
        endptr: *mut *mut ::std::os::raw::c_char,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " parse the given string as variable list (here ',' is the delimiter)) (\\<x1\\>, \\<x2\\>, ..., \\<xn\\>) (see\n  SCIPwriteVarsList() ); if it was successful, the pointer success is set to TRUE\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMING\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_SOLVING\n\n  @note The pointer success in only set to FALSE in the case that a variable with a parsed variable name does not exist.\n\n  @note If the number of (parsed) variables is greater than the available slots in the variable array, nothing happens\n        except that the required size is stored in the corresponding integer; the reason for this approach is that we\n        cannot reallocate memory, since we do not know how the memory has been allocated (e.g., by a C++ 'new' or SCIP\n        memory functions)."]
    pub fn SCIPparseVarsList(
        scip: *mut SCIP,
        str_: *const ::std::os::raw::c_char,
        vars: *mut *mut SCIP_VAR,
        nvars: *mut ::std::os::raw::c_int,
        varssize: ::std::os::raw::c_int,
        requiredsize: *mut ::std::os::raw::c_int,
        endptr: *mut *mut ::std::os::raw::c_char,
        delimiter: ::std::os::raw::c_char,
        success: *mut ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " parse the given string as linear sum of variables and coefficients (c1 \\<x1\\> + c2 \\<x2\\> + ... + cn \\<xn\\>)\n  (see SCIPwriteVarsLinearsum() ); if it was successful, the pointer success is set to TRUE\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMING\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_SOLVING\n\n  @note The pointer success in only set to FALSE in the case that a variable with a parsed variable name does not exist.\n\n  @note If the number of (parsed) variables is greater than the available slots in the variable array, nothing happens\n        except that the required size is stored in the corresponding integer; the reason for this approach is that we\n        cannot reallocate memory, since we do not know how the memory has been allocated (e.g., by a C++ 'new' or SCIP\n        memory functions)."]
    pub fn SCIPparseVarsLinearsum(
        scip: *mut SCIP,
        str_: *const ::std::os::raw::c_char,
        vars: *mut *mut SCIP_VAR,
        vals: *mut f64,
        nvars: *mut ::std::os::raw::c_int,
        varssize: ::std::os::raw::c_int,
        requiredsize: *mut ::std::os::raw::c_int,
        endptr: *mut *mut ::std::os::raw::c_char,
        success: *mut ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " parse the given string as signomial of variables and coefficients\n  (c1 \\<x11\\>^e11 \\<x12\\>^e12 ... \\<x1n\\>^e1n + c2 \\<x21\\>^e21 \\<x22\\>^e22 ... + ... + cn \\<xn1\\>^en1 ...)\n  (see SCIPwriteVarsPolynomial()); if it was successful, the pointer success is set to TRUE\n\n  The user has to call SCIPfreeParseVarsPolynomialData(scip, monomialvars, monomialexps,\n  monomialcoefs, monomialnvars, *nmonomials) short after SCIPparseVarsPolynomial to free all the\n  allocated memory again.  Do not keep the arrays created by SCIPparseVarsPolynomial around, since\n  they use buffer memory that is intended for short term use only.\n\n  Parsing is stopped at the end of string (indicated by the \\\\0-character) or when no more monomials\n  are recognized.\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMING\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPparseVarsPolynomial(
        scip: *mut SCIP,
        str_: *const ::std::os::raw::c_char,
        monomialvars: *mut *mut *mut *mut SCIP_VAR,
        monomialexps: *mut *mut *mut f64,
        monomialcoefs: *mut *mut f64,
        monomialnvars: *mut *mut ::std::os::raw::c_int,
        nmonomials: *mut ::std::os::raw::c_int,
        endptr: *mut *mut ::std::os::raw::c_char,
        success: *mut ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " frees memory allocated when parsing a signomial from a string\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMING\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPfreeParseVarsPolynomialData(
        scip: *mut SCIP,
        monomialvars: *mut *mut *mut *mut SCIP_VAR,
        monomialexps: *mut *mut *mut f64,
        monomialcoefs: *mut *mut f64,
        monomialnvars: *mut *mut ::std::os::raw::c_int,
        nmonomials: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " increases usage counter of variable\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMING\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED\n       - \\ref SCIP_STAGE_EXITSOLVE"]
    pub fn SCIPcaptureVar(scip: *mut SCIP, var: *mut SCIP_VAR) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " decreases usage counter of variable, if the usage pointer reaches zero the variable gets freed\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMING\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED\n       - \\ref SCIP_STAGE_EXITSOLVE\n       - \\ref SCIP_STAGE_FREETRANS\n\n  @note the pointer of the variable will be NULLed"]
    pub fn SCIPreleaseVar(scip: *mut SCIP, var: *mut *mut SCIP_VAR) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " changes the name of a variable\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can only be called if @p scip is in stage \\ref SCIP_STAGE_PROBLEM\n\n  @note to get the current name of a variable, use SCIPvarGetName() from pub_var.h"]
    pub fn SCIPchgVarName(
        scip: *mut SCIP,
        var: *mut SCIP_VAR,
        name: *const ::std::os::raw::c_char,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " gets and captures transformed variable of a given variable; if the variable is not yet transformed,\n  a new transformed variable for this variable is created\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_TRANSFORMING\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPtransformVar(
        scip: *mut SCIP,
        var: *mut SCIP_VAR,
        transvar: *mut *mut SCIP_VAR,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " gets and captures transformed variables for an array of variables;\n  if a variable of the array is not yet transformed, a new transformed variable for this variable is created;\n  it is possible to call this method with vars == transvars\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_TRANSFORMING\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPtransformVars(
        scip: *mut SCIP,
        nvars: ::std::os::raw::c_int,
        vars: *mut *mut SCIP_VAR,
        transvars: *mut *mut SCIP_VAR,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " gets corresponding transformed variable of a given variable;\n  returns NULL as transvar, if transformed variable is not yet existing\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_TRANSFORMING\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED\n       - \\ref SCIP_STAGE_EXITSOLVE\n       - \\ref SCIP_STAGE_FREETRANS"]
    pub fn SCIPgetTransformedVar(
        scip: *mut SCIP,
        var: *mut SCIP_VAR,
        transvar: *mut *mut SCIP_VAR,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " gets corresponding transformed variables for an array of variables;\n  stores NULL in a transvars slot, if the transformed variable is not yet existing;\n  it is possible to call this method with vars == transvars, but remember that variables that are not\n  yet transformed will be replaced with NULL\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_TRANSFORMING\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED\n       - \\ref SCIP_STAGE_EXITSOLVE\n       - \\ref SCIP_STAGE_FREETRANS"]
    pub fn SCIPgetTransformedVars(
        scip: *mut SCIP,
        nvars: ::std::os::raw::c_int,
        vars: *mut *mut SCIP_VAR,
        transvars: *mut *mut SCIP_VAR,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " gets negated variable x' = lb + ub - x of variable x; negated variable is created, if not yet existing\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMING\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED\n       - \\ref SCIP_STAGE_EXITSOLVE\n       - \\ref SCIP_STAGE_FREETRANS"]
    pub fn SCIPgetNegatedVar(
        scip: *mut SCIP,
        var: *mut SCIP_VAR,
        negvar: *mut *mut SCIP_VAR,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " gets negated variables x' = lb + ub - x of variables x; negated variables are created, if not yet existing;\n  in difference to \\ref SCIPcreateVar, the negated variable must not be released (unless captured explicitly)\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMING\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED\n       - \\ref SCIP_STAGE_EXITSOLVE\n       - \\ref SCIP_STAGE_FREETRANS"]
    pub fn SCIPgetNegatedVars(
        scip: *mut SCIP,
        nvars: ::std::os::raw::c_int,
        vars: *mut *mut SCIP_VAR,
        negvars: *mut *mut SCIP_VAR,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " gets a binary variable that is equal to the given binary variable, and that is either active, fixed, or\n  multi-aggregated, or the negated variable of an active, fixed, or multi-aggregated variable\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED\n       - \\ref SCIP_STAGE_EXITSOLVE"]
    pub fn SCIPgetBinvarRepresentative(
        scip: *mut SCIP,
        var: *mut SCIP_VAR,
        repvar: *mut *mut SCIP_VAR,
        negated: *mut ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " gets binary variables that are equal to the given binary variables, and which are either active, fixed, or\n  multi-aggregated, or the negated variables of active, fixed, or multi-aggregated variables\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED\n       - \\ref SCIP_STAGE_EXITSOLVE"]
    pub fn SCIPgetBinvarRepresentatives(
        scip: *mut SCIP,
        nvars: ::std::os::raw::c_int,
        vars: *mut *mut SCIP_VAR,
        repvars: *mut *mut SCIP_VAR,
        negated: *mut ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " flattens aggregation graph of multi-aggregated variable in order to avoid exponential recursion later on\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPflattenVarAggregationGraph(scip: *mut SCIP, var: *mut SCIP_VAR) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " Transforms a given linear sum of variables, that is a_1*x_1 + ... + a_n*x_n + c into a corresponding linear sum of\n  active variables, that is b_1*y_1 + ... + b_m*y_m + d.\n\n  If the number of needed active variables is greater than the available slots in the variable array, nothing happens\n  except that the required size is stored in the corresponding variable (requiredsize). Otherwise, the active variable\n  representation is stored in the variable array, scalar array and constant.\n\n  The reason for this approach is that we cannot reallocate memory, since we do not know how the memory has been\n  allocated (e.g., by a C++ 'new' or SCIP functions).\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED\n       - \\ref SCIP_STAGE_EXITSOLVE\n       - \\ref SCIP_STAGE_FREETRANS\n\n  @note The resulting linear sum is stored into the given variable array, scalar array, and constant. That means the\n        given entries are overwritten.\n\n  @note That method can be used to convert a single variables into variable space of active variables. Therefore call\n        the method with the linear sum 1.0*x + 0.0."]
    pub fn SCIPgetProbvarLinearSum(
        scip: *mut SCIP,
        vars: *mut *mut SCIP_VAR,
        scalars: *mut f64,
        nvars: *mut ::std::os::raw::c_int,
        varssize: ::std::os::raw::c_int,
        constant: *mut f64,
        requiredsize: *mut ::std::os::raw::c_int,
        mergemultiples: ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " transforms given variable, scalar and constant to the corresponding active, fixed, or\n  multi-aggregated variable, scalar and constant; if the variable resolves to a fixed variable,\n  \"scalar\" will be 0.0 and the value of the sum will be stored in \"constant\"; a multi-aggregation\n  with only one active variable (this can happen due to fixings after the multi-aggregation),\n  is treated like an aggregation; if the multi-aggregation constant is infinite, \"scalar\" will be 0.0\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED\n       - \\ref SCIP_STAGE_EXITSOLVE\n       - \\ref SCIP_STAGE_FREETRANS"]
    pub fn SCIPgetProbvarSum(
        scip: *mut SCIP,
        var: *mut *mut SCIP_VAR,
        scalar: *mut f64,
        constant: *mut f64,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " return for given variables all their active counterparts; all active variables will be pairwise different\n  @note It does not hold that the first output variable is the active variable for the first input variable.\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED\n       - \\ref SCIP_STAGE_EXITSOLVE\n       - \\ref SCIP_STAGE_FREETRANS"]
    pub fn SCIPgetActiveVars(
        scip: *mut SCIP,
        vars: *mut *mut SCIP_VAR,
        nvars: *mut ::std::os::raw::c_int,
        varssize: ::std::os::raw::c_int,
        requiredsize: *mut ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " returns the reduced costs of the variable in the current node's LP relaxation;\n  the current node has to have a feasible LP.\n\n  returns SCIP_INVALID if the variable is active but not in the current LP;\n  returns 0 if the variable has been aggregated out or fixed in presolving.\n\n  @pre This method can only be called if @p scip is in stage \\ref SCIP_STAGE_SOLVING\n\n  @note The return value of this method should be used carefully if the dual feasibility check was explictely disabled."]
    pub fn SCIPgetVarRedcost(scip: *mut SCIP, var: *mut SCIP_VAR) -> f64;
}
extern "C" {
    #[doc = " returns the implied reduced costs of the variable in the current node's LP relaxation;\n  the current node has to have a feasible LP.\n\n  returns SCIP_INVALID if the variable is active but not in the current LP;\n  returns 0 if the variable has been aggregated out or fixed in presolving.\n\n  @pre This method can only be called if @p scip is in stage \\ref SCIP_STAGE_SOLVING\n\n  @note The return value of this method should be used carefully if the dual feasibility check was explictely disabled."]
    pub fn SCIPgetVarImplRedcost(
        scip: *mut SCIP,
        var: *mut SCIP_VAR,
        varfixing: ::std::os::raw::c_uint,
    ) -> f64;
}
extern "C" {
    #[doc = " returns the Farkas coefficient of the variable in the current node's LP relaxation;\n  the current node has to have an infeasible LP.\n\n  returns SCIP_INVALID if the variable is active but not in the current LP;\n  returns 0 if the variable has been aggregated out or fixed in presolving.\n\n  @pre This method can only be called if @p scip is in stage \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPgetVarFarkasCoef(scip: *mut SCIP, var: *mut SCIP_VAR) -> f64;
}
extern "C" {
    #[doc = " returns lower bound of variable directly before or after the bound change given by the bound change index\n  was applied"]
    pub fn SCIPgetVarLbAtIndex(
        scip: *mut SCIP,
        var: *mut SCIP_VAR,
        bdchgidx: *mut SCIP_BDCHGIDX,
        after: ::std::os::raw::c_uint,
    ) -> f64;
}
extern "C" {
    #[doc = " returns upper bound of variable directly before or after the bound change given by the bound change index\n  was applied"]
    pub fn SCIPgetVarUbAtIndex(
        scip: *mut SCIP,
        var: *mut SCIP_VAR,
        bdchgidx: *mut SCIP_BDCHGIDX,
        after: ::std::os::raw::c_uint,
    ) -> f64;
}
extern "C" {
    #[doc = " returns lower or upper bound of variable directly before or after the bound change given by the bound change index\n  was applied"]
    pub fn SCIPgetVarBdAtIndex(
        scip: *mut SCIP,
        var: *mut SCIP_VAR,
        boundtype: SCIP_BOUNDTYPE,
        bdchgidx: *mut SCIP_BDCHGIDX,
        after: ::std::os::raw::c_uint,
    ) -> f64;
}
extern "C" {
    #[doc = " returns whether the binary variable was fixed at the time given by the bound change index"]
    pub fn SCIPgetVarWasFixedAtIndex(
        scip: *mut SCIP,
        var: *mut SCIP_VAR,
        bdchgidx: *mut SCIP_BDCHGIDX,
        after: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " gets solution value for variable in current node\n\n  @return solution value for variable in current node\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPgetVarSol(scip: *mut SCIP, var: *mut SCIP_VAR) -> f64;
}
extern "C" {
    #[doc = " gets solution values of multiple variables in current node\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPgetVarSols(
        scip: *mut SCIP,
        nvars: ::std::os::raw::c_int,
        vars: *mut *mut SCIP_VAR,
        vals: *mut f64,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " sets the solution value of all variables in the global relaxation solution to zero\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPclearRelaxSolVals(scip: *mut SCIP, relax: *mut SCIP_RELAX) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " sets the value of the given variable in the global relaxation solution;\n  this solution can be filled by the relaxation handlers  and can be used by heuristics and for separation;\n  You can use SCIPclearRelaxSolVals() to set all values to zero, initially;\n  after setting all solution values, you have to call SCIPmarkRelaxSolValid()\n  to inform SCIP that the stored solution is valid\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_SOLVING\n\n  @note This method incrementally updates the objective value of the relaxation solution. If the whole solution\n        should be updated, using SCIPsetRelaxSolVals() instead or calling SCIPclearRelaxSolVals() before setting\n        the first value to reset the solution and the objective value to 0 may help the numerics."]
    pub fn SCIPsetRelaxSolVal(
        scip: *mut SCIP,
        relax: *mut SCIP_RELAX,
        var: *mut SCIP_VAR,
        val: f64,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " sets the values of the given variables in the global relaxation solution and informs SCIP about the validity\n  and whether the solution can be enforced via linear cuts;\n  this solution can be filled by the relaxation handlers  and can be used by heuristics and for separation;\n  the solution is automatically cleared, s.t. all other variables get value 0.0\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPsetRelaxSolVals(
        scip: *mut SCIP,
        relax: *mut SCIP_RELAX,
        nvars: ::std::os::raw::c_int,
        vars: *mut *mut SCIP_VAR,
        vals: *mut f64,
        includeslp: ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " sets the values of the variables in the global relaxation solution to the values in the given primal solution\n  and informs SCIP about the validity and whether the solution can be enforced via linear cuts;\n  the relaxation solution can be filled by the relaxation handlers and might be used by heuristics and for separation\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPsetRelaxSolValsSol(
        scip: *mut SCIP,
        relax: *mut SCIP_RELAX,
        sol: *mut SCIP_SOL,
        includeslp: ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " returns whether the relaxation solution is valid\n\n  @return TRUE, if the relaxation solution is valid; FALSE, otherwise\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPisRelaxSolValid(scip: *mut SCIP) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " informs SCIP that the relaxation solution is valid and whether the relaxation can be enforced through linear cuts\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPmarkRelaxSolValid(
        scip: *mut SCIP,
        relax: *mut SCIP_RELAX,
        includeslp: ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " informs SCIP, that the relaxation solution is invalid\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPmarkRelaxSolInvalid(scip: *mut SCIP) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " gets the relaxation solution value of the given variable\n\n  @return the relaxation solution value of the given variable\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPgetRelaxSolVal(scip: *mut SCIP, var: *mut SCIP_VAR) -> f64;
}
extern "C" {
    #[doc = " gets the relaxation solution objective value\n\n  @return the objective value of the relaxation solution\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPgetRelaxSolObj(scip: *mut SCIP) -> f64;
}
extern "C" {
    #[doc = " determine which branching direction should be evaluated first by strong branching\n\n  @return TRUE iff strong branching should first evaluate the down child\n"]
    pub fn SCIPisStrongbranchDownFirst(
        scip: *mut SCIP,
        var: *mut SCIP_VAR,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " start strong branching - call before any strong branching\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_SOLVING\n\n  @note if propagation is enabled, strong branching is not done directly on the LP, but probing nodes are created\n        which allow to perform propagation but also creates some overhead"]
    pub fn SCIPstartStrongbranch(
        scip: *mut SCIP,
        enablepropagation: ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " end strong branching - call after any strong branching\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPendStrongbranch(scip: *mut SCIP) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " gets strong branching information on column variable with fractional value\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPgetVarStrongbranchFrac(
        scip: *mut SCIP,
        var: *mut SCIP_VAR,
        itlim: ::std::os::raw::c_int,
        idempotent: ::std::os::raw::c_uint,
        down: *mut f64,
        up: *mut f64,
        downvalid: *mut ::std::os::raw::c_uint,
        upvalid: *mut ::std::os::raw::c_uint,
        downinf: *mut ::std::os::raw::c_uint,
        upinf: *mut ::std::os::raw::c_uint,
        downconflict: *mut ::std::os::raw::c_uint,
        upconflict: *mut ::std::os::raw::c_uint,
        lperror: *mut ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " gets strong branching information with previous domain propagation on column variable\n\n  Before calling this method, the strong branching mode must have been activated by calling SCIPstartStrongbranch();\n  after strong branching was done for all candidate variables, the strong branching mode must be ended by\n  SCIPendStrongbranch(). Since this method applies domain propagation before strongbranching, propagation has to be be\n  enabled in the SCIPstartStrongbranch() call.\n\n  Before solving the strong branching LP, domain propagation can be performed. The number of propagation rounds\n  can be specified by the parameter @p maxproprounds.\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_SOLVING\n\n  @warning When using this method, LP banching candidates and solution values must be copied beforehand, because\n           they are updated w.r.t. the strong branching LP solution."]
    pub fn SCIPgetVarStrongbranchWithPropagation(
        scip: *mut SCIP,
        var: *mut SCIP_VAR,
        solval: f64,
        lpobjval: f64,
        itlim: ::std::os::raw::c_int,
        maxproprounds: ::std::os::raw::c_int,
        down: *mut f64,
        up: *mut f64,
        downvalid: *mut ::std::os::raw::c_uint,
        upvalid: *mut ::std::os::raw::c_uint,
        ndomredsdown: *mut ::std::os::raw::c_longlong,
        ndomredsup: *mut ::std::os::raw::c_longlong,
        downinf: *mut ::std::os::raw::c_uint,
        upinf: *mut ::std::os::raw::c_uint,
        downconflict: *mut ::std::os::raw::c_uint,
        upconflict: *mut ::std::os::raw::c_uint,
        lperror: *mut ::std::os::raw::c_uint,
        newlbs: *mut f64,
        newubs: *mut f64,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " gets strong branching information on column variable x with integral LP solution value (val); that is, the down branch\n  is (val -1.0) and the up brach ins (val +1.0)\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_SOLVING\n\n  @note If the integral LP solution value is the lower or upper bound of the variable, the corresponding branch will be\n        marked as infeasible. That is, the valid pointer and the infeasible pointer are set to TRUE."]
    pub fn SCIPgetVarStrongbranchInt(
        scip: *mut SCIP,
        var: *mut SCIP_VAR,
        itlim: ::std::os::raw::c_int,
        idempotent: ::std::os::raw::c_uint,
        down: *mut f64,
        up: *mut f64,
        downvalid: *mut ::std::os::raw::c_uint,
        upvalid: *mut ::std::os::raw::c_uint,
        downinf: *mut ::std::os::raw::c_uint,
        upinf: *mut ::std::os::raw::c_uint,
        downconflict: *mut ::std::os::raw::c_uint,
        upconflict: *mut ::std::os::raw::c_uint,
        lperror: *mut ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " gets strong branching information on column variables with fractional values\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPgetVarsStrongbranchesFrac(
        scip: *mut SCIP,
        vars: *mut *mut SCIP_VAR,
        nvars: ::std::os::raw::c_int,
        itlim: ::std::os::raw::c_int,
        down: *mut f64,
        up: *mut f64,
        downvalid: *mut ::std::os::raw::c_uint,
        upvalid: *mut ::std::os::raw::c_uint,
        downinf: *mut ::std::os::raw::c_uint,
        upinf: *mut ::std::os::raw::c_uint,
        downconflict: *mut ::std::os::raw::c_uint,
        upconflict: *mut ::std::os::raw::c_uint,
        lperror: *mut ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " gets strong branching information on column variables with integral values\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPgetVarsStrongbranchesInt(
        scip: *mut SCIP,
        vars: *mut *mut SCIP_VAR,
        nvars: ::std::os::raw::c_int,
        itlim: ::std::os::raw::c_int,
        down: *mut f64,
        up: *mut f64,
        downvalid: *mut ::std::os::raw::c_uint,
        upvalid: *mut ::std::os::raw::c_uint,
        downinf: *mut ::std::os::raw::c_uint,
        upinf: *mut ::std::os::raw::c_uint,
        downconflict: *mut ::std::os::raw::c_uint,
        upconflict: *mut ::std::os::raw::c_uint,
        lperror: *mut ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " get LP solution status of last strong branching call (currently only works for strong branching with propagation)"]
    pub fn SCIPgetLastStrongbranchLPSolStat(
        scip: *mut SCIP,
        branchdir: SCIP_BRANCHDIR,
    ) -> SCIP_LPSOLSTAT;
}
extern "C" {
    #[doc = " gets strong branching information on COLUMN variable of the last SCIPgetVarStrongbranch() call;\n  returns values of SCIP_INVALID, if strong branching was not yet called on the given variable;\n  keep in mind, that the returned old values may have nothing to do with the current LP solution\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPgetVarStrongbranchLast(
        scip: *mut SCIP,
        var: *mut SCIP_VAR,
        down: *mut f64,
        up: *mut f64,
        downvalid: *mut ::std::os::raw::c_uint,
        upvalid: *mut ::std::os::raw::c_uint,
        solval: *mut f64,
        lpobjval: *mut f64,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " sets strong branching information for a column variable\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPsetVarStrongbranchData(
        scip: *mut SCIP,
        var: *mut SCIP_VAR,
        lpobjval: f64,
        primsol: f64,
        down: f64,
        up: f64,
        downvalid: ::std::os::raw::c_uint,
        upvalid: ::std::os::raw::c_uint,
        iter: ::std::os::raw::c_longlong,
        itlim: ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " rounds the current solution and tries it afterwards; if feasible, adds it to storage\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPtryStrongbranchLPSol(
        scip: *mut SCIP,
        foundsol: *mut ::std::os::raw::c_uint,
        cutoff: *mut ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " gets node number of the last node in current branch and bound run, where strong branching was used on the\n  given variable, or -1 if strong branching was never applied to the variable in current run\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_TRANSFORMING\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED\n       - \\ref SCIP_STAGE_EXITSOLVE"]
    pub fn SCIPgetVarStrongbranchNode(
        scip: *mut SCIP,
        var: *mut SCIP_VAR,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    #[doc = " if strong branching was already applied on the variable at the current node, returns the number of LPs solved after\n  the LP where the strong branching on this variable was applied;\n  if strong branching was not yet applied on the variable at the current node, returns INT_MAX\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_TRANSFORMING\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED\n       - \\ref SCIP_STAGE_EXITSOLVE"]
    pub fn SCIPgetVarStrongbranchLPAge(
        scip: *mut SCIP,
        var: *mut SCIP_VAR,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    #[doc = " gets number of times, strong branching was applied in current run on the given variable\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_TRANSFORMING\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED\n       - \\ref SCIP_STAGE_EXITSOLVE"]
    pub fn SCIPgetVarNStrongbranchs(scip: *mut SCIP, var: *mut SCIP_VAR) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " adds given values to lock numbers of type @p locktype of variable for rounding\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMING\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_EXITSOLVE\n       - \\ref SCIP_STAGE_FREETRANS"]
    pub fn SCIPaddVarLocksType(
        scip: *mut SCIP,
        var: *mut SCIP_VAR,
        locktype: SCIP_LOCKTYPE,
        nlocksdown: ::std::os::raw::c_int,
        nlocksup: ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " adds given values to lock numbers of variable for rounding\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMING\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_EXITSOLVE\n       - \\ref SCIP_STAGE_FREETRANS\n\n  @note This method will always add variable locks of type model"]
    pub fn SCIPaddVarLocks(
        scip: *mut SCIP,
        var: *mut SCIP_VAR,
        nlocksdown: ::std::os::raw::c_int,
        nlocksup: ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " add locks of type @p locktype of variable with respect to the lock status of the constraint and its negation;\n  this method should be called whenever the lock status of a variable in a constraint changes, for example if\n  the coefficient of the variable changed its sign or if the left or right hand sides of the constraint were\n  added or removed\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMING\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_EXITSOLVE\n       - \\ref SCIP_STAGE_FREETRANS"]
    pub fn SCIPlockVarCons(
        scip: *mut SCIP,
        var: *mut SCIP_VAR,
        cons: *mut SCIP_CONS,
        lockdown: ::std::os::raw::c_uint,
        lockup: ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " remove locks of type @p locktype of variable with respect to the lock status of the constraint and its negation;\n  this method should be called whenever the lock status of a variable in a constraint changes, for example if\n  the coefficient of the variable changed its sign or if the left or right hand sides of the constraint were\n  added or removed\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMING\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_EXITSOLVE\n       - \\ref SCIP_STAGE_FREETRANS"]
    pub fn SCIPunlockVarCons(
        scip: *mut SCIP,
        var: *mut SCIP_VAR,
        cons: *mut SCIP_CONS,
        lockdown: ::std::os::raw::c_uint,
        lockup: ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " changes variable's objective value\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMING\n       - \\ref SCIP_STAGE_PRESOLVING"]
    pub fn SCIPchgVarObj(scip: *mut SCIP, var: *mut SCIP_VAR, newobj: f64) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " adds value to variable's objective value\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMING\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED"]
    pub fn SCIPaddVarObj(scip: *mut SCIP, var: *mut SCIP_VAR, addobj: f64) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " returns the adjusted (i.e. rounded, if the given variable is of integral type) lower bound value;\n  does not change the bounds of the variable\n\n  @return adjusted lower bound for the given variable; the bound of the variable is not changed\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMING\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED\n       - \\ref SCIP_STAGE_EXITSOLVE\n       - \\ref SCIP_STAGE_FREETRANS"]
    pub fn SCIPadjustedVarLb(scip: *mut SCIP, var: *mut SCIP_VAR, lb: f64) -> f64;
}
extern "C" {
    #[doc = " returns the adjusted (i.e. rounded, if the given variable is of integral type) upper bound value;\n  does not change the bounds of the variable\n\n  @return adjusted upper bound for the given variable; the bound of the variable is not changed\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMING\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED\n       - \\ref SCIP_STAGE_EXITSOLVE\n       - \\ref SCIP_STAGE_FREETRANS"]
    pub fn SCIPadjustedVarUb(scip: *mut SCIP, var: *mut SCIP_VAR, ub: f64) -> f64;
}
extern "C" {
    #[doc = " depending on SCIP's stage, changes lower bound of variable in the problem, in preprocessing, or in current node;\n  if possible, adjusts bound to integral value; doesn't store any inference information in the bound change, such\n  that in conflict analysis, this change is treated like a branching decision\n\n  @warning If SCIP is in presolving stage, it can happen that the internal variable array (which can be accessed via\n           SCIPgetVars()) gets resorted.\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMING\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_SOLVING\n\n  @note During presolving, an integer variable whose bound changes to {0,1} is upgraded to a binary variable."]
    pub fn SCIPchgVarLb(scip: *mut SCIP, var: *mut SCIP_VAR, newbound: f64) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " depending on SCIP's stage, changes upper bound of variable in the problem, in preprocessing, or in current node;\n  if possible, adjusts bound to integral value; doesn't store any inference information in the bound change, such\n  that in conflict analysis, this change is treated like a branching decision\n\n  @warning If SCIP is in presolving stage, it can happen that the internal variable array (which can be accessed via\n           SCIPgetVars()) gets resorted.\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMING\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_SOLVING\n\n  @note During presolving, an integer variable whose bound changes to {0,1} is upgraded to a binary variable."]
    pub fn SCIPchgVarUb(scip: *mut SCIP, var: *mut SCIP_VAR, newbound: f64) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " changes lower bound of variable in the given node; if possible, adjust bound to integral value; doesn't store any\n  inference information in the bound change, such that in conflict analysis, this change is treated like a branching\n  decision\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can only be called if @p scip is in stage \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPchgVarLbNode(
        scip: *mut SCIP,
        node: *mut SCIP_NODE,
        var: *mut SCIP_VAR,
        newbound: f64,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " changes upper bound of variable in the given node; if possible, adjust bound to integral value; doesn't store any\n  inference information in the bound change, such that in conflict analysis, this change is treated like a branching\n  decision\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can only be called if @p scip is in stage \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPchgVarUbNode(
        scip: *mut SCIP,
        node: *mut SCIP_NODE,
        var: *mut SCIP_VAR,
        newbound: f64,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " changes global lower bound of variable; if possible, adjust bound to integral value; also tightens the local bound,\n  if the global bound is better than the local bound\n\n  @warning If SCIP is in presolving stage, it can happen that the internal variable array (which can be accessed via\n           SCIPgetVars()) gets resorted.\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMING\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_SOLVING\n\n  @note During presolving, an integer variable whose bound changes to {0,1} is upgraded to a binary variable."]
    pub fn SCIPchgVarLbGlobal(scip: *mut SCIP, var: *mut SCIP_VAR, newbound: f64) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " changes global upper bound of variable; if possible, adjust bound to integral value; also tightens the local bound,\n  if the global bound is better than the local bound\n\n  @warning If SCIP is in presolving stage, it can happen that the internal variable array (which can be accessed via\n           SCIPgetVars()) gets resorted.\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMING\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_SOLVING\n\n  @note During presolving, an integer variable whose bound changes to {0,1} is upgraded to a binary variable."]
    pub fn SCIPchgVarUbGlobal(scip: *mut SCIP, var: *mut SCIP_VAR, newbound: f64) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " changes lazy lower bound of the variable, this is only possible if the variable is not in the LP yet\n\n  Lazy bounds are bounds that are already enforced by constraints and the objective function.\n  Setting a lazy lower bound has the consequence that for variables which lower bound equals the lazy lower bound,\n  the lower bound does not need to be passed on to the LP solver.\n  This is especially useful in a column generation (branch-and-price) setting.\n\n  @attention If the variable has a global lower bound below lazylb, then the global lower bound is tightened to\n     lazylb by a call to SCIPchgVarLbGlobal().\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMING\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPchgVarLbLazy(scip: *mut SCIP, var: *mut SCIP_VAR, lazylb: f64) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " changes lazy upper bound of the variable, this is only possible if the variable is not in the LP yet\n\n  Lazy bounds are bounds that are already enforced by constraints and the objective function.\n  Setting a lazy upper bound has the consequence that for variables which upper bound equals the lazy upper bound,\n  the upper bound does not need to be passed on to the LP solver.\n  This is especially useful in a column generation (branch-and-price) setting.\n\n  @attention If the variable has a global upper bound above lazyub, then the global upper bound is tightened to\n     lazyub by a call to SCIPchgVarUbGlobal().\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMING\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPchgVarUbLazy(scip: *mut SCIP, var: *mut SCIP_VAR, lazyub: f64) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " changes lower bound of variable in preprocessing or in the current node, if the new bound is tighter\n  (w.r.t. bound strengthening epsilon) than the current bound; if possible, adjusts bound to integral value;\n  doesn't store any inference information in the bound change, such that in conflict analysis, this change\n  is treated like a branching decision\n\n  @warning If SCIP is in presolving stage, it can happen that the internal variable array (which can be accessed via\n           SCIPgetVars()) gets resorted.\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_SOLVING\n\n  @note During presolving, an integer variable whose bound changes to {0,1} is upgraded to a binary variable."]
    pub fn SCIPtightenVarLb(
        scip: *mut SCIP,
        var: *mut SCIP_VAR,
        newbound: f64,
        force: ::std::os::raw::c_uint,
        infeasible: *mut ::std::os::raw::c_uint,
        tightened: *mut ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " changes upper bound of variable in preprocessing or in the current node, if the new bound is tighter\n  (w.r.t. bound strengthening epsilon) than the current bound; if possible, adjusts bound to integral value;\n  doesn't store any inference information in the bound change, such that in conflict analysis, this change\n  is treated like a branching decision\n\n  @warning If SCIP is in presolving stage, it can happen that the internal variable array (which can be accessed via\n           SCIPgetVars()) gets resorted.\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_SOLVING\n\n  @note During presolving, an integer variable whose bound changes to {0,1} is upgraded to a binary variable."]
    pub fn SCIPtightenVarUb(
        scip: *mut SCIP,
        var: *mut SCIP_VAR,
        newbound: f64,
        force: ::std::os::raw::c_uint,
        infeasible: *mut ::std::os::raw::c_uint,
        tightened: *mut ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " fixes variable in preprocessing or in the current node, if the new bound is tighter (w.r.t. bound strengthening\n  epsilon) than the current bound; if possible, adjusts bound to integral value; the given inference constraint is\n  stored, such that the conflict analysis is able to find out the reason for the deduction of the bound change\n\n  @note In presolving stage when not in probing mode the variable will be fixed directly, otherwise this method\n        changes first the lowerbound by calling SCIPinferVarLbCons and second the upperbound by calling\n        SCIPinferVarUbCons\n\n  @note If SCIP is in presolving stage, it can happen that the internal variable array (which get be accessed via\n        SCIPgetVars()) gets resorted.\n\n  @note During presolving, an integer variable which bound changes to {0,1} is upgraded to a binary variable."]
    pub fn SCIPinferVarFixCons(
        scip: *mut SCIP,
        var: *mut SCIP_VAR,
        fixedval: f64,
        infercons: *mut SCIP_CONS,
        inferinfo: ::std::os::raw::c_int,
        force: ::std::os::raw::c_uint,
        infeasible: *mut ::std::os::raw::c_uint,
        tightened: *mut ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " changes lower bound of variable in preprocessing or in the current node, if the new bound is tighter\n  (w.r.t. bound strengthening epsilon) than the current bound; if possible, adjusts bound to integral value;\n  the given inference constraint is stored, such that the conflict analysis is able to find out the reason\n  for the deduction of the bound change\n\n  @warning If SCIP is in presolving stage, it can happen that the internal variable array (which can be accessed via\n           SCIPgetVars()) gets resorted.\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_SOLVING\n\n  @note During presolving, an integer variable whose bound changes to {0,1} is upgraded to a binary variable."]
    pub fn SCIPinferVarLbCons(
        scip: *mut SCIP,
        var: *mut SCIP_VAR,
        newbound: f64,
        infercons: *mut SCIP_CONS,
        inferinfo: ::std::os::raw::c_int,
        force: ::std::os::raw::c_uint,
        infeasible: *mut ::std::os::raw::c_uint,
        tightened: *mut ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " changes upper bound of variable in preprocessing or in the current node, if the new bound is tighter\n  (w.r.t. bound strengthening epsilon) than the current bound; if possible, adjusts bound to integral value;\n  the given inference constraint is stored, such that the conflict analysis is able to find out the reason\n  for the deduction of the bound change\n\n  @warning If SCIP is in presolving stage, it can happen that the internal variable array (which can be accessed via\n           SCIPgetVars()) gets resorted.\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_SOLVING\n\n  @note During presolving, an integer variable whose bound changes to {0,1} is upgraded to a binary variable."]
    pub fn SCIPinferVarUbCons(
        scip: *mut SCIP,
        var: *mut SCIP_VAR,
        newbound: f64,
        infercons: *mut SCIP_CONS,
        inferinfo: ::std::os::raw::c_int,
        force: ::std::os::raw::c_uint,
        infeasible: *mut ::std::os::raw::c_uint,
        tightened: *mut ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " depending on SCIP's stage, fixes binary variable in the problem, in preprocessing, or in current node;\n  the given inference constraint is stored, such that the conflict analysis is able to find out the reason for the\n  deduction of the fixing\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPinferBinvarCons(
        scip: *mut SCIP,
        var: *mut SCIP_VAR,
        fixedval: ::std::os::raw::c_uint,
        infercons: *mut SCIP_CONS,
        inferinfo: ::std::os::raw::c_int,
        infeasible: *mut ::std::os::raw::c_uint,
        tightened: *mut ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " fixes variable in preprocessing or in the current node, if the new bound is tighter (w.r.t. bound strengthening\n  epsilon) than the current bound; if possible, adjusts bound to integral value; the given inference constraint is\n  stored, such that the conflict analysis is able to find out the reason for the deduction of the bound change\n\n  @note In presolving stage when not in probing mode the variable will be fixed directly, otherwise this method\n        changes first the lowerbound by calling SCIPinferVarLbProp and second the upperbound by calling\n        SCIPinferVarUbProp\n\n  @note If SCIP is in presolving stage, it can happen that the internal variable array (which get be accessed via\n        SCIPgetVars()) gets resorted.\n\n  @note During presolving, an integer variable which bound changes to {0,1} is upgraded to a binary variable."]
    pub fn SCIPinferVarFixProp(
        scip: *mut SCIP,
        var: *mut SCIP_VAR,
        fixedval: f64,
        inferprop: *mut SCIP_PROP,
        inferinfo: ::std::os::raw::c_int,
        force: ::std::os::raw::c_uint,
        infeasible: *mut ::std::os::raw::c_uint,
        tightened: *mut ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " changes lower bound of variable in preprocessing or in the current node, if the new bound is tighter\n  (w.r.t. bound strengthening epsilon) than the current bound; if possible, adjusts bound to integral value;\n  the given inference propagator is stored, such that the conflict analysis is able to find out the reason\n  for the deduction of the bound change\n\n  @warning If SCIP is in presolving stage, it can happen that the internal variable array (which can be accessed via\n           SCIPgetVars()) gets resorted.\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_SOLVING\n\n  @note During presolving, an integer variable whose bound changes to {0,1} is upgraded to a binary variable."]
    pub fn SCIPinferVarLbProp(
        scip: *mut SCIP,
        var: *mut SCIP_VAR,
        newbound: f64,
        inferprop: *mut SCIP_PROP,
        inferinfo: ::std::os::raw::c_int,
        force: ::std::os::raw::c_uint,
        infeasible: *mut ::std::os::raw::c_uint,
        tightened: *mut ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " changes upper bound of variable in preprocessing or in the current node, if the new bound is tighter\n  (w.r.t. bound strengthening epsilon) than the current bound; if possible, adjusts bound to integral value;\n  the given inference propagator is stored, such that the conflict analysis is able to find out the reason\n  for the deduction of the bound change\n\n  @warning If SCIP is in presolving stage, it can happen that the internal variable array (which can be accessed via\n           SCIPgetVars()) gets resorted.\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_SOLVING\n\n  @note During presolving, an integer variable whose bound changes to {0,1} is upgraded to a binary variable."]
    pub fn SCIPinferVarUbProp(
        scip: *mut SCIP,
        var: *mut SCIP_VAR,
        newbound: f64,
        inferprop: *mut SCIP_PROP,
        inferinfo: ::std::os::raw::c_int,
        force: ::std::os::raw::c_uint,
        infeasible: *mut ::std::os::raw::c_uint,
        tightened: *mut ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " depending on SCIP's stage, fixes binary variable in the problem, in preprocessing, or in current node;\n  the given inference propagator is stored, such that the conflict analysis is able to find out the reason for the\n  deduction of the fixing\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPinferBinvarProp(
        scip: *mut SCIP,
        var: *mut SCIP_VAR,
        fixedval: ::std::os::raw::c_uint,
        inferprop: *mut SCIP_PROP,
        inferinfo: ::std::os::raw::c_int,
        infeasible: *mut ::std::os::raw::c_uint,
        tightened: *mut ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " changes global lower bound of variable in preprocessing or in the current node, if the new bound is tighter\n  (w.r.t. bound strengthening epsilon) than the current global bound; if possible, adjusts bound to integral value;\n  also tightens the local bound, if the global bound is better than the local bound\n\n  @warning If SCIP is in presolving stage, it can happen that the internal variable array (which can be accessed via\n           SCIPgetVars()) gets resorted.\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMING\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_SOLVING\n\n  @note During presolving, an integer variable whose bound changes to {0,1} is upgraded to a binary variable."]
    pub fn SCIPtightenVarLbGlobal(
        scip: *mut SCIP,
        var: *mut SCIP_VAR,
        newbound: f64,
        force: ::std::os::raw::c_uint,
        infeasible: *mut ::std::os::raw::c_uint,
        tightened: *mut ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " changes global upper bound of variable in preprocessing or in the current node, if the new bound is tighter\n  (w.r.t. bound strengthening epsilon) than the current global bound; if possible, adjusts bound to integral value;\n  also tightens the local bound, if the global bound is better than the local bound\n\n  @warning If SCIP is in presolving stage, it can happen that the internal variable array (which can be accessed via\n           SCIPgetVars()) gets resorted.\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMING\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_SOLVING\n\n  @note During presolving, an integer variable whose bound changes to {0,1} is upgraded to a binary variable."]
    pub fn SCIPtightenVarUbGlobal(
        scip: *mut SCIP,
        var: *mut SCIP_VAR,
        newbound: f64,
        force: ::std::os::raw::c_uint,
        infeasible: *mut ::std::os::raw::c_uint,
        tightened: *mut ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " for a multi-aggregated variable, returns the global lower bound computed by adding the global bounds from all aggregation variables\n\n  This global bound may be tighter than the one given by SCIPvarGetLbGlobal, since the latter is not updated if bounds of aggregation variables are changing\n  calling this function for a non-multi-aggregated variable results in a call to SCIPvarGetLbGlobal.\n\n  @return the global lower bound computed by adding the global bounds from all aggregation variables"]
    pub fn SCIPcomputeVarLbGlobal(scip: *mut SCIP, var: *mut SCIP_VAR) -> f64;
}
extern "C" {
    #[doc = " for a multi-aggregated variable, returns the global upper bound computed by adding the global bounds from all aggregation variables\n\n  This global bound may be tighter than the one given by SCIPvarGetUbGlobal, since the latter is not updated if bounds of aggregation variables are changing\n  calling this function for a non-multi-aggregated variable results in a call to SCIPvarGetUbGlobal.\n\n  @return the global upper bound computed by adding the global bounds from all aggregation variables"]
    pub fn SCIPcomputeVarUbGlobal(scip: *mut SCIP, var: *mut SCIP_VAR) -> f64;
}
extern "C" {
    #[doc = " for a multi-aggregated variable, returns the local lower bound computed by adding the local bounds from all aggregation variables\n\n  This local bound may be tighter than the one given by SCIPvarGetLbLocal, since the latter is not updated if bounds of aggregation variables are changing\n  calling this function for a non-multi-aggregated variable results in a call to SCIPvarGetLbLocal.\n\n  @return the local lower bound computed by adding the global bounds from all aggregation variables"]
    pub fn SCIPcomputeVarLbLocal(scip: *mut SCIP, var: *mut SCIP_VAR) -> f64;
}
extern "C" {
    #[doc = " for a multi-aggregated variable, returns the local upper bound computed by adding the local bounds from all aggregation variables\n\n  This local bound may be tighter than the one given by SCIPvarGetUbLocal, since the latter is not updated if bounds of aggregation variables are changing\n  calling this function for a non-multi-aggregated variable results in a call to SCIPvarGetUbLocal.\n\n  @return the local upper bound computed by adding the global bounds from all aggregation variables"]
    pub fn SCIPcomputeVarUbLocal(scip: *mut SCIP, var: *mut SCIP_VAR) -> f64;
}
extern "C" {
    #[doc = " for a multi-aggregated variable, gives the global lower bound computed by adding the global bounds from all\n  aggregation variables, this global bound may be tighter than the one given by SCIPvarGetLbGlobal, since the latter is\n  not updated if bounds of aggregation variables are changing\n\n  calling this function for a non-multi-aggregated variable is not allowed"]
    pub fn SCIPgetVarMultaggrLbGlobal(scip: *mut SCIP, var: *mut SCIP_VAR) -> f64;
}
extern "C" {
    #[doc = " for a multi-aggregated variable, gives the global upper bound computed by adding the global bounds from all\n  aggregation variables, this upper bound may be tighter than the one given by SCIPvarGetUbGlobal, since the latter is\n  not updated if bounds of aggregation variables are changing\n\n  calling this function for a non-multi-aggregated variable is not allowed"]
    pub fn SCIPgetVarMultaggrUbGlobal(scip: *mut SCIP, var: *mut SCIP_VAR) -> f64;
}
extern "C" {
    #[doc = " for a multi-aggregated variable, gives the local lower bound computed by adding the local bounds from all\n  aggregation variables, this lower bound may be tighter than the one given by SCIPvarGetLbLocal, since the latter is\n  not updated if bounds of aggregation variables are changing\n\n  calling this function for a non-multi-aggregated variable is not allowed"]
    pub fn SCIPgetVarMultaggrLbLocal(scip: *mut SCIP, var: *mut SCIP_VAR) -> f64;
}
extern "C" {
    #[doc = " for a multi-aggregated variable, gives the local upper bound computed by adding the local bounds from all\n  aggregation variables, this upper bound may be tighter than the one given by SCIPvarGetUbLocal, since the latter is\n  not updated if bounds of aggregation variables are changing\n\n  calling this function for a non-multi-aggregated variable is not allowed"]
    pub fn SCIPgetVarMultaggrUbLocal(scip: *mut SCIP, var: *mut SCIP_VAR) -> f64;
}
extern "C" {
    #[doc = " returns solution value and index of variable lower bound that is closest to the variable's value in the given primal\n  solution or current LP solution if no primal solution is given; returns an index of -1 if no variable lower bound is\n  available\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can only be called if @p scip is in stage \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPgetVarClosestVlb(
        scip: *mut SCIP,
        var: *mut SCIP_VAR,
        sol: *mut SCIP_SOL,
        closestvlb: *mut f64,
        closestvlbidx: *mut ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " returns solution value and index of variable upper bound that is closest to the variable's value in the given primal solution;\n  or current LP solution if no primal solution is given; returns an index of -1 if no variable upper bound is available\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can only be called if @p scip is in stage \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPgetVarClosestVub(
        scip: *mut SCIP,
        var: *mut SCIP_VAR,
        sol: *mut SCIP_SOL,
        closestvub: *mut f64,
        closestvubidx: *mut ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " informs variable x about a globally valid variable lower bound x >= b*z + d with integer variable z;\n  if z is binary, the corresponding valid implication for z is also added;\n  if z is non-continuous and 1/b not too small, the corresponding valid upper/lower bound\n  z <= (x-d)/b or z >= (x-d)/b (depending on the sign of of b) is added, too;\n  improves the global bounds of the variable and the vlb variable if possible\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPaddVarVlb(
        scip: *mut SCIP,
        var: *mut SCIP_VAR,
        vlbvar: *mut SCIP_VAR,
        vlbcoef: f64,
        vlbconstant: f64,
        infeasible: *mut ::std::os::raw::c_uint,
        nbdchgs: *mut ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " informs variable x about a globally valid variable upper bound x <= b*z + d with integer variable z;\n  if z is binary, the corresponding valid implication for z is also added;\n  if z is non-continuous and 1/b not too small, the corresponding valid lower/upper bound\n  z >= (x-d)/b or z <= (x-d)/b (depending on the sign of of b) is added, too;\n  improves the global bounds of the variable and the vlb variable if possible\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPaddVarVub(
        scip: *mut SCIP,
        var: *mut SCIP_VAR,
        vubvar: *mut SCIP_VAR,
        vubcoef: f64,
        vubconstant: f64,
        infeasible: *mut ::std::os::raw::c_uint,
        nbdchgs: *mut ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " informs binary variable x about a globally valid implication:  x == 0 or x == 1  ==>  y <= b  or  y >= b;\n  also adds the corresponding implication or variable bound to the implied variable;\n  if the implication is conflicting, the variable is fixed to the opposite value;\n  if the variable is already fixed to the given value, the implication is performed immediately;\n  if the implication is redundant with respect to the variables' global bounds, it is ignored\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPaddVarImplication(
        scip: *mut SCIP,
        var: *mut SCIP_VAR,
        varfixing: ::std::os::raw::c_uint,
        implvar: *mut SCIP_VAR,
        impltype: SCIP_BOUNDTYPE,
        implbound: f64,
        infeasible: *mut ::std::os::raw::c_uint,
        nbdchgs: *mut ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " adds a clique information to SCIP, stating that at most one of the given binary variables can be set to 1;\n  if a variable appears twice in the same clique, the corresponding implications are performed\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPaddClique(
        scip: *mut SCIP,
        vars: *mut *mut SCIP_VAR,
        values: *mut ::std::os::raw::c_uint,
        nvars: ::std::os::raw::c_int,
        isequation: ::std::os::raw::c_uint,
        infeasible: *mut ::std::os::raw::c_uint,
        nbdchgs: *mut ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " calculates a partition of the given set of binary variables into cliques; takes into account independent clique components\n\n  The algorithm performs the following steps:\n  - recomputes connected components of the clique table, if necessary\n  - computes a clique partition for every connected component greedily.\n  - relabels the resulting clique partition such that it satisfies the description below\n\n  afterwards the output array contains one value for each variable, such that two variables got the same value iff they\n  were assigned to the same clique;\n  the first variable is always assigned to clique 0, and a variable can only be assigned to clique i if at least one of\n  the preceding variables was assigned to clique i-1;\n  for each clique at most 1 variables can be set to TRUE in a feasible solution;\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPcalcCliquePartition(
        scip: *mut SCIP,
        vars: *mut *mut SCIP_VAR,
        nvars: ::std::os::raw::c_int,
        cliquepartition: *mut ::std::os::raw::c_int,
        ncliques: *mut ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " calculates a partition of the given set of binary variables into negated cliques;\n  afterwards the output array contains one value for each variable, such that two variables got the same value iff they\n  were assigned to the same negated clique;\n  the first variable is always assigned to clique 0 and a variable can only be assigned to clique i if at least one of\n  the preceding variables was assigned to clique i-1;\n  for each clique with n_c variables at least n_c-1 variables can be set to TRUE in a feasible solution;\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPcalcNegatedCliquePartition(
        scip: *mut SCIP,
        vars: *mut *mut SCIP_VAR,
        nvars: ::std::os::raw::c_int,
        cliquepartition: *mut ::std::os::raw::c_int,
        ncliques: *mut ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " force SCIP to clean up all cliques; cliques do not get automatically cleaned up after presolving. Use\n  this method to prevent inactive variables in cliques when retrieved via SCIPgetCliques()\n\n  @return SCIP_OKAY if everything worked, otherwise a suitable error code is passed\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED\n       - \\ref SCIP_STAGE_EXITSOLVE"]
    pub fn SCIPcleanupCliques(
        scip: *mut SCIP,
        infeasible: *mut ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " gets the number of cliques in the clique table\n\n  @return number of cliques in the clique table\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED\n       - \\ref SCIP_STAGE_EXITSOLVE"]
    pub fn SCIPgetNCliques(scip: *mut SCIP) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " gets the number of cliques created so far by the cliquetable\n\n  @return number of cliques created so far by the cliquetable\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED\n       - \\ref SCIP_STAGE_EXITSOLVE"]
    pub fn SCIPgetNCliquesCreated(scip: *mut SCIP) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " gets the array of cliques in the clique table\n\n  @return array of cliques in the clique table\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED\n       - \\ref SCIP_STAGE_EXITSOLVE"]
    pub fn SCIPgetCliques(scip: *mut SCIP) -> *mut *mut SCIP_CLIQUE;
}
extern "C" {
    #[doc = " returns whether there is a clique that contains both given variable/value pairs;\n  the variables must be active binary variables;\n  if regardimplics is FALSE, only the cliques in the clique table are looked at;\n  if regardimplics is TRUE, both the cliques and the implications of the implication graph are regarded\n\n  @return TRUE, if there is a clique that contains both variable/clique pairs; FALSE, otherwise\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED\n       - \\ref SCIP_STAGE_EXITSOLVE\n\n  @note a variable with it's negated variable are NOT! in a clique\n  @note a variable with itself are in a clique"]
    pub fn SCIPhaveVarsCommonClique(
        scip: *mut SCIP,
        var1: *mut SCIP_VAR,
        value1: ::std::os::raw::c_uint,
        var2: *mut SCIP_VAR,
        value2: ::std::os::raw::c_uint,
        regardimplics: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " writes the clique graph to a gml file\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED\n       - \\ref SCIP_STAGE_EXITSOLVE\n\n  @note there can be duplicated arcs in the output file\n\n  If @p writenodeweights is true, only nodes corresponding to variables that have a fractional value and only edges\n  between such nodes are written."]
    pub fn SCIPwriteCliqueGraph(
        scip: *mut SCIP,
        fname: *const ::std::os::raw::c_char,
        writenodeweights: ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " Removes (irrelevant) variable from all its global structures, i.e. cliques, implications and variable bounds.\n  This is an advanced method which should be used with care.\n\n  @return SCIP_OKAY if everything worked, otherwise a suitable error code is passed\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED\n       - \\ref SCIP_STAGE_EXITSOLVE"]
    pub fn SCIPremoveVarFromGlobalStructures(scip: *mut SCIP, var: *mut SCIP_VAR) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " sets the branch factor of the variable; this value can be used in the branching methods to scale the score\n  values of the variables; higher factor leads to a higher probability that this variable is chosen for branching\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMING\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPchgVarBranchFactor(
        scip: *mut SCIP,
        var: *mut SCIP_VAR,
        branchfactor: f64,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " scales the branch factor of the variable with the given value\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMING\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPscaleVarBranchFactor(
        scip: *mut SCIP,
        var: *mut SCIP_VAR,
        scale: f64,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " adds the given value to the branch factor of the variable\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMING\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPaddVarBranchFactor(
        scip: *mut SCIP,
        var: *mut SCIP_VAR,
        addfactor: f64,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " sets the branch priority of the variable; variables with higher branch priority are always preferred to variables\n  with lower priority in selection of branching variable\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMING\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_SOLVING\n\n @note the default branching priority is 0"]
    pub fn SCIPchgVarBranchPriority(
        scip: *mut SCIP,
        var: *mut SCIP_VAR,
        branchpriority: ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " changes the branch priority of the variable to the given value, if it is larger than the current priority\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMING\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPupdateVarBranchPriority(
        scip: *mut SCIP,
        var: *mut SCIP_VAR,
        branchpriority: ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " adds the given value to the branch priority of the variable\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMING\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPaddVarBranchPriority(
        scip: *mut SCIP,
        var: *mut SCIP_VAR,
        addpriority: ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " sets the branch direction of the variable (-1: prefer downwards branch, 0: automatic selection, +1: prefer upwards\n  branch)\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMING\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPchgVarBranchDirection(
        scip: *mut SCIP,
        var: *mut SCIP_VAR,
        branchdirection: SCIP_BRANCHDIR,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " changes type of variable in the problem;\n\n  @warning This type change might change the variable array returned from SCIPgetVars() and SCIPgetVarsData();\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMING\n       - \\ref SCIP_STAGE_PRESOLVING\n\n  @note If SCIP is already beyond the SCIP_STAGE_PROBLEM and a original variable is passed, the variable type of the\n        corresponding transformed variable is changed; the type of the original variable does not change\n\n  @note If the type changes from a continuous variable to a non-continuous variable the bounds of the variable get\n        adjusted w.r.t. to integrality information"]
    pub fn SCIPchgVarType(
        scip: *mut SCIP,
        var: *mut SCIP_VAR,
        vartype: SCIP_VARTYPE,
        infeasible: *mut ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " in problem creation and solving stage, both bounds of the variable are set to the given value;\n  in presolving stage, the variable is converted into a fixed variable, and bounds are changed respectively;\n  conversion into a fixed variable changes the vars array returned from SCIPgetVars() and SCIPgetVarsData(),\n  and also renders arrays returned from the SCIPvarGetImpl...() methods invalid\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPfixVar(
        scip: *mut SCIP,
        var: *mut SCIP_VAR,
        fixedval: f64,
        infeasible: *mut ::std::os::raw::c_uint,
        fixed: *mut ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " From a given equality a*x + b*y == c, aggregates one of the variables and removes it from the set of\n  active problem variables. This changes the vars array returned from SCIPgetVars() and SCIPgetVarsData(),\n  and also renders the arrays returned from the SCIPvarGetImpl...() methods for the two variables invalid.\n  In the first step, the equality is transformed into an equality with active problem variables\n  a'*x' + b'*y' == c'. If x' == y', this leads to the detection of redundancy if a' == -b' and c' == 0,\n  of infeasibility, if a' == -b' and c' != 0, or to a variable fixing x' == c'/(a'+b') (and possible\n  infeasibility) otherwise.\n  In the second step, the variable to be aggregated is chosen among x' and y', prefering a less strict variable\n  type as aggregation variable (i.e. continuous variables are preferred over implicit integers, implicit integers\n  over integers, and integers over binaries). If none of the variables is continuous, it is tried to find an integer\n  aggregation (i.e. integral coefficients a'' and b'', such that a''*x' + b''*y' == c''). This can lead to\n  the detection of infeasibility (e.g. if c'' is fractional), or to a rejection of the aggregation (denoted by\n  aggregated == FALSE), if the resulting integer coefficients are too large and thus numerically instable.\n\n  The output flags have the following meaning:\n  - infeasible: the problem is infeasible\n  - redundant:  the equality can be deleted from the constraint set\n  - aggregated: the aggregation was successfully performed (the variables were not aggregated before)\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can only be called if @p scip is in stage \\ref SCIP_STAGE_PRESOLVING"]
    pub fn SCIPaggregateVars(
        scip: *mut SCIP,
        varx: *mut SCIP_VAR,
        vary: *mut SCIP_VAR,
        scalarx: f64,
        scalary: f64,
        rhs: f64,
        infeasible: *mut ::std::os::raw::c_uint,
        redundant: *mut ::std::os::raw::c_uint,
        aggregated: *mut ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " converts variable into multi-aggregated variable; this changes the variable array returned from\n  SCIPgetVars() and SCIPgetVarsData();\n\n  @warning The integrality condition is not checked anymore on the multi-aggregated variable. You must not\n           multi-aggregate an integer variable without being sure, that integrality on the aggregation variables\n           implies integrality on the aggregated variable.\n\n  The output flags have the following meaning:\n  - infeasible: the problem is infeasible\n  - aggregated: the aggregation was successfully performed (the variables were not aggregated before)\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can only be called if @p scip is in stage \\ref SCIP_STAGE_PRESOLVING"]
    pub fn SCIPmultiaggregateVar(
        scip: *mut SCIP,
        var: *mut SCIP_VAR,
        naggvars: ::std::os::raw::c_int,
        aggvars: *mut *mut SCIP_VAR,
        scalars: *mut f64,
        constant: f64,
        infeasible: *mut ::std::os::raw::c_uint,
        aggregated: *mut ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " returns whether aggregation of variables is not allowed"]
    pub fn SCIPdoNotAggr(scip: *mut SCIP) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " returns whether multi-aggregation is disabled"]
    pub fn SCIPdoNotMultaggr(scip: *mut SCIP) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " returns whether variable is not allowed to be aggregated"]
    pub fn SCIPdoNotAggrVar(scip: *mut SCIP, var: *mut SCIP_VAR) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " returns whether variable is not allowed to be multi-aggregated"]
    pub fn SCIPdoNotMultaggrVar(scip: *mut SCIP, var: *mut SCIP_VAR) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " returns whether dual reductions are allowed during propagation and presolving\n\n  @deprecated Please use SCIPallowStrongDualReds()"]
    pub fn SCIPallowDualReds(scip: *mut SCIP) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " returns whether strong dual reductions are allowed during propagation and presolving\n\n  @note A reduction is called strong dual, if it may discard feasible/optimal solutions, but leaves at least one\n        optimal solution intact. Often such reductions are based on analyzing the objective function and variable\n        locks."]
    pub fn SCIPallowStrongDualReds(scip: *mut SCIP) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " returns whether propagation w.r.t. current objective is allowed\n\n  @deprecated Please use SCIPallowWeakDualReds()"]
    pub fn SCIPallowObjProp(scip: *mut SCIP) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " returns whether weak dual reductions are allowed during propagation and presolving\n\n  @note A reduction is called weak dual, if it may discard feasible solutions, but leaves at all optimal solutions\n        intact. Often such reductions are based on analyzing the objective function, reduced costs, and/or dual LPs."]
    pub fn SCIPallowWeakDualReds(scip: *mut SCIP) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " marks the variable that it must not be aggregated\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_INIT\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMING\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n\n  @note There exists no \"unmark\" method since it has to be ensured that if a plugin requires that a variable is not\n        aggregated that this is will be the case."]
    pub fn SCIPmarkDoNotAggrVar(scip: *mut SCIP, var: *mut SCIP_VAR) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " marks the variable that it must not be multi-aggregated\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_INIT\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMING\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n\n  @note There exists no \"unmark\" method since it has to be ensured that if a plugin requires that a variable is not\n        multi-aggregated that this is will be the case."]
    pub fn SCIPmarkDoNotMultaggrVar(scip: *mut SCIP, var: *mut SCIP_VAR) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " enables the collection of statistics for a variable\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPenableVarHistory(scip: *mut SCIP);
}
extern "C" {
    #[doc = " disables the collection of any statistic for a variable\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPdisableVarHistory(scip: *mut SCIP);
}
extern "C" {
    #[doc = " updates the pseudo costs of the given variable and the global pseudo costs after a change of \"solvaldelta\" in the\n  variable's solution value and resulting change of \"objdelta\" in the in the LP's objective value;\n  the update is ignored, if the objective value difference is infinite\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPupdateVarPseudocost(
        scip: *mut SCIP,
        var: *mut SCIP_VAR,
        solvaldelta: f64,
        objdelta: f64,
        weight: f64,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " gets the variable's pseudo cost value for the given change of the variable's LP value\n\n  @return the variable's pseudo cost value for the given change of the variable's LP value\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPgetVarPseudocostVal(scip: *mut SCIP, var: *mut SCIP_VAR, solvaldelta: f64) -> f64;
}
extern "C" {
    #[doc = " gets the variable's pseudo cost value for the given change of the variable's LP value,\n  only using the pseudo cost information of the current run\n\n  @return the variable's pseudo cost value for the given change of the variable's LP value,\n  only using the pseudo cost information of the current run\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPgetVarPseudocostValCurrentRun(
        scip: *mut SCIP,
        var: *mut SCIP_VAR,
        solvaldelta: f64,
    ) -> f64;
}
extern "C" {
    #[doc = " gets the variable's pseudo cost value for the given direction\n\n  @return the variable's pseudo cost value for the given direction\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPgetVarPseudocost(scip: *mut SCIP, var: *mut SCIP_VAR, dir: SCIP_BRANCHDIR) -> f64;
}
extern "C" {
    #[doc = " gets the variable's pseudo cost value for the given direction,\n  only using the pseudo cost information of the current run\n\n  @return the variable's pseudo cost value for the given direction,\n  only using the pseudo cost information of the current run\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPgetVarPseudocostCurrentRun(
        scip: *mut SCIP,
        var: *mut SCIP_VAR,
        dir: SCIP_BRANCHDIR,
    ) -> f64;
}
extern "C" {
    #[doc = " gets the variable's (possible fractional) number of pseudo cost updates for the given direction\n\n  @return the variable's (possible fractional) number of pseudo cost updates for the given direction\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPgetVarPseudocostCount(
        scip: *mut SCIP,
        var: *mut SCIP_VAR,
        dir: SCIP_BRANCHDIR,
    ) -> f64;
}
extern "C" {
    #[doc = " gets the variable's (possible fractional) number of pseudo cost updates for the given direction,\n  only using the pseudo cost information of the current run\n\n  @return the variable's (possible fractional) number of pseudo cost updates for the given direction,\n  only using the pseudo cost information of the current run\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPgetVarPseudocostCountCurrentRun(
        scip: *mut SCIP,
        var: *mut SCIP_VAR,
        dir: SCIP_BRANCHDIR,
    ) -> f64;
}
extern "C" {
    #[doc = " get pseudo cost variance of the variable, either for entire solve or only for current branch and bound run\n\n  @return returns the (corrected) variance of pseudo code information collected so far.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPgetVarPseudocostVariance(
        scip: *mut SCIP,
        var: *mut SCIP_VAR,
        dir: SCIP_BRANCHDIR,
        onlycurrentrun: ::std::os::raw::c_uint,
    ) -> f64;
}
extern "C" {
    #[doc = " calculates a confidence bound for this variable under the assumption of normally distributed pseudo costs\n\n  The confidence bound \\f$ \\theta \\geq 0\\f$ denotes the interval borders \\f$ [X - \\theta, \\ X + \\theta]\\f$, which contains\n  the true pseudo costs of the variable, i.e., the expected value of the normal distribution, with a probability\n  of 2 * clevel - 1.\n\n  @return value of confidence bound for this variable"]
    pub fn SCIPcalculatePscostConfidenceBound(
        scip: *mut SCIP,
        var: *mut SCIP_VAR,
        dir: SCIP_BRANCHDIR,
        onlycurrentrun: ::std::os::raw::c_uint,
        clevel: SCIP_CONFIDENCELEVEL,
    ) -> f64;
}
extern "C" {
    #[doc = " check if variable pseudo-costs have a significant difference in location. The significance depends on\n  the choice of \\p clevel and on the kind of tested hypothesis. The one-sided hypothesis, which\n  should be rejected, is that fracy * mu_y >= fracx * mu_x, where mu_y and mu_x denote the\n  unknown location means of the underlying pseudo-cost distributions of x and y.\n\n  This method is applied best if variable x has a better pseudo-cost score than y. The method hypothesizes that y were actually\n  better than x (despite the current information), meaning that y can be expected to yield branching\n  decisions as least as good as x in the long run. If the method returns TRUE, the current history information is\n  sufficient to safely rely on the alternative hypothesis that x yields indeed a better branching score (on average)\n  than y.\n\n  @note The order of x and y matters for the one-sided hypothesis\n\n  @note set \\p onesided to FALSE if you are not sure which variable is better. The hypothesis tested then reads\n        fracy * mu_y == fracx * mu_x vs the alternative hypothesis fracy * mu_y != fracx * mu_x.\n\n  @return TRUE if the hypothesis can be safely rejected at the given confidence level"]
    pub fn SCIPsignificantVarPscostDifference(
        scip: *mut SCIP,
        varx: *mut SCIP_VAR,
        fracx: f64,
        vary: *mut SCIP_VAR,
        fracy: f64,
        dir: SCIP_BRANCHDIR,
        clevel: SCIP_CONFIDENCELEVEL,
        onesided: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " tests at a given confidence level whether the variable pseudo-costs only have a small probability to\n  exceed a \\p threshold. This is useful to determine if past observations provide enough evidence\n  to skip an expensive strong-branching step if there is already a candidate that has been proven to yield an improvement\n  of at least \\p threshold.\n\n  @note use \\p clevel to adjust the level of confidence. For SCIP_CONFIDENCELEVEL_MIN, the method returns TRUE if\n        the estimated probability to exceed \\p threshold is less than 25 %.\n\n  @see  SCIP_Confidencelevel for a list of available levels. The used probability limits refer to the one-sided levels\n        of confidence.\n\n  @return TRUE if the variable pseudo-cost probabilistic model is likely to be smaller than \\p threshold\n          at the given confidence level \\p clevel."]
    pub fn SCIPpscostThresholdProbabilityTest(
        scip: *mut SCIP,
        var: *mut SCIP_VAR,
        frac: f64,
        threshold: f64,
        dir: SCIP_BRANCHDIR,
        clevel: SCIP_CONFIDENCELEVEL,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " check if the current pseudo cost relative error in a direction violates the given threshold. The Relative\n  Error is calculated at a specific confidence level\n\n  @return TRUE if relative error in variable pseudo costs is smaller than \\p threshold"]
    pub fn SCIPisVarPscostRelerrorReliable(
        scip: *mut SCIP,
        var: *mut SCIP_VAR,
        threshold: f64,
        clevel: SCIP_CONFIDENCELEVEL,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " gets the variable's pseudo cost score value for the given LP solution value\n\n  @return the variable's pseudo cost score value for the given LP solution value\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPgetVarPseudocostScore(scip: *mut SCIP, var: *mut SCIP_VAR, solval: f64) -> f64;
}
extern "C" {
    #[doc = " gets the variable's pseudo cost score value for the given LP solution value,\n  only using the pseudo cost information of the current run\n\n  @return the variable's pseudo cost score value for the given LP solution value,\n  only using the pseudo cost information of the current run\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPgetVarPseudocostScoreCurrentRun(
        scip: *mut SCIP,
        var: *mut SCIP_VAR,
        solval: f64,
    ) -> f64;
}
extern "C" {
    #[doc = " returns the variable's VSIDS value\n\n  @return the variable's VSIDS value\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPgetVarVSIDS(scip: *mut SCIP, var: *mut SCIP_VAR, dir: SCIP_BRANCHDIR) -> f64;
}
extern "C" {
    #[doc = " returns the variable's VSIDS value only using conflicts of the current run\n\n  @return the variable's VSIDS value only using conflicts of the current run\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPgetVarVSIDSCurrentRun(
        scip: *mut SCIP,
        var: *mut SCIP_VAR,
        dir: SCIP_BRANCHDIR,
    ) -> f64;
}
extern "C" {
    #[doc = " returns the variable's conflict score value\n\n  @return the variable's conflict score value\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPgetVarConflictScore(scip: *mut SCIP, var: *mut SCIP_VAR) -> f64;
}
extern "C" {
    #[doc = " returns the variable's conflict score value only using conflicts of the current run\n\n  @return the variable's conflict score value only using conflicts of the current run\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPgetVarConflictScoreCurrentRun(scip: *mut SCIP, var: *mut SCIP_VAR) -> f64;
}
extern "C" {
    #[doc = " returns the variable's conflict length score\n\n  @return the variable's conflict length score\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPgetVarConflictlengthScore(scip: *mut SCIP, var: *mut SCIP_VAR) -> f64;
}
extern "C" {
    #[doc = " returns the variable's conflict length score only using conflicts of the current run\n\n  @return the variable's conflict length score only using conflicts of the current run\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPgetVarConflictlengthScoreCurrentRun(scip: *mut SCIP, var: *mut SCIP_VAR) -> f64;
}
extern "C" {
    #[doc = " returns the variable's average conflict length\n\n  @return the variable's average conflict length\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPgetVarAvgConflictlength(
        scip: *mut SCIP,
        var: *mut SCIP_VAR,
        dir: SCIP_BRANCHDIR,
    ) -> f64;
}
extern "C" {
    #[doc = " returns the variable's average  conflict length only using conflicts of the current run\n\n  @return the variable's average conflict length only using conflicts of the current run\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPgetVarAvgConflictlengthCurrentRun(
        scip: *mut SCIP,
        var: *mut SCIP_VAR,
        dir: SCIP_BRANCHDIR,
    ) -> f64;
}
extern "C" {
    #[doc = " returns the average number of inferences found after branching on the variable in given direction;\n  if branching on the variable in the given direction was yet evaluated, the average number of inferences\n  over all variables for branching in the given direction is returned\n\n  @return the average number of inferences found after branching on the variable in given direction\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPgetVarAvgInferences(scip: *mut SCIP, var: *mut SCIP_VAR, dir: SCIP_BRANCHDIR)
        -> f64;
}
extern "C" {
    #[doc = " returns the average number of inferences found after branching on the variable in given direction in the current run;\n  if branching on the variable in the given direction was yet evaluated, the average number of inferences\n  over all variables for branching in the given direction is returned\n\n  @return the average number of inferences found after branching on the variable in given direction in the current run\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPgetVarAvgInferencesCurrentRun(
        scip: *mut SCIP,
        var: *mut SCIP_VAR,
        dir: SCIP_BRANCHDIR,
    ) -> f64;
}
extern "C" {
    #[doc = " returns the variable's average inference score value\n\n  @return the variable's average inference score value\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPgetVarAvgInferenceScore(scip: *mut SCIP, var: *mut SCIP_VAR) -> f64;
}
extern "C" {
    #[doc = " returns the variable's average inference score value only using inferences of the current run\n\n  @return the variable's average inference score value only using inferences of the current run\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPgetVarAvgInferenceScoreCurrentRun(scip: *mut SCIP, var: *mut SCIP_VAR) -> f64;
}
extern "C" {
    #[doc = " initializes the upwards and downwards pseudocosts, conflict scores, conflict lengths, inference scores, cutoff scores\n  of a variable to the given values\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPinitVarBranchStats(
        scip: *mut SCIP,
        var: *mut SCIP_VAR,
        downpscost: f64,
        uppscost: f64,
        downvsids: f64,
        upvsids: f64,
        downconflen: f64,
        upconflen: f64,
        downinfer: f64,
        upinfer: f64,
        downcutoff: f64,
        upcutoff: f64,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " initializes the upwards and downwards conflict scores, conflict lengths, inference scores, cutoff scores of a\n  variable w.r.t. a value by the given values (SCIP_VALUEHISTORY)\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPinitVarValueBranchStats(
        scip: *mut SCIP,
        var: *mut SCIP_VAR,
        value: f64,
        downvsids: f64,
        upvsids: f64,
        downconflen: f64,
        upconflen: f64,
        downinfer: f64,
        upinfer: f64,
        downcutoff: f64,
        upcutoff: f64,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " returns the average number of cutoffs found after branching on the variable in given direction;\n  if branching on the variable in the given direction was yet evaluated, the average number of cutoffs\n  over all variables for branching in the given direction is returned\n\n  @return the average number of cutoffs found after branching on the variable in given direction\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPgetVarAvgCutoffs(scip: *mut SCIP, var: *mut SCIP_VAR, dir: SCIP_BRANCHDIR) -> f64;
}
extern "C" {
    #[doc = " returns the average number of cutoffs found after branching on the variable in given direction in the current run;\n  if branching on the variable in the given direction was yet evaluated, the average number of cutoffs\n  over all variables for branching in the given direction is returned\n\n  @return the average number of cutoffs found after branching on the variable in given direction in the current run\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPgetVarAvgCutoffsCurrentRun(
        scip: *mut SCIP,
        var: *mut SCIP_VAR,
        dir: SCIP_BRANCHDIR,
    ) -> f64;
}
extern "C" {
    #[doc = " returns the variable's average cutoff score value\n\n  @return the variable's average cutoff score value\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPgetVarAvgCutoffScore(scip: *mut SCIP, var: *mut SCIP_VAR) -> f64;
}
extern "C" {
    #[doc = " returns the variable's average cutoff score value, only using cutoffs of the current run\n\n  @return the variable's average cutoff score value, only using cutoffs of the current run\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPgetVarAvgCutoffScoreCurrentRun(scip: *mut SCIP, var: *mut SCIP_VAR) -> f64;
}
extern "C" {
    #[doc = " returns the variable's average inference/cutoff score value, weighting the cutoffs of the variable with the given\n  factor\n\n  @return the variable's average inference/cutoff score value\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPgetVarAvgInferenceCutoffScore(
        scip: *mut SCIP,
        var: *mut SCIP_VAR,
        cutoffweight: f64,
    ) -> f64;
}
extern "C" {
    #[doc = " returns the variable's average inference/cutoff score value, weighting the cutoffs of the variable with the given\n  factor, only using inferences and cutoffs of the current run\n\n  @return the variable's average inference/cutoff score value, only using inferences and cutoffs of the current run\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPgetVarAvgInferenceCutoffScoreCurrentRun(
        scip: *mut SCIP,
        var: *mut SCIP_VAR,
        cutoffweight: f64,
    ) -> f64;
}
extern "C" {
    #[doc = " returns the variable's average GMI efficacy score value\n\n  @return the variable's average GMI efficacy score value (for when it was fractional and basic in the LP)\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPgetVarAvgGMIScore(scip: *mut SCIP, var: *mut SCIP_VAR) -> f64;
}
extern "C" {
    #[doc = " sets the variable's avg GMI efficacy score value\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPincVarGMISumScore(scip: *mut SCIP, var: *mut SCIP_VAR, gmieff: f64) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " returns the variable's last GMI efficacy score value\n\n  @return the variable's last GMI efficacy score value (for when it was fractional and basic in the LP)\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPgetVarLastGMIScore(scip: *mut SCIP, var: *mut SCIP_VAR) -> f64;
}
extern "C" {
    #[doc = " sets the variable's last GMI efficacy score value\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPsetVarLastGMIScore(scip: *mut SCIP, var: *mut SCIP_VAR, gmieff: f64)
        -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " outputs variable information to file stream via the message system\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMING\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED\n       - \\ref SCIP_STAGE_EXITSOLVE\n       - \\ref SCIP_STAGE_FREETRANS\n\n  @note If the message handler is set to a NULL pointer nothing will be printed"]
    pub fn SCIPprintVar(scip: *mut SCIP, var: *mut SCIP_VAR, file: *mut FILE) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " Selects a variable from a set of candidates by strong branching\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n @note The variables in the lpcands array must have a fractional value in the current LP solution"]
    pub fn SCIPselectVarPseudoStrongBranching(
        scip: *mut SCIP,
        pseudocands: *mut *mut SCIP_VAR,
        skipdown: *mut ::std::os::raw::c_uint,
        skipup: *mut ::std::os::raw::c_uint,
        npseudocands: ::std::os::raw::c_int,
        npriopseudocands: ::std::os::raw::c_int,
        bestpseudocand: *mut ::std::os::raw::c_int,
        bestdown: *mut f64,
        bestup: *mut f64,
        bestscore: *mut f64,
        bestdownvalid: *mut ::std::os::raw::c_uint,
        bestupvalid: *mut ::std::os::raw::c_uint,
        provedbound: *mut f64,
        result: *mut SCIP_RESULT,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " creates the all variables full strong LP branching rule and includes it in SCIP"]
    pub fn SCIPincludeBranchruleAllfullstrong(scip: *mut SCIP) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " creates the cloud branching rule and includes it in SCIP\n\n  @ingroup BranchingRuleIncludes"]
    pub fn SCIPincludeBranchruleCloud(scip: *mut SCIP) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " creates the distribution branching rule and includes it in SCIP\n\n  @ingroup BranchingRuleIncludes"]
    pub fn SCIPincludeBranchruleDistribution(scip: *mut SCIP) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " calculate the variable's distribution parameters (mean and variance) for the bounds specified in the arguments.\n  special treatment of infinite bounds necessary"]
    pub fn SCIPvarCalcDistributionParameters(
        scip: *mut SCIP,
        varlb: f64,
        varub: f64,
        vartype: SCIP_VARTYPE,
        mean: *mut f64,
        variance: *mut f64,
    );
}
extern "C" {
    #[doc = " calculates the cumulative distribution P(-infinity <= x <= value) that a normally distributed\n  random variable x takes a value between -infinity and parameter \\p value.\n\n  The distribution is given by the respective mean and deviation. This implementation\n  uses the error function erf()."]
    pub fn SCIPcalcCumulativeDistribution(
        scip: *mut SCIP,
        mean: f64,
        variance: f64,
        value: f64,
    ) -> f64;
}
extern "C" {
    #[doc = " calculates the probability of satisfying an LP-row under the assumption\n  of uniformly distributed variable values.\n\n  For inequalities, we use the cumulative distribution function of the standard normal\n  distribution PHI(rhs - mu/sqrt(sigma2)) to calculate the probability\n  for a right hand side row with mean activity mu and variance sigma2 to be satisfied.\n  Similarly, 1 - PHI(lhs - mu/sqrt(sigma2)) is the probability to satisfy a left hand side row.\n  For equations (lhs==rhs), we use the centeredness measure p = min(PHI(lhs'), 1-PHI(lhs'))/max(PHI(lhs'), 1 - PHI(lhs')),\n  where lhs' = lhs - mu / sqrt(sigma2)."]
    pub fn SCIProwCalcProbability(
        scip: *mut SCIP,
        row: *mut SCIP_ROW,
        mu: f64,
        sigma2: f64,
        rowinfinitiesdown: ::std::os::raw::c_int,
        rowinfinitiesup: ::std::os::raw::c_int,
    ) -> f64;
}
extern "C" {
    #[doc = " update the up- and downscore of a single variable after calculating the impact of branching on a\n  particular row, depending on the chosen score parameter"]
    pub fn SCIPupdateDistributionScore(
        scip: *mut SCIP,
        currentprob: f64,
        newprobup: f64,
        newprobdown: f64,
        upscore: *mut f64,
        downscore: *mut f64,
        scoreparam: ::std::os::raw::c_char,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " creates the full strong LP branching rule and includes it in SCIP\n\n  @ingroup BranchingRuleIncludes"]
    pub fn SCIPincludeBranchruleFullstrong(scip: *mut SCIP) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " Selects a variable from a set of candidates by strong branching\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n @note The variables in the lpcands array must have a fractional value in the current LP solution"]
    pub fn SCIPselectVarStrongBranching(
        scip: *mut SCIP,
        lpcands: *mut *mut SCIP_VAR,
        lpcandssol: *mut f64,
        lpcandsfrac: *mut f64,
        skipdown: *mut ::std::os::raw::c_uint,
        skipup: *mut ::std::os::raw::c_uint,
        nlpcands: ::std::os::raw::c_int,
        npriolpcands: ::std::os::raw::c_int,
        ncomplete: ::std::os::raw::c_int,
        start: *mut ::std::os::raw::c_int,
        maxproprounds: ::std::os::raw::c_int,
        probingbounds: ::std::os::raw::c_uint,
        forcestrongbranch: ::std::os::raw::c_uint,
        bestcand: *mut ::std::os::raw::c_int,
        bestdown: *mut f64,
        bestup: *mut f64,
        bestscore: *mut f64,
        bestdownvalid: *mut ::std::os::raw::c_uint,
        bestupvalid: *mut ::std::os::raw::c_uint,
        provedbound: *mut f64,
        result: *mut SCIP_RESULT,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " creates the Gomory cut branching rule and includes it in SCIP\n\n  @ingroup BranchingRuleIncludes"]
    pub fn SCIPincludeBranchruleGomory(scip: *mut SCIP) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " creates the inference history branching rule and includes it in SCIP\n\n  @ingroup BranchingRuleIncludes"]
    pub fn SCIPincludeBranchruleInference(scip: *mut SCIP) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " creates the least infeasible LP branching rule and includes it in SCIP\n\n  @ingroup BranchingRuleIncludes"]
    pub fn SCIPincludeBranchruleLeastinf(scip: *mut SCIP) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " creates the lookahead branching rule and includes it in SCIP"]
    pub fn SCIPincludeBranchruleLookahead(scip: *mut SCIP) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " creates the most infeasible LP branching rule and includes it in SCIP\n\n  @ingroup BranchingRuleIncludes"]
    pub fn SCIPincludeBranchruleMostinf(scip: *mut SCIP) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " creates the multi-aggregated branching rule and includes it in SCIP\n\n  @ingroup BranchingRuleIncludes"]
    pub fn SCIPincludeBranchruleMultAggr(scip: *mut SCIP) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " creates the nodereopt branching rule and includes it in SCIP\n\n  @ingroup BranchingRuleIncludes"]
    pub fn SCIPincludeBranchruleNodereopt(scip: *mut SCIP) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " creates the pseudo cost branching rule and includes it in SCIP\n\n   @ingroup BranchingRuleIncludes"]
    pub fn SCIPincludeBranchrulePscost(scip: *mut SCIP) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " selects a branching variable, due to pseudo cost, from the given candidate array and returns this variable together\n  with a branching point"]
    pub fn SCIPselectBranchVarPscost(
        scip: *mut SCIP,
        branchcands: *mut *mut SCIP_VAR,
        branchcandssol: *mut f64,
        branchcandsscore: *mut f64,
        nbranchcands: ::std::os::raw::c_int,
        var: *mut *mut SCIP_VAR,
        brpoint: *mut f64,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " creates the random branching rule and includes it in SCIP\n\n  @ingroup BranchingRuleIncludes"]
    pub fn SCIPincludeBranchruleRandom(scip: *mut SCIP) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " creates the reliable pseudo cost branching rule and includes it in SCIP\n\n  @ingroup BranchingRuleIncludes"]
    pub fn SCIPincludeBranchruleRelpscost(scip: *mut SCIP) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " execution reliability pseudo cost branching with the given branching candidates"]
    pub fn SCIPexecRelpscostBranching(
        scip: *mut SCIP,
        branchcands: *mut *mut SCIP_VAR,
        branchcandssol: *mut f64,
        branchcandsfrac: *mut f64,
        nbranchcands: ::std::os::raw::c_int,
        executebranching: ::std::os::raw::c_uint,
        result: *mut SCIP_RESULT,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " creates the vanilla full strong branching rule and includes it in SCIP\n\n  @ingroup BranchingRuleIncludes"]
    pub fn SCIPincludeBranchruleVanillafullstrong(scip: *mut SCIP) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " recovers candidate variables and their scores from last vanilla full strong branching call"]
    pub fn SCIPgetVanillafullstrongData(
        scip: *mut SCIP,
        cands: *mut *mut *mut SCIP_VAR,
        candscores: *mut *mut f64,
        ncands: *mut ::std::os::raw::c_int,
        npriocands: *mut ::std::os::raw::c_int,
        bestcand: *mut ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " creates the largestrepr tree compression and includes it in SCIP"]
    pub fn SCIPincludeComprLargestrepr(scip: *mut SCIP) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " creates the weakcompr tree compression and includes it in SCIP"]
    pub fn SCIPincludeComprWeakcompr(scip: *mut SCIP) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " creates the handler for and constraints and includes it in SCIP\n\n @ingroup ConshdlrIncludes"]
    pub fn SCIPincludeConshdlrAnd(scip: *mut SCIP) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " creates and captures an and constraint\n\n  @note the constraint gets captured, hence at one point you have to release it using the method SCIPreleaseCons()"]
    pub fn SCIPcreateConsAnd(
        scip: *mut SCIP,
        cons: *mut *mut SCIP_CONS,
        name: *const ::std::os::raw::c_char,
        resvar: *mut SCIP_VAR,
        nvars: ::std::os::raw::c_int,
        vars: *mut *mut SCIP_VAR,
        initial: ::std::os::raw::c_uint,
        separate: ::std::os::raw::c_uint,
        enforce: ::std::os::raw::c_uint,
        check: ::std::os::raw::c_uint,
        propagate: ::std::os::raw::c_uint,
        local: ::std::os::raw::c_uint,
        modifiable: ::std::os::raw::c_uint,
        dynamic: ::std::os::raw::c_uint,
        removable: ::std::os::raw::c_uint,
        stickingatnode: ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " creates and captures an and constraint\n  in its most basic version, i. e., all constraint flags are set to their basic value as explained for the\n  method SCIPcreateConsAnd(); all flags can be set via SCIPsetConsFLAGNAME-methods in scip.h\n\n  @see SCIPcreateConsAnd() for information about the basic constraint flag configuration\n\n  @note the constraint gets captured, hence at one point you have to release it using the method SCIPreleaseCons()"]
    pub fn SCIPcreateConsBasicAnd(
        scip: *mut SCIP,
        cons: *mut *mut SCIP_CONS,
        name: *const ::std::os::raw::c_char,
        resvar: *mut SCIP_VAR,
        nvars: ::std::os::raw::c_int,
        vars: *mut *mut SCIP_VAR,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " gets number of variables in and constraint"]
    pub fn SCIPgetNVarsAnd(scip: *mut SCIP, cons: *mut SCIP_CONS) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " gets array of variables in and constraint"]
    pub fn SCIPgetVarsAnd(scip: *mut SCIP, cons: *mut SCIP_CONS) -> *mut *mut SCIP_VAR;
}
extern "C" {
    #[doc = " gets the resultant variable in and constraint"]
    pub fn SCIPgetResultantAnd(scip: *mut SCIP, cons: *mut SCIP_CONS) -> *mut SCIP_VAR;
}
extern "C" {
    #[doc = " return if the variables of the AND-constraint are sorted with respect to their indices"]
    pub fn SCIPisAndConsSorted(scip: *mut SCIP, cons: *mut SCIP_CONS) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " sort the variables of the AND-constraint with respect to their indices"]
    pub fn SCIPsortAndCons(scip: *mut SCIP, cons: *mut SCIP_CONS) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " when 'upgrading' the given AND-constraint, should the check flag for the upgraded constraint be set to TRUE, even if\n  the check flag of this AND-constraint is set to FALSE?"]
    pub fn SCIPchgAndConsCheckFlagWhenUpgr(
        scip: *mut SCIP,
        cons: *mut SCIP_CONS,
        flag: ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " when 'upgrading' the given AND-constraint, should the removable flag for the upgraded constraint be set to FALSE,\n  even if the removable flag of this AND-constraint is set to TRUE?"]
    pub fn SCIPchgAndConsRemovableFlagWhenUpgr(
        scip: *mut SCIP,
        cons: *mut SCIP_CONS,
        flag: ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " creates the handler for Benders' decomposition and includes it in SCIP\n\n @ingroup ConshdlrIncludes"]
    pub fn SCIPincludeConshdlrBenders(scip: *mut SCIP) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " enforces Benders' constraints for given solution\n\n  This method is called from cons_benderslp and cons_benders. If the method is called from cons_benderslp, then the\n  solutions are not guaranteed to be integer feasible. This is because the default priority is set greater than the\n  integer constraint handler. If this method is called from cons_benders, then, because the default enforcement\n  priority is set less than that of the integer constraint handler, then it can be assumed that the solutions are\n  integer feasible.\n\n  The checkint flag indicates whether integer feasibility can be assumed. If it is not assumed, i.e. checkint ==\n  FALSE, then only the convex relaxations of the subproblems are solved. If integer feasibility is assumed, i.e.\n  checkint == TRUE, then the convex relaxations and the full CIP are solved to generate Benders' cuts and check\n  solution feasibility."]
    pub fn SCIPconsBendersEnforceSolution(
        scip: *mut SCIP,
        sol: *mut SCIP_SOL,
        conshdlr: *mut SCIP_CONSHDLR,
        result: *mut SCIP_RESULT,
        type_: SCIP_BENDERSENFOTYPE,
        checkint: ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " creates the handler for benderslp constraints and includes it in SCIP\n\n @ingroup ConshdlrIncludes"]
    pub fn SCIPincludeConshdlrBenderslp(scip: *mut SCIP) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " creates the handler for bound disjunction constraints and includes it in SCIP\n\n @ingroup ConshdlrIncludes"]
    pub fn SCIPincludeConshdlrBounddisjunction(scip: *mut SCIP) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " creates and captures a bound disjunction constraint\n\n  @note the constraint gets captured, hence at one point you have to release it using the method SCIPreleaseCons()"]
    pub fn SCIPcreateConsBounddisjunction(
        scip: *mut SCIP,
        cons: *mut *mut SCIP_CONS,
        name: *const ::std::os::raw::c_char,
        nvars: ::std::os::raw::c_int,
        vars: *mut *mut SCIP_VAR,
        boundtypes: *mut SCIP_BOUNDTYPE,
        bounds: *mut f64,
        initial: ::std::os::raw::c_uint,
        separate: ::std::os::raw::c_uint,
        enforce: ::std::os::raw::c_uint,
        check: ::std::os::raw::c_uint,
        propagate: ::std::os::raw::c_uint,
        local: ::std::os::raw::c_uint,
        modifiable: ::std::os::raw::c_uint,
        dynamic: ::std::os::raw::c_uint,
        removable: ::std::os::raw::c_uint,
        stickingatnode: ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " creates and captures an and constraint\n  in its most basic version, i. e., all constraint flags are set to their basic value as explained for the\n  method SCIPcreateConsBounddisjunction(); all flags can be set via SCIPsetConsFLAGNAME-methods in scip.h\n\n  @see SCIPcreateConsBounddisjunction() for information about the basic constraint flag configuration\n\n  @note the constraint gets captured, hence at one point you have to release it using the method SCIPreleaseCons()"]
    pub fn SCIPcreateConsBasicBounddisjunction(
        scip: *mut SCIP,
        cons: *mut *mut SCIP_CONS,
        name: *const ::std::os::raw::c_char,
        nvars: ::std::os::raw::c_int,
        vars: *mut *mut SCIP_VAR,
        boundtypes: *mut SCIP_BOUNDTYPE,
        bounds: *mut f64,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " creates and captures a bound disjunction constraint with possibly redundant literals\n\n  @note the constraint gets captured, hence at one point you have to release it using the method SCIPreleaseCons()"]
    pub fn SCIPcreateConsBounddisjunctionRedundant(
        scip: *mut SCIP,
        cons: *mut *mut SCIP_CONS,
        name: *const ::std::os::raw::c_char,
        nvars: ::std::os::raw::c_int,
        vars: *mut *mut SCIP_VAR,
        boundtypes: *mut SCIP_BOUNDTYPE,
        bounds: *mut f64,
        initial: ::std::os::raw::c_uint,
        separate: ::std::os::raw::c_uint,
        enforce: ::std::os::raw::c_uint,
        check: ::std::os::raw::c_uint,
        propagate: ::std::os::raw::c_uint,
        local: ::std::os::raw::c_uint,
        modifiable: ::std::os::raw::c_uint,
        dynamic: ::std::os::raw::c_uint,
        removable: ::std::os::raw::c_uint,
        stickingatnode: ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " creates and captures an and constraint with possibly redundant literals\n  in its most basic version, i. e., all constraint flags are set to their basic value as explained for the\n  method SCIPcreateConsBounddisjunction(); all flags can be set via SCIPsetConsFLAGNAME-methods in scip.h\n\n  @see SCIPcreateConsBounddisjunction() for information about the basic constraint flag configuration\n\n  @note the constraint gets captured, hence at one point you have to release it using the method SCIPreleaseCons()"]
    pub fn SCIPcreateConsBasicBounddisjunctionRedundant(
        scip: *mut SCIP,
        cons: *mut *mut SCIP_CONS,
        name: *const ::std::os::raw::c_char,
        nvars: ::std::os::raw::c_int,
        vars: *mut *mut SCIP_VAR,
        boundtypes: *mut SCIP_BOUNDTYPE,
        bounds: *mut f64,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " gets number of variables in bound disjunction constraint"]
    pub fn SCIPgetNVarsBounddisjunction(
        scip: *mut SCIP,
        cons: *mut SCIP_CONS,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " gets array of variables in bound disjunction constraint"]
    pub fn SCIPgetVarsBounddisjunction(scip: *mut SCIP, cons: *mut SCIP_CONS)
        -> *mut *mut SCIP_VAR;
}
extern "C" {
    #[doc = " gets array of bound types in bound disjunction constraint"]
    pub fn SCIPgetBoundtypesBounddisjunction(
        scip: *mut SCIP,
        cons: *mut SCIP_CONS,
    ) -> *mut SCIP_BOUNDTYPE;
}
extern "C" {
    #[doc = " gets array of bounds in bound disjunction constraint"]
    pub fn SCIPgetBoundsBounddisjunction(scip: *mut SCIP, cons: *mut SCIP_CONS) -> *mut f64;
}
extern "C" {
    #[doc = " creates the handler for cardinality constraints and includes it in SCIP\n\n @ingroup ConshdlrIncludes"]
    pub fn SCIPincludeConshdlrCardinality(scip: *mut SCIP) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " creates and captures an cardinality constraint\n\n  We set the constraint to not be modifable. If the weights are non\n  NULL, the variables are ordered according to these weights (in\n  ascending order).\n\n  @note the constraint gets captured, hence at one point you have to release it using the method SCIPreleaseCons()"]
    pub fn SCIPcreateConsCardinality(
        scip: *mut SCIP,
        cons: *mut *mut SCIP_CONS,
        name: *const ::std::os::raw::c_char,
        nvars: ::std::os::raw::c_int,
        vars: *mut *mut SCIP_VAR,
        cardval: ::std::os::raw::c_int,
        indvars: *mut *mut SCIP_VAR,
        weights: *mut f64,
        initial: ::std::os::raw::c_uint,
        separate: ::std::os::raw::c_uint,
        enforce: ::std::os::raw::c_uint,
        check: ::std::os::raw::c_uint,
        propagate: ::std::os::raw::c_uint,
        local: ::std::os::raw::c_uint,
        dynamic: ::std::os::raw::c_uint,
        removable: ::std::os::raw::c_uint,
        stickingatnode: ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " creates and captures an cardinality constraint\n  in its most basic variant, i. e., with all constraint flags set to their default values, which can be set\n  afterwards using SCIPsetConsFLAGNAME() in scip.h\n\n  @see SCIPcreateConsCardinality() for the default constraint flag configuration\n\n  @warning Do NOT set the constraint to be modifiable manually, because this might lead\n  to wrong results as the variable array will not be resorted\n\n  @note the constraint gets captured, hence at one point you have to release it using the method SCIPreleaseCons()"]
    pub fn SCIPcreateConsBasicCardinality(
        scip: *mut SCIP,
        cons: *mut *mut SCIP_CONS,
        name: *const ::std::os::raw::c_char,
        nvars: ::std::os::raw::c_int,
        vars: *mut *mut SCIP_VAR,
        cardval: ::std::os::raw::c_int,
        indvars: *mut *mut SCIP_VAR,
        weights: *mut f64,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " changes cardinality value of cardinality constraint (i.e., right hand side of cardinality constraint)"]
    pub fn SCIPchgCardvalCardinality(
        scip: *mut SCIP,
        cons: *mut SCIP_CONS,
        cardval: ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " adds variable to cardinality constraint, the position is determined by the given weight"]
    pub fn SCIPaddVarCardinality(
        scip: *mut SCIP,
        cons: *mut SCIP_CONS,
        var: *mut SCIP_VAR,
        indvar: *mut SCIP_VAR,
        weight: f64,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " appends variable to cardinality constraint"]
    pub fn SCIPappendVarCardinality(
        scip: *mut SCIP,
        cons: *mut SCIP_CONS,
        var: *mut SCIP_VAR,
        indvar: *mut SCIP_VAR,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " gets number of variables in cardinality constraint"]
    pub fn SCIPgetNVarsCardinality(scip: *mut SCIP, cons: *mut SCIP_CONS) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " gets array of variables in cardinality constraint"]
    pub fn SCIPgetVarsCardinality(scip: *mut SCIP, cons: *mut SCIP_CONS) -> *mut *mut SCIP_VAR;
}
extern "C" {
    #[doc = " gets cardinality value of cardinality constraint (i.e., right hand side of cardinality constraint)"]
    pub fn SCIPgetCardvalCardinality(
        scip: *mut SCIP,
        cons: *mut SCIP_CONS,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " gets array of weights in cardinality constraint (or NULL if not existent)"]
    pub fn SCIPgetWeightsCardinality(scip: *mut SCIP, cons: *mut SCIP_CONS) -> *mut f64;
}
extern "C" {
    #[doc = " creates the handler for conjunction constraints and includes it in SCIP\n\n @ingroup ConshdlrIncludes"]
    pub fn SCIPincludeConshdlrConjunction(scip: *mut SCIP) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " creates and captures a conjunction constraint\n\n  @note the constraint gets captured, hence at one point you have to release it using the method SCIPreleaseCons()"]
    pub fn SCIPcreateConsConjunction(
        scip: *mut SCIP,
        cons: *mut *mut SCIP_CONS,
        name: *const ::std::os::raw::c_char,
        nconss: ::std::os::raw::c_int,
        conss: *mut *mut SCIP_CONS,
        enforce: ::std::os::raw::c_uint,
        check: ::std::os::raw::c_uint,
        local: ::std::os::raw::c_uint,
        modifiable: ::std::os::raw::c_uint,
        dynamic: ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " creates and captures an and constraint\n  in its most basic version, i. e., all constraint flags are set to their basic value as explained for the\n  method SCIPcreateConsConjunction(); all flags can be set via SCIPsetConsFLAGNAME-methods in scip.h\n\n  @see SCIPcreateConsConjunction() for information about the basic constraint flag configuration\n\n  @note the constraint gets captured, hence at one point you have to release it using the method SCIPreleaseCons()"]
    pub fn SCIPcreateConsBasicConjunction(
        scip: *mut SCIP,
        cons: *mut *mut SCIP_CONS,
        name: *const ::std::os::raw::c_char,
        nconss: ::std::os::raw::c_int,
        conss: *mut *mut SCIP_CONS,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " adds constraint to the conjunction of constraints"]
    pub fn SCIPaddConsElemConjunction(
        scip: *mut SCIP,
        cons: *mut SCIP_CONS,
        addcons: *mut SCIP_CONS,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " creates the handler for countsol constraints and includes it in SCIP\n\n @ingroup ConshdlrIncludes"]
    pub fn SCIPincludeConshdlrCountsols(scip: *mut SCIP) -> SCIP_RETCODE;
}
extern "C" {
    pub fn SCIPdialogExecCountPresolve(
        scip: *mut SCIP,
        dialog: *mut SCIP_DIALOG,
        dialoghdlr: *mut SCIP_DIALOGHDLR,
        nextdialog: *mut *mut SCIP_DIALOG,
    ) -> SCIP_RETCODE;
}
extern "C" {
    pub fn SCIPdialogExecCount(
        scip: *mut SCIP,
        dialog: *mut SCIP_DIALOG,
        dialoghdlr: *mut SCIP_DIALOGHDLR,
        nextdialog: *mut *mut SCIP_DIALOG,
    ) -> SCIP_RETCODE;
}
extern "C" {
    pub fn SCIPdialogExecWriteAllsolutions(
        scip: *mut SCIP,
        dialog: *mut SCIP_DIALOG,
        dialoghdlr: *mut SCIP_DIALOGHDLR,
        nextdialog: *mut *mut SCIP_DIALOG,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " execute counting"]
    pub fn SCIPcount(scip: *mut SCIP) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " returns number of feasible solutions found as SCIP_Longint; if the number does not fit into\n  a SCIP_Longint the valid flag is set to FALSE"]
    pub fn SCIPgetNCountedSols(
        scip: *mut SCIP,
        valid: *mut ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    #[doc = " returns number of counted solutions as string"]
    pub fn SCIPgetNCountedSolsstr(
        scip: *mut SCIP,
        buffer: *mut *mut ::std::os::raw::c_char,
        buffersize: ::std::os::raw::c_int,
        requiredsize: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " returns number of counted feasible subtrees"]
    pub fn SCIPgetNCountedFeasSubtrees(scip: *mut SCIP) -> ::std::os::raw::c_longlong;
}
extern "C" {
    #[doc = " Method to get the sparse solution.\n\n  @note You get the pointer to the sparse solutions stored in the constraint handler (not a copy).\n\n  @note The sparse solutions are stored w.r.t. the active variables. This are the variables which got not removed\n        during presolving. For none active variables the value has to be computed depending on their aggregation\n        type. See for more details about that \\ref COLLECTALLFEASEBLES."]
    pub fn SCIPgetCountedSparseSols(
        scip: *mut SCIP,
        vars: *mut *mut *mut SCIP_VAR,
        nvars: *mut ::std::os::raw::c_int,
        sols: *mut *mut *mut SCIP_SPARSESOL,
        nsols: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " setting SCIP parameters for such that a valid counting process is possible"]
    pub fn SCIPsetParamsCountsols(scip: *mut SCIP) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " creates the constraint handler for cumulative constraints and includes it in SCIP\n\n @ingroup ConshdlrIncludes"]
    pub fn SCIPincludeConshdlrCumulative(scip: *mut SCIP) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " creates and captures a cumulative constraint"]
    pub fn SCIPcreateConsCumulative(
        scip: *mut SCIP,
        cons: *mut *mut SCIP_CONS,
        name: *const ::std::os::raw::c_char,
        nvars: ::std::os::raw::c_int,
        vars: *mut *mut SCIP_VAR,
        durations: *mut ::std::os::raw::c_int,
        demands: *mut ::std::os::raw::c_int,
        capacity: ::std::os::raw::c_int,
        initial: ::std::os::raw::c_uint,
        separate: ::std::os::raw::c_uint,
        enforce: ::std::os::raw::c_uint,
        check: ::std::os::raw::c_uint,
        propagate: ::std::os::raw::c_uint,
        local: ::std::os::raw::c_uint,
        modifiable: ::std::os::raw::c_uint,
        dynamic: ::std::os::raw::c_uint,
        removable: ::std::os::raw::c_uint,
        stickingatnode: ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " creates and captures an absolute power constraint\n  in its most basic version, i. e., all constraint flags are set to their basic value as explained for the\n  method SCIPcreateConsCumulative(); all flags can be set via SCIPsetConsFLAGNAME-methods in scip.h\n\n  @see SCIPcreateConsCumulative() for information about the basic constraint flag configuration\n\n  @note the constraint gets captured, hence at one point you have to release it using the method SCIPreleaseCons()"]
    pub fn SCIPcreateConsBasicCumulative(
        scip: *mut SCIP,
        cons: *mut *mut SCIP_CONS,
        name: *const ::std::os::raw::c_char,
        nvars: ::std::os::raw::c_int,
        vars: *mut *mut SCIP_VAR,
        durations: *mut ::std::os::raw::c_int,
        demands: *mut ::std::os::raw::c_int,
        capacity: ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " set the left bound of effective horizon"]
    pub fn SCIPsetHminCumulative(
        scip: *mut SCIP,
        cons: *mut SCIP_CONS,
        hmin: ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " returns the left bound of the effective horizon"]
    pub fn SCIPgetHminCumulative(scip: *mut SCIP, cons: *mut SCIP_CONS) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " set the right bound of the effective horizon"]
    pub fn SCIPsetHmaxCumulative(
        scip: *mut SCIP,
        cons: *mut SCIP_CONS,
        hmax: ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " returns the right bound of effective horizon"]
    pub fn SCIPgetHmaxCumulative(scip: *mut SCIP, cons: *mut SCIP_CONS) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " returns the start time variables of the cumulative constraint"]
    pub fn SCIPgetVarsCumulative(scip: *mut SCIP, cons: *mut SCIP_CONS) -> *mut *mut SCIP_VAR;
}
extern "C" {
    #[doc = " returns the number of start time variables of the cumulative constraint"]
    pub fn SCIPgetNVarsCumulative(scip: *mut SCIP, cons: *mut SCIP_CONS) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " returns the capacity of the cumulative constraint"]
    pub fn SCIPgetCapacityCumulative(
        scip: *mut SCIP,
        cons: *mut SCIP_CONS,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " returns the durations of the cumulative constraint"]
    pub fn SCIPgetDurationsCumulative(
        scip: *mut SCIP,
        cons: *mut SCIP_CONS,
    ) -> *mut ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " returns the demands of the cumulative constraint"]
    pub fn SCIPgetDemandsCumulative(
        scip: *mut SCIP,
        cons: *mut SCIP_CONS,
    ) -> *mut ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " check for the given starting time variables with their demands and durations if the cumulative conditions for the\n  given solution is satisfied"]
    pub fn SCIPcheckCumulativeCondition(
        scip: *mut SCIP,
        sol: *mut SCIP_SOL,
        nvars: ::std::os::raw::c_int,
        vars: *mut *mut SCIP_VAR,
        durations: *mut ::std::os::raw::c_int,
        demands: *mut ::std::os::raw::c_int,
        capacity: ::std::os::raw::c_int,
        hmin: ::std::os::raw::c_int,
        hmax: ::std::os::raw::c_int,
        violated: *mut ::std::os::raw::c_uint,
        cons: *mut SCIP_CONS,
        printreason: ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " normalize cumulative condition"]
    pub fn SCIPnormalizeCumulativeCondition(
        scip: *mut SCIP,
        nvars: ::std::os::raw::c_int,
        vars: *mut *mut SCIP_VAR,
        durations: *mut ::std::os::raw::c_int,
        demands: *mut ::std::os::raw::c_int,
        capacity: *mut ::std::os::raw::c_int,
        nchgcoefs: *mut ::std::os::raw::c_int,
        nchgsides: *mut ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " searches for a time point within the cumulative condition were the cumulative condition can be split"]
    pub fn SCIPsplitCumulativeCondition(
        scip: *mut SCIP,
        nvars: ::std::os::raw::c_int,
        vars: *mut *mut SCIP_VAR,
        durations: *mut ::std::os::raw::c_int,
        demands: *mut ::std::os::raw::c_int,
        capacity: ::std::os::raw::c_int,
        hmin: *mut ::std::os::raw::c_int,
        hmax: *mut ::std::os::raw::c_int,
        split: *mut ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " presolve cumulative condition w.r.t. effective horizon by detecting irrelevant variables"]
    pub fn SCIPpresolveCumulativeCondition(
        scip: *mut SCIP,
        nvars: ::std::os::raw::c_int,
        vars: *mut *mut SCIP_VAR,
        durations: *mut ::std::os::raw::c_int,
        hmin: ::std::os::raw::c_int,
        hmax: ::std::os::raw::c_int,
        downlocks: *mut ::std::os::raw::c_uint,
        uplocks: *mut ::std::os::raw::c_uint,
        cons: *mut SCIP_CONS,
        delvars: *mut ::std::os::raw::c_uint,
        nfixedvars: *mut ::std::os::raw::c_int,
        nchgsides: *mut ::std::os::raw::c_int,
        cutoff: *mut ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " propagate the given cumulative condition"]
    pub fn SCIPpropCumulativeCondition(
        scip: *mut SCIP,
        presoltiming: SCIP_PRESOLTIMING,
        nvars: ::std::os::raw::c_int,
        vars: *mut *mut SCIP_VAR,
        durations: *mut ::std::os::raw::c_int,
        demands: *mut ::std::os::raw::c_int,
        capacity: ::std::os::raw::c_int,
        hmin: ::std::os::raw::c_int,
        hmax: ::std::os::raw::c_int,
        cons: *mut SCIP_CONS,
        nchgbds: *mut ::std::os::raw::c_int,
        initialized: *mut ::std::os::raw::c_uint,
        explanation: *mut ::std::os::raw::c_uint,
        cutoff: *mut ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " resolve propagation w.r.t. the cumulative condition"]
    pub fn SCIPrespropCumulativeCondition(
        scip: *mut SCIP,
        nvars: ::std::os::raw::c_int,
        vars: *mut *mut SCIP_VAR,
        durations: *mut ::std::os::raw::c_int,
        demands: *mut ::std::os::raw::c_int,
        capacity: ::std::os::raw::c_int,
        hmin: ::std::os::raw::c_int,
        hmax: ::std::os::raw::c_int,
        infervar: *mut SCIP_VAR,
        inferinfo: ::std::os::raw::c_int,
        boundtype: SCIP_BOUNDTYPE,
        bdchgidx: *mut SCIP_BDCHGIDX,
        relaxedbd: f64,
        explanation: *mut ::std::os::raw::c_uint,
        result: *mut SCIP_RESULT,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " this method visualizes the cumulative structure in GML format"]
    pub fn SCIPvisualizeConsCumulative(scip: *mut SCIP, cons: *mut SCIP_CONS) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " sets method to solve an individual cumulative condition"]
    pub fn SCIPsetSolveCumulative(
        scip: *mut SCIP,
        solveCumulative: ::std::option::Option<
            unsafe extern "C" fn(
                njobs: ::std::os::raw::c_int,
                ests: *mut f64,
                lsts: *mut f64,
                objvals: *mut f64,
                durations: *mut ::std::os::raw::c_int,
                demands: *mut ::std::os::raw::c_int,
                capacity: ::std::os::raw::c_int,
                hmin: ::std::os::raw::c_int,
                hmax: ::std::os::raw::c_int,
                timelimit: f64,
                memorylimit: f64,
                maxnodes: ::std::os::raw::c_longlong,
                solved: *mut ::std::os::raw::c_uint,
                infeasible: *mut ::std::os::raw::c_uint,
                unbounded: *mut ::std::os::raw::c_uint,
                error: *mut ::std::os::raw::c_uint,
            ) -> SCIP_RETCODE,
        >,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " solves given cumulative condition as independent sub problem\n\n  @note If the problem was solved to the earliest start times (ests) and latest start times (lsts) array contain the\n        solution values; If the problem was not solved these two arrays contain the global bounds at the time the sub\n        solver was interrupted."]
    pub fn SCIPsolveCumulative(
        scip: *mut SCIP,
        njobs: ::std::os::raw::c_int,
        ests: *mut f64,
        lsts: *mut f64,
        objvals: *mut f64,
        durations: *mut ::std::os::raw::c_int,
        demands: *mut ::std::os::raw::c_int,
        capacity: ::std::os::raw::c_int,
        hmin: ::std::os::raw::c_int,
        hmax: ::std::os::raw::c_int,
        timelimit: f64,
        memorylimit: f64,
        maxnodes: ::std::os::raw::c_longlong,
        solved: *mut ::std::os::raw::c_uint,
        infeasible: *mut ::std::os::raw::c_uint,
        unbounded: *mut ::std::os::raw::c_uint,
        error: *mut ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " creates the worst case resource profile, that is, all jobs are inserted with the earliest start and latest\n  completion time"]
    pub fn SCIPcreateWorstCaseProfile(
        scip: *mut SCIP,
        profile: *mut SCIP_PROFILE,
        nvars: ::std::os::raw::c_int,
        vars: *mut *mut SCIP_VAR,
        durations: *mut ::std::os::raw::c_int,
        demands: *mut ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " computes w.r.t. the given worst case resource profile the first time point where the given capacity can be violated"]
    pub fn SCIPcomputeHmin(
        scip: *mut SCIP,
        profile: *mut SCIP_PROFILE,
        capacity: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " computes w.r.t. the given worst case resource profile the first time point where the given capacity is satisfied for sure"]
    pub fn SCIPcomputeHmax(
        scip: *mut SCIP,
        profile: *mut SCIP_PROFILE,
        capacity: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " creates the handler for disjunction constraints and includes it in SCIP\n\n @ingroup ConshdlrIncludes"]
    pub fn SCIPincludeConshdlrDisjunction(scip: *mut SCIP) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " creates and captures a disjunction constraint\n\n  @note the constraint gets captured, hence at one point you have to release it using the method SCIPreleaseCons()"]
    pub fn SCIPcreateConsDisjunction(
        scip: *mut SCIP,
        cons: *mut *mut SCIP_CONS,
        name: *const ::std::os::raw::c_char,
        nconss: ::std::os::raw::c_int,
        conss: *mut *mut SCIP_CONS,
        relaxcons: *mut SCIP_CONS,
        initial: ::std::os::raw::c_uint,
        enforce: ::std::os::raw::c_uint,
        check: ::std::os::raw::c_uint,
        local: ::std::os::raw::c_uint,
        modifiable: ::std::os::raw::c_uint,
        dynamic: ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " creates and captures a cumulative constraint\n  in its most basic version, i. e., all constraint flags are set to their basic value as explained for the\n  method SCIPcreateConsDisjunction(); all flags can be set via SCIPsetConsFLAGNAME-methods in scip.h\n\n  @see SCIPcreateConsDisjunction() for information about the basic constraint flag configuration\n\n  @note the constraint gets captured, hence at one point you have to release it using the method SCIPreleaseCons()"]
    pub fn SCIPcreateConsBasicDisjunction(
        scip: *mut SCIP,
        cons: *mut *mut SCIP_CONS,
        name: *const ::std::os::raw::c_char,
        nconss: ::std::os::raw::c_int,
        conss: *mut *mut SCIP_CONS,
        relaxcons: *mut SCIP_CONS,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " adds constraint to the disjunction of constraints"]
    pub fn SCIPaddConsElemDisjunction(
        scip: *mut SCIP,
        cons: *mut SCIP_CONS,
        addcons: *mut SCIP_CONS,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " creates the handler for indicator constraints and includes it in SCIP\n\n @ingroup ConshdlrIncludes"]
    pub fn SCIPincludeConshdlrIndicator(scip: *mut SCIP) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " creates and captures an indicator constraint\n\n  @note @a binvar is checked to be binary only later. This enables a change of the type in\n  procedures reading an instance.\n\n  @note the constraint gets captured, hence at one point you have to release it using the method SCIPreleaseCons()"]
    pub fn SCIPcreateConsIndicator(
        scip: *mut SCIP,
        cons: *mut *mut SCIP_CONS,
        name: *const ::std::os::raw::c_char,
        binvar: *mut SCIP_VAR,
        nvars: ::std::os::raw::c_int,
        vars: *mut *mut SCIP_VAR,
        vals: *mut f64,
        rhs: f64,
        initial: ::std::os::raw::c_uint,
        separate: ::std::os::raw::c_uint,
        enforce: ::std::os::raw::c_uint,
        check: ::std::os::raw::c_uint,
        propagate: ::std::os::raw::c_uint,
        local: ::std::os::raw::c_uint,
        dynamic: ::std::os::raw::c_uint,
        removable: ::std::os::raw::c_uint,
        stickingatnode: ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " creates and captures an indicator constraint in its most basic version, i. e., all constraint flags are set to their\n  basic value as explained for the method SCIPcreateConsIndicator(); all flags can be set via\n  SCIPsetConsFLAGNAME-methods in scip.h\n\n  @see SCIPcreateConsIndicator() for information about the basic constraint flag configuration\n\n  @note the constraint gets captured, hence at one point you have to release it using the method SCIPreleaseCons()"]
    pub fn SCIPcreateConsBasicIndicator(
        scip: *mut SCIP,
        cons: *mut *mut SCIP_CONS,
        name: *const ::std::os::raw::c_char,
        binvar: *mut SCIP_VAR,
        nvars: ::std::os::raw::c_int,
        vars: *mut *mut SCIP_VAR,
        vals: *mut f64,
        rhs: f64,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " creates and captures a indicator constraint in a more generic version.\n\n  The key difference from SCIPcreateConsIndicator() is the activeone and lessthanineq Booleans.\n  If \\f$z = o\\f$, with \\f$o\\f$ the activeone flag, then:\n  if lessthanineq then \\f$a^T x \\leq b\\f$ holds, else the passed vectors are assumed to be of the form \\f$a^T x \\geq b\\f$.\n  The underlying linear constraint is always created as a less-than inequality."]
    pub fn SCIPcreateConsIndicatorGeneric(
        scip: *mut SCIP,
        cons: *mut *mut SCIP_CONS,
        name: *const ::std::os::raw::c_char,
        binvar: *mut SCIP_VAR,
        nvars: ::std::os::raw::c_int,
        vars: *mut *mut SCIP_VAR,
        vals: *mut f64,
        rhs: f64,
        activeone: ::std::os::raw::c_uint,
        lessthanineq: ::std::os::raw::c_uint,
        initial: ::std::os::raw::c_uint,
        separate: ::std::os::raw::c_uint,
        enforce: ::std::os::raw::c_uint,
        check: ::std::os::raw::c_uint,
        propagate: ::std::os::raw::c_uint,
        local: ::std::os::raw::c_uint,
        dynamic: ::std::os::raw::c_uint,
        removable: ::std::os::raw::c_uint,
        stickingatnode: ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " creates and captures an indicator constraint with given linear constraint and slack variable\n\n  @note @a binvar is checked to be binary only later. This enables a change of the type in\n  procedures reading an instance.\n\n  @note we assume that @a slackvar actually appears in @a lincons and we also assume that it takes\n  the role of a slack variable!\n\n  @note the constraint gets captured, hence at one point you have to release it using the method SCIPreleaseCons()"]
    pub fn SCIPcreateConsIndicatorLinCons(
        scip: *mut SCIP,
        cons: *mut *mut SCIP_CONS,
        name: *const ::std::os::raw::c_char,
        binvar: *mut SCIP_VAR,
        lincons: *mut SCIP_CONS,
        slackvar: *mut SCIP_VAR,
        initial: ::std::os::raw::c_uint,
        separate: ::std::os::raw::c_uint,
        enforce: ::std::os::raw::c_uint,
        check: ::std::os::raw::c_uint,
        propagate: ::std::os::raw::c_uint,
        local: ::std::os::raw::c_uint,
        dynamic: ::std::os::raw::c_uint,
        removable: ::std::os::raw::c_uint,
        stickingatnode: ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " creates and captures an indicator constraint with given linear constraint and slack variable\n  in a generic version, i. e., with a flag activeone indicating whether the constraint is active on\n  value 1 or 0 of the binary variable.\n\n  @note @a binvar is checked to be binary only later. This enables a change of the type in\n  procedures reading an instance.\n\n  @note we assume that @a slackvar actually appears in @a lincons and we also assume that it takes\n  the role of a slack variable!\n\n  @note the constraint gets captured, hence at one point you have to release it using the method SCIPreleaseCons()\n\n  @see SCIPcreateConsIndicatorLinCons() for information about the basic constraint flag configuration"]
    pub fn SCIPcreateConsIndicatorGenericLinCons(
        scip: *mut SCIP,
        cons: *mut *mut SCIP_CONS,
        name: *const ::std::os::raw::c_char,
        binvar: *mut SCIP_VAR,
        lincons: *mut SCIP_CONS,
        slackvar: *mut SCIP_VAR,
        activeone: ::std::os::raw::c_uint,
        initial: ::std::os::raw::c_uint,
        separate: ::std::os::raw::c_uint,
        enforce: ::std::os::raw::c_uint,
        check: ::std::os::raw::c_uint,
        propagate: ::std::os::raw::c_uint,
        local: ::std::os::raw::c_uint,
        dynamic: ::std::os::raw::c_uint,
        removable: ::std::os::raw::c_uint,
        stickingatnode: ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " creates and captures an indicator constraint with given linear constraint and slack variable\n  in its most basic version, i. e., all constraint flags are set to their basic value as explained for the\n  method SCIPcreateConsIndicator(); all flags can be set via SCIPsetConsFLAGNAME-methods in scip.h\n\n  @note @a binvar is checked to be binary only later. This enables a change of the type in\n  procedures reading an instance.\n\n  @note we assume that @a slackvar actually appears in @a lincons and we also assume that it takes\n  the role of a slack variable!\n\n  @note the constraint gets captured, hence at one point you have to release it using the method SCIPreleaseCons()\n\n  @see SCIPcreateConsIndicatorLinCons() for information about the basic constraint flag configuration\n\n  @note the constraint gets captured, hence at one point you have to release it using the method SCIPreleaseCons()"]
    pub fn SCIPcreateConsBasicIndicatorLinCons(
        scip: *mut SCIP,
        cons: *mut *mut SCIP_CONS,
        name: *const ::std::os::raw::c_char,
        binvar: *mut SCIP_VAR,
        lincons: *mut SCIP_CONS,
        slackvar: *mut SCIP_VAR,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " creates and captures an indicator constraint with given linear constraint in a generic version, i. e., with a flag\n  activeone indicating whether the constraint is active on value 1 or 0 of the binary variable; no slack variable is\n  specified\n\n  @note @a binvar is checked to be binary only later. This enables a change of the type in\n  procedures reading an instance.\n\n  @note The linear constraint has to be single sided only, i.e., either rhs or lhs have to be infinite.\n\n  @note the constraint gets captured, hence at one point you have to release it using the method SCIPreleaseCons()\n\n  @see SCIPcreateConsIndicatorLinCons() for information about the basic constraint flag configuration"]
    pub fn SCIPcreateConsIndicatorGenericLinConsPure(
        scip: *mut SCIP,
        cons: *mut *mut SCIP_CONS,
        name: *const ::std::os::raw::c_char,
        binvar: *mut SCIP_VAR,
        lincons: *mut SCIP_CONS,
        activeone: ::std::os::raw::c_uint,
        initial: ::std::os::raw::c_uint,
        separate: ::std::os::raw::c_uint,
        enforce: ::std::os::raw::c_uint,
        check: ::std::os::raw::c_uint,
        propagate: ::std::os::raw::c_uint,
        local: ::std::os::raw::c_uint,
        dynamic: ::std::os::raw::c_uint,
        removable: ::std::os::raw::c_uint,
        stickingatnode: ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " creates and captures an indicator constraint with given linear constraint; no slack variable is specified\n\n  @note @a binvar is checked to be binary only later. This enables a change of the type in\n  procedures reading an instance.\n\n  @note The linear constraint has to be single sided only, i.e., either rhs or lhs have to be infinite.\n\n  @note the constraint gets captured, hence at one point you have to release it using the method SCIPreleaseCons()"]
    pub fn SCIPcreateConsIndicatorLinConsPure(
        scip: *mut SCIP,
        cons: *mut *mut SCIP_CONS,
        name: *const ::std::os::raw::c_char,
        binvar: *mut SCIP_VAR,
        lincons: *mut SCIP_CONS,
        initial: ::std::os::raw::c_uint,
        separate: ::std::os::raw::c_uint,
        enforce: ::std::os::raw::c_uint,
        check: ::std::os::raw::c_uint,
        propagate: ::std::os::raw::c_uint,
        local: ::std::os::raw::c_uint,
        dynamic: ::std::os::raw::c_uint,
        removable: ::std::os::raw::c_uint,
        stickingatnode: ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " adds variable to the inequality of the indicator constraint"]
    pub fn SCIPaddVarIndicator(
        scip: *mut SCIP,
        cons: *mut SCIP_CONS,
        var: *mut SCIP_VAR,
        val: f64,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " gets the linear constraint corresponding to the indicator constraint (may be NULL)"]
    pub fn SCIPgetLinearConsIndicator(cons: *mut SCIP_CONS) -> *mut SCIP_CONS;
}
extern "C" {
    #[doc = " sets the linear constraint corresponding to the indicator constraint (may be NULL)"]
    pub fn SCIPsetLinearConsIndicator(
        scip: *mut SCIP,
        cons: *mut SCIP_CONS,
        lincons: *mut SCIP_CONS,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " sets binary indicator variable for indicator constraint"]
    pub fn SCIPsetBinaryVarIndicator(
        scip: *mut SCIP,
        cons: *mut SCIP_CONS,
        binvar: *mut SCIP_VAR,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " gets activation value of an indicator constraint, TRUE for active on 1, FALSE for active on 0"]
    pub fn SCIPgetActiveOnIndicator(cons: *mut SCIP_CONS) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " gets binary variable corresponding to indicator constraint. Returns the negative of the original binary variable if activeone was set to false"]
    pub fn SCIPgetBinaryVarIndicator(cons: *mut SCIP_CONS) -> *mut SCIP_VAR;
}
extern "C" {
    #[doc = " similar to SCIPgetBinaryVarIndicator but returns the original binary variable passed by the user."]
    pub fn SCIPgetBinaryVarIndicatorGeneric(cons: *mut SCIP_CONS) -> *mut SCIP_VAR;
}
extern "C" {
    #[doc = " gets slack variable corresponding to indicator constraint"]
    pub fn SCIPgetSlackVarIndicator(cons: *mut SCIP_CONS) -> *mut SCIP_VAR;
}
extern "C" {
    #[doc = " sets upper bound for slack variable corresponding to indicator constraint\n\n  Use with care if you know that the maximal violation of the corresponding constraint is at most @p ub. This bound\n  might be improved automatically during the solution process.\n\n  @pre This method should only be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_INIT\n       - \\ref SCIP_STAGE_PROBLEM"]
    pub fn SCIPsetSlackVarUb(scip: *mut SCIP, cons: *mut SCIP_CONS, ub: f64) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " checks whether indicator constraint is violated w.r.t. sol"]
    pub fn SCIPisViolatedIndicator(
        scip: *mut SCIP,
        cons: *mut SCIP_CONS,
        sol: *mut SCIP_SOL,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " based on values of other variables, computes slack and binary variable to turn constraint feasible"]
    pub fn SCIPmakeIndicatorFeasible(
        scip: *mut SCIP,
        cons: *mut SCIP_CONS,
        sol: *mut SCIP_SOL,
        changed: *mut ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " based on values of other variables, computes slack and binary variable to turn all constraints feasible"]
    pub fn SCIPmakeIndicatorsFeasible(
        scip: *mut SCIP,
        conshdlr: *mut SCIP_CONSHDLR,
        sol: *mut SCIP_SOL,
        changed: *mut ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " adds additional linear constraint that is not connected with an indicator constraint, but can be used for separation"]
    pub fn SCIPaddLinearConsIndicator(
        scip: *mut SCIP,
        conshdlr: *mut SCIP_CONSHDLR,
        lincons: *mut SCIP_CONS,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " adds additional globally valid row that is not connected with an indicator constraint, but can be used for separation"]
    pub fn SCIPaddRowIndicator(
        scip: *mut SCIP,
        conshdlr: *mut SCIP_CONSHDLR,
        row: *mut SCIP_ROW,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " creates the handler for the integrality constraint and includes it in SCIP\n\n @ingroup ConshdlrIncludes"]
    pub fn SCIPincludeConshdlrIntegral(scip: *mut SCIP) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " creates the handler for knapsack constraints and includes it in SCIP\n\n @ingroup ConshdlrIncludes"]
    pub fn SCIPincludeConshdlrKnapsack(scip: *mut SCIP) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " creates and captures a knapsack constraint\n\n  @note the constraint gets captured, hence at one point you have to release it using the method SCIPreleaseCons()"]
    pub fn SCIPcreateConsKnapsack(
        scip: *mut SCIP,
        cons: *mut *mut SCIP_CONS,
        name: *const ::std::os::raw::c_char,
        nvars: ::std::os::raw::c_int,
        vars: *mut *mut SCIP_VAR,
        weights: *mut ::std::os::raw::c_longlong,
        capacity: ::std::os::raw::c_longlong,
        initial: ::std::os::raw::c_uint,
        separate: ::std::os::raw::c_uint,
        enforce: ::std::os::raw::c_uint,
        check: ::std::os::raw::c_uint,
        propagate: ::std::os::raw::c_uint,
        local: ::std::os::raw::c_uint,
        modifiable: ::std::os::raw::c_uint,
        dynamic: ::std::os::raw::c_uint,
        removable: ::std::os::raw::c_uint,
        stickingatnode: ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " creates and captures a knapsack constraint\n  in its most basic version, i. e., all constraint flags are set to their basic value as explained for the\n  method SCIPcreateConsKnapsack(); all flags can be set via SCIPsetConsFLAGNAME-methods in scip.h\n\n  @see SCIPcreateConsKnapsack() for information about the basic constraint flag configuration\n\n  @note the constraint gets captured, hence at one point you have to release it using the method SCIPreleaseCons()"]
    pub fn SCIPcreateConsBasicKnapsack(
        scip: *mut SCIP,
        cons: *mut *mut SCIP_CONS,
        name: *const ::std::os::raw::c_char,
        nvars: ::std::os::raw::c_int,
        vars: *mut *mut SCIP_VAR,
        weights: *mut ::std::os::raw::c_longlong,
        capacity: ::std::os::raw::c_longlong,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " adds new item to knapsack constraint"]
    pub fn SCIPaddCoefKnapsack(
        scip: *mut SCIP,
        cons: *mut SCIP_CONS,
        var: *mut SCIP_VAR,
        weight: ::std::os::raw::c_longlong,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " gets the capacity of the knapsack constraint"]
    pub fn SCIPgetCapacityKnapsack(
        scip: *mut SCIP,
        cons: *mut SCIP_CONS,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    #[doc = " changes capacity of the knapsack constraint\n\n  @note This method can only be called during problem creation stage (SCIP_STAGE_PROBLEM)"]
    pub fn SCIPchgCapacityKnapsack(
        scip: *mut SCIP,
        cons: *mut SCIP_CONS,
        capacity: ::std::os::raw::c_longlong,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " gets the number of items in the knapsack constraint"]
    pub fn SCIPgetNVarsKnapsack(scip: *mut SCIP, cons: *mut SCIP_CONS) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " gets the array of variables in the knapsack constraint; the user must not modify this array!"]
    pub fn SCIPgetVarsKnapsack(scip: *mut SCIP, cons: *mut SCIP_CONS) -> *mut *mut SCIP_VAR;
}
extern "C" {
    #[doc = " gets the array of weights in the knapsack constraint; the user must not modify this array!"]
    pub fn SCIPgetWeightsKnapsack(
        scip: *mut SCIP,
        cons: *mut SCIP_CONS,
    ) -> *mut ::std::os::raw::c_longlong;
}
extern "C" {
    #[doc = " gets the dual solution of the knapsack constraint in the current LP"]
    pub fn SCIPgetDualsolKnapsack(scip: *mut SCIP, cons: *mut SCIP_CONS) -> f64;
}
extern "C" {
    #[doc = " gets the dual Farkas value of the knapsack constraint in the current infeasible LP"]
    pub fn SCIPgetDualfarkasKnapsack(scip: *mut SCIP, cons: *mut SCIP_CONS) -> f64;
}
extern "C" {
    #[doc = " returns the linear relaxation of the given knapsack constraint; may return NULL if no LP row was yet created;\n  the user must not modify the row!"]
    pub fn SCIPgetRowKnapsack(scip: *mut SCIP, cons: *mut SCIP_CONS) -> *mut SCIP_ROW;
}
extern "C" {
    #[doc = " solves knapsack problem in maximization form exactly using dynamic programming;\n  if needed, one can provide arrays to store all selected items and all not selected items\n\n @note in case you provide the solitems or nonsolitems array you also have to provide the counter part, as well\n\n @note the algorithm will first compute a greedy solution and terminate\n       if the greedy solution is proven to be optimal.\n       The dynamic programming algorithm runs with a time and space complexity\n       of O(nitems * capacity)."]
    pub fn SCIPsolveKnapsackExactly(
        scip: *mut SCIP,
        nitems: ::std::os::raw::c_int,
        weights: *mut ::std::os::raw::c_longlong,
        profits: *mut f64,
        capacity: ::std::os::raw::c_longlong,
        items: *mut ::std::os::raw::c_int,
        solitems: *mut ::std::os::raw::c_int,
        nonsolitems: *mut ::std::os::raw::c_int,
        nsolitems: *mut ::std::os::raw::c_int,
        nnonsolitems: *mut ::std::os::raw::c_int,
        solval: *mut f64,
        success: *mut ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " solves knapsack problem in maximization form approximately by solving the LP-relaxation of the problem using Dantzig's\n  method and rounding down the solution; if needed, one can provide arrays to store all selected items and all not\n  selected items"]
    pub fn SCIPsolveKnapsackApproximately(
        scip: *mut SCIP,
        nitems: ::std::os::raw::c_int,
        weights: *mut ::std::os::raw::c_longlong,
        profits: *mut f64,
        capacity: ::std::os::raw::c_longlong,
        items: *mut ::std::os::raw::c_int,
        solitems: *mut ::std::os::raw::c_int,
        nonsolitems: *mut ::std::os::raw::c_int,
        nsolitems: *mut ::std::os::raw::c_int,
        nnonsolitems: *mut ::std::os::raw::c_int,
        solval: *mut f64,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " separates different classes of valid inequalities for the 0-1 knapsack problem"]
    pub fn SCIPseparateKnapsackCuts(
        scip: *mut SCIP,
        cons: *mut SCIP_CONS,
        sepa: *mut SCIP_SEPA,
        vars: *mut *mut SCIP_VAR,
        nvars: ::std::os::raw::c_int,
        weights: *mut ::std::os::raw::c_longlong,
        capacity: ::std::os::raw::c_longlong,
        sol: *mut SCIP_SOL,
        usegubs: ::std::os::raw::c_uint,
        cutoff: *mut ::std::os::raw::c_uint,
        ncuts: *mut ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
extern "C" {
    pub fn SCIPseparateRelaxedKnapsack(
        scip: *mut SCIP,
        cons: *mut SCIP_CONS,
        sepa: *mut SCIP_SEPA,
        nknapvars: ::std::os::raw::c_int,
        knapvars: *mut *mut SCIP_VAR,
        knapvals: *mut f64,
        valscale: f64,
        rhs: f64,
        sol: *mut SCIP_SOL,
        cutoff: *mut ::std::os::raw::c_uint,
        ncuts: *mut ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " cleans up (multi-)aggregations and fixings from knapsack constraints"]
    pub fn SCIPcleanupConssKnapsack(
        scip: *mut SCIP,
        onlychecked: ::std::os::raw::c_uint,
        infeasible: *mut ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " creates the handler for linear constraints and includes it in SCIP\n\n @ingroup ConshdlrIncludes"]
    pub fn SCIPincludeConshdlrLinear(scip: *mut SCIP) -> SCIP_RETCODE;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_LinConsUpgrade {
    _unused: [u8; 0],
}
#[doc = "@addtogroup CONSHDLRS\n\n @{\n\n @name Linear Constraints\n\n This constraint handler handles linear constraints in their most general form. That is,\n \\f[\n   lhs \\leq \\sum_{i=1}^n a_i x_i \\leq rhs\n \\f]\n with \\f$a_i \\in Q, i = 1,\\dots,n\\f$, \\f$lhs\\in Q \\cup \\{-\\infty\\}\\f$, \\f$rhs\\in Q \\cup \\{\\infty\\}\\f$,\n and decision variables \\f$x_i, i = 1,\\dots,n\\f$ which can be binary, integer, or continuous.\n\n Furthermore, this header offers the upgrade functionality of a general linear constraint into a more specific\n constraint, such as a knapsack constraint, via SCIP_DECL_LINCONSUPGD() and SCIPincludeLinconsUpgrade()\n\n @{"]
pub type SCIP_LINCONSUPGRADE = SCIP_LinConsUpgrade;
extern "C" {
    #[doc = " includes a linear constraint update method into the linear constraint handler"]
    pub fn SCIPincludeLinconsUpgrade(
        scip: *mut SCIP,
        linconsupgd: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                cons: *mut SCIP_CONS,
                nvars: ::std::os::raw::c_int,
                vars: *mut *mut SCIP_VAR,
                vals: *mut f64,
                lhs: f64,
                rhs: f64,
                nposbin: ::std::os::raw::c_int,
                nnegbin: ::std::os::raw::c_int,
                nposint: ::std::os::raw::c_int,
                nnegint: ::std::os::raw::c_int,
                nposimpl: ::std::os::raw::c_int,
                nnegimpl: ::std::os::raw::c_int,
                nposimplbin: ::std::os::raw::c_int,
                nnegimplbin: ::std::os::raw::c_int,
                nposcont: ::std::os::raw::c_int,
                nnegcont: ::std::os::raw::c_int,
                ncoeffspone: ::std::os::raw::c_int,
                ncoeffsnone: ::std::os::raw::c_int,
                ncoeffspint: ::std::os::raw::c_int,
                ncoeffsnint: ::std::os::raw::c_int,
                ncoeffspfrac: ::std::os::raw::c_int,
                ncoeffsnfrac: ::std::os::raw::c_int,
                poscoeffsum: f64,
                negcoeffsum: f64,
                integral: ::std::os::raw::c_uint,
                upgdcons: *mut *mut SCIP_CONS,
            ) -> SCIP_RETCODE,
        >,
        priority: ::std::os::raw::c_int,
        conshdlrname: *const ::std::os::raw::c_char,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " creates and captures a linear constraint\n\n  @note the constraint gets captured, hence at one point you have to release it using the method SCIPreleaseCons()"]
    pub fn SCIPcreateConsLinear(
        scip: *mut SCIP,
        cons: *mut *mut SCIP_CONS,
        name: *const ::std::os::raw::c_char,
        nvars: ::std::os::raw::c_int,
        vars: *mut *mut SCIP_VAR,
        vals: *mut f64,
        lhs: f64,
        rhs: f64,
        initial: ::std::os::raw::c_uint,
        separate: ::std::os::raw::c_uint,
        enforce: ::std::os::raw::c_uint,
        check: ::std::os::raw::c_uint,
        propagate: ::std::os::raw::c_uint,
        local: ::std::os::raw::c_uint,
        modifiable: ::std::os::raw::c_uint,
        dynamic: ::std::os::raw::c_uint,
        removable: ::std::os::raw::c_uint,
        stickingatnode: ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " creates and captures a linear constraint\n  in its most basic version, i. e., all constraint flags are set to their basic value as explained for the\n  method SCIPcreateConsLinear(); all flags can be set via SCIPsetConsFLAGNAME-methods in scip.h\n\n  @see SCIPcreateConsLinear() for information about the basic constraint flag configuration\n\n  @note the constraint gets captured, hence at one point you have to release it using the method SCIPreleaseCons()"]
    pub fn SCIPcreateConsBasicLinear(
        scip: *mut SCIP,
        cons: *mut *mut SCIP_CONS,
        name: *const ::std::os::raw::c_char,
        nvars: ::std::os::raw::c_int,
        vars: *mut *mut SCIP_VAR,
        vals: *mut f64,
        lhs: f64,
        rhs: f64,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " creates by copying and captures a linear constraint"]
    pub fn SCIPcopyConsLinear(
        scip: *mut SCIP,
        cons: *mut *mut SCIP_CONS,
        sourcescip: *mut SCIP,
        name: *const ::std::os::raw::c_char,
        nvars: ::std::os::raw::c_int,
        sourcevars: *mut *mut SCIP_VAR,
        sourcecoefs: *mut f64,
        lhs: f64,
        rhs: f64,
        varmap: *mut SCIP_HASHMAP,
        consmap: *mut SCIP_HASHMAP,
        initial: ::std::os::raw::c_uint,
        separate: ::std::os::raw::c_uint,
        enforce: ::std::os::raw::c_uint,
        check: ::std::os::raw::c_uint,
        propagate: ::std::os::raw::c_uint,
        local: ::std::os::raw::c_uint,
        modifiable: ::std::os::raw::c_uint,
        dynamic: ::std::os::raw::c_uint,
        removable: ::std::os::raw::c_uint,
        stickingatnode: ::std::os::raw::c_uint,
        global: ::std::os::raw::c_uint,
        valid: *mut ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " adds coefficient to linear constraint (if it is not zero)"]
    pub fn SCIPaddCoefLinear(
        scip: *mut SCIP,
        cons: *mut SCIP_CONS,
        var: *mut SCIP_VAR,
        val: f64,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " changes coefficient of variable in linear constraint; deletes the variable if coefficient is zero; adds variable if\n  not yet contained in the constraint\n\n  @note This method may only be called during problem creation stage for an original constraint and variable.\n\n  @note This method requires linear time to search for occurences of the variable in the constraint data."]
    pub fn SCIPchgCoefLinear(
        scip: *mut SCIP,
        cons: *mut SCIP_CONS,
        var: *mut SCIP_VAR,
        val: f64,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " deletes variable from linear constraint\n\n  @note This method may only be called during problem creation stage for an original constraint and variable.\n\n  @note This method requires linear time to search for occurences of the variable in the constraint data."]
    pub fn SCIPdelCoefLinear(
        scip: *mut SCIP,
        cons: *mut SCIP_CONS,
        var: *mut SCIP_VAR,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " gets left hand side of linear constraint"]
    pub fn SCIPgetLhsLinear(scip: *mut SCIP, cons: *mut SCIP_CONS) -> f64;
}
extern "C" {
    #[doc = " gets right hand side of linear constraint"]
    pub fn SCIPgetRhsLinear(scip: *mut SCIP, cons: *mut SCIP_CONS) -> f64;
}
extern "C" {
    #[doc = " changes left hand side of linear constraint"]
    pub fn SCIPchgLhsLinear(scip: *mut SCIP, cons: *mut SCIP_CONS, lhs: f64) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " changes right hand side of linear constraint"]
    pub fn SCIPchgRhsLinear(scip: *mut SCIP, cons: *mut SCIP_CONS, rhs: f64) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " gets the number of variables in the linear constraint"]
    pub fn SCIPgetNVarsLinear(scip: *mut SCIP, cons: *mut SCIP_CONS) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " gets the array of variables in the linear constraint; the user must not modify this array!"]
    pub fn SCIPgetVarsLinear(scip: *mut SCIP, cons: *mut SCIP_CONS) -> *mut *mut SCIP_VAR;
}
extern "C" {
    #[doc = " gets the array of coefficient values in the linear constraint; the user must not modify this array!"]
    pub fn SCIPgetValsLinear(scip: *mut SCIP, cons: *mut SCIP_CONS) -> *mut f64;
}
extern "C" {
    #[doc = " gets the activity of the linear constraint in the given solution\n\n  @note if the solution contains values at infinity, this method will return SCIP_INVALID in case the activity\n        comprises positive and negative infinity contributions"]
    pub fn SCIPgetActivityLinear(scip: *mut SCIP, cons: *mut SCIP_CONS, sol: *mut SCIP_SOL) -> f64;
}
extern "C" {
    #[doc = " gets the feasibility of the linear constraint in the given solution"]
    pub fn SCIPgetFeasibilityLinear(
        scip: *mut SCIP,
        cons: *mut SCIP_CONS,
        sol: *mut SCIP_SOL,
    ) -> f64;
}
extern "C" {
    #[doc = " gets the dual solution of the linear constraint in the current LP"]
    pub fn SCIPgetDualsolLinear(scip: *mut SCIP, cons: *mut SCIP_CONS) -> f64;
}
extern "C" {
    #[doc = " gets the dual Farkas value of the linear constraint in the current infeasible LP"]
    pub fn SCIPgetDualfarkasLinear(scip: *mut SCIP, cons: *mut SCIP_CONS) -> f64;
}
extern "C" {
    #[doc = " returns the linear relaxation of the given linear constraint; may return NULL if no LP row was yet created;\n  the user must not modify the row!"]
    pub fn SCIPgetRowLinear(scip: *mut SCIP, cons: *mut SCIP_CONS) -> *mut SCIP_ROW;
}
extern "C" {
    #[doc = " tries to automatically convert a linear constraint into a more specific and more specialized constraint"]
    pub fn SCIPupgradeConsLinear(
        scip: *mut SCIP,
        cons: *mut SCIP_CONS,
        upgdcons: *mut *mut SCIP_CONS,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " performs linear constraint type classification as used for MIPLIB\n\n  iterates through all linear constraints and stores relevant statistics in the linear constraint statistics \\p linconsstats.\n\n  @note only constraints are iterated that belong to the linear constraint handler. If the problem has been presolved already,\n  constraints that were upgraded to more special types such as, e.g., varbound constraints, will not be shown correctly anymore.\n  Similarly, if specialized constraints were created through the API, these are currently not present."]
    pub fn SCIPclassifyConstraintTypesLinear(
        scip: *mut SCIP,
        linconsstats: *mut SCIP_LINCONSSTATS,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " cleans up (multi-)aggregations and fixings from linear constraints"]
    pub fn SCIPcleanupConssLinear(
        scip: *mut SCIP,
        onlychecked: ::std::os::raw::c_uint,
        infeasible: *mut ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " creates the handler for linking constraints and includes it in SCIP\n\n @ingroup ConshdlrIncludes"]
    pub fn SCIPincludeConshdlrLinking(scip: *mut SCIP) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " creates and captures a linking constraint\n\n  @note the constraint gets captured, hence at one point you have to release it using the method SCIPreleaseCons()"]
    pub fn SCIPcreateConsLinking(
        scip: *mut SCIP,
        cons: *mut *mut SCIP_CONS,
        name: *const ::std::os::raw::c_char,
        linkvar: *mut SCIP_VAR,
        binvars: *mut *mut SCIP_VAR,
        vals: *mut f64,
        nbinvars: ::std::os::raw::c_int,
        initial: ::std::os::raw::c_uint,
        separate: ::std::os::raw::c_uint,
        enforce: ::std::os::raw::c_uint,
        check: ::std::os::raw::c_uint,
        propagate: ::std::os::raw::c_uint,
        local: ::std::os::raw::c_uint,
        modifiable: ::std::os::raw::c_uint,
        dynamic: ::std::os::raw::c_uint,
        removable: ::std::os::raw::c_uint,
        stickingatnode: ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " creates and captures a linking constraint\n  in its most basic version, i. e., all constraint flags are set to their basic value as explained for the\n  method SCIPcreateConsLinking(); all flags can be set via SCIPsetConsFLAGNAME-methods in scip.h\n\n  @see SCIPcreateConsLinking() for information about the basic constraint flag configuration\n\n  @note the constraint gets captured, hence at one point you have to release it using the method SCIPreleaseCons()"]
    pub fn SCIPcreateConsBasicLinking(
        scip: *mut SCIP,
        cons: *mut *mut SCIP_CONS,
        name: *const ::std::os::raw::c_char,
        linkvar: *mut SCIP_VAR,
        binvars: *mut *mut SCIP_VAR,
        vals: *mut f64,
        nbinvars: ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " checks if for the given linking variable (continuous or integer) a linking constraint exists"]
    pub fn SCIPexistsConsLinking(scip: *mut SCIP, linkvar: *mut SCIP_VAR)
        -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " returns the linking constraint belonging the given linking variable (continuous or integer) or NULL if it does not exist yet"]
    pub fn SCIPgetConsLinking(scip: *mut SCIP, linkvar: *mut SCIP_VAR) -> *mut SCIP_CONS;
}
extern "C" {
    #[doc = " returns the linking variable (continuous or integer) of the linking constraint"]
    pub fn SCIPgetLinkvarLinking(scip: *mut SCIP, cons: *mut SCIP_CONS) -> *mut SCIP_VAR;
}
extern "C" {
    #[doc = " returns the binary variables of the linking constraint"]
    pub fn SCIPgetBinvarsLinking(
        scip: *mut SCIP,
        cons: *mut SCIP_CONS,
        binvars: *mut *mut *mut SCIP_VAR,
        nbinvars: *mut ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " returns the number of binary variables of the linking constraint"]
    pub fn SCIPgetNBinvarsLinking(scip: *mut SCIP, cons: *mut SCIP_CONS) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " returns the coefficients of the binary variables"]
    pub fn SCIPgetValsLinking(scip: *mut SCIP, cons: *mut SCIP_CONS) -> *mut f64;
}
extern "C" {
    #[doc = " return all binary variable information of the linking constraint"]
    pub fn SCIPgetBinvarsDataLinking(
        cons: *mut SCIP_CONS,
        binvars: *mut *mut *mut SCIP_VAR,
        vals: *mut *mut f64,
        nbinvars: *mut ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " creates the handler for logic or constraints and includes it in SCIP\n\n @ingroup ConshdlrIncludes"]
    pub fn SCIPincludeConshdlrLogicor(scip: *mut SCIP) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " creates and captures a logic or constraint\n\n  @note the constraint gets captured, hence at one point you have to release it using the method SCIPreleaseCons()"]
    pub fn SCIPcreateConsLogicor(
        scip: *mut SCIP,
        cons: *mut *mut SCIP_CONS,
        name: *const ::std::os::raw::c_char,
        nvars: ::std::os::raw::c_int,
        vars: *mut *mut SCIP_VAR,
        initial: ::std::os::raw::c_uint,
        separate: ::std::os::raw::c_uint,
        enforce: ::std::os::raw::c_uint,
        check: ::std::os::raw::c_uint,
        propagate: ::std::os::raw::c_uint,
        local: ::std::os::raw::c_uint,
        modifiable: ::std::os::raw::c_uint,
        dynamic: ::std::os::raw::c_uint,
        removable: ::std::os::raw::c_uint,
        stickingatnode: ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " creates and captures a logicor constraint\n  in its most basic version, i. e., all constraint flags are set to their basic value as explained for the\n  method SCIPcreateConsLogicor(); all flags can be set via SCIPsetConsFLAGNAME-methods in scip.h\n\n  @see SCIPcreateConsLogicor() for information about the basic constraint flag configuration\n\n  @note the constraint gets captured, hence at one point you have to release it using the method SCIPreleaseCons()"]
    pub fn SCIPcreateConsBasicLogicor(
        scip: *mut SCIP,
        cons: *mut *mut SCIP_CONS,
        name: *const ::std::os::raw::c_char,
        nvars: ::std::os::raw::c_int,
        vars: *mut *mut SCIP_VAR,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " adds coefficient in logic or constraint"]
    pub fn SCIPaddCoefLogicor(
        scip: *mut SCIP,
        cons: *mut SCIP_CONS,
        var: *mut SCIP_VAR,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " gets number of variables in logic or constraint"]
    pub fn SCIPgetNVarsLogicor(scip: *mut SCIP, cons: *mut SCIP_CONS) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " gets array of variables in logic or constraint"]
    pub fn SCIPgetVarsLogicor(scip: *mut SCIP, cons: *mut SCIP_CONS) -> *mut *mut SCIP_VAR;
}
extern "C" {
    #[doc = " gets the dual solution of the logic or constraint in the current LP"]
    pub fn SCIPgetDualsolLogicor(scip: *mut SCIP, cons: *mut SCIP_CONS) -> f64;
}
extern "C" {
    #[doc = " gets the dual Farkas value of the logic or constraint in the current infeasible LP"]
    pub fn SCIPgetDualfarkasLogicor(scip: *mut SCIP, cons: *mut SCIP_CONS) -> f64;
}
extern "C" {
    #[doc = " returns the linear relaxation of the given logic or constraint; may return NULL if no LP row was yet created;\n  the user must not modify the row!"]
    pub fn SCIPgetRowLogicor(scip: *mut SCIP, cons: *mut SCIP_CONS) -> *mut SCIP_ROW;
}
extern "C" {
    #[doc = " cleans up (multi-)aggregations and fixings from logicor constraints"]
    pub fn SCIPcleanupConssLogicor(
        scip: *mut SCIP,
        onlychecked: ::std::os::raw::c_uint,
        naddconss: *mut ::std::os::raw::c_int,
        ndelconss: *mut ::std::os::raw::c_int,
        nchgcoefs: *mut ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
pub type SCIP_NLHDLR_METHOD = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_Nlhdlr {
    _unused: [u8; 0],
}
pub type SCIP_NLHDLR = SCIP_Nlhdlr;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_NlhdlrData {
    _unused: [u8; 0],
}
pub type SCIP_NLHDLRDATA = SCIP_NlhdlrData;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_NlhdlrExprData {
    _unused: [u8; 0],
}
pub type SCIP_NLHDLREXPRDATA = SCIP_NlhdlrExprData;
#[doc = " linear auxiliary expression of the form xy {&le;,&ge;,=} coefs[0]w + coefs[1]x + coefs[2]y + cst"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_ConsNonlinear_Auxexpr {
    #[doc = "< coefficients in the auxiliary expression"]
    pub coefs: [f64; 3usize],
    #[doc = "< constant"]
    pub cst: f64,
    #[doc = "< auxiliary variable w in xy {&le;,&ge;,=} auxexpr(w, x, y)"]
    pub auxvar: *mut SCIP_VAR,
    #[doc = "< whether the auxexpr underestimates the product"]
    pub underestimate: ::std::os::raw::c_uint,
    #[doc = "< whether the auxexpr overestimates the product"]
    pub overestimate: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_SCIP_ConsNonlinear_Auxexpr() {
    const UNINIT: ::std::mem::MaybeUninit<SCIP_ConsNonlinear_Auxexpr> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<SCIP_ConsNonlinear_Auxexpr>(),
        48usize,
        concat!("Size of: ", stringify!(SCIP_ConsNonlinear_Auxexpr))
    );
    assert_eq!(
        ::std::mem::align_of::<SCIP_ConsNonlinear_Auxexpr>(),
        8usize,
        concat!("Alignment of ", stringify!(SCIP_ConsNonlinear_Auxexpr))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).coefs) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SCIP_ConsNonlinear_Auxexpr),
            "::",
            stringify!(coefs)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cst) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(SCIP_ConsNonlinear_Auxexpr),
            "::",
            stringify!(cst)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).auxvar) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(SCIP_ConsNonlinear_Auxexpr),
            "::",
            stringify!(auxvar)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).underestimate) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(SCIP_ConsNonlinear_Auxexpr),
            "::",
            stringify!(underestimate)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).overestimate) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(SCIP_ConsNonlinear_Auxexpr),
            "::",
            stringify!(overestimate)
        )
    );
}
#[doc = " linear auxiliary expression of the form xy {&le;,&ge;,=} coefs[0]w + coefs[1]x + coefs[2]y + cst"]
pub type SCIP_CONSNONLINEAR_AUXEXPR = SCIP_ConsNonlinear_Auxexpr;
#[doc = " bilinear term structure\n\n This can represent a product which\n - explicitly exists in the problem and is under- and/or overestimated by a single auxiliary variable\n   stored as `var` in the union `aux` (case `nauxexprs` = 0) or\n - is involved in bilinear relations implicitly given by linear constraints with binary variables, and\n   is under- and/or overestimated by linear expression(s) stored as `exprs` in the union `aux` (case `nauxexprs` > 0).\n\n An explicitly existing product can also be involved in implicit relations, then it will be stored as in\n the second case."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SCIP_ConsNonlinear_BilinTerm {
    #[doc = "< first variable"]
    pub x: *mut SCIP_VAR,
    #[doc = "< second variable"]
    pub y: *mut SCIP_VAR,
    pub aux: SCIP_ConsNonlinear_BilinTerm__bindgen_ty_1,
    #[doc = "< number of aux.exprs (0 for products without implicit relations)"]
    pub nauxexprs: ::std::os::raw::c_int,
    #[doc = "< size of the aux.exprs array"]
    pub auxexprssize: ::std::os::raw::c_int,
    #[doc = "< number of positive expression locks"]
    pub nlockspos: ::std::os::raw::c_int,
    #[doc = "< number of negative expression locks"]
    pub nlocksneg: ::std::os::raw::c_int,
    #[doc = "< does the product exist explicitly in the problem?"]
    pub existing: ::std::os::raw::c_uint,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union SCIP_ConsNonlinear_BilinTerm__bindgen_ty_1 {
    #[doc = "< auxiliary expressions for the implicit product of x and y"]
    pub exprs: *mut *mut SCIP_CONSNONLINEAR_AUXEXPR,
    #[doc = "< auxiliary variable for the explicit product of x and y"]
    pub var: *mut SCIP_VAR,
}
#[test]
fn bindgen_test_layout_SCIP_ConsNonlinear_BilinTerm__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<SCIP_ConsNonlinear_BilinTerm__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<SCIP_ConsNonlinear_BilinTerm__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(SCIP_ConsNonlinear_BilinTerm__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<SCIP_ConsNonlinear_BilinTerm__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(SCIP_ConsNonlinear_BilinTerm__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).exprs) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SCIP_ConsNonlinear_BilinTerm__bindgen_ty_1),
            "::",
            stringify!(exprs)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).var) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SCIP_ConsNonlinear_BilinTerm__bindgen_ty_1),
            "::",
            stringify!(var)
        )
    );
}
#[test]
fn bindgen_test_layout_SCIP_ConsNonlinear_BilinTerm() {
    const UNINIT: ::std::mem::MaybeUninit<SCIP_ConsNonlinear_BilinTerm> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<SCIP_ConsNonlinear_BilinTerm>(),
        48usize,
        concat!("Size of: ", stringify!(SCIP_ConsNonlinear_BilinTerm))
    );
    assert_eq!(
        ::std::mem::align_of::<SCIP_ConsNonlinear_BilinTerm>(),
        8usize,
        concat!("Alignment of ", stringify!(SCIP_ConsNonlinear_BilinTerm))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).x) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SCIP_ConsNonlinear_BilinTerm),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).y) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SCIP_ConsNonlinear_BilinTerm),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).aux) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(SCIP_ConsNonlinear_BilinTerm),
            "::",
            stringify!(aux)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nauxexprs) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(SCIP_ConsNonlinear_BilinTerm),
            "::",
            stringify!(nauxexprs)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).auxexprssize) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(SCIP_ConsNonlinear_BilinTerm),
            "::",
            stringify!(auxexprssize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nlockspos) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(SCIP_ConsNonlinear_BilinTerm),
            "::",
            stringify!(nlockspos)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nlocksneg) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(SCIP_ConsNonlinear_BilinTerm),
            "::",
            stringify!(nlocksneg)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).existing) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(SCIP_ConsNonlinear_BilinTerm),
            "::",
            stringify!(existing)
        )
    );
}
#[doc = " bilinear term structure\n\n This can represent a product which\n - explicitly exists in the problem and is under- and/or overestimated by a single auxiliary variable\n   stored as `var` in the union `aux` (case `nauxexprs` = 0) or\n - is involved in bilinear relations implicitly given by linear constraints with binary variables, and\n   is under- and/or overestimated by linear expression(s) stored as `exprs` in the union `aux` (case `nauxexprs` > 0).\n\n An explicitly existing product can also be involved in implicit relations, then it will be stored as in\n the second case."]
pub type SCIP_CONSNONLINEAR_BILINTERM = SCIP_ConsNonlinear_BilinTerm;
extern "C" {
    #[doc = " creates the handler for nonlinear constraints and includes it in SCIP\n\n @ingroup ConshdlrIncludes"]
    pub fn SCIPincludeConshdlrNonlinear(scip: *mut SCIP) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " includes a nonlinear constraint upgrade method into the nonlinear constraint handler"]
    pub fn SCIPincludeConsUpgradeNonlinear(
        scip: *mut SCIP,
        nlconsupgd: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                cons: *mut SCIP_CONS,
                nvarexprs: ::std::os::raw::c_int,
                nupgdconss: *mut ::std::os::raw::c_int,
                upgdconss: *mut *mut SCIP_CONS,
                upgdconsssize: ::std::os::raw::c_int,
            ) -> SCIP_RETCODE,
        >,
        priority: ::std::os::raw::c_int,
        active: ::std::os::raw::c_uint,
        conshdlrname: *const ::std::os::raw::c_char,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " creates and captures a nonlinear constraint\n\n  @note the constraint gets captured, hence at one point you have to release it using the method SCIPreleaseCons()"]
    pub fn SCIPcreateConsNonlinear(
        scip: *mut SCIP,
        cons: *mut *mut SCIP_CONS,
        name: *const ::std::os::raw::c_char,
        expr: *mut SCIP_EXPR,
        lhs: f64,
        rhs: f64,
        initial: ::std::os::raw::c_uint,
        separate: ::std::os::raw::c_uint,
        enforce: ::std::os::raw::c_uint,
        check: ::std::os::raw::c_uint,
        propagate: ::std::os::raw::c_uint,
        local: ::std::os::raw::c_uint,
        modifiable: ::std::os::raw::c_uint,
        dynamic: ::std::os::raw::c_uint,
        removable: ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " creates and captures a nonlinear constraint with all its constraint flags set to their default values\n\n  All flags can be set via SCIPconsSetFLAGNAME-methods.\n\n  @see SCIPcreateConsNonlinear() for information about the basic constraint flag configuration.\n\n  @note the constraint gets captured, hence at one point you have to release it using the method SCIPreleaseCons()"]
    pub fn SCIPcreateConsBasicNonlinear(
        scip: *mut SCIP,
        cons: *mut *mut SCIP_CONS,
        name: *const ::std::os::raw::c_char,
        expr: *mut SCIP_EXPR,
        lhs: f64,
        rhs: f64,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " creates and captures a quadratic nonlinear constraint\n\n  @note the constraint gets captured, hence at one point you have to release it using the method SCIPreleaseCons()"]
    pub fn SCIPcreateConsQuadraticNonlinear(
        scip: *mut SCIP,
        cons: *mut *mut SCIP_CONS,
        name: *const ::std::os::raw::c_char,
        nlinvars: ::std::os::raw::c_int,
        linvars: *mut *mut SCIP_VAR,
        lincoefs: *mut f64,
        nquadterms: ::std::os::raw::c_int,
        quadvars1: *mut *mut SCIP_VAR,
        quadvars2: *mut *mut SCIP_VAR,
        quadcoefs: *mut f64,
        lhs: f64,
        rhs: f64,
        initial: ::std::os::raw::c_uint,
        separate: ::std::os::raw::c_uint,
        enforce: ::std::os::raw::c_uint,
        check: ::std::os::raw::c_uint,
        propagate: ::std::os::raw::c_uint,
        local: ::std::os::raw::c_uint,
        modifiable: ::std::os::raw::c_uint,
        dynamic: ::std::os::raw::c_uint,
        removable: ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " creates and captures a quadratic nonlinear constraint with all its constraint flags set to their default values\n\n  All flags can be set via SCIPconsSetFLAGNAME-methods.\n\n  @see SCIPcreateConsQuadraticNonlinear() for information about the basic constraint flag configuration.\n\n  @note the constraint gets captured, hence at one point you have to release it using the method SCIPreleaseCons()"]
    pub fn SCIPcreateConsBasicQuadraticNonlinear(
        scip: *mut SCIP,
        cons: *mut *mut SCIP_CONS,
        name: *const ::std::os::raw::c_char,
        nlinvars: ::std::os::raw::c_int,
        linvars: *mut *mut SCIP_VAR,
        lincoefs: *mut f64,
        nquadterms: ::std::os::raw::c_int,
        quadvars1: *mut *mut SCIP_VAR,
        quadvars2: *mut *mut SCIP_VAR,
        quadcoefs: *mut f64,
        lhs: f64,
        rhs: f64,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " creates and captures a nonlinear constraint that is a second-order cone constraint with all its constraint flags set to their default values\n\n \\f$\\sqrt{\\gamma + \\sum_{i=1}^{n} (\\alpha_i\\, (x_i + \\beta_i))^2} \\leq \\alpha_{n+1}\\, (x_{n+1}+\\beta_{n+1})\\f$\n\n  @note the constraint gets captured, hence at one point you have to release it using the method SCIPreleaseCons()"]
    pub fn SCIPcreateConsBasicSOCNonlinear(
        scip: *mut SCIP,
        cons: *mut *mut SCIP_CONS,
        name: *const ::std::os::raw::c_char,
        nvars: ::std::os::raw::c_int,
        vars: *mut *mut SCIP_VAR,
        coefs: *mut f64,
        offsets: *mut f64,
        constant: f64,
        rhsvar: *mut SCIP_VAR,
        rhscoeff: f64,
        rhsoffset: f64,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " creates and captures a signpower nonlinear constraint with all its constraint flags set to their default values\n\n \\f$\\textrm{lhs} \\leq \\textrm{sign}(x+a) |x+a|^n + c z \\leq \\textrm{rhs}\\f$\n\n  @note the constraint gets captured, hence at one point you have to release it using the method SCIPreleaseCons()"]
    pub fn SCIPcreateConsBasicSignpowerNonlinear(
        scip: *mut SCIP,
        cons: *mut *mut SCIP_CONS,
        name: *const ::std::os::raw::c_char,
        x: *mut SCIP_VAR,
        z: *mut SCIP_VAR,
        exponent: f64,
        xoffset: f64,
        zcoef: f64,
        lhs: f64,
        rhs: f64,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " gets tag indicating current local variable bounds"]
    pub fn SCIPgetCurBoundsTagNonlinear(conshdlr: *mut SCIP_CONSHDLR)
        -> ::std::os::raw::c_longlong;
}
extern "C" {
    #[doc = " gets the `curboundstag` from the last time where variable bounds were relaxed"]
    pub fn SCIPgetLastBoundRelaxTagNonlinear(
        conshdlr: *mut SCIP_CONSHDLR,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    #[doc = " increments `curboundstag` and resets `lastboundrelax` in constraint handler data\n\n @attention This method is not intended for normal use.\n   These tags are maintained by the event handler for variable bound change events.\n   This method is used by some unittests."]
    pub fn SCIPincrementCurBoundsTagNonlinear(
        conshdlr: *mut SCIP_CONSHDLR,
        boundrelax: ::std::os::raw::c_uint,
    );
}
extern "C" {
    #[doc = " returns the hashmap that is internally used to map variables to their corresponding variable expressions"]
    pub fn SCIPgetVarExprHashmapNonlinear(conshdlr: *mut SCIP_CONSHDLR) -> *mut SCIP_HASHMAP;
}
extern "C" {
    #[doc = " processes a rowprep for cut addition and maybe report branchscores"]
    pub fn SCIPprocessRowprepNonlinear(
        scip: *mut SCIP,
        nlhdlr: *mut SCIP_NLHDLR,
        cons: *mut SCIP_CONS,
        expr: *mut SCIP_EXPR,
        rowprep: *mut SCIP_ROWPREP,
        overestimate: ::std::os::raw::c_uint,
        auxvar: *mut SCIP_VAR,
        auxvalue: f64,
        allowweakcuts: ::std::os::raw::c_uint,
        branchscoresuccess: ::std::os::raw::c_uint,
        inenforcement: ::std::os::raw::c_uint,
        sol: *mut SCIP_SOL,
        result: *mut SCIP_RESULT,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " returns whether all nonlinear constraints are assumed to be convex"]
    pub fn SCIPassumeConvexNonlinear(conshdlr: *mut SCIP_CONSHDLR) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " collects all bilinear terms for a given set of constraints\n\n @attention This method should only be used for unit tests that depend on SCIPgetBilinTermsNonlinear(),\n       SCIPgetBilinTermNonlinear() or SCIPgetBilinTermIdxNonlinear()."]
    pub fn SCIPcollectBilinTermsNonlinear(
        scip: *mut SCIP,
        conshdlr: *mut SCIP_CONSHDLR,
        conss: *mut *mut SCIP_CONS,
        nconss: ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " returns the total number of bilinear terms that are contained in all nonlinear constraints\n\n  @note This method should only be used after auxiliary variables have been created, i.e., after CONSINITLP."]
    pub fn SCIPgetNBilinTermsNonlinear(conshdlr: *mut SCIP_CONSHDLR) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " returns all bilinear terms that are contained in all nonlinear constraints\n\n @note This method should only be used after auxiliary variables have been created, i.e., after CONSINITLP.\n @note The value of the auxiliary variable of a bilinear term might be NULL, which indicates that the term does not have an auxiliary variable."]
    pub fn SCIPgetBilinTermsNonlinear(
        conshdlr: *mut SCIP_CONSHDLR,
    ) -> *mut SCIP_CONSNONLINEAR_BILINTERM;
}
extern "C" {
    #[doc = " returns the index of the bilinear term representing the product of the two given variables\n\n @note The method should only be used after auxiliary variables have been created, i.e., after CONSINITLP.\n @return The method returns -1 if the variables do not appear bilinearly."]
    pub fn SCIPgetBilinTermIdxNonlinear(
        conshdlr: *mut SCIP_CONSHDLR,
        x: *mut SCIP_VAR,
        y: *mut SCIP_VAR,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " returns the bilinear term that represents the product of two given variables\n\n @note The method should only be used after auxiliary variables have been created, i.e., after CONSINITLP.\n @return The method returns NULL if the variables do not appear bilinearly."]
    pub fn SCIPgetBilinTermNonlinear(
        conshdlr: *mut SCIP_CONSHDLR,
        x: *mut SCIP_VAR,
        y: *mut SCIP_VAR,
    ) -> *mut SCIP_CONSNONLINEAR_BILINTERM;
}
extern "C" {
    #[doc = " evaluates an auxiliary expression for a bilinear term"]
    pub fn SCIPevalBilinAuxExprNonlinear(
        scip: *mut SCIP,
        x: *mut SCIP_VAR,
        y: *mut SCIP_VAR,
        auxexpr: *mut SCIP_CONSNONLINEAR_AUXEXPR,
        sol: *mut SCIP_SOL,
    ) -> f64;
}
extern "C" {
    #[doc = " stores the variables of a bilinear term in the data of the constraint handler"]
    pub fn SCIPinsertBilinearTermExistingNonlinear(
        scip: *mut SCIP,
        conshdlr: *mut SCIP_CONSHDLR,
        x: *mut SCIP_VAR,
        y: *mut SCIP_VAR,
        auxvar: *mut SCIP_VAR,
        nlockspos: ::std::os::raw::c_int,
        nlocksneg: ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " stores the variables of a bilinear term in the data of the constraint handler"]
    pub fn SCIPinsertBilinearTermImplicitNonlinear(
        scip: *mut SCIP,
        conshdlr: *mut SCIP_CONSHDLR,
        x: *mut SCIP_VAR,
        y: *mut SCIP_VAR,
        auxvar: *mut SCIP_VAR,
        coefx: f64,
        coefy: f64,
        coefaux: f64,
        cst: f64,
        overestimate: ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " computes a facet of the convex or concave envelope of a vertex polyhedral function\n\n If \\f$ f(x) \\f$ is vertex-polyhedral, then \\f$ g \\f$ is a convex underestimator if and only if\n \\f$ g(v^i) \\leq f(v^i), \\forall i \\f$, where \\f$ \\{ v^i \\}_{i = 1}^{2^n} \\subseteq \\mathbb R^n \\f$ are the vertices\n of the domain of \\f$ x \\f$, \\f$ [\\ell,u] \\f$. Hence, we can compute a linear underestimator by solving the following\n LP (we don't necessarily get a facet of the convex envelope, see below):\n\n \\f{align*}{\n              \\max \\, & \\alpha^T x^* + \\beta \\\\\n     s.t. \\; & \\alpha^T v^i + \\beta \\le f(v^i), \\, \\forall i = 1, \\ldots, 2^n\n \\f}\n\n In principle, one would need to update the LP whenever the domain changes. However, \\f$ [\\ell,u] = T([0, 1]^n) \\f$,\n where \\f$ T \\f$ is an affine linear invertible transformation given by \\f$ T(y)_i = (u_i - \\ell_i) y_i + \\ell_i \\f$.\n Working with the change of variables \\f$ x = T(y) \\f$ allows us to keep the constraints of the LP, even if the domain\n changes. Indeed, after the change of variables, the problem is: find an affine underestimator \\f$ g \\f$ such that \\f$\n g(T(y)) \\le f(T(y)) \\f$, for all \\f$ y \\in [0, 1]^n \\f$. Now \\f$ f(T(y)) \\f$ is componentwise affine, but still\n satisfies that \\f$ g \\f$ is a valid underestimator if and only if \\f$ g(T(u)) \\leq f(T(u)), \\forall u \\in \\{0, 1\\}^n\n \\f$. So we now look for \\f$ \\bar g(y) := g(T(y)) = g(((u_i - \\ell_i) y_i + \\ell_i)_i) = \\bar \\alpha^T y + \\bar \\beta\n \\f$, where \\f$ \\bar \\alpha_i = (u_i - \\ell_i) \\alpha_i \\f$ and \\f$ \\bar \\beta = \\sum_i \\alpha_i \\ell_i + \\beta \\f$. So\n we find \\f$ \\bar g \\f$ by solving the LP:\n\n \\f{align*}{\n              \\max \\, & \\bar \\alpha^T T^{-1}(x^*) + \\bar \\beta \\\\\n     s.t. \\; & \\bar \\alpha^T u + \\bar \\beta \\le f(T(u)), \\, \\forall u \\in \\{0, 1\\}^n\n \\f}\n\n and recover \\f$ g \\f$ by calculating \\f$ \\bar \\alpha_i = (u_i - \\ell_i) \\alpha_i, \\bar \\beta = \\sum_i \\alpha_i \\ell_i +\n \\beta \\f$. Notice that \\f$ f(T(u^i)) = f(v^i) \\f$ so the right hand side doesn't change after the change of variables.\n\n Furthermore, the LP has more constraints than variables, so we solve its dual:\n \\f{align*}{\n              \\min \\, & \\sum_i \\lambda_i f(v^i) \\\\\n     s.t. \\; & \\sum_i \\lambda_i u^i = T^{-1}(x^*) \\\\\n             & \\sum_i \\lambda_i = 1 \\\\\n             & \\forall i, \\, \\lambda_i \\geq 0\n \\f}\n\n In case we look for an overestimate, we do exactly the same, but have to maximize in the dual LP instead\n of minimize.\n\n #### Technical and implementation details\n -# \\f$ U \\f$ has exponentially many variables, so we only apply this separator for \\f$n\\f$ &le; \\ref SCIP_MAXVERTEXPOLYDIM.\n -# If the bounds are not finite, there is no underestimator. Also, \\f$ T^{-1}(x^*) \\f$ must be in the domain,\n otherwise the dual is infeasible.\n -# After a facet is computed, we check whether it is a valid facet (i.e. we check \\f$ \\alpha^T v + \\beta \\le f(v) \\f$\n  for every vertex \\f$ v \\f$). If we find a violation of at most ADJUSTFACETFACTOR * SCIPlpfeastol(), then we weaken \\f$\n  \\beta \\f$ by this amount, otherwise, we discard the cut.\n -# If a variable is fixed within tolerances, we replace it with its value and compute the facet of the remaining\n expression. Note that since we are checking the cut for validity, this will never produce wrong result.\n -# If \\f$ x^* \\f$ is in the boundary of the domain, then the LP has infinitely many solutions, some of which might\n have very bad numerical properties. For this reason, we perturb \\f$ x^* \\f$ to be in the interior of the region.\n Furthermore, for some interior points, there might also be infinitely many solutions (e.g. for \\f$ x y \\f$ in \\f$\n [0,1]^2 \\f$ any point \\f$ (x^*, y^*) \\f$ such that \\f$ y^* = 1 - x^* \\f$ has infinitely many solutions). For this\n reason, we perturb any given \\f$ x^* \\f$. The idea is to try to get a facet of the convex/concave envelope. This only\n happens when the solution has \\f$ n + 1 \\f$ non zero \\f$ \\lambda \\f$'s (i.e. the primal has a unique solution).\n -# We need to compute \\f$ f(v^i) \\f$ for every vertex of \\f$ [\\ell,u] \\f$. A vertex is encoded by a number between 0\n and \\f$ 2^n - 1 \\f$, via its binary representation (0 bit is lower bound, 1 bit is upper bound), so we can compute\n all these values by iterating between 0 and \\f$ 2^n - 1 \\f$.\n -# To check that the computed cut is valid we do the following: we use a gray code to loop over the vertices\n of the box domain w.r.t. unfixed variables in order to evaluate the underestimator. To ensure the validity of the\n underestimator, we check whether \\f$ \\alpha v^i + \\beta \\le f(v^i) \\f$ for every vertex \\f$ v^i \\f$ and adjust\n \\f$ \\beta \\f$ if the maximal violation is small.\n\n @todo the solution is a facet if all variables of the primal have positive reduced costs (i.e. the solution is\n unique). In the dual, this means that there are \\f$ n + 1 \\f$ variables with positive value. Can we use this or some\n other information to handle any of both cases (point in the boundary or point in the intersection of polytopes\n defining different pieces of the convex envelope)? In the case where the point is in the boundary, can we use that\n information to maybe solve another to find a facet? How do the polytopes defining the pieces where the convex\n envelope is linear looks like, i.e, given a point in the interior of a facet of the domain, does the midpoint of the\n segment joining \\f$ x^* \\f$ with the center of the domain, always belongs to the interior of one of those polytopes?"]
    pub fn SCIPcomputeFacetVertexPolyhedralNonlinear(
        scip: *mut SCIP,
        conshdlr: *mut SCIP_CONSHDLR,
        overestimate: ::std::os::raw::c_uint,
        function: ::std::option::Option<
            unsafe extern "C" fn(
                args: *mut f64,
                nargs: ::std::os::raw::c_int,
                funcdata: *mut ::std::os::raw::c_void,
            ) -> f64,
        >,
        fundata: *mut ::std::os::raw::c_void,
        xstar: *mut f64,
        box_: *mut f64,
        nallvars: ::std::os::raw::c_int,
        targetvalue: f64,
        success: *mut ::std::os::raw::c_uint,
        facetcoefs: *mut f64,
        facetconstant: *mut f64,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " returns the expression of the given nonlinear constraint"]
    pub fn SCIPgetExprNonlinear(cons: *mut SCIP_CONS) -> *mut SCIP_EXPR;
}
extern "C" {
    #[doc = " gets the left hand side of a nonlinear constraint"]
    pub fn SCIPgetLhsNonlinear(cons: *mut SCIP_CONS) -> f64;
}
extern "C" {
    #[doc = " gets the right hand side of a nonlinear constraint"]
    pub fn SCIPgetRhsNonlinear(cons: *mut SCIP_CONS) -> f64;
}
extern "C" {
    #[doc = " gets the nonlinear constraint as a nonlinear row representation."]
    pub fn SCIPgetNlRowNonlinear(
        scip: *mut SCIP,
        cons: *mut SCIP_CONS,
        nlrow: *mut *mut SCIP_NLROW,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " returns the curvature of the expression of a given nonlinear constraint\n\n @note The curvature information is computed during CONSINITSOL."]
    pub fn SCIPgetCurvatureNonlinear(cons: *mut SCIP_CONS) -> SCIP_EXPRCURV;
}
extern "C" {
    #[doc = " checks whether expression of constraint can be represented as quadratic form\n\n Only sets `*isquadratic` to TRUE if the whole expression is quadratic (in the non-extended formulation) and non-linear.\n That is, the expression in each \\ref SCIP_QUADEXPR_QUADTERM will be a variable expressions and\n \\ref SCIPgetVarExprVar() can be used to retrieve the variable."]
    pub fn SCIPcheckQuadraticNonlinear(
        scip: *mut SCIP,
        cons: *mut SCIP_CONS,
        isquadratic: *mut ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " changes left-hand-side of a nonlinear constraint\n\n @attention This method can only be called in the problem stage."]
    pub fn SCIPchgLhsNonlinear(scip: *mut SCIP, cons: *mut SCIP_CONS, lhs: f64) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " changes right-hand-side of a nonlinear constraint\n\n @attention This method can only be called in the problem stage."]
    pub fn SCIPchgRhsNonlinear(scip: *mut SCIP, cons: *mut SCIP_CONS, rhs: f64) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " changes expression of a nonlinear constraint\n\n @attention This method can only be called in the problem stage."]
    pub fn SCIPchgExprNonlinear(
        scip: *mut SCIP,
        cons: *mut SCIP_CONS,
        expr: *mut SCIP_EXPR,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " adds coef * var to nonlinear constraint\n\n @attention This method can only be called in the problem stage."]
    pub fn SCIPaddLinearVarNonlinear(
        scip: *mut SCIP,
        cons: *mut SCIP_CONS,
        var: *mut SCIP_VAR,
        coef: f64,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " adds coef * expr to nonlinear constraint\n\n @attention This method can only be called in the problem stage."]
    pub fn SCIPaddExprNonlinear(
        scip: *mut SCIP,
        cons: *mut SCIP_CONS,
        expr: *mut SCIP_EXPR,
        coef: f64,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " gets absolute violation of nonlinear constraint\n\n This function evaluates the constraints in the given solution.\n\n If this value is at most SCIPfeastol(), the constraint would be considered feasible."]
    pub fn SCIPgetAbsViolationNonlinear(
        scip: *mut SCIP,
        cons: *mut SCIP_CONS,
        sol: *mut SCIP_SOL,
        viol: *mut f64,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " gets scaled violation of nonlinear constraint\n\n This function evaluates the constraints in the given solution.\n\n The scaling that is applied to the absolute violation of the constraint\n depends on the setting of parameter constraints/nonlinear/violscale."]
    pub fn SCIPgetRelViolationNonlinear(
        scip: *mut SCIP,
        cons: *mut SCIP_CONS,
        sol: *mut SCIP_SOL,
        viol: *mut f64,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " returns a variable that appears linearly that may be decreased without making any other constraint infeasible"]
    pub fn SCIPgetLinvarMayDecreaseNonlinear(
        scip: *mut SCIP,
        cons: *mut SCIP_CONS,
        var: *mut *mut SCIP_VAR,
        coef: *mut f64,
    );
}
extern "C" {
    #[doc = " returns a variable that appears linearly that may be increased without making any other constraint infeasible"]
    pub fn SCIPgetLinvarMayIncreaseNonlinear(
        scip: *mut SCIP,
        cons: *mut SCIP_CONS,
        var: *mut *mut SCIP_VAR,
        coef: *mut f64,
    );
}
extern "C" {
    #[doc = " returns the number of positive rounding locks of an expression"]
    pub fn SCIPgetExprNLocksPosNonlinear(expr: *mut SCIP_EXPR) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " returns the number of negative rounding locks of an expression"]
    pub fn SCIPgetExprNLocksNegNonlinear(expr: *mut SCIP_EXPR) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " returns the variable used for linearizing a given expression (return value might be NULL)\n\n @note for variable expression it returns the corresponding variable"]
    pub fn SCIPgetExprAuxVarNonlinear(expr: *mut SCIP_EXPR) -> *mut SCIP_VAR;
}
extern "C" {
    #[doc = " returns the number of enforcements for an expression"]
    pub fn SCIPgetExprNEnfosNonlinear(expr: *mut SCIP_EXPR) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " returns the data for one of the enforcements of an expression"]
    pub fn SCIPgetExprEnfoDataNonlinear(
        expr: *mut SCIP_EXPR,
        idx: ::std::os::raw::c_int,
        nlhdlr: *mut *mut SCIP_NLHDLR,
        nlhdlrexprdata: *mut *mut SCIP_NLHDLREXPRDATA,
        nlhdlrparticipation: *mut SCIP_NLHDLR_METHOD,
        sepabelowusesactivity: *mut ::std::os::raw::c_uint,
        sepaaboveusesactivity: *mut ::std::os::raw::c_uint,
        auxvalue: *mut f64,
    );
}
extern "C" {
    #[doc = " sets the auxiliary value of expression for one of the enforcements of an expression"]
    pub fn SCIPsetExprEnfoAuxValueNonlinear(
        expr: *mut SCIP_EXPR,
        idx: ::std::os::raw::c_int,
        auxvalue: f64,
    );
}
extern "C" {
    #[doc = " number of nonlinear handlers whose activity computation and propagation methods depend on the activity of the expression\n\n @note This method can only be used after the detection methods of the nonlinear handlers have been called."]
    pub fn SCIPgetExprNPropUsesActivityNonlinear(expr: *mut SCIP_EXPR) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " number of nonlinear handlers whose separation methods (estimate or enforcement) depend on the activity of the expression\n\n @note This method can only be used after the detection methods of the nonlinear handlers have been called."]
    pub fn SCIPgetExprNSepaUsesActivityNonlinear(expr: *mut SCIP_EXPR) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " number of nonlinear handlers whose separation methods (estimate or enforcement) use auxiliary variable of the expression\n\n @note This method can only be used after the detection methods of the nonlinear handlers have been called."]
    pub fn SCIPgetExprNAuxvarUsesNonlinear(expr: *mut SCIP_EXPR) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " method to be called by a nlhdlr during NLHDLRDETECT to notify an expression that it will be used\n\n - if `useauxvar` is enabled, then ensures that an auxiliary variable will be created in INITLP\n - if `useactivityforprop` or `useactivityforsepa{below,above}` is enabled, then ensured that activity will be updated for `expr`\n - if `useactivityforprop` is enabled, then increments the count returned by SCIPgetExprNPropUsesActivityNonlinear()\n - if `useactivityforsepa{below,above}` is enabled, then increments the count returned by SCIPgetExprNSepaUsesActivityNonlinear()\n   and also increments this count for all variables in the expression.\n\n The distinction into `useactivityforprop` and `useactivityforsepa{below,above}` is to recognize variables which domain influences\n under/overestimators. Domain propagation routines (like OBBT) may invest more work for these variables.\n The distinction into `useactivityforsepabelow` and `useactivityforsepaabove` is to recognize whether a nlhdlr that called this method\n will use activity of `expr` in enfomethod \\ref SCIP_NLHDLR_METHOD_SEPABELOW or \\ref SCIP_NLHDLR_METHOD_SEPAABOVE."]
    pub fn SCIPregisterExprUsageNonlinear(
        scip: *mut SCIP,
        expr: *mut SCIP_EXPR,
        useauxvar: ::std::os::raw::c_uint,
        useactivityforprop: ::std::os::raw::c_uint,
        useactivityforsepabelow: ::std::os::raw::c_uint,
        useactivityforsepaabove: ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " computes absolute violation for auxvar relation in an expression w.r.t. original variables\n\n Assume the expression is f(x), where x are original (i.e., not auxiliary) variables.\n Assume that f(x) is associated with auxiliary variable z.\n\n If there are negative locks, then returns the violation of z &le; f(x) and sets `violover` to TRUE.\n If there are positive locks, then returns the violation of z &ge; f(x) and sets `violunder` to TRUE.\n Of course, if there both negative and positive locks, then return the violation of z = f(x).\n\n If necessary, f is evaluated in the given solution. If that fails (domain error),\n then `viol` is set to SCIPinfinity() and both `violover` and `violunder` are set to TRUE."]
    pub fn SCIPgetExprAbsOrigViolationNonlinear(
        scip: *mut SCIP,
        expr: *mut SCIP_EXPR,
        sol: *mut SCIP_SOL,
        soltag: ::std::os::raw::c_longlong,
        viol: *mut f64,
        violunder: *mut ::std::os::raw::c_uint,
        violover: *mut ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " computes absolute violation for auxvar relation in an expression w.r.t. auxiliary variables\n\n Assume the expression is f(w), where w are auxiliary variables that were introduced by some nlhdlr.\n Assume that f(w) is associated with auxiliary variable z.\n\n If there are negative locks, then returns the violation of z &le; f(w) and sets `violover` to TRUE.\n If there are positive locks, then returns the violation of z &ge; f(w) and sets `violunder` to TRUE.\n Of course, if there both negative and positive locks, then return the violation of z = f(w).\n\n If the given value of f(w) is SCIP_INVALID, then `viol` is set to SCIPinfinity() and\n both `violover` and `violunder` are set to TRUE."]
    pub fn SCIPgetExprAbsAuxViolationNonlinear(
        scip: *mut SCIP,
        expr: *mut SCIP_EXPR,
        auxvalue: f64,
        sol: *mut SCIP_SOL,
        viol: *mut f64,
        violunder: *mut ::std::os::raw::c_uint,
        violover: *mut ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " computes relative violation for auxvar relation in an expression w.r.t. auxiliary variables\n\n Assume the expression is f(w), where w are auxiliary variables that were introduced by some nlhdlr.\n Assume that f(w) is associated with auxiliary variable z.\n\n Taking the absolute violation from SCIPgetExprAbsAuxViolationNonlinear(), this function returns\n the absolute violation divided by max(1,|f(w)|).\n\n If the given value of f(w) is SCIP_INVALID, then `viol` is set to SCIPinfinity() and\n both `violover` and `violunder` are set to TRUE."]
    pub fn SCIPgetExprRelAuxViolationNonlinear(
        scip: *mut SCIP,
        expr: *mut SCIP_EXPR,
        auxvalue: f64,
        sol: *mut SCIP_SOL,
        viol: *mut f64,
        violunder: *mut ::std::os::raw::c_uint,
        violover: *mut ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " returns bounds on the expression\n\n This gives an intersection of bounds from\n - activity calculation (SCIPexprGetActivity()), if valid,\n - auxiliary variable, if present,\n - stored by SCIPtightenExprIntervalNonlinear() during domain propagation\n\n @note The returned interval can be empty!"]
    pub fn SCIPgetExprBoundsNonlinear(scip: *mut SCIP, expr: *mut SCIP_EXPR) -> SCIP_INTERVAL;
}
extern "C" {
    #[doc = " informs the expression about new bounds that can be used for reverse-propagation and to tighten bounds of\n corresponding (auxiliary) variable (if any)\n\n @attention this function should only be called during domain propagation in cons_nonlinear"]
    pub fn SCIPtightenExprIntervalNonlinear(
        scip: *mut SCIP,
        expr: *mut SCIP_EXPR,
        newbounds: SCIP_INTERVAL,
        cutoff: *mut ::std::os::raw::c_uint,
        ntightenings: *mut ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " mark constraints that include this expression to be propagated again\n\n This can be used by, e.g., nlhdlrs, to trigger a new propagation of constraints without\n a change of variable bounds, e.g., because new information on the expression is available\n that could potentially lead to tighter expression activity values.\n\n Note, that this call marks also constraints for propagation which only share some variable\n with this expression."]
    pub fn SCIPmarkExprPropagateNonlinear(scip: *mut SCIP, expr: *mut SCIP_EXPR) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " adds violation-branching score to an expression\n\n Adds a score to the expression-specific violation-branching score, thereby marking it as branching candidate.\n The expression must either be a variable expression or have an aux-variable.\n In the latter case, branching on auxiliary variables must have been enabled.\n In case of doubt, use SCIPaddExprsViolScoreNonlinear(). Roughly, the difference between these functions is that the current\n function adds `violscore` to the expression directly, while SCIPaddExprsViolScoreNonlinear() will split the\n violation score among all the given expressions according to parameter constraints/nonlinear/branching/violsplit.\n\n @see SCIPaddExprsViolScoreNonlinear()"]
    pub fn SCIPaddExprViolScoreNonlinear(scip: *mut SCIP, expr: *mut SCIP_EXPR, violscore: f64);
}
extern "C" {
    #[doc = " adds violation-branching score to a set of expressions, distributing the score among all the expressions\n\n Each expression must either be a variable expression or have an aux-variable.\n If branching on aux-variables is disabled, then the violation branching score will be distributed among all\n variables present in `exprs`."]
    pub fn SCIPaddExprsViolScoreNonlinear(
        scip: *mut SCIP,
        exprs: *mut *mut SCIP_EXPR,
        nexprs: ::std::os::raw::c_int,
        violscore: f64,
        sol: *mut SCIP_SOL,
        success: *mut ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " gives violation-branching score stored in expression, or 0.0 if no valid score has been stored"]
    pub fn SCIPgetExprViolScoreNonlinear(expr: *mut SCIP_EXPR) -> f64;
}
extern "C" {
    #[doc = " returns the partial derivative of an expression w.r.t. a variable (or SCIP_INVALID if there was an evaluation error)\n\n @see SCIPexprGetDerivative()"]
    pub fn SCIPgetExprPartialDiffNonlinear(
        scip: *mut SCIP,
        expr: *mut SCIP_EXPR,
        var: *mut SCIP_VAR,
    ) -> f64;
}
extern "C" {
    #[doc = " returns the var's coordinate of Hu partial derivative of an expression w.r.t. a variable (or SCIP_INVALID if there was an evaluation error)\n\n @see SCIPexprGetBardot()"]
    pub fn SCIPgetExprPartialDiffGradientDirNonlinear(
        scip: *mut SCIP,
        expr: *mut SCIP_EXPR,
        var: *mut SCIP_VAR,
    ) -> f64;
}
extern "C" {
    #[doc = " evaluates quadratic term in a solution w.r.t. auxiliary variables\n\n \\note This requires that for every expr used in the quadratic data, a variable or auxiliary variable is available."]
    pub fn SCIPevalExprQuadraticAuxNonlinear(
        scip: *mut SCIP,
        expr: *mut SCIP_EXPR,
        sol: *mut SCIP_SOL,
    ) -> f64;
}
extern "C" {
    #[doc = " creates a nonlinear handler and includes it into the nonlinear constraint handler"]
    pub fn SCIPincludeNlhdlrNonlinear(
        scip: *mut SCIP,
        nlhdlr: *mut *mut SCIP_NLHDLR,
        name: *const ::std::os::raw::c_char,
        desc: *const ::std::os::raw::c_char,
        detectpriority: ::std::os::raw::c_int,
        enfopriority: ::std::os::raw::c_int,
        detect: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                conshdlr: *mut SCIP_CONSHDLR,
                nlhdlr: *mut SCIP_NLHDLR,
                expr: *mut SCIP_EXPR,
                cons: *mut SCIP_CONS,
                enforcing: *mut SCIP_NLHDLR_METHOD,
                participating: *mut SCIP_NLHDLR_METHOD,
                nlhdlrexprdata: *mut *mut SCIP_NLHDLREXPRDATA,
            ) -> SCIP_RETCODE,
        >,
        evalaux: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                nlhdlr: *mut SCIP_NLHDLR,
                expr: *mut SCIP_EXPR,
                nlhdlrexprdata: *mut SCIP_NLHDLREXPRDATA,
                auxvalue: *mut f64,
                sol: *mut SCIP_SOL,
            ) -> SCIP_RETCODE,
        >,
        nlhdlrdata: *mut SCIP_NLHDLRDATA,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " get number of nonlinear handler"]
    pub fn SCIPgetNNlhdlrsNonlinear(conshdlr: *mut SCIP_CONSHDLR) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " get nonlinear handlers"]
    pub fn SCIPgetNlhdlrsNonlinear(conshdlr: *mut SCIP_CONSHDLR) -> *mut *mut SCIP_NLHDLR;
}
extern "C" {
    #[doc = " returns a nonlinear handler of a given name (or NULL if not found)"]
    pub fn SCIPfindNlhdlrNonlinear(
        conshdlr: *mut SCIP_CONSHDLR,
        name: *const ::std::os::raw::c_char,
    ) -> *mut SCIP_NLHDLR;
}
extern "C" {
    #[doc = " gives expression data that a given nonlinear handler stored in an expression\n\n Returns NULL if expr has not been detected by nlhdlr or nlhdlr did not store data."]
    pub fn SCIPgetNlhdlrExprDataNonlinear(
        nlhdlr: *mut SCIP_NLHDLR,
        expr: *mut SCIP_EXPR,
    ) -> *mut SCIP_NLHDLREXPRDATA;
}
extern "C" {
    #[doc = " creates the handler for or constraints and includes it in SCIP\n\n @ingroup ConshdlrIncludes"]
    pub fn SCIPincludeConshdlrOr(scip: *mut SCIP) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " creates and captures an or constraint\n\n  @note the constraint gets captured, hence at one point you have to release it using the method SCIPreleaseCons()"]
    pub fn SCIPcreateConsOr(
        scip: *mut SCIP,
        cons: *mut *mut SCIP_CONS,
        name: *const ::std::os::raw::c_char,
        resvar: *mut SCIP_VAR,
        nvars: ::std::os::raw::c_int,
        vars: *mut *mut SCIP_VAR,
        initial: ::std::os::raw::c_uint,
        separate: ::std::os::raw::c_uint,
        enforce: ::std::os::raw::c_uint,
        check: ::std::os::raw::c_uint,
        propagate: ::std::os::raw::c_uint,
        local: ::std::os::raw::c_uint,
        modifiable: ::std::os::raw::c_uint,
        dynamic: ::std::os::raw::c_uint,
        removable: ::std::os::raw::c_uint,
        stickingatnode: ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " creates and captures an or constraint\n  in its most basic version, i. e., all constraint flags are set to their basic value as explained for the\n  method SCIPcreateConsNonlinear(); all flags can be set via SCIPsetConsFLAGNAME-methods in scip.h\n\n  @see SCIPcreateConsOr() for information about the basic constraint flag configuration\n\n  @note the constraint gets captured, hence at one point you have to release it using the method SCIPreleaseCons()"]
    pub fn SCIPcreateConsBasicOr(
        scip: *mut SCIP,
        cons: *mut *mut SCIP_CONS,
        name: *const ::std::os::raw::c_char,
        resvar: *mut SCIP_VAR,
        nvars: ::std::os::raw::c_int,
        vars: *mut *mut SCIP_VAR,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " gets number of variables in or constraint"]
    pub fn SCIPgetNVarsOr(scip: *mut SCIP, cons: *mut SCIP_CONS) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " gets array of variables in or constraint"]
    pub fn SCIPgetVarsOr(scip: *mut SCIP, cons: *mut SCIP_CONS) -> *mut *mut SCIP_VAR;
}
extern "C" {
    #[doc = " gets the resultant variable in or constraint"]
    pub fn SCIPgetResultantOr(scip: *mut SCIP, cons: *mut SCIP_CONS) -> *mut SCIP_VAR;
}
extern "C" {
    #[doc = " creates the handler for orbisack constraints and includes it in SCIP\n\n  @ingroup ConshdlrIncludes"]
    pub fn SCIPincludeConshdlrOrbisack(scip: *mut SCIP) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " checks whether a given binary solution is feasible for the orbisack"]
    pub fn SCIPcheckSolutionOrbisack(
        scip: *mut SCIP,
        sol: *mut SCIP_SOL,
        vars1: *mut *mut SCIP_VAR,
        vars2: *mut *mut SCIP_VAR,
        nrows: ::std::os::raw::c_int,
        printreason: ::std::os::raw::c_uint,
        feasible: *mut ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " creates and captures a orbisack constraint\n\n  @note the constraint gets captured, hence at one point you have to release it using the method SCIPreleaseCons()"]
    pub fn SCIPcreateConsOrbisack(
        scip: *mut SCIP,
        cons: *mut *mut SCIP_CONS,
        name: *const ::std::os::raw::c_char,
        vars1: *const *mut SCIP_VAR,
        vars2: *const *mut SCIP_VAR,
        nrows: ::std::os::raw::c_int,
        ispporbisack: ::std::os::raw::c_uint,
        isparttype: ::std::os::raw::c_uint,
        ismodelcons: ::std::os::raw::c_uint,
        initial: ::std::os::raw::c_uint,
        separate: ::std::os::raw::c_uint,
        enforce: ::std::os::raw::c_uint,
        check: ::std::os::raw::c_uint,
        propagate: ::std::os::raw::c_uint,
        local: ::std::os::raw::c_uint,
        modifiable: ::std::os::raw::c_uint,
        dynamic: ::std::os::raw::c_uint,
        removable: ::std::os::raw::c_uint,
        stickingatnode: ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " creates and captures an orbisack constraint in its most basic variant\n\n  All constraint flags set to their default values, which can be set afterwards using SCIPsetConsFLAGNAME() in scip.h.\n\n  @see SCIPcreateConsOrbisack() for the default constraint flag configuration\n\n  @note the constraint gets captured, hence at one point you have to release it using the method SCIPreleaseCons()"]
    pub fn SCIPcreateConsBasicOrbisack(
        scip: *mut SCIP,
        cons: *mut *mut SCIP_CONS,
        name: *const ::std::os::raw::c_char,
        vars1: *mut *mut SCIP_VAR,
        vars2: *mut *mut SCIP_VAR,
        nrows: ::std::os::raw::c_int,
        ispporbisack: ::std::os::raw::c_uint,
        isparttype: ::std::os::raw::c_uint,
        ismodelcons: ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
pub type SYM_SPEC = u32;
#[doc = "< permutation symmetries"]
pub const SYM_Symtype_SYM_SYMTYPE_PERM: SYM_Symtype = 0;
#[doc = "< signed permutation symmetries"]
pub const SYM_Symtype_SYM_SYMTYPE_SIGNPERM: SYM_Symtype = 1;
#[doc = " define symmetry types detectable by SCIP"]
pub type SYM_Symtype = ::std::os::raw::c_uint;
#[doc = " define symmetry types detectable by SCIP"]
pub use self::SYM_Symtype as SYM_SYMTYPE;
#[doc = "< operator node"]
pub const SYM_Nodetype_SYM_NODETYPE_OPERATOR: SYM_Nodetype = 0;
#[doc = "< numerical value node"]
pub const SYM_Nodetype_SYM_NODETYPE_VAL: SYM_Nodetype = 1;
#[doc = "< constraint node"]
pub const SYM_Nodetype_SYM_NODETYPE_CONS: SYM_Nodetype = 2;
#[doc = "< variable node"]
pub const SYM_Nodetype_SYM_NODETYPE_VAR: SYM_Nodetype = 3;
#[doc = " define type of nodes in symmetry detection expression trees"]
pub type SYM_Nodetype = ::std::os::raw::c_uint;
#[doc = " define type of nodes in symmetry detection expression trees"]
pub use self::SYM_Nodetype as SYM_NODETYPE;
#[doc = "< unknown constraint type"]
pub const SYM_Consoptype_SYM_CONSOPTYPE_UNKNOWN: SYM_Consoptype = 0;
#[doc = "< constraint of type bounddisjunction"]
pub const SYM_Consoptype_SYM_CONSOPTYPE_BDDISJ: SYM_Consoptype = 1;
#[doc = "< encodes == in indicator constraints for activation variable"]
pub const SYM_Consoptype_SYM_CONSOPTYPE_EQ: SYM_Consoptype = 2;
#[doc = "< encodes pairs in SOS2 constraints"]
pub const SYM_Consoptype_SYM_CONSOPTYPE_SOS2_TUPLE: SYM_Consoptype = 3;
#[doc = "< indicates sums if sum-expr undefined"]
pub const SYM_Consoptype_SYM_CONSOPTYPE_SUM: SYM_Consoptype = 4;
#[doc = "< indicates slack vars in indicator constraints"]
pub const SYM_Consoptype_SYM_CONSOPTYPE_SLACK: SYM_Consoptype = 5;
#[doc = "< indicates coefficients from parent expressions"]
pub const SYM_Consoptype_SYM_CONSOPTYPE_COEF: SYM_Consoptype = 6;
#[doc = "< indicates a squared difference"]
pub const SYM_Consoptype_SYM_CONSOPTYPE_SQDIFF: SYM_Consoptype = 7;
#[doc = "< encodes pairs in cardinality constraints"]
pub const SYM_Consoptype_SYM_CONSOPTYPE_CARD_TUPLE: SYM_Consoptype = 8;
#[doc = "< number of predefined enum types, needs to always\n   hold the biggest value"]
pub const SYM_Consoptype_SYM_CONSOPTYPE_LAST: SYM_Consoptype = 9;
#[doc = " define type of simple constraints/operators in symmetry detection"]
pub type SYM_Consoptype = ::std::os::raw::c_uint;
#[doc = " define type of simple constraints/operators in symmetry detection"]
pub use self::SYM_Consoptype as SYM_CONSOPTYPE;
pub type SYM_HANDLETYPE = u32;
#[doc = "< first var in orbit"]
pub const SCIP_LeaderRule_SCIP_LEADERRULE_FIRSTINORBIT: SCIP_LeaderRule = 0;
#[doc = "< last var in orbit"]
pub const SCIP_LeaderRule_SCIP_LEADERRULE_LASTINORBIT: SCIP_LeaderRule = 1;
#[doc = "< var with most conflicting vars in its orbit"]
pub const SCIP_LeaderRule_SCIP_LEADERRULE_MAXCONFLICTSINORBIT: SCIP_LeaderRule = 2;
#[doc = " selection rules for leaders in SST cuts"]
pub type SCIP_LeaderRule = ::std::os::raw::c_uint;
#[doc = " selection rules for leaders in SST cuts"]
pub use self::SCIP_LeaderRule as SCIP_LEADERRULE;
#[doc = "< orbit of minimum size"]
pub const SCIP_LeaderTiebreakRule_SCIP_LEADERTIEBREAKRULE_MINORBIT: SCIP_LeaderTiebreakRule = 0;
#[doc = "< orbit of maximum size"]
pub const SCIP_LeaderTiebreakRule_SCIP_LEADERTIEBREAKRULE_MAXORBIT: SCIP_LeaderTiebreakRule = 1;
#[doc = "< orbit with maximum number of vars in conflict with leader"]
pub const SCIP_LeaderTiebreakRule_SCIP_LEADERTIEBREAKRULE_MAXCONFLICTSINORBIT:
    SCIP_LeaderTiebreakRule = 2;
#[doc = " tie breaks for leader rule based on the leader's orbit"]
pub type SCIP_LeaderTiebreakRule = ::std::os::raw::c_uint;
#[doc = "< binary variables"]
pub const SCIP_SSTType_SCIP_SSTTYPE_BINARY: SCIP_SSTType = 1;
#[doc = "< integer variables"]
pub const SCIP_SSTType_SCIP_SSTTYPE_INTEGER: SCIP_SSTType = 2;
#[doc = "< implicitly integer variables"]
pub const SCIP_SSTType_SCIP_SSTTYPE_IMPLINT: SCIP_SSTType = 4;
#[doc = "< continuous variables"]
pub const SCIP_SSTType_SCIP_SSTTYPE_CONTINUOUS: SCIP_SSTType = 8;
#[doc = " variable types for leader in Schreier Sims cuts"]
pub type SCIP_SSTType = ::std::os::raw::c_uint;
#[doc = " variable types for leader in Schreier Sims cuts"]
pub use self::SCIP_SSTType as SCIP_SSTTYPE;
#[doc = "< constraint is a full orbitope constraint:         rowsum(x) unrestricted"]
pub const SCIP_OrbitopeType_SCIP_ORBITOPETYPE_FULL: SCIP_OrbitopeType = 0;
#[doc = "< constraint is a partitioning orbitope constraint: rowsum(x) == 1"]
pub const SCIP_OrbitopeType_SCIP_ORBITOPETYPE_PARTITIONING: SCIP_OrbitopeType = 1;
#[doc = "< constraint is a packing orbitope constraint:      rowsum(x) <= 1"]
pub const SCIP_OrbitopeType_SCIP_ORBITOPETYPE_PACKING: SCIP_OrbitopeType = 2;
#[doc = " type of orbitope constraint: full, packing, or partitioning orbitope"]
pub type SCIP_OrbitopeType = ::std::os::raw::c_uint;
#[doc = " type of orbitope constraint: full, packing, or partitioning orbitope"]
pub use self::SCIP_OrbitopeType as SCIP_ORBITOPETYPE;
extern "C" {
    #[doc = " creates the handler for orbitope constraints and includes it in SCIP\n\n @ingroup ConshdlrIncludes"]
    pub fn SCIPincludeConshdlrOrbitope(scip: *mut SCIP) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " creates and captures a orbitope constraint\n\n  @note the constraint gets captured, hence at one point you have to release it using the method SCIPreleaseCons()"]
    pub fn SCIPcreateConsOrbitope(
        scip: *mut SCIP,
        cons: *mut *mut SCIP_CONS,
        name: *const ::std::os::raw::c_char,
        vars: *mut *mut *mut SCIP_VAR,
        orbitopetype: SCIP_ORBITOPETYPE,
        nspcons: ::std::os::raw::c_int,
        nblocks: ::std::os::raw::c_int,
        usedynamicprop: ::std::os::raw::c_uint,
        mayinteract: ::std::os::raw::c_uint,
        resolveprop: ::std::os::raw::c_uint,
        ismodelcons: ::std::os::raw::c_uint,
        initial: ::std::os::raw::c_uint,
        separate: ::std::os::raw::c_uint,
        enforce: ::std::os::raw::c_uint,
        check: ::std::os::raw::c_uint,
        propagate: ::std::os::raw::c_uint,
        local: ::std::os::raw::c_uint,
        modifiable: ::std::os::raw::c_uint,
        dynamic: ::std::os::raw::c_uint,
        removable: ::std::os::raw::c_uint,
        stickingatnode: ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " creates and captures an orbitope constraint\n  in its most basic variant, i. e., with all constraint flags set to their default values, which can be set\n  afterwards using SCIPsetConsFLAGNAME() in scip.h\n\n  @see SCIPcreateConsOrbitope() for the default constraint flag configuration\n\n  @note the constraint gets captured, hence at one point you have to release it using the method SCIPreleaseCons()"]
    pub fn SCIPcreateConsBasicOrbitope(
        scip: *mut SCIP,
        cons: *mut *mut SCIP_CONS,
        name: *const ::std::os::raw::c_char,
        vars: *mut *mut *mut SCIP_VAR,
        orbitopetype: SCIP_ORBITOPETYPE,
        nspcons: ::std::os::raw::c_int,
        nblocks: ::std::os::raw::c_int,
        usedynamicprop: ::std::os::raw::c_uint,
        resolveprop: ::std::os::raw::c_uint,
        ismodelcons: ::std::os::raw::c_uint,
        mayinteract: ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " creates the handler for pseudoboolean constraints and includes it in SCIP\n\n @ingroup ConshdlrIncludes"]
    pub fn SCIPincludeConshdlrPseudoboolean(scip: *mut SCIP) -> SCIP_RETCODE;
}
#[doc = "< this is no valid linear constraint type"]
pub const SCIP_LinearConsType_SCIP_LINEARCONSTYPE_INVALIDCONS: SCIP_LinearConsType = -1;
#[doc = "< this is the common linear constraint"]
pub const SCIP_LinearConsType_SCIP_LINEARCONSTYPE_LINEAR: SCIP_LinearConsType = 0;
#[doc = "< this is a logicor constraint"]
pub const SCIP_LinearConsType_SCIP_LINEARCONSTYPE_LOGICOR: SCIP_LinearConsType = 1;
#[doc = "< this is a knapsack constraint"]
pub const SCIP_LinearConsType_SCIP_LINEARCONSTYPE_KNAPSACK: SCIP_LinearConsType = 2;
#[doc = "< this is a setppc constraint"]
pub const SCIP_LinearConsType_SCIP_LINEARCONSTYPE_SETPPC: SCIP_LinearConsType = 3;
#[doc = " solution status after solving LP"]
pub type SCIP_LinearConsType = ::std::os::raw::c_int;
#[doc = " solution status after solving LP"]
pub use self::SCIP_LinearConsType as SCIP_LINEARCONSTYPE;
extern "C" {
    #[doc = " creates and captures a pseudoboolean constraint, with given linear and and-constraints\n\n  @note intvar must currently be NULL"]
    pub fn SCIPcreateConsPseudobooleanWithConss(
        scip: *mut SCIP,
        cons: *mut *mut SCIP_CONS,
        name: *const ::std::os::raw::c_char,
        lincons: *mut SCIP_CONS,
        linconstype: SCIP_LINEARCONSTYPE,
        andconss: *mut *mut SCIP_CONS,
        andcoefs: *mut f64,
        nandconss: ::std::os::raw::c_int,
        indvar: *mut SCIP_VAR,
        weight: f64,
        issoftcons: ::std::os::raw::c_uint,
        intvar: *mut SCIP_VAR,
        lhs: f64,
        rhs: f64,
        initial: ::std::os::raw::c_uint,
        separate: ::std::os::raw::c_uint,
        enforce: ::std::os::raw::c_uint,
        check: ::std::os::raw::c_uint,
        propagate: ::std::os::raw::c_uint,
        local: ::std::os::raw::c_uint,
        modifiable: ::std::os::raw::c_uint,
        dynamic: ::std::os::raw::c_uint,
        removable: ::std::os::raw::c_uint,
        stickingatnode: ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " creates and captures a pseudoboolean constraint\n\n  @note linear and nonlinear terms can be added using SCIPaddCoefPseudoboolean() and SCIPaddTermPseudoboolean(),\n        respectively\n\n  @note the constraint gets captured, hence at one point you have to release it using the method SCIPreleaseCons()\n\n  @note intvar must currently be NULL"]
    pub fn SCIPcreateConsPseudoboolean(
        scip: *mut SCIP,
        cons: *mut *mut SCIP_CONS,
        name: *const ::std::os::raw::c_char,
        linvars: *mut *mut SCIP_VAR,
        nlinvars: ::std::os::raw::c_int,
        linvals: *mut f64,
        terms: *mut *mut *mut SCIP_VAR,
        nterms: ::std::os::raw::c_int,
        ntermvars: *mut ::std::os::raw::c_int,
        termvals: *mut f64,
        indvar: *mut SCIP_VAR,
        weight: f64,
        issoftcons: ::std::os::raw::c_uint,
        intvar: *mut SCIP_VAR,
        lhs: f64,
        rhs: f64,
        initial: ::std::os::raw::c_uint,
        separate: ::std::os::raw::c_uint,
        enforce: ::std::os::raw::c_uint,
        check: ::std::os::raw::c_uint,
        propagate: ::std::os::raw::c_uint,
        local: ::std::os::raw::c_uint,
        modifiable: ::std::os::raw::c_uint,
        dynamic: ::std::os::raw::c_uint,
        removable: ::std::os::raw::c_uint,
        stickingatnode: ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " creates and captures a pseudoboolean constraint\n  in its most basic variant, i. e., with all constraint flags set to their default values, which can be set\n  afterwards using SCIPsetConsFLAGNAME() in scip.h\n\n  @see SCIPcreateConsPseudoboolean() for the default constraint flag configuration\n\n  @note the constraint gets captured, hence at one point you have to release it using the method SCIPreleaseCons()\n\n  @note intvar must currently be NULL"]
    pub fn SCIPcreateConsBasicPseudoboolean(
        scip: *mut SCIP,
        cons: *mut *mut SCIP_CONS,
        name: *const ::std::os::raw::c_char,
        linvars: *mut *mut SCIP_VAR,
        nlinvars: ::std::os::raw::c_int,
        linvals: *mut f64,
        terms: *mut *mut *mut SCIP_VAR,
        nterms: ::std::os::raw::c_int,
        ntermvars: *mut ::std::os::raw::c_int,
        termvals: *mut f64,
        indvar: *mut SCIP_VAR,
        weight: f64,
        issoftcons: ::std::os::raw::c_uint,
        intvar: *mut SCIP_VAR,
        lhs: f64,
        rhs: f64,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " adds linear term pseudo boolean constraint (if it is not zero)\n\n @note you can only add a coefficient if the special type of linear constraint won't changed\n\n @todo if adding a coefficient would change the type of the special linear constraint, we need to erase it and\n       create a new linear constraint"]
    pub fn SCIPaddCoefPseudoboolean(
        scip: *mut SCIP,
        cons: *mut SCIP_CONS,
        var: *mut SCIP_VAR,
        val: f64,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " adds nonlinear term to pseudo boolean constraint (if it is not zero)\n\n @note you can only add a coefficient if the special type of linear constraint won't changed\n\n @todo if adding a coefficient would change the type of the special linear constraint, we need to erase it and\n       create a new linear constraint"]
    pub fn SCIPaddTermPseudoboolean(
        scip: *mut SCIP,
        cons: *mut SCIP_CONS,
        vars: *mut *mut SCIP_VAR,
        nvars: ::std::os::raw::c_int,
        val: f64,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " gets indicator variable of pseudoboolean constraint, or NULL if there is no"]
    pub fn SCIPgetIndVarPseudoboolean(scip: *mut SCIP, cons: *mut SCIP_CONS) -> *mut SCIP_VAR;
}
extern "C" {
    #[doc = " gets linear constraint of pseudoboolean constraint"]
    pub fn SCIPgetLinearConsPseudoboolean(scip: *mut SCIP, cons: *mut SCIP_CONS) -> *mut SCIP_CONS;
}
extern "C" {
    #[doc = " gets type of linear constraint of pseudoboolean constraint"]
    pub fn SCIPgetLinearConsTypePseudoboolean(
        scip: *mut SCIP,
        cons: *mut SCIP_CONS,
    ) -> SCIP_LINEARCONSTYPE;
}
extern "C" {
    #[doc = " gets number of linear variables without artificial terms variables of pseudoboolean constraint"]
    pub fn SCIPgetNLinVarsWithoutAndPseudoboolean(
        scip: *mut SCIP,
        cons: *mut SCIP_CONS,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " gets linear constraint of pseudoboolean constraint"]
    pub fn SCIPgetLinDatasWithoutAndPseudoboolean(
        scip: *mut SCIP,
        cons: *mut SCIP_CONS,
        linvars: *mut *mut SCIP_VAR,
        lincoefs: *mut f64,
        nlinvars: *mut ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " gets and-constraints of pseudoboolean constraint"]
    pub fn SCIPgetAndDatasPseudoboolean(
        scip: *mut SCIP,
        cons: *mut SCIP_CONS,
        andconss: *mut *mut SCIP_CONS,
        andcoefs: *mut f64,
        nandconss: *mut ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " gets number of and constraints of pseudoboolean constraint"]
    pub fn SCIPgetNAndsPseudoboolean(
        scip: *mut SCIP,
        cons: *mut SCIP_CONS,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " changes left hand side of pseudoboolean constraint\n\n @note you can only change the left hand side if the special type of linear constraint won't changed\n\n @todo if changing the left hand side would change the type of the special linear constraint, we need to erase it\n       and create a new linear constraint"]
    pub fn SCIPchgLhsPseudoboolean(scip: *mut SCIP, cons: *mut SCIP_CONS, lhs: f64)
        -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " changes right hand side of pseudoboolean constraint\n\n @note you can only change the right hand side if the special type of linear constraint won't changed\n\n @todo if changing the right hand side would change the type of the special linear constraint, we need to erase it\n       and create a new linear constraint"]
    pub fn SCIPchgRhsPseudoboolean(scip: *mut SCIP, cons: *mut SCIP_CONS, rhs: f64)
        -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " get left hand side of pseudoboolean constraint"]
    pub fn SCIPgetLhsPseudoboolean(scip: *mut SCIP, cons: *mut SCIP_CONS) -> f64;
}
extern "C" {
    #[doc = " get right hand side of pseudoboolean constraint"]
    pub fn SCIPgetRhsPseudoboolean(scip: *mut SCIP, cons: *mut SCIP_CONS) -> f64;
}
extern "C" {
    #[doc = " creates the handler for set partitioning / packing / covering constraints and includes it in SCIP\n\n @ingroup ConshdlrIncludes"]
    pub fn SCIPincludeConshdlrSetppc(scip: *mut SCIP) -> SCIP_RETCODE;
}
#[doc = "< constraint is a set partitioning constraint: sum(x) == 1"]
pub const SCIP_SetppcType_SCIP_SETPPCTYPE_PARTITIONING: SCIP_SetppcType = 0;
#[doc = "< constraint is a set packing constraint:      sum(x) <= 1"]
pub const SCIP_SetppcType_SCIP_SETPPCTYPE_PACKING: SCIP_SetppcType = 1;
#[doc = "< constraint is a set covering constraint:     sum(x) >= 1"]
pub const SCIP_SetppcType_SCIP_SETPPCTYPE_COVERING: SCIP_SetppcType = 2;
#[doc = " type of setppc constraint: set partitioning, set packing, or set covering"]
pub type SCIP_SetppcType = ::std::os::raw::c_uint;
#[doc = " type of setppc constraint: set partitioning, set packing, or set covering"]
pub use self::SCIP_SetppcType as SCIP_SETPPCTYPE;
extern "C" {
    #[doc = " creates and captures a set partitioning constraint\n\n  @note the constraint gets captured, hence at one point you have to release it using the method SCIPreleaseCons()"]
    pub fn SCIPcreateConsSetpart(
        scip: *mut SCIP,
        cons: *mut *mut SCIP_CONS,
        name: *const ::std::os::raw::c_char,
        nvars: ::std::os::raw::c_int,
        vars: *mut *mut SCIP_VAR,
        initial: ::std::os::raw::c_uint,
        separate: ::std::os::raw::c_uint,
        enforce: ::std::os::raw::c_uint,
        check: ::std::os::raw::c_uint,
        propagate: ::std::os::raw::c_uint,
        local: ::std::os::raw::c_uint,
        modifiable: ::std::os::raw::c_uint,
        dynamic: ::std::os::raw::c_uint,
        removable: ::std::os::raw::c_uint,
        stickingatnode: ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " creates and captures a set partitioning constraint\n  in its most basic variant, i. e., with all constraint flags set to their default values, which can be set\n  afterwards using SCIPsetConsFLAGNAME() in scip.h\n\n  @see SCIPcreateConsSetpart() for the default constraint flag configuration\n\n  @note the constraint gets captured, hence at one point you have to release it using the method SCIPreleaseCons()"]
    pub fn SCIPcreateConsBasicSetpart(
        scip: *mut SCIP,
        cons: *mut *mut SCIP_CONS,
        name: *const ::std::os::raw::c_char,
        nvars: ::std::os::raw::c_int,
        vars: *mut *mut SCIP_VAR,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " creates and captures a set packing constraint\n\n  @note the constraint gets captured, hence at one point you have to release it using the method SCIPreleaseCons()"]
    pub fn SCIPcreateConsSetpack(
        scip: *mut SCIP,
        cons: *mut *mut SCIP_CONS,
        name: *const ::std::os::raw::c_char,
        nvars: ::std::os::raw::c_int,
        vars: *mut *mut SCIP_VAR,
        initial: ::std::os::raw::c_uint,
        separate: ::std::os::raw::c_uint,
        enforce: ::std::os::raw::c_uint,
        check: ::std::os::raw::c_uint,
        propagate: ::std::os::raw::c_uint,
        local: ::std::os::raw::c_uint,
        modifiable: ::std::os::raw::c_uint,
        dynamic: ::std::os::raw::c_uint,
        removable: ::std::os::raw::c_uint,
        stickingatnode: ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " creates and captures a set packing constraint\n  in its most basic variant, i. e., with all constraint flags set to their default values, which can be set\n  afterwards using SCIPsetConsFLAGNAME() in scip.h\n\n  @see SCIPcreateConsSetpack() for the default constraint flag configuration\n\n  @note the constraint gets captured, hence at one point you have to release it using the method SCIPreleaseCons()"]
    pub fn SCIPcreateConsBasicSetpack(
        scip: *mut SCIP,
        cons: *mut *mut SCIP_CONS,
        name: *const ::std::os::raw::c_char,
        nvars: ::std::os::raw::c_int,
        vars: *mut *mut SCIP_VAR,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " creates and captures a set covering constraint\n\n  @note the constraint gets captured, hence at one point you have to release it using the method SCIPreleaseCons()"]
    pub fn SCIPcreateConsSetcover(
        scip: *mut SCIP,
        cons: *mut *mut SCIP_CONS,
        name: *const ::std::os::raw::c_char,
        nvars: ::std::os::raw::c_int,
        vars: *mut *mut SCIP_VAR,
        initial: ::std::os::raw::c_uint,
        separate: ::std::os::raw::c_uint,
        enforce: ::std::os::raw::c_uint,
        check: ::std::os::raw::c_uint,
        propagate: ::std::os::raw::c_uint,
        local: ::std::os::raw::c_uint,
        modifiable: ::std::os::raw::c_uint,
        dynamic: ::std::os::raw::c_uint,
        removable: ::std::os::raw::c_uint,
        stickingatnode: ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " creates and captures a set packing constraint\n  in its most basic variant, i. e., with all constraint flags set to their default values, which can be set\n  afterwards using SCIPsetConsFLAGNAME() in scip.h\n\n  @see SCIPcreateConsSetpack() for the default constraint flag configuration\n\n  @note the constraint gets captured, hence at one point you have to release it using the method SCIPreleaseCons()"]
    pub fn SCIPcreateConsBasicSetcover(
        scip: *mut SCIP,
        cons: *mut *mut SCIP_CONS,
        name: *const ::std::os::raw::c_char,
        nvars: ::std::os::raw::c_int,
        vars: *mut *mut SCIP_VAR,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " adds coefficient in set partitioning / packing / covering constraint"]
    pub fn SCIPaddCoefSetppc(
        scip: *mut SCIP,
        cons: *mut SCIP_CONS,
        var: *mut SCIP_VAR,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " gets number of variables in set partitioning / packing / covering constraint"]
    pub fn SCIPgetNVarsSetppc(scip: *mut SCIP, cons: *mut SCIP_CONS) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " gets array of variables in set partitioning / packing / covering constraint"]
    pub fn SCIPgetVarsSetppc(scip: *mut SCIP, cons: *mut SCIP_CONS) -> *mut *mut SCIP_VAR;
}
extern "C" {
    #[doc = " gets type of set partitioning / packing / covering constraint"]
    pub fn SCIPgetTypeSetppc(scip: *mut SCIP, cons: *mut SCIP_CONS) -> SCIP_SETPPCTYPE;
}
extern "C" {
    #[doc = " gets the dual solution of the set partitioning / packing / covering constraint in the current LP"]
    pub fn SCIPgetDualsolSetppc(scip: *mut SCIP, cons: *mut SCIP_CONS) -> f64;
}
extern "C" {
    #[doc = " gets the dual Farkas value of the set partitioning / packing / covering constraint in the current infeasible LP"]
    pub fn SCIPgetDualfarkasSetppc(scip: *mut SCIP, cons: *mut SCIP_CONS) -> f64;
}
extern "C" {
    #[doc = " returns the linear relaxation of the given set partitioning / packing / covering constraint; may return NULL if no\n  LP row was yet created; the user must not modify the row!"]
    pub fn SCIPgetRowSetppc(scip: *mut SCIP, cons: *mut SCIP_CONS) -> *mut SCIP_ROW;
}
extern "C" {
    #[doc = " returns current number of variables fixed to one in the constraint"]
    pub fn SCIPgetNFixedonesSetppc(scip: *mut SCIP, cons: *mut SCIP_CONS) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " returns current number of variables fixed to zero in the constraint"]
    pub fn SCIPgetNFixedzerosSetppc(scip: *mut SCIP, cons: *mut SCIP_CONS)
        -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " cleans up (multi-)aggregations and fixings from setppc constraints"]
    pub fn SCIPcleanupConssSetppc(
        scip: *mut SCIP,
        onlychecked: ::std::os::raw::c_uint,
        infeasible: *mut ::std::os::raw::c_uint,
        naddconss: *mut ::std::os::raw::c_int,
        ndelconss: *mut ::std::os::raw::c_int,
        nchgcoefs: *mut ::std::os::raw::c_int,
        nfixedvars: *mut ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " creates the handler for SOS1 constraints and includes it in SCIP\n\n @ingroup ConshdlrIncludes"]
    pub fn SCIPincludeConshdlrSOS1(scip: *mut SCIP) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " creates and captures an SOS1 constraint\n\n  We set the constraint to not be modifable. If the weights are non\n  NULL, the variables are ordered according to these weights (in\n  ascending order).\n\n  @note The constraint gets captured, hence at one point you have to release it using the method SCIPreleaseCons()."]
    pub fn SCIPcreateConsSOS1(
        scip: *mut SCIP,
        cons: *mut *mut SCIP_CONS,
        name: *const ::std::os::raw::c_char,
        nvars: ::std::os::raw::c_int,
        vars: *mut *mut SCIP_VAR,
        weights: *mut f64,
        initial: ::std::os::raw::c_uint,
        separate: ::std::os::raw::c_uint,
        enforce: ::std::os::raw::c_uint,
        check: ::std::os::raw::c_uint,
        propagate: ::std::os::raw::c_uint,
        local: ::std::os::raw::c_uint,
        dynamic: ::std::os::raw::c_uint,
        removable: ::std::os::raw::c_uint,
        stickingatnode: ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " creates and captures an SOS1 constraint\n  in its most basic variant, i. e., with all constraint flags set to their default values, which can be set\n  afterwards using SCIPsetConsFLAGNAME() in scip.h\n\n  @see SCIPcreateConsSOS1() for the default constraint flag configuration\n\n  @warning Do NOT set the constraint to be modifiable manually, because this might lead\n  to wrong results as the variable array will not be resorted\n\n  @note the constraint gets captured, hence at one point you have to release it using the method SCIPreleaseCons()"]
    pub fn SCIPcreateConsBasicSOS1(
        scip: *mut SCIP,
        cons: *mut *mut SCIP_CONS,
        name: *const ::std::os::raw::c_char,
        nvars: ::std::os::raw::c_int,
        vars: *mut *mut SCIP_VAR,
        weights: *mut f64,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " adds variable to SOS1 constraint, the position is determined by the given weight"]
    pub fn SCIPaddVarSOS1(
        scip: *mut SCIP,
        cons: *mut SCIP_CONS,
        var: *mut SCIP_VAR,
        weight: f64,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " appends variable to SOS1 constraint"]
    pub fn SCIPappendVarSOS1(
        scip: *mut SCIP,
        cons: *mut SCIP_CONS,
        var: *mut SCIP_VAR,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " gets number of variables in SOS1 constraint"]
    pub fn SCIPgetNVarsSOS1(scip: *mut SCIP, cons: *mut SCIP_CONS) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " gets array of variables in SOS1 constraint"]
    pub fn SCIPgetVarsSOS1(scip: *mut SCIP, cons: *mut SCIP_CONS) -> *mut *mut SCIP_VAR;
}
extern "C" {
    #[doc = " gets array of weights in SOS1 constraint (or NULL if not existent)"]
    pub fn SCIPgetWeightsSOS1(scip: *mut SCIP, cons: *mut SCIP_CONS) -> *mut f64;
}
extern "C" {
    #[doc = " gets conflict graph of SOS1 constraints (or NULL if not existent)\n\n  @note The conflict graph is globally valid; local changes are not taken into account."]
    pub fn SCIPgetConflictgraphSOS1(conshdlr: *mut SCIP_CONSHDLR) -> *mut SCIP_DIGRAPH;
}
extern "C" {
    #[doc = " gets number of problem variables that are part of the SOS1 conflict graph"]
    pub fn SCIPgetNSOS1Vars(conshdlr: *mut SCIP_CONSHDLR) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " returns whether variable is part of the SOS1 conflict graph"]
    pub fn SCIPvarIsSOS1(
        conshdlr: *mut SCIP_CONSHDLR,
        var: *mut SCIP_VAR,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " returns node of variable in the conflict graph or -1 if variable is not part of the SOS1 conflict graph"]
    pub fn SCIPvarGetNodeSOS1(
        conshdlr: *mut SCIP_CONSHDLR,
        var: *mut SCIP_VAR,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " returns variable that belongs to a given node from the conflict graph"]
    pub fn SCIPnodeGetVarSOS1(
        conflictgraph: *mut SCIP_DIGRAPH,
        node: ::std::os::raw::c_int,
    ) -> *mut SCIP_VAR;
}
extern "C" {
    #[doc = " based on solution values of the variables, fixes variables to zero to turn all SOS1 constraints feasible"]
    pub fn SCIPmakeSOS1sFeasible(
        scip: *mut SCIP,
        conshdlr: *mut SCIP_CONSHDLR,
        sol: *mut SCIP_SOL,
        changed: *mut ::std::os::raw::c_uint,
        success: *mut ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " creates the handler for SOS2 constraints and includes it in SCIP\n\n @ingroup ConshdlrIncludes"]
    pub fn SCIPincludeConshdlrSOS2(scip: *mut SCIP) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " creates and captures an SOS2 constraint\n\n  We set the constraint to not be modifable. If the weights are non\n  NULL, the variables are ordered according to these weights (in\n  ascending order).\n\n  @note the constraint gets captured, hence at one point you have to release it using the method SCIPreleaseCons()"]
    pub fn SCIPcreateConsSOS2(
        scip: *mut SCIP,
        cons: *mut *mut SCIP_CONS,
        name: *const ::std::os::raw::c_char,
        nvars: ::std::os::raw::c_int,
        vars: *mut *mut SCIP_VAR,
        weights: *mut f64,
        initial: ::std::os::raw::c_uint,
        separate: ::std::os::raw::c_uint,
        enforce: ::std::os::raw::c_uint,
        check: ::std::os::raw::c_uint,
        propagate: ::std::os::raw::c_uint,
        local: ::std::os::raw::c_uint,
        dynamic: ::std::os::raw::c_uint,
        removable: ::std::os::raw::c_uint,
        stickingatnode: ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " creates and captures a SOS2 constraint with all constraint flags set to their default values.\n\n  @warning Do NOT set the constraint to be modifiable manually, because this might lead\n  to wrong results as the variable array will not be resorted\n\n  @note the constraint gets captured, hence at one point you have to release it using the method SCIPreleaseCons()"]
    pub fn SCIPcreateConsBasicSOS2(
        scip: *mut SCIP,
        cons: *mut *mut SCIP_CONS,
        name: *const ::std::os::raw::c_char,
        nvars: ::std::os::raw::c_int,
        vars: *mut *mut SCIP_VAR,
        weights: *mut f64,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " adds variable to SOS2 constraint, the position is determined by the given weight"]
    pub fn SCIPaddVarSOS2(
        scip: *mut SCIP,
        cons: *mut SCIP_CONS,
        var: *mut SCIP_VAR,
        weight: f64,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " appends variable to SOS2 constraint"]
    pub fn SCIPappendVarSOS2(
        scip: *mut SCIP,
        cons: *mut SCIP_CONS,
        var: *mut SCIP_VAR,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " gets number of variables in SOS2 constraint"]
    pub fn SCIPgetNVarsSOS2(scip: *mut SCIP, cons: *mut SCIP_CONS) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " gets array of variables in SOS2 constraint"]
    pub fn SCIPgetVarsSOS2(scip: *mut SCIP, cons: *mut SCIP_CONS) -> *mut *mut SCIP_VAR;
}
extern "C" {
    #[doc = " gets array of weights in SOS2 constraint (or NULL if not existent)"]
    pub fn SCIPgetWeightsSOS2(scip: *mut SCIP, cons: *mut SCIP_CONS) -> *mut f64;
}
extern "C" {
    #[doc = " creates the handler for superindicator constraints and includes it in SCIP\n\n @ingroup ConshdlrIncludes"]
    pub fn SCIPincludeConshdlrSuperindicator(scip: *mut SCIP) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " creates and captures a superindicator constraint\n\n  @note the constraint gets captured, hence at one point you have to release it using the method SCIPreleaseCons()"]
    pub fn SCIPcreateConsSuperindicator(
        scip: *mut SCIP,
        cons: *mut *mut SCIP_CONS,
        name: *const ::std::os::raw::c_char,
        binvar: *mut SCIP_VAR,
        slackcons: *mut SCIP_CONS,
        initial: ::std::os::raw::c_uint,
        separate: ::std::os::raw::c_uint,
        enforce: ::std::os::raw::c_uint,
        check: ::std::os::raw::c_uint,
        propagate: ::std::os::raw::c_uint,
        local: ::std::os::raw::c_uint,
        dynamic: ::std::os::raw::c_uint,
        removable: ::std::os::raw::c_uint,
        stickingatnode: ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " creates and captures a superindicator constraint\n  in its most basic version, i. e., all constraint flags are set to their basic value as explained for the\n  method SCIPcreateConsSuperindicator(); all flags can be set via SCIPsetConsFLAGNAME-methods in scip.h\n\n  @see SCIPcreateConsSuperindicator() for information about the basic constraint flag configuration\n\n  @note the constraint gets captured, hence at one point you have to release it using the method SCIPreleaseCons()"]
    pub fn SCIPcreateConsBasicSuperindicator(
        scip: *mut SCIP,
        cons: *mut *mut SCIP_CONS,
        name: *const ::std::os::raw::c_char,
        binvar: *mut SCIP_VAR,
        slackcons: *mut SCIP_CONS,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " gets binary variable corresponding to the superindicator constraint"]
    pub fn SCIPgetBinaryVarSuperindicator(cons: *mut SCIP_CONS) -> *mut SCIP_VAR;
}
extern "C" {
    #[doc = " gets the slack constraint corresponding to the superindicator constraint"]
    pub fn SCIPgetSlackConsSuperindicator(cons: *mut SCIP_CONS) -> *mut SCIP_CONS;
}
extern "C" {
    #[doc = " transforms the current problem into a MinUC problem (minimizing the number of unsatisfied constraints),\n  a CIP generalization of the MinULR (min. unsatisfied linear relations) problem"]
    pub fn SCIPtransformMinUC(
        scip: *mut SCIP,
        success: *mut ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    pub fn SCIPdialogExecChangeMinUC(
        scip: *mut SCIP,
        dialog: *mut SCIP_DIALOG,
        dialoghdlr: *mut SCIP_DIALOGHDLR,
        nextdialog: *mut *mut SCIP_DIALOG,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " creates the handler for symresack constraints and includes it in SCIP\n\n @ingroup ConshdlrIncludes"]
    pub fn SCIPincludeConshdlrSymresack(scip: *mut SCIP) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " creates a symmetry breaking constraint\n\n Depending on the given permutation, either an orbisack or symresack constraint\n is created."]
    pub fn SCIPcreateSymbreakCons(
        scip: *mut SCIP,
        cons: *mut *mut SCIP_CONS,
        name: *const ::std::os::raw::c_char,
        perm: *mut ::std::os::raw::c_int,
        vars: *mut *mut SCIP_VAR,
        nvars: ::std::os::raw::c_int,
        ismodelcons: ::std::os::raw::c_uint,
        initial: ::std::os::raw::c_uint,
        separate: ::std::os::raw::c_uint,
        enforce: ::std::os::raw::c_uint,
        check: ::std::os::raw::c_uint,
        propagate: ::std::os::raw::c_uint,
        local: ::std::os::raw::c_uint,
        modifiable: ::std::os::raw::c_uint,
        dynamic: ::std::os::raw::c_uint,
        removable: ::std::os::raw::c_uint,
        stickingatnode: ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " creates and captures a symresack constraint\n\n  @note the constraint gets captured, hence at one point you have to release it using the method SCIPreleaseCons()"]
    pub fn SCIPcreateConsSymresack(
        scip: *mut SCIP,
        cons: *mut *mut SCIP_CONS,
        name: *const ::std::os::raw::c_char,
        perm: *mut ::std::os::raw::c_int,
        vars: *mut *mut SCIP_VAR,
        nvars: ::std::os::raw::c_int,
        ismodelcons: ::std::os::raw::c_uint,
        initial: ::std::os::raw::c_uint,
        separate: ::std::os::raw::c_uint,
        enforce: ::std::os::raw::c_uint,
        check: ::std::os::raw::c_uint,
        propagate: ::std::os::raw::c_uint,
        local: ::std::os::raw::c_uint,
        modifiable: ::std::os::raw::c_uint,
        dynamic: ::std::os::raw::c_uint,
        removable: ::std::os::raw::c_uint,
        stickingatnode: ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " creates and captures a symresack constraint\n  in its most basic variant, i.e., with all constraint flags set to their default values, which can be set\n  afterwards using SCIPsetConsFLAGNAME() in scip.h\n\n  @see SCIPcreateConsSymresack() for the default constraint flag configuration\n\n  @note the constraint gets captured, hence at one point you have to release it using the method SCIPreleaseCons()"]
    pub fn SCIPcreateConsBasicSymresack(
        scip: *mut SCIP,
        cons: *mut *mut SCIP_CONS,
        name: *const ::std::os::raw::c_char,
        perm: *mut ::std::os::raw::c_int,
        vars: *mut *mut SCIP_VAR,
        nvars: ::std::os::raw::c_int,
        ismodelcons: ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " creates the handler for variable bound constraints and includes it in SCIP\n\n @ingroup ConshdlrIncludes"]
    pub fn SCIPincludeConshdlrVarbound(scip: *mut SCIP) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " creates and captures a variable bound constraint: lhs <= x + c*y <= rhs\n\n  @note the constraint gets captured, hence at one point you have to release it using the method SCIPreleaseCons()"]
    pub fn SCIPcreateConsVarbound(
        scip: *mut SCIP,
        cons: *mut *mut SCIP_CONS,
        name: *const ::std::os::raw::c_char,
        var: *mut SCIP_VAR,
        vbdvar: *mut SCIP_VAR,
        vbdcoef: f64,
        lhs: f64,
        rhs: f64,
        initial: ::std::os::raw::c_uint,
        separate: ::std::os::raw::c_uint,
        enforce: ::std::os::raw::c_uint,
        check: ::std::os::raw::c_uint,
        propagate: ::std::os::raw::c_uint,
        local: ::std::os::raw::c_uint,
        modifiable: ::std::os::raw::c_uint,
        dynamic: ::std::os::raw::c_uint,
        removable: ::std::os::raw::c_uint,
        stickingatnode: ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " creates and captures a varbound constraint\n  in its most basic version, i. e., all constraint flags are set to their basic value as explained for the\n  method SCIPcreateConsVarbound(); all flags can be set via SCIPsetConsFLAGNAME-methods in scip.h\n\n  @see SCIPcreateConsVarbound() for information about the basic constraint flag configuration\n\n  @note the constraint gets captured, hence at one point you have to release it using the method SCIPreleaseCons()"]
    pub fn SCIPcreateConsBasicVarbound(
        scip: *mut SCIP,
        cons: *mut *mut SCIP_CONS,
        name: *const ::std::os::raw::c_char,
        var: *mut SCIP_VAR,
        vbdvar: *mut SCIP_VAR,
        vbdcoef: f64,
        lhs: f64,
        rhs: f64,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " gets left hand side of variable bound constraint lhs <= x + c*y <= rhs"]
    pub fn SCIPgetLhsVarbound(scip: *mut SCIP, cons: *mut SCIP_CONS) -> f64;
}
extern "C" {
    #[doc = " gets right hand side of variable bound constraint lhs <= x + c*y <= rhs"]
    pub fn SCIPgetRhsVarbound(scip: *mut SCIP, cons: *mut SCIP_CONS) -> f64;
}
extern "C" {
    #[doc = " gets bounded variable x of variable bound constraint lhs <= x + c*y <= rhs"]
    pub fn SCIPgetVarVarbound(scip: *mut SCIP, cons: *mut SCIP_CONS) -> *mut SCIP_VAR;
}
extern "C" {
    #[doc = " gets bounding variable y of variable bound constraint lhs <= x + c*y <= rhs"]
    pub fn SCIPgetVbdvarVarbound(scip: *mut SCIP, cons: *mut SCIP_CONS) -> *mut SCIP_VAR;
}
extern "C" {
    #[doc = " gets bound coefficient c of variable bound constraint lhs <= x + c*y <= rhs"]
    pub fn SCIPgetVbdcoefVarbound(scip: *mut SCIP, cons: *mut SCIP_CONS) -> f64;
}
extern "C" {
    #[doc = " gets the dual solution of the variable bound constraint in the current LP"]
    pub fn SCIPgetDualsolVarbound(scip: *mut SCIP, cons: *mut SCIP_CONS) -> f64;
}
extern "C" {
    #[doc = " gets the dual Farkas value of the variable bound constraint in the current infeasible LP"]
    pub fn SCIPgetDualfarkasVarbound(scip: *mut SCIP, cons: *mut SCIP_CONS) -> f64;
}
extern "C" {
    #[doc = " returns the linear relaxation of the given variable bound constraint; may return NULL if no LP row was yet created;\n  the user must not modify the row!"]
    pub fn SCIPgetRowVarbound(scip: *mut SCIP, cons: *mut SCIP_CONS) -> *mut SCIP_ROW;
}
extern "C" {
    #[doc = " cleans up (multi-)aggregations and fixings from varbound constraints"]
    pub fn SCIPcleanupConssVarbound(
        scip: *mut SCIP,
        onlychecked: ::std::os::raw::c_uint,
        infeasible: *mut ::std::os::raw::c_uint,
        naddconss: *mut ::std::os::raw::c_int,
        ndelconss: *mut ::std::os::raw::c_int,
        nchgbds: *mut ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " creates the handler for xor constraints and includes it in SCIP\n\n @ingroup ConshdlrIncludes"]
    pub fn SCIPincludeConshdlrXor(scip: *mut SCIP) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " creates and captures an xor constraint\n\n  @note the constraint gets captured, hence at one point you have to release it using the method SCIPreleaseCons()"]
    pub fn SCIPcreateConsXor(
        scip: *mut SCIP,
        cons: *mut *mut SCIP_CONS,
        name: *const ::std::os::raw::c_char,
        rhs: ::std::os::raw::c_uint,
        nvars: ::std::os::raw::c_int,
        vars: *mut *mut SCIP_VAR,
        initial: ::std::os::raw::c_uint,
        separate: ::std::os::raw::c_uint,
        enforce: ::std::os::raw::c_uint,
        check: ::std::os::raw::c_uint,
        propagate: ::std::os::raw::c_uint,
        local: ::std::os::raw::c_uint,
        modifiable: ::std::os::raw::c_uint,
        dynamic: ::std::os::raw::c_uint,
        removable: ::std::os::raw::c_uint,
        stickingatnode: ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " creates and captures an xor constraint\n  in its most basic version, i. e., all constraint flags are set to their basic value as explained for the\n  method SCIPcreateConsXor(); all flags can be set via SCIPsetConsFLAGNAME-methods in scip.h\n\n  @see SCIPcreateConsXor() for information about the basic constraint flag configuration\n\n  @note the constraint gets captured, hence at one point you have to release it using the method SCIPreleaseCons()"]
    pub fn SCIPcreateConsBasicXor(
        scip: *mut SCIP,
        cons: *mut *mut SCIP_CONS,
        name: *const ::std::os::raw::c_char,
        rhs: ::std::os::raw::c_uint,
        nvars: ::std::os::raw::c_int,
        vars: *mut *mut SCIP_VAR,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " gets number of variables in xor constraint"]
    pub fn SCIPgetNVarsXor(scip: *mut SCIP, cons: *mut SCIP_CONS) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " gets array of variables in xor constraint"]
    pub fn SCIPgetVarsXor(scip: *mut SCIP, cons: *mut SCIP_CONS) -> *mut *mut SCIP_VAR;
}
extern "C" {
    #[doc = " gets integer variable in xor constraint"]
    pub fn SCIPgetIntVarXor(scip: *mut SCIP, cons: *mut SCIP_CONS) -> *mut SCIP_VAR;
}
extern "C" {
    #[doc = " gets the right hand side of the xor constraint"]
    pub fn SCIPgetRhsXor(scip: *mut SCIP, cons: *mut SCIP_CONS) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " creates the components constraint handler and includes it in SCIP\n\n @ingroup ConshdlrIncludes"]
    pub fn SCIPincludeConshdlrComponents(scip: *mut SCIP) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " includes the default display columns in SCIP\n\n  @ingroup DisplayIncludes"]
    pub fn SCIPincludeDispDefault(scip: *mut SCIP) -> SCIP_RETCODE;
}
extern "C" {
    pub fn SCIPdialogExecMenu(
        scip: *mut SCIP,
        dialog: *mut SCIP_DIALOG,
        dialoghdlr: *mut SCIP_DIALOGHDLR,
        nextdialog: *mut *mut SCIP_DIALOG,
    ) -> SCIP_RETCODE;
}
extern "C" {
    pub fn SCIPdialogExecMenuLazy(
        scip: *mut SCIP,
        dialog: *mut SCIP_DIALOG,
        dialoghdlr: *mut SCIP_DIALOGHDLR,
        nextdialog: *mut *mut SCIP_DIALOG,
    ) -> SCIP_RETCODE;
}
extern "C" {
    pub fn SCIPdialogExecChangeAddCons(
        scip: *mut SCIP,
        dialog: *mut SCIP_DIALOG,
        dialoghdlr: *mut SCIP_DIALOGHDLR,
        nextdialog: *mut *mut SCIP_DIALOG,
    ) -> SCIP_RETCODE;
}
extern "C" {
    pub fn SCIPdialogExecChangeBounds(
        scip: *mut SCIP,
        dialog: *mut SCIP_DIALOG,
        dialoghdlr: *mut SCIP_DIALOGHDLR,
        nextdialog: *mut *mut SCIP_DIALOG,
    ) -> SCIP_RETCODE;
}
extern "C" {
    pub fn SCIPdialogExecChangeFreetransproblem(
        scip: *mut SCIP,
        dialog: *mut SCIP_DIALOG,
        dialoghdlr: *mut SCIP_DIALOGHDLR,
        nextdialog: *mut *mut SCIP_DIALOG,
    ) -> SCIP_RETCODE;
}
extern "C" {
    pub fn SCIPdialogExecChangeObjSense(
        scip: *mut SCIP,
        dialog: *mut SCIP_DIALOG,
        dialoghdlr: *mut SCIP_DIALOGHDLR,
        nextdialog: *mut *mut SCIP_DIALOG,
    ) -> SCIP_RETCODE;
}
extern "C" {
    pub fn SCIPdialogExecChecksol(
        scip: *mut SCIP,
        dialog: *mut SCIP_DIALOG,
        dialoghdlr: *mut SCIP_DIALOGHDLR,
        nextdialog: *mut *mut SCIP_DIALOG,
    ) -> SCIP_RETCODE;
}
extern "C" {
    pub fn SCIPdialogExecCliquegraph(
        scip: *mut SCIP,
        dialog: *mut SCIP_DIALOG,
        dialoghdlr: *mut SCIP_DIALOGHDLR,
        nextdialog: *mut *mut SCIP_DIALOG,
    ) -> SCIP_RETCODE;
}
extern "C" {
    pub fn SCIPdialogExecDisplayBenders(
        scip: *mut SCIP,
        dialog: *mut SCIP_DIALOG,
        dialoghdlr: *mut SCIP_DIALOGHDLR,
        nextdialog: *mut *mut SCIP_DIALOG,
    ) -> SCIP_RETCODE;
}
extern "C" {
    pub fn SCIPdialogExecDisplayBranching(
        scip: *mut SCIP,
        dialog: *mut SCIP_DIALOG,
        dialoghdlr: *mut SCIP_DIALOGHDLR,
        nextdialog: *mut *mut SCIP_DIALOG,
    ) -> SCIP_RETCODE;
}
extern "C" {
    pub fn SCIPdialogExecDisplayCompression(
        scip: *mut SCIP,
        dialog: *mut SCIP_DIALOG,
        dialoghdlr: *mut SCIP_DIALOGHDLR,
        nextdialog: *mut *mut SCIP_DIALOG,
    ) -> SCIP_RETCODE;
}
extern "C" {
    pub fn SCIPdialogExecDisplayConflict(
        scip: *mut SCIP,
        dialog: *mut SCIP_DIALOG,
        dialoghdlr: *mut SCIP_DIALOGHDLR,
        nextdialog: *mut *mut SCIP_DIALOG,
    ) -> SCIP_RETCODE;
}
extern "C" {
    pub fn SCIPdialogExecDisplayConshdlrs(
        scip: *mut SCIP,
        dialog: *mut SCIP_DIALOG,
        dialoghdlr: *mut SCIP_DIALOGHDLR,
        nextdialog: *mut *mut SCIP_DIALOG,
    ) -> SCIP_RETCODE;
}
extern "C" {
    pub fn SCIPdialogExecDisplayDisplaycols(
        scip: *mut SCIP,
        dialog: *mut SCIP_DIALOG,
        dialoghdlr: *mut SCIP_DIALOGHDLR,
        nextdialog: *mut *mut SCIP_DIALOG,
    ) -> SCIP_RETCODE;
}
extern "C" {
    pub fn SCIPdialogExecDisplayExprhdlrs(
        scip: *mut SCIP,
        dialog: *mut SCIP_DIALOG,
        dialoghdlr: *mut SCIP_DIALOGHDLR,
        nextdialog: *mut *mut SCIP_DIALOG,
    ) -> SCIP_RETCODE;
}
extern "C" {
    pub fn SCIPdialogExecDisplayCutselectors(
        scip: *mut SCIP,
        dialog: *mut SCIP_DIALOG,
        dialoghdlr: *mut SCIP_DIALOGHDLR,
        nextdialog: *mut *mut SCIP_DIALOG,
    ) -> SCIP_RETCODE;
}
extern "C" {
    pub fn SCIPdialogExecDisplayHeuristics(
        scip: *mut SCIP,
        dialog: *mut SCIP_DIALOG,
        dialoghdlr: *mut SCIP_DIALOGHDLR,
        nextdialog: *mut *mut SCIP_DIALOG,
    ) -> SCIP_RETCODE;
}
extern "C" {
    pub fn SCIPdialogExecDisplayMemory(
        scip: *mut SCIP,
        dialog: *mut SCIP_DIALOG,
        dialoghdlr: *mut SCIP_DIALOGHDLR,
        nextdialog: *mut *mut SCIP_DIALOG,
    ) -> SCIP_RETCODE;
}
extern "C" {
    pub fn SCIPdialogExecDisplayNodeselectors(
        scip: *mut SCIP,
        dialog: *mut SCIP_DIALOG,
        dialoghdlr: *mut SCIP_DIALOGHDLR,
        nextdialog: *mut *mut SCIP_DIALOG,
    ) -> SCIP_RETCODE;
}
extern "C" {
    pub fn SCIPdialogExecDisplayNlpi(
        scip: *mut SCIP,
        dialog: *mut SCIP_DIALOG,
        dialoghdlr: *mut SCIP_DIALOGHDLR,
        nextdialog: *mut *mut SCIP_DIALOG,
    ) -> SCIP_RETCODE;
}
extern "C" {
    pub fn SCIPdialogExecDisplayParameters(
        scip: *mut SCIP,
        dialog: *mut SCIP_DIALOG,
        dialoghdlr: *mut SCIP_DIALOGHDLR,
        nextdialog: *mut *mut SCIP_DIALOG,
    ) -> SCIP_RETCODE;
}
extern "C" {
    pub fn SCIPdialogExecDisplayPresolvers(
        scip: *mut SCIP,
        dialog: *mut SCIP_DIALOG,
        dialoghdlr: *mut SCIP_DIALOGHDLR,
        nextdialog: *mut *mut SCIP_DIALOG,
    ) -> SCIP_RETCODE;
}
extern "C" {
    pub fn SCIPdialogExecDisplayPricers(
        scip: *mut SCIP,
        dialog: *mut SCIP_DIALOG,
        dialoghdlr: *mut SCIP_DIALOGHDLR,
        nextdialog: *mut *mut SCIP_DIALOG,
    ) -> SCIP_RETCODE;
}
extern "C" {
    pub fn SCIPdialogExecDisplayProblem(
        scip: *mut SCIP,
        dialog: *mut SCIP_DIALOG,
        dialoghdlr: *mut SCIP_DIALOGHDLR,
        nextdialog: *mut *mut SCIP_DIALOG,
    ) -> SCIP_RETCODE;
}
extern "C" {
    pub fn SCIPdialogExecDisplayPropagators(
        scip: *mut SCIP,
        dialog: *mut SCIP_DIALOG,
        dialoghdlr: *mut SCIP_DIALOGHDLR,
        nextdialog: *mut *mut SCIP_DIALOG,
    ) -> SCIP_RETCODE;
}
extern "C" {
    pub fn SCIPdialogExecDisplayReaders(
        scip: *mut SCIP,
        dialog: *mut SCIP_DIALOG,
        dialoghdlr: *mut SCIP_DIALOGHDLR,
        nextdialog: *mut *mut SCIP_DIALOG,
    ) -> SCIP_RETCODE;
}
extern "C" {
    pub fn SCIPdialogExecDisplayRelaxators(
        scip: *mut SCIP,
        dialog: *mut SCIP_DIALOG,
        dialoghdlr: *mut SCIP_DIALOGHDLR,
        nextdialog: *mut *mut SCIP_DIALOG,
    ) -> SCIP_RETCODE;
}
extern "C" {
    pub fn SCIPdialogExecDisplaySeparators(
        scip: *mut SCIP,
        dialog: *mut SCIP_DIALOG,
        dialoghdlr: *mut SCIP_DIALOGHDLR,
        nextdialog: *mut *mut SCIP_DIALOG,
    ) -> SCIP_RETCODE;
}
extern "C" {
    pub fn SCIPdialogExecDisplaySolution(
        scip: *mut SCIP,
        dialog: *mut SCIP_DIALOG,
        dialoghdlr: *mut SCIP_DIALOGHDLR,
        nextdialog: *mut *mut SCIP_DIALOG,
    ) -> SCIP_RETCODE;
}
extern "C" {
    pub fn SCIPdialogExecDisplayFiniteSolution(
        scip: *mut SCIP,
        dialog: *mut SCIP_DIALOG,
        dialoghdlr: *mut SCIP_DIALOGHDLR,
        nextdialog: *mut *mut SCIP_DIALOG,
    ) -> SCIP_RETCODE;
}
extern "C" {
    pub fn SCIPdialogExecDisplayDualSolution(
        scip: *mut SCIP,
        dialog: *mut SCIP_DIALOG,
        dialoghdlr: *mut SCIP_DIALOGHDLR,
        nextdialog: *mut *mut SCIP_DIALOG,
    ) -> SCIP_RETCODE;
}
extern "C" {
    pub fn SCIPdialogExecDisplaySolutionPool(
        scip: *mut SCIP,
        dialog: *mut SCIP_DIALOG,
        dialoghdlr: *mut SCIP_DIALOGHDLR,
        nextdialog: *mut *mut SCIP_DIALOG,
    ) -> SCIP_RETCODE;
}
extern "C" {
    pub fn SCIPdialogExecDisplaySubproblem(
        scip: *mut SCIP,
        dialog: *mut SCIP_DIALOG,
        dialoghdlr: *mut SCIP_DIALOGHDLR,
        nextdialog: *mut *mut SCIP_DIALOG,
    ) -> SCIP_RETCODE;
}
extern "C" {
    pub fn SCIPdialogExecDisplaySubSolution(
        scip: *mut SCIP,
        dialog: *mut SCIP_DIALOG,
        dialoghdlr: *mut SCIP_DIALOGHDLR,
        nextdialog: *mut *mut SCIP_DIALOG,
    ) -> SCIP_RETCODE;
}
extern "C" {
    pub fn SCIPdialogExecDisplayStatistics(
        scip: *mut SCIP,
        dialog: *mut SCIP_DIALOG,
        dialoghdlr: *mut SCIP_DIALOGHDLR,
        nextdialog: *mut *mut SCIP_DIALOG,
    ) -> SCIP_RETCODE;
}
extern "C" {
    pub fn SCIPdialogExecDisplayReoptStatistics(
        scip: *mut SCIP,
        dialog: *mut SCIP_DIALOG,
        dialoghdlr: *mut SCIP_DIALOGHDLR,
        nextdialog: *mut *mut SCIP_DIALOG,
    ) -> SCIP_RETCODE;
}
extern "C" {
    pub fn SCIPdialogExecDisplayTransproblem(
        scip: *mut SCIP,
        dialog: *mut SCIP_DIALOG,
        dialoghdlr: *mut SCIP_DIALOGHDLR,
        nextdialog: *mut *mut SCIP_DIALOG,
    ) -> SCIP_RETCODE;
}
extern "C" {
    pub fn SCIPdialogExecDisplayValue(
        scip: *mut SCIP,
        dialog: *mut SCIP_DIALOG,
        dialoghdlr: *mut SCIP_DIALOGHDLR,
        nextdialog: *mut *mut SCIP_DIALOG,
    ) -> SCIP_RETCODE;
}
extern "C" {
    pub fn SCIPdialogExecDisplayVarbranchstatistics(
        scip: *mut SCIP,
        dialog: *mut SCIP_DIALOG,
        dialoghdlr: *mut SCIP_DIALOGHDLR,
        nextdialog: *mut *mut SCIP_DIALOG,
    ) -> SCIP_RETCODE;
}
extern "C" {
    pub fn SCIPdialogExecDisplayLPSolutionQuality(
        scip: *mut SCIP,
        dialog: *mut SCIP_DIALOG,
        dialoghdlr: *mut SCIP_DIALOGHDLR,
        nextdialog: *mut *mut SCIP_DIALOG,
    ) -> SCIP_RETCODE;
}
extern "C" {
    pub fn SCIPdialogExecDisplayTranssolution(
        scip: *mut SCIP,
        dialog: *mut SCIP_DIALOG,
        dialoghdlr: *mut SCIP_DIALOGHDLR,
        nextdialog: *mut *mut SCIP_DIALOG,
    ) -> SCIP_RETCODE;
}
extern "C" {
    pub fn SCIPdialogExecHelp(
        scip: *mut SCIP,
        dialog: *mut SCIP_DIALOG,
        dialoghdlr: *mut SCIP_DIALOGHDLR,
        nextdialog: *mut *mut SCIP_DIALOG,
    ) -> SCIP_RETCODE;
}
extern "C" {
    pub fn SCIPdialogExecFree(
        scip: *mut SCIP,
        dialog: *mut SCIP_DIALOG,
        dialoghdlr: *mut SCIP_DIALOGHDLR,
        nextdialog: *mut *mut SCIP_DIALOG,
    ) -> SCIP_RETCODE;
}
extern "C" {
    pub fn SCIPdialogExecNewstart(
        scip: *mut SCIP,
        dialog: *mut SCIP_DIALOG,
        dialoghdlr: *mut SCIP_DIALOGHDLR,
        nextdialog: *mut *mut SCIP_DIALOG,
    ) -> SCIP_RETCODE;
}
extern "C" {
    pub fn SCIPdialogExecTransform(
        scip: *mut SCIP,
        dialog: *mut SCIP_DIALOG,
        dialoghdlr: *mut SCIP_DIALOGHDLR,
        nextdialog: *mut *mut SCIP_DIALOG,
    ) -> SCIP_RETCODE;
}
extern "C" {
    pub fn SCIPdialogExecOptimize(
        scip: *mut SCIP,
        dialog: *mut SCIP_DIALOG,
        dialoghdlr: *mut SCIP_DIALOGHDLR,
        nextdialog: *mut *mut SCIP_DIALOG,
    ) -> SCIP_RETCODE;
}
extern "C" {
    pub fn SCIPdialogExecConcurrentOpt(
        scip: *mut SCIP,
        dialog: *mut SCIP_DIALOG,
        dialoghdlr: *mut SCIP_DIALOGHDLR,
        nextdialog: *mut *mut SCIP_DIALOG,
    ) -> SCIP_RETCODE;
}
extern "C" {
    pub fn SCIPdialogExecPresolve(
        scip: *mut SCIP,
        dialog: *mut SCIP_DIALOG,
        dialoghdlr: *mut SCIP_DIALOGHDLR,
        nextdialog: *mut *mut SCIP_DIALOG,
    ) -> SCIP_RETCODE;
}
extern "C" {
    pub fn SCIPdialogExecQuit(
        scip: *mut SCIP,
        dialog: *mut SCIP_DIALOG,
        dialoghdlr: *mut SCIP_DIALOGHDLR,
        nextdialog: *mut *mut SCIP_DIALOG,
    ) -> SCIP_RETCODE;
}
extern "C" {
    pub fn SCIPdialogExecRead(
        scip: *mut SCIP,
        dialog: *mut SCIP_DIALOG,
        dialoghdlr: *mut SCIP_DIALOGHDLR,
        nextdialog: *mut *mut SCIP_DIALOG,
    ) -> SCIP_RETCODE;
}
extern "C" {
    pub fn SCIPdialogExecSetDefault(
        scip: *mut SCIP,
        dialog: *mut SCIP_DIALOG,
        dialoghdlr: *mut SCIP_DIALOGHDLR,
        nextdialog: *mut *mut SCIP_DIALOG,
    ) -> SCIP_RETCODE;
}
extern "C" {
    pub fn SCIPdialogExecSetLoad(
        scip: *mut SCIP,
        dialog: *mut SCIP_DIALOG,
        dialoghdlr: *mut SCIP_DIALOGHDLR,
        nextdialog: *mut *mut SCIP_DIALOG,
    ) -> SCIP_RETCODE;
}
extern "C" {
    pub fn SCIPdialogExecSetSave(
        scip: *mut SCIP,
        dialog: *mut SCIP_DIALOG,
        dialoghdlr: *mut SCIP_DIALOGHDLR,
        nextdialog: *mut *mut SCIP_DIALOG,
    ) -> SCIP_RETCODE;
}
extern "C" {
    pub fn SCIPdialogExecSetDiffsave(
        scip: *mut SCIP,
        dialog: *mut SCIP_DIALOG,
        dialoghdlr: *mut SCIP_DIALOGHDLR,
        nextdialog: *mut *mut SCIP_DIALOG,
    ) -> SCIP_RETCODE;
}
extern "C" {
    pub fn SCIPdialogExecSetParam(
        scip: *mut SCIP,
        dialog: *mut SCIP_DIALOG,
        dialoghdlr: *mut SCIP_DIALOGHDLR,
        nextdialog: *mut *mut SCIP_DIALOG,
    ) -> SCIP_RETCODE;
}
extern "C" {
    pub fn SCIPdialogDescSetParam(scip: *mut SCIP, dialog: *mut SCIP_DIALOG) -> SCIP_RETCODE;
}
extern "C" {
    pub fn SCIPdialogExecFixParam(
        scip: *mut SCIP,
        dialog: *mut SCIP_DIALOG,
        dialoghdlr: *mut SCIP_DIALOGHDLR,
        nextdialog: *mut *mut SCIP_DIALOG,
    ) -> SCIP_RETCODE;
}
extern "C" {
    pub fn SCIPdialogDescFixParam(scip: *mut SCIP, dialog: *mut SCIP_DIALOG) -> SCIP_RETCODE;
}
extern "C" {
    pub fn SCIPdialogExecSetBranchingDirection(
        scip: *mut SCIP,
        dialog: *mut SCIP_DIALOG,
        dialoghdlr: *mut SCIP_DIALOGHDLR,
        nextdialog: *mut *mut SCIP_DIALOG,
    ) -> SCIP_RETCODE;
}
extern "C" {
    pub fn SCIPdialogExecSetBranchingPriority(
        scip: *mut SCIP,
        dialog: *mut SCIP_DIALOG,
        dialoghdlr: *mut SCIP_DIALOGHDLR,
        nextdialog: *mut *mut SCIP_DIALOG,
    ) -> SCIP_RETCODE;
}
extern "C" {
    pub fn SCIPdialogExecSetHeuristicsAggressive(
        scip: *mut SCIP,
        dialog: *mut SCIP_DIALOG,
        dialoghdlr: *mut SCIP_DIALOGHDLR,
        nextdialog: *mut *mut SCIP_DIALOG,
    ) -> SCIP_RETCODE;
}
extern "C" {
    pub fn SCIPdialogExecSetHeuristicsDefault(
        scip: *mut SCIP,
        dialog: *mut SCIP_DIALOG,
        dialoghdlr: *mut SCIP_DIALOGHDLR,
        nextdialog: *mut *mut SCIP_DIALOG,
    ) -> SCIP_RETCODE;
}
extern "C" {
    pub fn SCIPdialogExecSetHeuristicsFast(
        scip: *mut SCIP,
        dialog: *mut SCIP_DIALOG,
        dialoghdlr: *mut SCIP_DIALOGHDLR,
        nextdialog: *mut *mut SCIP_DIALOG,
    ) -> SCIP_RETCODE;
}
extern "C" {
    pub fn SCIPdialogExecSetHeuristicsOff(
        scip: *mut SCIP,
        dialog: *mut SCIP_DIALOG,
        dialoghdlr: *mut SCIP_DIALOGHDLR,
        nextdialog: *mut *mut SCIP_DIALOG,
    ) -> SCIP_RETCODE;
}
extern "C" {
    pub fn SCIPdialogExecSetPresolvingAggressive(
        scip: *mut SCIP,
        dialog: *mut SCIP_DIALOG,
        dialoghdlr: *mut SCIP_DIALOGHDLR,
        nextdialog: *mut *mut SCIP_DIALOG,
    ) -> SCIP_RETCODE;
}
extern "C" {
    pub fn SCIPdialogExecSetPresolvingDefault(
        scip: *mut SCIP,
        dialog: *mut SCIP_DIALOG,
        dialoghdlr: *mut SCIP_DIALOGHDLR,
        nextdialog: *mut *mut SCIP_DIALOG,
    ) -> SCIP_RETCODE;
}
extern "C" {
    pub fn SCIPdialogExecSetPresolvingFast(
        scip: *mut SCIP,
        dialog: *mut SCIP_DIALOG,
        dialoghdlr: *mut SCIP_DIALOGHDLR,
        nextdialog: *mut *mut SCIP_DIALOG,
    ) -> SCIP_RETCODE;
}
extern "C" {
    pub fn SCIPdialogExecSetPresolvingOff(
        scip: *mut SCIP,
        dialog: *mut SCIP_DIALOG,
        dialoghdlr: *mut SCIP_DIALOGHDLR,
        nextdialog: *mut *mut SCIP_DIALOG,
    ) -> SCIP_RETCODE;
}
extern "C" {
    pub fn SCIPdialogExecSetSeparatingAggressive(
        scip: *mut SCIP,
        dialog: *mut SCIP_DIALOG,
        dialoghdlr: *mut SCIP_DIALOGHDLR,
        nextdialog: *mut *mut SCIP_DIALOG,
    ) -> SCIP_RETCODE;
}
extern "C" {
    pub fn SCIPdialogExecSetSeparatingDefault(
        scip: *mut SCIP,
        dialog: *mut SCIP_DIALOG,
        dialoghdlr: *mut SCIP_DIALOGHDLR,
        nextdialog: *mut *mut SCIP_DIALOG,
    ) -> SCIP_RETCODE;
}
extern "C" {
    pub fn SCIPdialogExecSetSeparatingFast(
        scip: *mut SCIP,
        dialog: *mut SCIP_DIALOG,
        dialoghdlr: *mut SCIP_DIALOGHDLR,
        nextdialog: *mut *mut SCIP_DIALOG,
    ) -> SCIP_RETCODE;
}
extern "C" {
    pub fn SCIPdialogExecSetSeparatingOff(
        scip: *mut SCIP,
        dialog: *mut SCIP_DIALOG,
        dialoghdlr: *mut SCIP_DIALOGHDLR,
        nextdialog: *mut *mut SCIP_DIALOG,
    ) -> SCIP_RETCODE;
}
extern "C" {
    pub fn SCIPdialogExecSetEmphasisCounter(
        scip: *mut SCIP,
        dialog: *mut SCIP_DIALOG,
        dialoghdlr: *mut SCIP_DIALOGHDLR,
        nextdialog: *mut *mut SCIP_DIALOG,
    ) -> SCIP_RETCODE;
}
extern "C" {
    pub fn SCIPdialogExecSetEmphasisCpsolver(
        scip: *mut SCIP,
        dialog: *mut SCIP_DIALOG,
        dialoghdlr: *mut SCIP_DIALOGHDLR,
        nextdialog: *mut *mut SCIP_DIALOG,
    ) -> SCIP_RETCODE;
}
extern "C" {
    pub fn SCIPdialogExecSetEmphasisEasycip(
        scip: *mut SCIP,
        dialog: *mut SCIP_DIALOG,
        dialoghdlr: *mut SCIP_DIALOGHDLR,
        nextdialog: *mut *mut SCIP_DIALOG,
    ) -> SCIP_RETCODE;
}
extern "C" {
    pub fn SCIPdialogExecSetEmphasisFeasibility(
        scip: *mut SCIP,
        dialog: *mut SCIP_DIALOG,
        dialoghdlr: *mut SCIP_DIALOGHDLR,
        nextdialog: *mut *mut SCIP_DIALOG,
    ) -> SCIP_RETCODE;
}
extern "C" {
    pub fn SCIPdialogExecSetEmphasisHardlp(
        scip: *mut SCIP,
        dialog: *mut SCIP_DIALOG,
        dialoghdlr: *mut SCIP_DIALOGHDLR,
        nextdialog: *mut *mut SCIP_DIALOG,
    ) -> SCIP_RETCODE;
}
extern "C" {
    pub fn SCIPdialogExecSetEmphasisOptimality(
        scip: *mut SCIP,
        dialog: *mut SCIP_DIALOG,
        dialoghdlr: *mut SCIP_DIALOGHDLR,
        nextdialog: *mut *mut SCIP_DIALOG,
    ) -> SCIP_RETCODE;
}
extern "C" {
    pub fn SCIPdialogExecSetEmphasisNumerics(
        scip: *mut SCIP,
        dialog: *mut SCIP_DIALOG,
        dialoghdlr: *mut SCIP_DIALOGHDLR,
        nextdialog: *mut *mut SCIP_DIALOG,
    ) -> SCIP_RETCODE;
}
extern "C" {
    pub fn SCIPdialogExecSetEmphasisBenchmark(
        scip: *mut SCIP,
        dialog: *mut SCIP_DIALOG,
        dialoghdlr: *mut SCIP_DIALOGHDLR,
        nextdialog: *mut *mut SCIP_DIALOG,
    ) -> SCIP_RETCODE;
}
extern "C" {
    pub fn SCIPdialogExecSetLimitsObjective(
        scip: *mut SCIP,
        dialog: *mut SCIP_DIALOG,
        dialoghdlr: *mut SCIP_DIALOGHDLR,
        nextdialog: *mut *mut SCIP_DIALOG,
    ) -> SCIP_RETCODE;
}
extern "C" {
    pub fn SCIPdialogExecDisplayLinearConsClassification(
        scip: *mut SCIP,
        dialog: *mut SCIP_DIALOG,
        dialoghdlr: *mut SCIP_DIALOGHDLR,
        nextdialog: *mut *mut SCIP_DIALOG,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " creates a root dialog"]
    pub fn SCIPcreateRootDialog(scip: *mut SCIP, root: *mut *mut SCIP_DIALOG) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " includes or updates the default dialog menus in SCIP except for menus \"fix\" and \"set\""]
    pub fn SCIPincludeDialogDefaultBasic(scip: *mut SCIP) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " includes or updates the \"set\" menu for each available parameter setting"]
    pub fn SCIPincludeDialogDefaultSet(scip: *mut SCIP) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " includes or updates the \"fix\" menu for each available parameter setting"]
    pub fn SCIPincludeDialogDefaultFix(scip: *mut SCIP) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " creates event handler for tree size estimation"]
    pub fn SCIPincludeEventHdlrEstim(scip: *mut SCIP) -> SCIP_RETCODE;
}
extern "C" {
    pub fn SCIPgetTreesizeEstimation(scip: *mut SCIP) -> f64;
}
extern "C" {
    #[doc = " creates event handler for solving phase event"]
    pub fn SCIPincludeEventHdlrSolvingphase(scip: *mut SCIP) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " includes event handler for soft time limit"]
    pub fn SCIPincludeEventHdlrSofttimelimit(scip: *mut SCIP) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " creates an absolute value expression"]
    pub fn SCIPcreateExprAbs(
        scip: *mut SCIP,
        expr: *mut *mut SCIP_EXPR,
        child: *mut SCIP_EXPR,
        ownercreate: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                expr: *mut SCIP_EXPR,
                ownerdata: *mut *mut SCIP_EXPR_OWNERDATA,
                ownerfree: *mut ::std::option::Option<
                    unsafe extern "C" fn(
                        scip: *mut SCIP,
                        expr: *mut SCIP_EXPR,
                        ownerdata: *mut *mut SCIP_EXPR_OWNERDATA,
                    ) -> SCIP_RETCODE,
                >,
                ownerprint: *mut ::std::option::Option<
                    unsafe extern "C" fn(
                        scip: *mut SCIP,
                        file: *mut FILE,
                        expr: *mut SCIP_EXPR,
                        ownerdata: *mut SCIP_EXPR_OWNERDATA,
                    ) -> SCIP_RETCODE,
                >,
                ownerevalactivity: *mut ::std::option::Option<
                    unsafe extern "C" fn(
                        scip: *mut SCIP,
                        expr: *mut SCIP_EXPR,
                        ownerdata: *mut SCIP_EXPR_OWNERDATA,
                    ) -> SCIP_RETCODE,
                >,
                ownercreatedata: *mut ::std::os::raw::c_void,
            ) -> SCIP_RETCODE,
        >,
        ownercreatedata: *mut ::std::os::raw::c_void,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " indicates whether expression is of abs-type"]
    pub fn SCIPisExprAbs(scip: *mut SCIP, expr: *mut SCIP_EXPR) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " creates the handler for absolute expression and includes it into SCIP\n\n @ingroup ExprhdlrIncludes"]
    pub fn SCIPincludeExprhdlrAbs(scip: *mut SCIP) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " creates the handler for entropy expressions and includes it into SCIP\n\n @ingroup ExprhdlrIncludes"]
    pub fn SCIPincludeExprhdlrEntropy(scip: *mut SCIP) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " creates an entropy expression"]
    pub fn SCIPcreateExprEntropy(
        scip: *mut SCIP,
        expr: *mut *mut SCIP_EXPR,
        child: *mut SCIP_EXPR,
        ownercreate: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                expr: *mut SCIP_EXPR,
                ownerdata: *mut *mut SCIP_EXPR_OWNERDATA,
                ownerfree: *mut ::std::option::Option<
                    unsafe extern "C" fn(
                        scip: *mut SCIP,
                        expr: *mut SCIP_EXPR,
                        ownerdata: *mut *mut SCIP_EXPR_OWNERDATA,
                    ) -> SCIP_RETCODE,
                >,
                ownerprint: *mut ::std::option::Option<
                    unsafe extern "C" fn(
                        scip: *mut SCIP,
                        file: *mut FILE,
                        expr: *mut SCIP_EXPR,
                        ownerdata: *mut SCIP_EXPR_OWNERDATA,
                    ) -> SCIP_RETCODE,
                >,
                ownerevalactivity: *mut ::std::option::Option<
                    unsafe extern "C" fn(
                        scip: *mut SCIP,
                        expr: *mut SCIP_EXPR,
                        ownerdata: *mut SCIP_EXPR_OWNERDATA,
                    ) -> SCIP_RETCODE,
                >,
                ownercreatedata: *mut ::std::os::raw::c_void,
            ) -> SCIP_RETCODE,
        >,
        ownercreatedata: *mut ::std::os::raw::c_void,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " indicates whether expression is of entropy-type"]
    pub fn SCIPisExprEntropy(scip: *mut SCIP, expr: *mut SCIP_EXPR) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " creates an exponential expression"]
    pub fn SCIPcreateExprExp(
        scip: *mut SCIP,
        expr: *mut *mut SCIP_EXPR,
        child: *mut SCIP_EXPR,
        ownercreate: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                expr: *mut SCIP_EXPR,
                ownerdata: *mut *mut SCIP_EXPR_OWNERDATA,
                ownerfree: *mut ::std::option::Option<
                    unsafe extern "C" fn(
                        scip: *mut SCIP,
                        expr: *mut SCIP_EXPR,
                        ownerdata: *mut *mut SCIP_EXPR_OWNERDATA,
                    ) -> SCIP_RETCODE,
                >,
                ownerprint: *mut ::std::option::Option<
                    unsafe extern "C" fn(
                        scip: *mut SCIP,
                        file: *mut FILE,
                        expr: *mut SCIP_EXPR,
                        ownerdata: *mut SCIP_EXPR_OWNERDATA,
                    ) -> SCIP_RETCODE,
                >,
                ownerevalactivity: *mut ::std::option::Option<
                    unsafe extern "C" fn(
                        scip: *mut SCIP,
                        expr: *mut SCIP_EXPR,
                        ownerdata: *mut SCIP_EXPR_OWNERDATA,
                    ) -> SCIP_RETCODE,
                >,
                ownercreatedata: *mut ::std::os::raw::c_void,
            ) -> SCIP_RETCODE,
        >,
        ownercreatedata: *mut ::std::os::raw::c_void,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " indicates whether expression is of exp-type"]
    pub fn SCIPisExprExp(scip: *mut SCIP, expr: *mut SCIP_EXPR) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " creates the handler for exponential expressions and includes it into SCIP\n\n @ingroup ExprhdlrIncludes"]
    pub fn SCIPincludeExprhdlrExp(scip: *mut SCIP) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " creates a logarithmic expression"]
    pub fn SCIPcreateExprLog(
        scip: *mut SCIP,
        expr: *mut *mut SCIP_EXPR,
        child: *mut SCIP_EXPR,
        ownercreate: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                expr: *mut SCIP_EXPR,
                ownerdata: *mut *mut SCIP_EXPR_OWNERDATA,
                ownerfree: *mut ::std::option::Option<
                    unsafe extern "C" fn(
                        scip: *mut SCIP,
                        expr: *mut SCIP_EXPR,
                        ownerdata: *mut *mut SCIP_EXPR_OWNERDATA,
                    ) -> SCIP_RETCODE,
                >,
                ownerprint: *mut ::std::option::Option<
                    unsafe extern "C" fn(
                        scip: *mut SCIP,
                        file: *mut FILE,
                        expr: *mut SCIP_EXPR,
                        ownerdata: *mut SCIP_EXPR_OWNERDATA,
                    ) -> SCIP_RETCODE,
                >,
                ownerevalactivity: *mut ::std::option::Option<
                    unsafe extern "C" fn(
                        scip: *mut SCIP,
                        expr: *mut SCIP_EXPR,
                        ownerdata: *mut SCIP_EXPR_OWNERDATA,
                    ) -> SCIP_RETCODE,
                >,
                ownercreatedata: *mut ::std::os::raw::c_void,
            ) -> SCIP_RETCODE,
        >,
        ownercreatedata: *mut ::std::os::raw::c_void,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " indicates whether expression is of log-type"]
    pub fn SCIPisExprLog(scip: *mut SCIP, expr: *mut SCIP_EXPR) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " creates the handler for logarithmic expression and includes it into SCIP\n\n @ingroup ExprhdlrIncludes"]
    pub fn SCIPincludeExprhdlrLog(scip: *mut SCIP) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " creates a power expression"]
    pub fn SCIPcreateExprPow(
        scip: *mut SCIP,
        expr: *mut *mut SCIP_EXPR,
        child: *mut SCIP_EXPR,
        exponent: f64,
        ownercreate: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                expr: *mut SCIP_EXPR,
                ownerdata: *mut *mut SCIP_EXPR_OWNERDATA,
                ownerfree: *mut ::std::option::Option<
                    unsafe extern "C" fn(
                        scip: *mut SCIP,
                        expr: *mut SCIP_EXPR,
                        ownerdata: *mut *mut SCIP_EXPR_OWNERDATA,
                    ) -> SCIP_RETCODE,
                >,
                ownerprint: *mut ::std::option::Option<
                    unsafe extern "C" fn(
                        scip: *mut SCIP,
                        file: *mut FILE,
                        expr: *mut SCIP_EXPR,
                        ownerdata: *mut SCIP_EXPR_OWNERDATA,
                    ) -> SCIP_RETCODE,
                >,
                ownerevalactivity: *mut ::std::option::Option<
                    unsafe extern "C" fn(
                        scip: *mut SCIP,
                        expr: *mut SCIP_EXPR,
                        ownerdata: *mut SCIP_EXPR_OWNERDATA,
                    ) -> SCIP_RETCODE,
                >,
                ownercreatedata: *mut ::std::os::raw::c_void,
            ) -> SCIP_RETCODE,
        >,
        ownercreatedata: *mut ::std::os::raw::c_void,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " creates a signpower expression"]
    pub fn SCIPcreateExprSignpower(
        scip: *mut SCIP,
        expr: *mut *mut SCIP_EXPR,
        child: *mut SCIP_EXPR,
        exponent: f64,
        ownercreate: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                expr: *mut SCIP_EXPR,
                ownerdata: *mut *mut SCIP_EXPR_OWNERDATA,
                ownerfree: *mut ::std::option::Option<
                    unsafe extern "C" fn(
                        scip: *mut SCIP,
                        expr: *mut SCIP_EXPR,
                        ownerdata: *mut *mut SCIP_EXPR_OWNERDATA,
                    ) -> SCIP_RETCODE,
                >,
                ownerprint: *mut ::std::option::Option<
                    unsafe extern "C" fn(
                        scip: *mut SCIP,
                        file: *mut FILE,
                        expr: *mut SCIP_EXPR,
                        ownerdata: *mut SCIP_EXPR_OWNERDATA,
                    ) -> SCIP_RETCODE,
                >,
                ownerevalactivity: *mut ::std::option::Option<
                    unsafe extern "C" fn(
                        scip: *mut SCIP,
                        expr: *mut SCIP_EXPR,
                        ownerdata: *mut SCIP_EXPR_OWNERDATA,
                    ) -> SCIP_RETCODE,
                >,
                ownercreatedata: *mut ::std::os::raw::c_void,
            ) -> SCIP_RETCODE,
        >,
        ownercreatedata: *mut ::std::os::raw::c_void,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " indicates whether expression is of signpower-type"]
    pub fn SCIPisExprSignpower(scip: *mut SCIP, expr: *mut SCIP_EXPR) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " creates the handler for power expression and includes it into SCIP\n\n @ingroup ExprhdlrIncludes"]
    pub fn SCIPincludeExprhdlrPow(scip: *mut SCIP) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " creates the handler for signed power expression and includes it into SCIP\n\n @ingroup ExprhdlrIncludes"]
    pub fn SCIPincludeExprhdlrSignpower(scip: *mut SCIP) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " computes coefficients of linearization of a square term in a reference point"]
    pub fn SCIPaddSquareLinearization(
        scip: *mut SCIP,
        sqrcoef: f64,
        refpoint: f64,
        isint: ::std::os::raw::c_uint,
        lincoef: *mut f64,
        linconstant: *mut f64,
        success: *mut ::std::os::raw::c_uint,
    );
}
extern "C" {
    #[doc = " computes coefficients of secant of a square term"]
    pub fn SCIPaddSquareSecant(
        scip: *mut SCIP,
        sqrcoef: f64,
        lb: f64,
        ub: f64,
        lincoef: *mut f64,
        linconstant: *mut f64,
        success: *mut ::std::os::raw::c_uint,
    );
}
extern "C" {
    #[doc = " Separation for roots with exponent in [0,1]"]
    pub fn SCIPestimateRoot(
        scip: *mut SCIP,
        exponent: f64,
        overestimate: ::std::os::raw::c_uint,
        xlb: f64,
        xub: f64,
        xref: f64,
        constant: *mut f64,
        slope: *mut f64,
        islocal: *mut ::std::os::raw::c_uint,
        success: *mut ::std::os::raw::c_uint,
    );
}
extern "C" {
    #[doc = " creates the handler for product expressions and includes it into SCIP\n\n @ingroup ExprhdlrIncludes"]
    pub fn SCIPincludeExprhdlrProduct(scip: *mut SCIP) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " creates a product expression"]
    pub fn SCIPcreateExprProduct(
        scip: *mut SCIP,
        expr: *mut *mut SCIP_EXPR,
        nchildren: ::std::os::raw::c_int,
        children: *mut *mut SCIP_EXPR,
        coefficient: f64,
        ownercreate: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                expr: *mut SCIP_EXPR,
                ownerdata: *mut *mut SCIP_EXPR_OWNERDATA,
                ownerfree: *mut ::std::option::Option<
                    unsafe extern "C" fn(
                        scip: *mut SCIP,
                        expr: *mut SCIP_EXPR,
                        ownerdata: *mut *mut SCIP_EXPR_OWNERDATA,
                    ) -> SCIP_RETCODE,
                >,
                ownerprint: *mut ::std::option::Option<
                    unsafe extern "C" fn(
                        scip: *mut SCIP,
                        file: *mut FILE,
                        expr: *mut SCIP_EXPR,
                        ownerdata: *mut SCIP_EXPR_OWNERDATA,
                    ) -> SCIP_RETCODE,
                >,
                ownerevalactivity: *mut ::std::option::Option<
                    unsafe extern "C" fn(
                        scip: *mut SCIP,
                        expr: *mut SCIP_EXPR,
                        ownerdata: *mut SCIP_EXPR_OWNERDATA,
                    ) -> SCIP_RETCODE,
                >,
                ownercreatedata: *mut ::std::os::raw::c_void,
            ) -> SCIP_RETCODE,
        >,
        ownercreatedata: *mut ::std::os::raw::c_void,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " creates the handler for sum expressions and includes it into SCIP\n\n @ingroup ExprhdlrIncludes"]
    pub fn SCIPincludeExprhdlrSum(scip: *mut SCIP) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " creates a sum expression"]
    pub fn SCIPcreateExprSum(
        scip: *mut SCIP,
        expr: *mut *mut SCIP_EXPR,
        nchildren: ::std::os::raw::c_int,
        children: *mut *mut SCIP_EXPR,
        coefficients: *mut f64,
        constant: f64,
        ownercreate: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                expr: *mut SCIP_EXPR,
                ownerdata: *mut *mut SCIP_EXPR_OWNERDATA,
                ownerfree: *mut ::std::option::Option<
                    unsafe extern "C" fn(
                        scip: *mut SCIP,
                        expr: *mut SCIP_EXPR,
                        ownerdata: *mut *mut SCIP_EXPR_OWNERDATA,
                    ) -> SCIP_RETCODE,
                >,
                ownerprint: *mut ::std::option::Option<
                    unsafe extern "C" fn(
                        scip: *mut SCIP,
                        file: *mut FILE,
                        expr: *mut SCIP_EXPR,
                        ownerdata: *mut SCIP_EXPR_OWNERDATA,
                    ) -> SCIP_RETCODE,
                >,
                ownerevalactivity: *mut ::std::option::Option<
                    unsafe extern "C" fn(
                        scip: *mut SCIP,
                        expr: *mut SCIP_EXPR,
                        ownerdata: *mut SCIP_EXPR_OWNERDATA,
                    ) -> SCIP_RETCODE,
                >,
                ownercreatedata: *mut ::std::os::raw::c_void,
            ) -> SCIP_RETCODE,
        >,
        ownercreatedata: *mut ::std::os::raw::c_void,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " sets the constant of a summation expression"]
    pub fn SCIPsetConstantExprSum(expr: *mut SCIP_EXPR, constant: f64);
}
extern "C" {
    #[doc = " appends an expression to a sum expression"]
    pub fn SCIPappendExprSumExpr(
        scip: *mut SCIP,
        expr: *mut SCIP_EXPR,
        child: *mut SCIP_EXPR,
        childcoef: f64,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " multiplies given sum expression by a constant"]
    pub fn SCIPmultiplyByConstantExprSum(expr: *mut SCIP_EXPR, constant: f64);
}
extern "C" {
    #[doc = " constructs the expanded product of two sum expressions"]
    pub fn SCIPmultiplyBySumExprSum(
        scip: *mut SCIP,
        product: *mut *mut SCIP_EXPR,
        factor1: *mut SCIP_EXPR,
        factor2: *mut SCIP_EXPR,
        simplify: ::std::os::raw::c_uint,
        ownercreate: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                expr: *mut SCIP_EXPR,
                ownerdata: *mut *mut SCIP_EXPR_OWNERDATA,
                ownerfree: *mut ::std::option::Option<
                    unsafe extern "C" fn(
                        scip: *mut SCIP,
                        expr: *mut SCIP_EXPR,
                        ownerdata: *mut *mut SCIP_EXPR_OWNERDATA,
                    ) -> SCIP_RETCODE,
                >,
                ownerprint: *mut ::std::option::Option<
                    unsafe extern "C" fn(
                        scip: *mut SCIP,
                        file: *mut FILE,
                        expr: *mut SCIP_EXPR,
                        ownerdata: *mut SCIP_EXPR_OWNERDATA,
                    ) -> SCIP_RETCODE,
                >,
                ownerevalactivity: *mut ::std::option::Option<
                    unsafe extern "C" fn(
                        scip: *mut SCIP,
                        expr: *mut SCIP_EXPR,
                        ownerdata: *mut SCIP_EXPR_OWNERDATA,
                    ) -> SCIP_RETCODE,
                >,
                ownercreatedata: *mut ::std::os::raw::c_void,
            ) -> SCIP_RETCODE,
        >,
        ownercreatedata: *mut ::std::os::raw::c_void,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " constructs the expanded power of a sum expression\n\n @attention The number of terms in the expansion grows exponential with the exponent. Be aware of what you wish for."]
    pub fn SCIPpowerExprSum(
        scip: *mut SCIP,
        result: *mut *mut SCIP_EXPR,
        base: *mut SCIP_EXPR,
        exponent: ::std::os::raw::c_int,
        simplify: ::std::os::raw::c_uint,
        ownercreate: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                expr: *mut SCIP_EXPR,
                ownerdata: *mut *mut SCIP_EXPR_OWNERDATA,
                ownerfree: *mut ::std::option::Option<
                    unsafe extern "C" fn(
                        scip: *mut SCIP,
                        expr: *mut SCIP_EXPR,
                        ownerdata: *mut *mut SCIP_EXPR_OWNERDATA,
                    ) -> SCIP_RETCODE,
                >,
                ownerprint: *mut ::std::option::Option<
                    unsafe extern "C" fn(
                        scip: *mut SCIP,
                        file: *mut FILE,
                        expr: *mut SCIP_EXPR,
                        ownerdata: *mut SCIP_EXPR_OWNERDATA,
                    ) -> SCIP_RETCODE,
                >,
                ownerevalactivity: *mut ::std::option::Option<
                    unsafe extern "C" fn(
                        scip: *mut SCIP,
                        expr: *mut SCIP_EXPR,
                        ownerdata: *mut SCIP_EXPR_OWNERDATA,
                    ) -> SCIP_RETCODE,
                >,
                ownercreatedata: *mut ::std::os::raw::c_void,
            ) -> SCIP_RETCODE,
        >,
        ownercreatedata: *mut ::std::os::raw::c_void,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " creates the handler for sin expressions and includes it into SCIP\n\n @ingroup ExprhdlrIncludes"]
    pub fn SCIPincludeExprhdlrSin(scip: *mut SCIP) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " creates the handler for cos expressions and includes it into SCIP\n\n @ingroup ExprhdlrIncludes"]
    pub fn SCIPincludeExprhdlrCos(scip: *mut SCIP) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " creates a sin expression"]
    pub fn SCIPcreateExprSin(
        scip: *mut SCIP,
        expr: *mut *mut SCIP_EXPR,
        child: *mut SCIP_EXPR,
        ownercreate: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                expr: *mut SCIP_EXPR,
                ownerdata: *mut *mut SCIP_EXPR_OWNERDATA,
                ownerfree: *mut ::std::option::Option<
                    unsafe extern "C" fn(
                        scip: *mut SCIP,
                        expr: *mut SCIP_EXPR,
                        ownerdata: *mut *mut SCIP_EXPR_OWNERDATA,
                    ) -> SCIP_RETCODE,
                >,
                ownerprint: *mut ::std::option::Option<
                    unsafe extern "C" fn(
                        scip: *mut SCIP,
                        file: *mut FILE,
                        expr: *mut SCIP_EXPR,
                        ownerdata: *mut SCIP_EXPR_OWNERDATA,
                    ) -> SCIP_RETCODE,
                >,
                ownerevalactivity: *mut ::std::option::Option<
                    unsafe extern "C" fn(
                        scip: *mut SCIP,
                        expr: *mut SCIP_EXPR,
                        ownerdata: *mut SCIP_EXPR_OWNERDATA,
                    ) -> SCIP_RETCODE,
                >,
                ownercreatedata: *mut ::std::os::raw::c_void,
            ) -> SCIP_RETCODE,
        >,
        ownercreatedata: *mut ::std::os::raw::c_void,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " creates a cos expression"]
    pub fn SCIPcreateExprCos(
        scip: *mut SCIP,
        expr: *mut *mut SCIP_EXPR,
        child: *mut SCIP_EXPR,
        ownercreate: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                expr: *mut SCIP_EXPR,
                ownerdata: *mut *mut SCIP_EXPR_OWNERDATA,
                ownerfree: *mut ::std::option::Option<
                    unsafe extern "C" fn(
                        scip: *mut SCIP,
                        expr: *mut SCIP_EXPR,
                        ownerdata: *mut *mut SCIP_EXPR_OWNERDATA,
                    ) -> SCIP_RETCODE,
                >,
                ownerprint: *mut ::std::option::Option<
                    unsafe extern "C" fn(
                        scip: *mut SCIP,
                        file: *mut FILE,
                        expr: *mut SCIP_EXPR,
                        ownerdata: *mut SCIP_EXPR_OWNERDATA,
                    ) -> SCIP_RETCODE,
                >,
                ownerevalactivity: *mut ::std::option::Option<
                    unsafe extern "C" fn(
                        scip: *mut SCIP,
                        expr: *mut SCIP_EXPR,
                        ownerdata: *mut SCIP_EXPR_OWNERDATA,
                    ) -> SCIP_RETCODE,
                >,
                ownercreatedata: *mut ::std::os::raw::c_void,
            ) -> SCIP_RETCODE,
        >,
        ownercreatedata: *mut ::std::os::raw::c_void,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " indicates whether expression is of sine-type"]
    pub fn SCIPisExprSin(scip: *mut SCIP, expr: *mut SCIP_EXPR) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " indicates whether expression is of cosine-type"]
    pub fn SCIPisExprCos(scip: *mut SCIP, expr: *mut SCIP_EXPR) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " creates the handler for constant value expression and includes it into SCIP\n\n @ingroup ExprhdlrIncludes"]
    pub fn SCIPincludeExprhdlrValue(scip: *mut SCIP) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " creates constant value expression"]
    pub fn SCIPcreateExprValue(
        scip: *mut SCIP,
        expr: *mut *mut SCIP_EXPR,
        value: f64,
        ownercreate: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                expr: *mut SCIP_EXPR,
                ownerdata: *mut *mut SCIP_EXPR_OWNERDATA,
                ownerfree: *mut ::std::option::Option<
                    unsafe extern "C" fn(
                        scip: *mut SCIP,
                        expr: *mut SCIP_EXPR,
                        ownerdata: *mut *mut SCIP_EXPR_OWNERDATA,
                    ) -> SCIP_RETCODE,
                >,
                ownerprint: *mut ::std::option::Option<
                    unsafe extern "C" fn(
                        scip: *mut SCIP,
                        file: *mut FILE,
                        expr: *mut SCIP_EXPR,
                        ownerdata: *mut SCIP_EXPR_OWNERDATA,
                    ) -> SCIP_RETCODE,
                >,
                ownerevalactivity: *mut ::std::option::Option<
                    unsafe extern "C" fn(
                        scip: *mut SCIP,
                        expr: *mut SCIP_EXPR,
                        ownerdata: *mut SCIP_EXPR_OWNERDATA,
                    ) -> SCIP_RETCODE,
                >,
                ownercreatedata: *mut ::std::os::raw::c_void,
            ) -> SCIP_RETCODE,
        >,
        ownercreatedata: *mut ::std::os::raw::c_void,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " creates the handler for variable expression and includes it into SCIP\n\n @ingroup ExprhdlrIncludes"]
    pub fn SCIPincludeExprhdlrVar(scip: *mut SCIP) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " creates a variable expression"]
    pub fn SCIPcreateExprVar(
        scip: *mut SCIP,
        expr: *mut *mut SCIP_EXPR,
        var: *mut SCIP_VAR,
        ownercreate: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                expr: *mut SCIP_EXPR,
                ownerdata: *mut *mut SCIP_EXPR_OWNERDATA,
                ownerfree: *mut ::std::option::Option<
                    unsafe extern "C" fn(
                        scip: *mut SCIP,
                        expr: *mut SCIP_EXPR,
                        ownerdata: *mut *mut SCIP_EXPR_OWNERDATA,
                    ) -> SCIP_RETCODE,
                >,
                ownerprint: *mut ::std::option::Option<
                    unsafe extern "C" fn(
                        scip: *mut SCIP,
                        file: *mut FILE,
                        expr: *mut SCIP_EXPR,
                        ownerdata: *mut SCIP_EXPR_OWNERDATA,
                    ) -> SCIP_RETCODE,
                >,
                ownerevalactivity: *mut ::std::option::Option<
                    unsafe extern "C" fn(
                        scip: *mut SCIP,
                        expr: *mut SCIP_EXPR,
                        ownerdata: *mut SCIP_EXPR_OWNERDATA,
                    ) -> SCIP_RETCODE,
                >,
                ownercreatedata: *mut ::std::os::raw::c_void,
            ) -> SCIP_RETCODE,
        >,
        ownercreatedata: *mut ::std::os::raw::c_void,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " creates the actconsdiving heuristic and includes it in SCIP\n\n  @ingroup PrimalHeuristicIncludes"]
    pub fn SCIPincludeHeurActconsdiving(scip: *mut SCIP) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " creates the adaptivediving heuristic and includes it in SCIP"]
    pub fn SCIPincludeHeurAdaptivediving(scip: *mut SCIP) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " creates the bound primal heuristic and includes it in SCIP\n\n  @ingroup PrimalHeuristicIncludes"]
    pub fn SCIPincludeHeurBound(scip: *mut SCIP) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " creates the clique primal heuristic and includes it in SCIP\n\n  @ingroup PrimalHeuristicIncludes"]
    pub fn SCIPincludeHeurClique(scip: *mut SCIP) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " creates the coefdiving heuristic and includes it in SCIP\n\n  @ingroup PrimalHeuristicIncludes"]
    pub fn SCIPincludeHeurCoefdiving(scip: *mut SCIP) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " creates the completesol primal heuristic and includes it in SCIP\n\n  @ingroup PrimalHeuristicIncludes"]
    pub fn SCIPincludeHeurCompletesol(scip: *mut SCIP) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " creates the conflictdiving heuristic and includes it in SCIP"]
    pub fn SCIPincludeHeurConflictdiving(scip: *mut SCIP) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " creates the crossover primal heuristic and includes it in SCIP\n\n  @ingroup PrimalHeuristicIncludes"]
    pub fn SCIPincludeHeurCrossover(scip: *mut SCIP) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " creates the DINS primal heuristic and includes it in SCIP\n\n  @ingroup PrimalHeuristicIncludes"]
    pub fn SCIPincludeHeurDins(scip: *mut SCIP) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " creates the distributiondiving heuristic and includes it in SCIP\n\n  @ingroup PrimalHeuristicIncludes"]
    pub fn SCIPincludeHeurDistributiondiving(scip: *mut SCIP) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " creates the dps primal heuristic and includes it in SCIP\n\n  @ingroup PrimalHeuristicIncludes"]
    pub fn SCIPincludeHeurDps(scip: *mut SCIP) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " creates the dualVal primal heuristic and includes it in SCIP\n\n  @ingroup PrimalHeuristicIncludes"]
    pub fn SCIPincludeHeurDualval(scip: *mut SCIP) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " main procedure of the dualval heuristic"]
    pub fn SCIPapplyHeurDualval(
        scip: *mut SCIP,
        heur: *mut SCIP_HEUR,
        result: *mut SCIP_RESULT,
        refpoint: *mut SCIP_SOL,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " creates the farkasdiving heuristic and includes it in SCIP\n\n  @ingroup PrimalHeuristicIncludes"]
    pub fn SCIPincludeHeurFarkasdiving(scip: *mut SCIP) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " creates the feaspump primal heuristic and includes it in SCIP\n\n  @ingroup PrimalHeuristicIncludes"]
    pub fn SCIPincludeHeurFeaspump(scip: *mut SCIP) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " creates the fix-and-infer primal heuristic and includes it in SCIP\n\n  @ingroup PrimalHeuristicIncludes"]
    pub fn SCIPincludeHeurFixandinfer(scip: *mut SCIP) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " creates the fracdiving heuristic and includes it in SCIP\n\n  @ingroup PrimalHeuristicIncludes"]
    pub fn SCIPincludeHeurFracdiving(scip: *mut SCIP) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " creates the gins primal heuristic and includes it in SCIP\n\n  @ingroup PrimalHeuristicIncludes"]
    pub fn SCIPincludeHeurGins(scip: *mut SCIP) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " creates the guideddiving heuristic and includes it in SCIP\n\n  @ingroup PrimalHeuristicIncludes"]
    pub fn SCIPincludeHeurGuideddiving(scip: *mut SCIP) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " creates the indicator primal heuristic and includes it in SCIP\n\n  @ingroup PrimalHeuristicIncludes"]
    pub fn SCIPincludeHeurIndicator(scip: *mut SCIP) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " pass partial solution for indicator variables to heuristic"]
    pub fn SCIPheurPassIndicator(
        scip: *mut SCIP,
        heur: *mut SCIP_HEUR,
        nindconss: ::std::os::raw::c_int,
        indconss: *mut *mut SCIP_CONS,
        solcand: *mut ::std::os::raw::c_uint,
        obj: f64,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " creates the indicatordiving heuristic and includes it in SCIP\n\n  @ingroup PrimalHeuristicIncludes"]
    pub fn SCIPincludeHeurIndicatordiving(scip: *mut SCIP) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " creates the intdiving heuristic and includes it in SCIP\n\n  @ingroup PrimalHeuristicIncludes"]
    pub fn SCIPincludeHeurIntdiving(scip: *mut SCIP) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " creates the intshifting heuristic and includes it in SCIP\n\n  @ingroup PrimalHeuristicIncludes"]
    pub fn SCIPincludeHeurIntshifting(scip: *mut SCIP) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " creates the linesearchdiving primal heuristic and includes it in SCIP\n\n  @ingroup PrimalHeuristicIncludes"]
    pub fn SCIPincludeHeurLinesearchdiving(scip: *mut SCIP) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " creates local branching primal heuristic and includes it in SCIP\n\n  @ingroup PrimalHeuristicIncludes"]
    pub fn SCIPincludeHeurLocalbranching(scip: *mut SCIP) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " creates the locks primal heuristic and includes it in SCIP\n\n  @ingroup PrimalHeuristicIncludes"]
    pub fn SCIPincludeHeurLocks(scip: *mut SCIP) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " apply fix-and-propagate scheme based on variable locks\n\n  @note probing mode of SCIP needs to be enabled before"]
    pub fn SCIPapplyLockFixings(
        scip: *mut SCIP,
        heurdata: *mut SCIP_HEURDATA,
        cutoff: *mut ::std::os::raw::c_uint,
        allrowsfulfilled: *mut ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " creates the lpface primal heuristic and includes it in SCIP\n\n  @ingroup PrimalHeuristicIncludes"]
    pub fn SCIPincludeHeurLpface(scip: *mut SCIP) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " creates the alns primal heuristic and includes it in SCIP\n\n  @ingroup PrimalHeuristicIncludes"]
    pub fn SCIPincludeHeurAlns(scip: *mut SCIP) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " creates the multistart primal heuristic and includes it in SCIP\n\n  @ingroup PrimalHeuristicIncludes"]
    pub fn SCIPincludeHeurMultistart(scip: *mut SCIP) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " creates the mutation primal heuristic and includes it in SCIP\n\n  @ingroup PrimalHeuristicIncludes"]
    pub fn SCIPincludeHeurMutation(scip: *mut SCIP) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " creates the mpec primal heuristic and includes it in SCIP\n\n  @ingroup PrimalHeuristicIncludes"]
    pub fn SCIPincludeHeurMpec(scip: *mut SCIP) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " creates the fracdiving heuristic and includes it in SCIP\n\n  @ingroup PrimalHeuristicIncludes"]
    pub fn SCIPincludeHeurNlpdiving(scip: *mut SCIP) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " creates the objpscostdiving heuristic and includes it in SCIP\n\n  @ingroup PrimalHeuristicIncludes"]
    pub fn SCIPincludeHeurObjpscostdiving(scip: *mut SCIP) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " creates the octane primal heuristic and includes it in SCIP\n\n  @ingroup PrimalHeuristicIncludes"]
    pub fn SCIPincludeHeurOctane(scip: *mut SCIP) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " creates the ofins primal heuristic and includes it in SCIP\n\n  @ingroup PrimalHeuristicIncludes"]
    pub fn SCIPincludeHeurOfins(scip: *mut SCIP) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " creates the oneopt primal heuristic and includes it in SCIP\n\n  @ingroup PrimalHeuristicIncludes"]
    pub fn SCIPincludeHeurOneopt(scip: *mut SCIP) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " creates the PADM primal heuristic and includes it in SCIP\n\n  @ingroup PrimalHeuristicIncludes"]
    pub fn SCIPincludeHeurPADM(scip: *mut SCIP) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " creates the pscostdiving heuristic and includes it in SCIP\n\n  @ingroup PrimalHeuristicIncludes"]
    pub fn SCIPincludeHeurPscostdiving(scip: *mut SCIP) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " creates the proximity primal heuristic and includes it in SCIP\n\n  @ingroup PrimalHeuristicIncludes"]
    pub fn SCIPincludeHeurProximity(scip: *mut SCIP) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " main procedure of the proximity heuristic, creates and solves a sub-SCIP\n\n  @note the method can be applied in an iterative way, keeping the same subscip in between. If the @p freesubscip\n        parameter is set to FALSE, the heuristic will keep the subscip data structures. Always set this parameter\n        to TRUE, or call SCIPdeleteSubproblemProximity() afterwards"]
    pub fn SCIPapplyProximity(
        scip: *mut SCIP,
        heur: *mut SCIP_HEUR,
        result: *mut SCIP_RESULT,
        minimprove: f64,
        nnodes: ::std::os::raw::c_longlong,
        nlpiters: ::std::os::raw::c_longlong,
        nusednodes: *mut ::std::os::raw::c_longlong,
        nusedlpiters: *mut ::std::os::raw::c_longlong,
        freesubscip: ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " frees the sub-MIP created by proximity"]
    pub fn SCIPdeleteSubproblemProximity(scip: *mut SCIP) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " creates the rand rounding heuristic and includes it in SCIP\n\n  @ingroup PrimalHeuristicIncludes"]
    pub fn SCIPincludeHeurRandrounding(scip: *mut SCIP) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " creates RENS primal heuristic and includes it in SCIP\n\n  @ingroup PrimalHeuristicIncludes"]
    pub fn SCIPincludeHeurRens(scip: *mut SCIP) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " main procedure of the RNS heuristic, creates and solves a sub-SCIP"]
    pub fn SCIPapplyRens(
        scip: *mut SCIP,
        heur: *mut SCIP_HEUR,
        result: *mut SCIP_RESULT,
        minfixingrate: f64,
        minimprove: f64,
        maxnodes: ::std::os::raw::c_longlong,
        nstallnodes: ::std::os::raw::c_longlong,
        startsol: ::std::os::raw::c_char,
        binarybounds: ::std::os::raw::c_uint,
        uselprows: ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " creates the reoptsols primal heuristic and includes it in SCIP\n\n  @ingroup PrimalHeuristicIncludes"]
    pub fn SCIPincludeHeurReoptsols(scip: *mut SCIP) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = "@addtogroup PRIMALHEURISTICS\n\n @{"]
    pub fn SCIPreoptsolsGetNCheckedsols(scip: *mut SCIP) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SCIPreoptsolsGetNImprovingsols(scip: *mut SCIP) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " creates the repair primal heuristic and includes it in SCIP\n\n  @ingroup PrimalHeuristicIncludes"]
    pub fn SCIPincludeHeurRepair(scip: *mut SCIP) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " creates RINS primal heuristic and includes it in SCIP\n\n  @ingroup PrimalHeuristicIncludes"]
    pub fn SCIPincludeHeurRins(scip: *mut SCIP) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " creates the rootsoldiving heuristic and includes it in SCIP\n\n  @ingroup PrimalHeuristicIncludes"]
    pub fn SCIPincludeHeurRootsoldiving(scip: *mut SCIP) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " creates the rounding heuristic with infeasibility recovering and includes it in SCIP\n\n  @ingroup PrimalHeuristicIncludes"]
    pub fn SCIPincludeHeurRounding(scip: *mut SCIP) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " creates the scheduler primal heuristic and includes it in SCIP\n\n  @ingroup PrimalHeuristicIncludes"]
    pub fn SCIPincludeHeurScheduler(scip: *mut SCIP) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " creates the shiftandpropagate primal heuristic and includes it in SCIP\n\n  @ingroup PrimalHeuristicIncludes"]
    pub fn SCIPincludeHeurShiftandpropagate(scip: *mut SCIP) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " creates the shifting heuristic and includes it in SCIP\n\n  @ingroup PrimalHeuristicIncludes"]
    pub fn SCIPincludeHeurShifting(scip: *mut SCIP) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " creates the simple rounding heuristic and includes it in SCIP\n\n  @ingroup PrimalHeuristicIncludes"]
    pub fn SCIPincludeHeurSimplerounding(scip: *mut SCIP) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " creates the NLP local search primal heuristic and includes it in SCIP\n\n  @ingroup PrimalHeuristicIncludes"]
    pub fn SCIPincludeHeurSubNlp(scip: *mut SCIP) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " main procedure of the subNLP heuristic"]
    pub fn SCIPapplyHeurSubNlp(
        scip: *mut SCIP,
        heur: *mut SCIP_HEUR,
        result: *mut SCIP_RESULT,
        refpoint: *mut SCIP_SOL,
        resultsol: *mut SCIP_SOL,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " updates the starting point for the NLP heuristic\n\n Is called, for example, by a constraint handler that handles nonlinear constraints when a check on feasibility of a solution fails."]
    pub fn SCIPupdateStartpointHeurSubNlp(
        scip: *mut SCIP,
        heur: *mut SCIP_HEUR,
        solcand: *mut SCIP_SOL,
        violation: f64,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " gets startpoint candidate to be used in next call to NLP heuristic, or NULL if none"]
    pub fn SCIPgetStartCandidateHeurSubNlp(scip: *mut SCIP, heur: *mut SCIP_HEUR) -> *mut SCIP_SOL;
}
extern "C" {
    #[doc = " creates the trivial primal heuristic and includes it in SCIP\n\n  @ingroup PrimalHeuristicIncludes"]
    pub fn SCIPincludeHeurTrivial(scip: *mut SCIP) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " creates the trivialnegation primal heuristic and includes it in SCIP\n\n  @ingroup PrimalHeuristicIncludes"]
    pub fn SCIPincludeHeurTrivialnegation(scip: *mut SCIP) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " creates local branching primal heuristic and includes it in SCIP\n\n  @ingroup PrimalHeuristicIncludes"]
    pub fn SCIPincludeHeurTrustregion(scip: *mut SCIP) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " creates the trysol primal heuristic and includes it in SCIP\n\n  @ingroup PrimalHeuristicIncludes"]
    pub fn SCIPincludeHeurTrySol(scip: *mut SCIP) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " pass solution to trysol heuristic"]
    pub fn SCIPheurPassSolTrySol(
        scip: *mut SCIP,
        heur: *mut SCIP_HEUR,
        sol: *mut SCIP_SOL,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " pass solution to trysol heuristic which just gets added (without checking feasibility"]
    pub fn SCIPheurPassSolAddSol(
        scip: *mut SCIP,
        heur: *mut SCIP_HEUR,
        sol: *mut SCIP_SOL,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " creates the twoopt primal heuristic and includes it in SCIP\n\n  @ingroup PrimalHeuristicIncludes"]
    pub fn SCIPincludeHeurTwoopt(scip: *mut SCIP) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " creates the undercover primal heuristic and includes it in SCIP\n\n  @ingroup PrimalHeuristicIncludes"]
    pub fn SCIPincludeHeurUndercover(scip: *mut SCIP) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " computes a minimal set of covering variables"]
    pub fn SCIPcomputeCoverUndercover(
        scip: *mut SCIP,
        coversize: *mut ::std::os::raw::c_int,
        cover: *mut *mut SCIP_VAR,
        timelimit: f64,
        memorylimit: f64,
        objlimit: f64,
        globalbounds: ::std::os::raw::c_uint,
        onlyconvexify: ::std::os::raw::c_uint,
        coverand: ::std::os::raw::c_uint,
        coverbd: ::std::os::raw::c_uint,
        coverind: ::std::os::raw::c_uint,
        covernl: ::std::os::raw::c_uint,
        coveringobj: ::std::os::raw::c_char,
        success: *mut ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " creates the variable bounds primal heuristic and includes it in SCIP\n\n  @ingroup PrimalHeuristicIncludes"]
    pub fn SCIPincludeHeurVbounds(scip: *mut SCIP) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " creates the veclendiving heuristic and includes it in SCIP\n\n  @ingroup PrimalHeuristicIncludes"]
    pub fn SCIPincludeHeurVeclendiving(scip: *mut SCIP) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " creates the zeroobj primal heuristic and includes it in SCIP\n\n  @ingroup PrimalHeuristicIncludes"]
    pub fn SCIPincludeHeurZeroobj(scip: *mut SCIP) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " main procedure of the zeroobj heuristic, creates and solves a sub-SCIP"]
    pub fn SCIPapplyZeroobj(
        scip: *mut SCIP,
        heur: *mut SCIP_HEUR,
        result: *mut SCIP_RESULT,
        minimprove: f64,
        nnodes: ::std::os::raw::c_longlong,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " creates the zirounding primal heuristic and includes it in SCIP\n\n  @ingroup PrimalHeuristicIncludes"]
    pub fn SCIPincludeHeurZirounding(scip: *mut SCIP) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " sets the copy handler callback of a nonlinear handler"]
    pub fn SCIPnlhdlrSetCopyHdlr(
        nlhdlr: *mut SCIP_NLHDLR,
        copy: ::std::option::Option<
            unsafe extern "C" fn(
                targetscip: *mut SCIP,
                targetconshdlr: *mut SCIP_CONSHDLR,
                sourceconshdlr: *mut SCIP_CONSHDLR,
                sourcenlhdlr: *mut SCIP_NLHDLR,
            ) -> SCIP_RETCODE,
        >,
    );
}
extern "C" {
    #[doc = " sets the nonlinear handler callback to free the nonlinear handler data"]
    pub fn SCIPnlhdlrSetFreeHdlrData(
        nlhdlr: *mut SCIP_NLHDLR,
        freehdlrdata: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                nlhdlr: *mut SCIP_NLHDLR,
                nlhdlrdata: *mut *mut SCIP_NLHDLRDATA,
            ) -> SCIP_RETCODE,
        >,
    );
}
extern "C" {
    #[doc = " sets the nonlinear handler callback to free expression specific data of nonlinear handler"]
    pub fn SCIPnlhdlrSetFreeExprData(
        nlhdlr: *mut SCIP_NLHDLR,
        freeexprdata: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                nlhdlr: *mut SCIP_NLHDLR,
                expr: *mut SCIP_EXPR,
                nlhdlrexprdata: *mut *mut SCIP_NLHDLREXPRDATA,
            ) -> SCIP_RETCODE,
        >,
    );
}
extern "C" {
    #[doc = " sets the initialization and deinitialization callback of a nonlinear handler"]
    pub fn SCIPnlhdlrSetInitExit(
        nlhdlr: *mut SCIP_NLHDLR,
        init: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, nlhdlr: *mut SCIP_NLHDLR) -> SCIP_RETCODE,
        >,
        exit: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, nlhdlr: *mut SCIP_NLHDLR) -> SCIP_RETCODE,
        >,
    );
}
extern "C" {
    #[doc = " sets the propagation callbacks of a nonlinear handler"]
    pub fn SCIPnlhdlrSetProp(
        nlhdlr: *mut SCIP_NLHDLR,
        inteval: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                nlhdlr: *mut SCIP_NLHDLR,
                expr: *mut SCIP_EXPR,
                nlhdlrexprdata: *mut SCIP_NLHDLREXPRDATA,
                interval: *mut SCIP_INTERVAL,
                intevalvar: ::std::option::Option<
                    unsafe extern "C" fn(
                        scip: *mut SCIP,
                        var: *mut SCIP_VAR,
                        intevalvardata: *mut ::std::os::raw::c_void,
                    ) -> SCIP_INTERVAL,
                >,
                intevalvardata: *mut ::std::os::raw::c_void,
            ) -> SCIP_RETCODE,
        >,
        reverseprop: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                conshdlr: *mut SCIP_CONSHDLR,
                nlhdlr: *mut SCIP_NLHDLR,
                expr: *mut SCIP_EXPR,
                nlhdlrexprdata: *mut SCIP_NLHDLREXPRDATA,
                bounds: SCIP_INTERVAL,
                infeasible: *mut ::std::os::raw::c_uint,
                nreductions: *mut ::std::os::raw::c_int,
            ) -> SCIP_RETCODE,
        >,
    );
}
extern "C" {
    #[doc = " sets the enforcement callbacks of a nonlinear handler"]
    pub fn SCIPnlhdlrSetSepa(
        nlhdlr: *mut SCIP_NLHDLR,
        initsepa: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                conshdlr: *mut SCIP_CONSHDLR,
                cons: *mut SCIP_CONS,
                nlhdlr: *mut SCIP_NLHDLR,
                expr: *mut SCIP_EXPR,
                nlhdlrexprdata: *mut SCIP_NLHDLREXPRDATA,
                overestimate: ::std::os::raw::c_uint,
                underestimate: ::std::os::raw::c_uint,
                infeasible: *mut ::std::os::raw::c_uint,
            ) -> SCIP_RETCODE,
        >,
        enfo: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                conshdlr: *mut SCIP_CONSHDLR,
                cons: *mut SCIP_CONS,
                nlhdlr: *mut SCIP_NLHDLR,
                expr: *mut SCIP_EXPR,
                nlhdlrexprdata: *mut SCIP_NLHDLREXPRDATA,
                sol: *mut SCIP_SOL,
                auxvalue: f64,
                overestimate: ::std::os::raw::c_uint,
                allowweakcuts: ::std::os::raw::c_uint,
                separated: ::std::os::raw::c_uint,
                addbranchscores: ::std::os::raw::c_uint,
                result: *mut SCIP_RESULT,
            ) -> SCIP_RETCODE,
        >,
        estimate: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                conshdlr: *mut SCIP_CONSHDLR,
                nlhdlr: *mut SCIP_NLHDLR,
                expr: *mut SCIP_EXPR,
                nlhdlrexprdata: *mut SCIP_NLHDLREXPRDATA,
                sol: *mut SCIP_SOL,
                auxvalue: f64,
                overestimate: ::std::os::raw::c_uint,
                targetvalue: f64,
                addbranchscores: ::std::os::raw::c_uint,
                rowpreps: *mut SCIP_PTRARRAY,
                success: *mut ::std::os::raw::c_uint,
                addedbranchscores: *mut ::std::os::raw::c_uint,
            ) -> SCIP_RETCODE,
        >,
        exitsepa: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                nlhdlr: *mut SCIP_NLHDLR,
                expr: *mut SCIP_EXPR,
                nlhdlrexprdata: *mut SCIP_NLHDLREXPRDATA,
            ) -> SCIP_RETCODE,
        >,
    );
}
extern "C" {
    #[doc = " sets the solution linearization callback of a nonlinear handler"]
    pub fn SCIPnlhdlrSetSollinearize(
        nlhdlr: *mut SCIP_NLHDLR,
        sollinearize: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                conshdlr: *mut SCIP_CONSHDLR,
                cons: *mut SCIP_CONS,
                nlhdlr: *mut SCIP_NLHDLR,
                expr: *mut SCIP_EXPR,
                nlhdlrexprdata: *mut SCIP_NLHDLREXPRDATA,
                sol: *mut SCIP_SOL,
                solisbest: ::std::os::raw::c_uint,
                overestimate: ::std::os::raw::c_uint,
                underestimate: ::std::os::raw::c_uint,
            ) -> SCIP_RETCODE,
        >,
    );
}
extern "C" {
    #[doc = " gives name of nonlinear handler"]
    pub fn SCIPnlhdlrGetName(nlhdlr: *mut SCIP_NLHDLR) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " gives description of nonlinear handler, can be NULL"]
    pub fn SCIPnlhdlrGetDesc(nlhdlr: *mut SCIP_NLHDLR) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " gives detection priority of nonlinear handler"]
    pub fn SCIPnlhdlrGetDetectPriority(nlhdlr: *mut SCIP_NLHDLR) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " gives enforcement priority of nonlinear handler"]
    pub fn SCIPnlhdlrGetEnfoPriority(nlhdlr: *mut SCIP_NLHDLR) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " returns whether nonlinear handler is enabled"]
    pub fn SCIPnlhdlrIsEnabled(nlhdlr: *mut SCIP_NLHDLR) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " gives handler data of nonlinear handler"]
    pub fn SCIPnlhdlrGetData(nlhdlr: *mut SCIP_NLHDLR) -> *mut SCIP_NLHDLRDATA;
}
extern "C" {
    #[doc = " returns whether nonlinear handler implements the interval evaluation callback"]
    pub fn SCIPnlhdlrHasIntEval(nlhdlr: *mut SCIP_NLHDLR) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " returns whether nonlinear handler implements the reverse propagation callback"]
    pub fn SCIPnlhdlrHasReverseProp(nlhdlr: *mut SCIP_NLHDLR) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " returns whether nonlinear handler implements the separation initialization callback"]
    pub fn SCIPnlhdlrHasInitSepa(nlhdlr: *mut SCIP_NLHDLR) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " returns whether nonlinear handler implements the separation deinitialization callback"]
    pub fn SCIPnlhdlrHasExitSepa(nlhdlr: *mut SCIP_NLHDLR) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " returns whether nonlinear handler implements the enforcement callback"]
    pub fn SCIPnlhdlrHasEnfo(nlhdlr: *mut SCIP_NLHDLR) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " returns whether nonlinear handler implements the estimator callback"]
    pub fn SCIPnlhdlrHasEstimate(nlhdlr: *mut SCIP_NLHDLR) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " returns whether nonlinear handler implements the solution linearization callback"]
    pub fn SCIPnlhdlrHasSollinearize(nlhdlr: *mut SCIP_NLHDLR) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn SCIPnlhdlrComp(
        elem1: *mut ::std::os::raw::c_void,
        elem2: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " includes bilinear nonlinear handler in nonlinear constraint handler\n\n @ingroup NlhdlrIncludes"]
    pub fn SCIPincludeNlhdlrBilinear(scip: *mut SCIP) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " returns an array of expressions that have been detected by the bilinear nonlinear handler"]
    pub fn SCIPgetExprsBilinear(nlhdlr: *mut SCIP_NLHDLR) -> *mut *mut SCIP_EXPR;
}
extern "C" {
    #[doc = " returns an array of nonlinear handler expressions data of expressions that have been detected by the bilinear nonlinear handler"]
    pub fn SCIPgetExprsdataBilinear(nlhdlr: *mut SCIP_NLHDLR) -> *mut *mut SCIP_NLHDLREXPRDATA;
}
extern "C" {
    #[doc = " returns the total number of expressions that have been detected by the bilinear nonlinear handler"]
    pub fn SCIPgetNExprsBilinear(nlhdlr: *mut SCIP_NLHDLR) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " adds a globally valid inequality of the form \\f$\\text{xcoef}\\cdot x \\leq \\text{ycoef} \\cdot y + \\text{constant}\\f$ to a product expression of the form \\f$x\\cdot y\\f$"]
    pub fn SCIPaddIneqBilinear(
        scip: *mut SCIP,
        nlhdlr: *mut SCIP_NLHDLR,
        expr: *mut SCIP_EXPR,
        xcoef: f64,
        ycoef: f64,
        constant: f64,
        success: *mut ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " computes coefficients of linearization of a bilinear term in a reference point"]
    pub fn SCIPaddBilinLinearization(
        scip: *mut SCIP,
        bilincoef: f64,
        refpointx: f64,
        refpointy: f64,
        lincoefx: *mut f64,
        lincoefy: *mut f64,
        linconstant: *mut f64,
        success: *mut ::std::os::raw::c_uint,
    );
}
extern "C" {
    #[doc = " computes coefficients of McCormick under- or overestimation of a bilinear term"]
    pub fn SCIPaddBilinMcCormick(
        scip: *mut SCIP,
        bilincoef: f64,
        lbx: f64,
        ubx: f64,
        refpointx: f64,
        lby: f64,
        uby: f64,
        refpointy: f64,
        overestimate: ::std::os::raw::c_uint,
        lincoefx: *mut f64,
        lincoefy: *mut f64,
        linconstant: *mut f64,
        success: *mut ::std::os::raw::c_uint,
    );
}
extern "C" {
    #[doc = " computes coefficients of linearization of a bilinear term in a reference point when given a linear inequality\n  involving only the variables of the bilinear term\n\n  @note the formulas are extracted from \"Convex envelopes of bivariate functions through the solution of KKT systems\"\n        by Marco Locatelli"]
    pub fn SCIPcomputeBilinEnvelope1(
        scip: *mut SCIP,
        bilincoef: f64,
        lbx: f64,
        ubx: f64,
        refpointx: f64,
        lby: f64,
        uby: f64,
        refpointy: f64,
        overestimate: ::std::os::raw::c_uint,
        xcoef: f64,
        ycoef: f64,
        constant: f64,
        lincoefx: *mut f64,
        lincoefy: *mut f64,
        linconstant: *mut f64,
        success: *mut ::std::os::raw::c_uint,
    );
}
extern "C" {
    #[doc = " computes coefficients of linearization of a bilinear term in a reference point when given two linear inequalities\n  involving only the variables of the bilinear term\n\n  @note the formulas are extracted from \"Convex envelopes of bivariate functions through the solution of KKT systems\"\n        by Marco Locatelli"]
    pub fn SCIPcomputeBilinEnvelope2(
        scip: *mut SCIP,
        bilincoef: f64,
        lbx: f64,
        ubx: f64,
        refpointx: f64,
        lby: f64,
        uby: f64,
        refpointy: f64,
        overestimate: ::std::os::raw::c_uint,
        alpha1: f64,
        beta1: f64,
        gamma1: f64,
        alpha2: f64,
        beta2: f64,
        gamma2: f64,
        lincoefx: *mut f64,
        lincoefy: *mut f64,
        linconstant: *mut f64,
        success: *mut ::std::os::raw::c_uint,
    );
}
extern "C" {
    #[doc = " includes convex nonlinear handler in nonlinear constraint handler\n\n @ingroup NlhdlrIncludes"]
    pub fn SCIPincludeNlhdlrConvex(scip: *mut SCIP) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " includes concave nonlinear handler in nonlinear constraint handler\n\n @ingroup NlhdlrIncludes"]
    pub fn SCIPincludeNlhdlrConcave(scip: *mut SCIP) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " checks whether a given expression is convex or concave w.r.t. the original variables\n\n This function uses the methods that are used in the detection algorithm of the convex nonlinear handler."]
    pub fn SCIPhasExprCurvature(
        scip: *mut SCIP,
        expr: *mut SCIP_EXPR,
        curv: SCIP_EXPRCURV,
        success: *mut ::std::os::raw::c_uint,
        assumevarfixed: *mut SCIP_HASHMAP,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " includes default nonlinear handler in nonlinear constraint handler\n\n @ingroup NlhdlrIncludes"]
    pub fn SCIPincludeNlhdlrDefault(scip: *mut SCIP) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " includes perspective nonlinear handler in nonlinear constraint handler\n\n @ingroup NlhdlrIncludes"]
    pub fn SCIPincludeNlhdlrPerspective(scip: *mut SCIP) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " includes quadratic nonlinear handler in nonlinear constraint handler\n\n @ingroup NlhdlrIncludes"]
    pub fn SCIPincludeNlhdlrQuadratic(scip: *mut SCIP) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " includes quotient nonlinear handler in nonlinear constraint handler\n\n @ingroup NlhdlrIncludes"]
    pub fn SCIPincludeNlhdlrQuotient(scip: *mut SCIP) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " includes signomial nonlinear handler to nonlinear constraint handler\n\n @ingroup NlhdlrIncludes"]
    pub fn SCIPincludeNlhdlrSignomial(scip: *mut SCIP) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " includes SOC nonlinear handler in nonlinear constraint handler\n\n @ingroup NlhdlrIncludes"]
    pub fn SCIPincludeNlhdlrSoc(scip: *mut SCIP) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " checks whether constraint is SOC representable in original variables and returns the SOC representation\n\n The SOC representation has the form:\n \\f$\\sqrt{\\sum_{i=1}^{n} (v_i^T x + \\beta_i)^2} - v_{n+1}^T x - \\beta_{n+1} \\lessgtr 0\\f$,\n where \\f$n+1 = \\text{nterms}\\f$ and the inequality type is given by sidetype (`SCIP_SIDETYPE_RIGHT` if inequality\n is \\f$\\leq\\f$, `SCIP_SIDETYPE_LEFT` if \\f$\\geq\\f$).\n\n For each term (i.e. for each \\f$i\\f$ in the above notation as well as \\f$n+1\\f$), the constant \\f$\\beta_i\\f$ is given by the\n corresponding element `offsets[i-1]` and `termbegins[i-1]` is the starting position of the term in arrays\n `transcoefs` and `transcoefsidx`. The overall number of nonzeros is `termbegins[nterms]`.\n\n Arrays `transcoefs` and `transcoefsidx` have size `termbegins[nterms]` and define the linear expressions \\f$v_i^T x\\f$\n for each term. For a term \\f$i\\f$ in the above notation, the nonzeroes are given by elements\n `termbegins[i-1]...termbegins[i]` of `transcoefs` and `transcoefsidx`. There may be no nonzeroes for some term (i.e.,\n constant terms are possible). `transcoefs` contains the coefficients \\f$v_i\\f$ and `transcoefsidx` contains positions of\n variables in the `vars` array.\n\n The `vars` array has size `nvars` and contains \\f$x\\f$ variables; each variable is included at most once.\n\n The arrays should be freed by calling SCIPfreeSOCArraysNonlinear().\n\n This function uses the methods that are used in the detection algorithm of the SOC nonlinear handler."]
    pub fn SCIPisSOCNonlinear(
        scip: *mut SCIP,
        cons: *mut SCIP_CONS,
        compeigenvalues: ::std::os::raw::c_uint,
        success: *mut ::std::os::raw::c_uint,
        sidetype: *mut SCIP_SIDETYPE,
        vars: *mut *mut *mut SCIP_VAR,
        offsets: *mut *mut f64,
        transcoefs: *mut *mut f64,
        transcoefsidx: *mut *mut ::std::os::raw::c_int,
        termbegins: *mut *mut ::std::os::raw::c_int,
        nvars: *mut ::std::os::raw::c_int,
        nterms: *mut ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " frees arrays created by SCIPisSOCNonlinear()"]
    pub fn SCIPfreeSOCArraysNonlinear(
        scip: *mut SCIP,
        vars: *mut *mut *mut SCIP_VAR,
        offsets: *mut *mut f64,
        transcoefs: *mut *mut f64,
        transcoefsidx: *mut *mut ::std::os::raw::c_int,
        termbegins: *mut *mut ::std::os::raw::c_int,
        nvars: ::std::os::raw::c_int,
        nterms: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " creates the node selector for best first search and includes it in SCIP\n\n  @ingroup NodeSelectorIncludes"]
    pub fn SCIPincludeNodeselBfs(scip: *mut SCIP) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " creates the node selector for breadth first search and includes it in SCIP\n\n  @ingroup NodeSelectorIncludes"]
    pub fn SCIPincludeNodeselBreadthfirst(scip: *mut SCIP) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " creates the node selector for depth first search and includes it in SCIP\n\n  @ingroup NodeSelectorIncludes"]
    pub fn SCIPincludeNodeselDfs(scip: *mut SCIP) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " creates the node selector for best estimate search and includes it in SCIP\n\n  @ingroup NodeSelectorIncludes"]
    pub fn SCIPincludeNodeselEstimate(scip: *mut SCIP) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " creates the node selector for hybrid best estim / best bound search and includes it in SCIP\n\n  @ingroup NodeSelectorIncludes"]
    pub fn SCIPincludeNodeselHybridestim(scip: *mut SCIP) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " creates the uct node selector and includes it in SCIP\n\n  @ingroup NodeSelectorIncludes"]
    pub fn SCIPincludeNodeselUct(scip: *mut SCIP) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " creates the node selector for restarting depth first search and includes it in SCIP\n\n  @ingroup NodeSelectorIncludes"]
    pub fn SCIPincludeNodeselRestartdfs(scip: *mut SCIP) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " creates the boundshift presolver and includes it in SCIP\n\n @ingroup PresolverIncludes"]
    pub fn SCIPincludePresolBoundshift(scip: *mut SCIP) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " creates the convertinttobin presolver and includes it in SCIP\n\n @ingroup PresolverIncludes"]
    pub fn SCIPincludePresolConvertinttobin(scip: *mut SCIP) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " creates the dominated column presolver and includes it in SCIP\n\n @ingroup PresolverIncludes"]
    pub fn SCIPincludePresolDomcol(scip: *mut SCIP) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " creates the dualagg presolver and includes it in SCIP\n\n @ingroup PresolverIncludes"]
    pub fn SCIPincludePresolDualagg(scip: *mut SCIP) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " creates the dualcomp presolver and includes it in SCIP\n\n @ingroup PresolverIncludes"]
    pub fn SCIPincludePresolDualcomp(scip: *mut SCIP) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " creates the dual inference presolver and includes it in SCIP\n\n @ingroup PresolverIncludes"]
    pub fn SCIPincludePresolDualinfer(scip: *mut SCIP) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " creates the gateextraction presolver and includes it in SCIP\n\n @ingroup PresolverIncludes"]
    pub fn SCIPincludePresolGateextraction(scip: *mut SCIP) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " creates the implics presolver and includes it in SCIP\n\n @ingroup PresolverIncludes"]
    pub fn SCIPincludePresolImplics(scip: *mut SCIP) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " creates the inttobinary presolver and includes it in SCIP\n\n @ingroup PresolverIncludes"]
    pub fn SCIPincludePresolInttobinary(scip: *mut SCIP) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " creates the MILP presolver and includes it in SCIP if the presolve library is available\n\n @ingroup PresolverIncludes"]
    pub fn SCIPincludePresolMILP(scip: *mut SCIP) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " creates the redvub presolver and includes it in SCIP\n\n @ingroup PresolverIncludes"]
    pub fn SCIPincludePresolRedvub(scip: *mut SCIP) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " creates the QP KKT reformulation presolver and includes it in SCIP\n\n @ingroup PresolverIncludes"]
    pub fn SCIPincludePresolQPKKTref(scip: *mut SCIP) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " creates the trivial presolver and includes it in SCIP\n\n @ingroup PresolverIncludes"]
    pub fn SCIPincludePresolTrivial(scip: *mut SCIP) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " creates the tworowbnd presolver and includes it in SCIP\n\n @ingroup PresolverIncludes"]
    pub fn SCIPincludePresolTworowbnd(scip: *mut SCIP) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " creates the sparsify presolver and includes it in SCIP"]
    pub fn SCIPincludePresolSparsify(scip: *mut SCIP) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " creates the dual sparsify presolver and includes it in SCIP"]
    pub fn SCIPincludePresolDualsparsify(scip: *mut SCIP) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " creates the stuffing presolver and includes it in SCIP\n\n @ingroup PresolverIncludes"]
    pub fn SCIPincludePresolStuffing(scip: *mut SCIP) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " creates the dual fixing propagator and includes it in SCIP\n\n @ingroup PropagatorIncludes"]
    pub fn SCIPincludePropDualfix(scip: *mut SCIP) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " adds a generalized variable bound to the genvbounds propagator; if there is already a genvbound for the bound\n  \"boundtype\" of variable \"var\", it will be replaced"]
    pub fn SCIPgenVBoundAdd(
        scip: *mut SCIP,
        genvboundprop: *mut SCIP_PROP,
        vars: *mut *mut SCIP_VAR,
        var: *mut SCIP_VAR,
        coefs: *mut f64,
        ncoefs: ::std::os::raw::c_int,
        coefprimalbound: f64,
        constant: f64,
        boundtype: SCIP_BOUNDTYPE,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " creates the genvbounds propagator and includes it in SCIP\n\n @ingroup PropagatorIncludes"]
    pub fn SCIPincludePropGenvbounds(scip: *mut SCIP) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " creates the nlobbt propagator and includes it in SCIP\n\n @ingroup PropagatorIncludes"]
    pub fn SCIPincludePropNlobbt(scip: *mut SCIP) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " creates the obbt propagator and includes it in SCIP\n\n @ingroup PropagatorIncludes"]
    pub fn SCIPincludePropObbt(scip: *mut SCIP) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " creates the probing propagator and includes it in SCIP\n\n @ingroup PropagatorIncludes"]
    pub fn SCIPincludePropProbing(scip: *mut SCIP) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " applies and evaluates probing of a single variable in the given direction and bound"]
    pub fn SCIPapplyProbingVar(
        scip: *mut SCIP,
        vars: *mut *mut SCIP_VAR,
        nvars: ::std::os::raw::c_int,
        probingpos: ::std::os::raw::c_int,
        boundtype: SCIP_BOUNDTYPE,
        bound: f64,
        maxproprounds: ::std::os::raw::c_int,
        impllbs: *mut f64,
        implubs: *mut f64,
        proplbs: *mut f64,
        propubs: *mut f64,
        cutoff: *mut ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " analyses boundchanges resulting from probing on a variable and performs deduced fixations, aggregations, and domain tightenings\n\n  Given a variable probingvar with domain [l,u] and bound tightening results from reducing the\n  domain once to [l,leftub] and once to [rightlb,u], the method computes and applies resulting\n  variable fixations, aggregations, implications, and bound changes. Variable probingvar does not\n  need to be binary.  The whole domain of probingvar need to be covered by the left and right\n  branches, i.e., we assume leftub >= rightlb for continuous variables or floor(leftub) >=\n  ceil(rightlb)-1 for discrete variables.  Bounds after applying implications and cliques do not\n  need to be provided, but if they are omitted and probingvar is a binary variable, then already\n  existing implications may be added."]
    pub fn SCIPanalyzeDeductionsProbing(
        scip: *mut SCIP,
        probingvar: *mut SCIP_VAR,
        leftub: f64,
        rightlb: f64,
        nvars: ::std::os::raw::c_int,
        vars: *mut *mut SCIP_VAR,
        leftimpllbs: *mut f64,
        leftimplubs: *mut f64,
        leftproplbs: *mut f64,
        leftpropubs: *mut f64,
        rightimpllbs: *mut f64,
        rightimplubs: *mut f64,
        rightproplbs: *mut f64,
        rightpropubs: *mut f64,
        nfixedvars: *mut ::std::os::raw::c_int,
        naggrvars: *mut ::std::os::raw::c_int,
        nimplications: *mut ::std::os::raw::c_int,
        nchgbds: *mut ::std::os::raw::c_int,
        cutoff: *mut ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " creates the pseudo objective function propagator and includes it in SCIP\n\n @ingroup PropagatorIncludes"]
    pub fn SCIPincludePropPseudoobj(scip: *mut SCIP) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " propagates the cutoff bound for the given variables"]
    pub fn SCIPpropagateCutoffboundVar(
        scip: *mut SCIP,
        prop: *mut SCIP_PROP,
        var: *mut SCIP_VAR,
        cutoffbound: f64,
        pseudoobjval: f64,
        tightened: *mut ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " creates the redcost propagator and includes it in SCIP\n\n @ingroup PropagatorIncludes"]
    pub fn SCIPincludePropRedcost(scip: *mut SCIP) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " creates the root node reduced cost strengthening propagator and includes it in SCIP\n\n @ingroup PropagatorIncludes"]
    pub fn SCIPincludePropRootredcost(scip: *mut SCIP) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " include symmetry propagator"]
    pub fn SCIPincludePropSymmetry(scip: *mut SCIP) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " return currently available symmetry group information"]
    pub fn SCIPgetSymmetry(
        scip: *mut SCIP,
        npermvars: *mut ::std::os::raw::c_int,
        permvars: *mut *mut *mut SCIP_VAR,
        permvarmap: *mut *mut SCIP_HASHMAP,
        nperms: *mut ::std::os::raw::c_int,
        perms: *mut *mut *mut ::std::os::raw::c_int,
        permstrans: *mut *mut *mut ::std::os::raw::c_int,
        log10groupsize: *mut f64,
        binvaraffected: *mut ::std::os::raw::c_uint,
        components: *mut *mut ::std::os::raw::c_int,
        componentbegins: *mut *mut ::std::os::raw::c_int,
        vartocomponent: *mut *mut ::std::os::raw::c_int,
        ncomponents: *mut ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " return number of the symmetry group's generators"]
    pub fn SCIPgetSymmetryNGenerators(scip: *mut SCIP) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " creates new operator node type (used for symmetry detection) and returns its representation\n\n  If the operator node already exists, the function terminates with SCIP_INVALIDDATA."]
    pub fn SCIPcreateSymOpNodeType(
        scip: *mut SCIP,
        opnodename: *const ::std::os::raw::c_char,
        nodetype: *mut ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " returns representation of an operator node type.\n\n  If the node type does not already exist, a new node type will be created."]
    pub fn SCIPgetSymOpNodeType(
        scip: *mut SCIP,
        opnodename: *const ::std::os::raw::c_char,
        nodetype: *mut ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " creates the vbounds propagator and includes it in SCIP\n\n @ingroup PropagatorIncludes"]
    pub fn SCIPincludePropVbounds(scip: *mut SCIP) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " returns TRUE if the propagator has the status that all variable lower and upper bounds are propagated"]
    pub fn SCIPisPropagatedVbounds(scip: *mut SCIP) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " performs propagation of variables lower and upper bounds"]
    pub fn SCIPexecPropVbounds(
        scip: *mut SCIP,
        force: ::std::os::raw::c_uint,
        result: *mut SCIP_RESULT,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " includes the bnd file reader into SCIP\n\n  @ingroup FileReaderIncludes"]
    pub fn SCIPincludeReaderBnd(scip: *mut SCIP) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " includes the ccg file reader into SCIP\n\n  @ingroup FileReaderIncludes"]
    pub fn SCIPincludeReaderCcg(scip: *mut SCIP) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " writes problem to file"]
    pub fn SCIPwriteCcg(
        scip: *mut SCIP,
        file: *mut FILE,
        name: *const ::std::os::raw::c_char,
        transformed: ::std::os::raw::c_uint,
        vars: *mut *mut SCIP_VAR,
        nvars: ::std::os::raw::c_int,
        conss: *mut *mut SCIP_CONS,
        nconss: ::std::os::raw::c_int,
        result: *mut SCIP_RESULT,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " includes the cip file reader into SCIP\n\n  @ingroup FileReaderIncludes"]
    pub fn SCIPincludeReaderCip(scip: *mut SCIP) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " includes the cnf file reader into SCIP\n\n  @ingroup FileReaderIncludes"]
    pub fn SCIPincludeReaderCnf(scip: *mut SCIP) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " includes the cor file reader into SCIP\n\n  @ingroup FileReaderIncludes"]
    pub fn SCIPincludeReaderCor(scip: *mut SCIP) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " reads problem from file"]
    pub fn SCIPreadCor(
        scip: *mut SCIP,
        filename: *const ::std::os::raw::c_char,
        result: *mut SCIP_RESULT,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " returns whether the COR file has been successfully read. This is used by the TIM and STO readers."]
    pub fn SCIPcorHasRead(reader: *mut SCIP_READER) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " returns the number of variable names in the COR problem"]
    pub fn SCIPcorGetNVarNames(reader: *mut SCIP_READER) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " returns the number of constraint names in the COR problem"]
    pub fn SCIPcorGetNConsNames(reader: *mut SCIP_READER) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " returns the variable name for the given index"]
    pub fn SCIPcorGetVarName(
        reader: *mut SCIP_READER,
        i: ::std::os::raw::c_int,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " returns the constraint name for the given index"]
    pub fn SCIPcorGetConsName(
        reader: *mut SCIP_READER,
        i: ::std::os::raw::c_int,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " includes the decomposition file reader into SCIP\n\n  @ingroup FileReaderIncludes"]
    pub fn SCIPincludeReaderDec(scip: *mut SCIP) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " includes the diff file reader into SCIP\n\n  @ingroup FileReaderIncludes"]
    pub fn SCIPincludeReaderDiff(scip: *mut SCIP) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " reads problem from file"]
    pub fn SCIPreadDiff(
        scip: *mut SCIP,
        reader: *mut SCIP_READER,
        filename: *const ::std::os::raw::c_char,
        result: *mut SCIP_RESULT,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " writes problem to file"]
    pub fn SCIPwriteDiff(
        scip: *mut SCIP,
        file: *mut FILE,
        name: *const ::std::os::raw::c_char,
        transformed: ::std::os::raw::c_uint,
        objsense: SCIP_OBJSENSE,
        objscale: f64,
        objoffset: f64,
        vars: *mut *mut SCIP_VAR,
        nvars: ::std::os::raw::c_int,
        nbinvars: ::std::os::raw::c_int,
        nintvars: ::std::os::raw::c_int,
        nimplvars: ::std::os::raw::c_int,
        ncontvars: ::std::os::raw::c_int,
        conss: *mut *mut SCIP_CONS,
        nconss: ::std::os::raw::c_int,
        result: *mut SCIP_RESULT,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " includes the fix file reader into SCIP\n\n  @ingroup FileReaderIncludes"]
    pub fn SCIPincludeReaderFix(scip: *mut SCIP) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " includes the FlatZinc file reader into SCIP\n\n  @ingroup FileReaderIncludes"]
    pub fn SCIPincludeReaderFzn(scip: *mut SCIP) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " print given solution in Flatzinc format w.r.t. the output annotation"]
    pub fn SCIPprintSolReaderFzn(
        scip: *mut SCIP,
        sol: *mut SCIP_SOL,
        file: *mut FILE,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " includes the gms file reader into SCIP\n\n  @ingroup FileReaderIncludes"]
    pub fn SCIPincludeReaderGms(scip: *mut SCIP) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " writes problem to file"]
    pub fn SCIPwriteGms(
        scip: *mut SCIP,
        file: *mut FILE,
        name: *const ::std::os::raw::c_char,
        transformed: ::std::os::raw::c_uint,
        objsense: SCIP_OBJSENSE,
        objscale: f64,
        objoffset: f64,
        vars: *mut *mut SCIP_VAR,
        nvars: ::std::os::raw::c_int,
        nbinvars: ::std::os::raw::c_int,
        nintvars: ::std::os::raw::c_int,
        nimplvars: ::std::os::raw::c_int,
        ncontvars: ::std::os::raw::c_int,
        conss: *mut *mut SCIP_CONS,
        nconss: ::std::os::raw::c_int,
        result: *mut SCIP_RESULT,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " includes the lp file reader into SCIP\n\n  @ingroup FileReaderIncludes"]
    pub fn SCIPincludeReaderLp(scip: *mut SCIP) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " reads problem from file"]
    pub fn SCIPreadLp(
        scip: *mut SCIP,
        reader: *mut SCIP_READER,
        filename: *const ::std::os::raw::c_char,
        result: *mut SCIP_RESULT,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " writes problem to file"]
    pub fn SCIPwriteLp(
        scip: *mut SCIP,
        file: *mut FILE,
        name: *const ::std::os::raw::c_char,
        transformed: ::std::os::raw::c_uint,
        objsense: SCIP_OBJSENSE,
        objscale: f64,
        objoffset: f64,
        vars: *mut *mut SCIP_VAR,
        nvars: ::std::os::raw::c_int,
        nbinvars: ::std::os::raw::c_int,
        nintvars: ::std::os::raw::c_int,
        nimplvars: ::std::os::raw::c_int,
        ncontvars: ::std::os::raw::c_int,
        conss: *mut *mut SCIP_CONS,
        nconss: ::std::os::raw::c_int,
        result: *mut SCIP_RESULT,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " includes the mps file reader into SCIP\n\n  @ingroup FileReaderIncludes"]
    pub fn SCIPincludeReaderMps(scip: *mut SCIP) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " reads problem from file"]
    pub fn SCIPreadMps(
        scip: *mut SCIP,
        reader: *mut SCIP_READER,
        filename: *const ::std::os::raw::c_char,
        result: *mut SCIP_RESULT,
        varnames: *mut *mut *const ::std::os::raw::c_char,
        consnames: *mut *mut *const ::std::os::raw::c_char,
        varnamessize: *mut ::std::os::raw::c_int,
        consnamessize: *mut ::std::os::raw::c_int,
        nvarnames: *mut ::std::os::raw::c_int,
        nconsnames: *mut ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " writes problem to file"]
    pub fn SCIPwriteMps(
        scip: *mut SCIP,
        reader: *mut SCIP_READER,
        file: *mut FILE,
        name: *const ::std::os::raw::c_char,
        transformed: ::std::os::raw::c_uint,
        objsense: SCIP_OBJSENSE,
        objscale: f64,
        objoffset: f64,
        vars: *mut *mut SCIP_VAR,
        nvars: ::std::os::raw::c_int,
        nbinvars: ::std::os::raw::c_int,
        nintvars: ::std::os::raw::c_int,
        nimplvars: ::std::os::raw::c_int,
        ncontvars: ::std::os::raw::c_int,
        fixedvars: *mut *mut SCIP_VAR,
        nfixedvars: ::std::os::raw::c_int,
        conss: *mut *mut SCIP_CONS,
        nconss: ::std::os::raw::c_int,
        result: *mut SCIP_RESULT,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " includes the mst file reader into SCIP\n\n  @ingroup FileReaderIncludes"]
    pub fn SCIPincludeReaderMst(scip: *mut SCIP) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " includes the .nl file reader into SCIP"]
    pub fn SCIPincludeReaderNl(scip: *mut SCIP) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " writes AMPL solution file\n\n problem must have been read with .nl reader"]
    pub fn SCIPwriteSolutionNl(scip: *mut SCIP) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " includes the opb file reader into SCIP\n\n  @ingroup FileReaderIncludes"]
    pub fn SCIPincludeReaderOpb(scip: *mut SCIP) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " reads problem from file"]
    pub fn SCIPreadOpb(
        scip: *mut SCIP,
        reader: *mut SCIP_READER,
        filename: *const ::std::os::raw::c_char,
        result: *mut SCIP_RESULT,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " writes problem to file"]
    pub fn SCIPwriteOpb(
        scip: *mut SCIP,
        file: *mut FILE,
        name: *const ::std::os::raw::c_char,
        transformed: ::std::os::raw::c_uint,
        objsense: SCIP_OBJSENSE,
        objscale: f64,
        objoffset: f64,
        vars: *mut *mut SCIP_VAR,
        nvars: ::std::os::raw::c_int,
        nbinvars: ::std::os::raw::c_int,
        nintvars: ::std::os::raw::c_int,
        nimplvars: ::std::os::raw::c_int,
        ncontvars: ::std::os::raw::c_int,
        fixedvars: *mut *mut SCIP_VAR,
        nfixedvars: ::std::os::raw::c_int,
        conss: *mut *mut SCIP_CONS,
        nconss: ::std::os::raw::c_int,
        genericnames: ::std::os::raw::c_uint,
        result: *mut SCIP_RESULT,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " includes the osil file reader into SCIP\n\n  @ingroup FileReaderIncludes"]
    pub fn SCIPincludeReaderOsil(scip: *mut SCIP) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " includes the pip file reader into SCIP\n\n  @ingroup FileReaderIncludes"]
    pub fn SCIPincludeReaderPip(scip: *mut SCIP) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " reads problem from file"]
    pub fn SCIPreadPip(
        scip: *mut SCIP,
        reader: *mut SCIP_READER,
        filename: *const ::std::os::raw::c_char,
        result: *mut SCIP_RESULT,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " writes problem to file"]
    pub fn SCIPwritePip(
        scip: *mut SCIP,
        file: *mut FILE,
        name: *const ::std::os::raw::c_char,
        transformed: ::std::os::raw::c_uint,
        objsense: SCIP_OBJSENSE,
        objscale: f64,
        objoffset: f64,
        vars: *mut *mut SCIP_VAR,
        nvars: ::std::os::raw::c_int,
        nbinvars: ::std::os::raw::c_int,
        nintvars: ::std::os::raw::c_int,
        nimplvars: ::std::os::raw::c_int,
        ncontvars: ::std::os::raw::c_int,
        conss: *mut *mut SCIP_CONS,
        nconss: ::std::os::raw::c_int,
        result: *mut SCIP_RESULT,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " includes the ppm file reader into SCIP\n\n  @ingroup FileReaderIncludes"]
    pub fn SCIPincludeReaderPpm(scip: *mut SCIP) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " writes problem to file"]
    pub fn SCIPwritePpm(
        scip: *mut SCIP,
        file: *mut FILE,
        name: *const ::std::os::raw::c_char,
        readerdata: *mut SCIP_READERDATA,
        transformed: ::std::os::raw::c_uint,
        vars: *mut *mut SCIP_VAR,
        nvars: ::std::os::raw::c_int,
        conss: *mut *mut SCIP_CONS,
        nconss: ::std::os::raw::c_int,
        result: *mut SCIP_RESULT,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " includes the pbm file reader into SCIP\n\n  @ingroup FileReaderIncludes"]
    pub fn SCIPincludeReaderPbm(scip: *mut SCIP) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = "@addtogroup FILEREADERS\n\n @{"]
    pub fn SCIPwritePbm(
        scip: *mut SCIP,
        file: *mut FILE,
        name: *const ::std::os::raw::c_char,
        readerdata: *mut SCIP_READERDATA,
        transformed: ::std::os::raw::c_uint,
        nvars: ::std::os::raw::c_int,
        conss: *mut *mut SCIP_CONS,
        nconss: ::std::os::raw::c_int,
        result: *mut SCIP_RESULT,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " includes the rlp file reader into SCIP\n\n  @ingroup FileReaderIncludes"]
    pub fn SCIPincludeReaderRlp(scip: *mut SCIP) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " includes the smps file reader into SCIP\n\n  @ingroup FileReaderIncludes"]
    pub fn SCIPincludeReaderSmps(scip: *mut SCIP) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " includes the sol file reader into SCIP\n\n  @ingroup FileReaderIncludes"]
    pub fn SCIPincludeReaderSol(scip: *mut SCIP) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " includes the sto file reader into SCIP\n\n  @ingroup FileReaderIncludes"]
    pub fn SCIPincludeReaderSto(scip: *mut SCIP) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " reads the stochastic information for a stochastic program that is in SMPS format"]
    pub fn SCIPreadSto(
        scip: *mut SCIP,
        filename: *const ::std::os::raw::c_char,
        result: *mut SCIP_RESULT,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " writes problem to file"]
    pub fn SCIPwriteSto(
        scip: *mut SCIP,
        file: *mut FILE,
        name: *const ::std::os::raw::c_char,
        transformed: ::std::os::raw::c_uint,
        objsense: SCIP_OBJSENSE,
        objscale: f64,
        objoffset: f64,
        vars: *mut *mut SCIP_VAR,
        nvars: ::std::os::raw::c_int,
        nbinvars: ::std::os::raw::c_int,
        nintvars: ::std::os::raw::c_int,
        nimplvars: ::std::os::raw::c_int,
        ncontvars: ::std::os::raw::c_int,
        conss: *mut *mut SCIP_CONS,
        nconss: ::std::os::raw::c_int,
        result: *mut SCIP_RESULT,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " returns the total number of scenarios added to the problem"]
    pub fn SCIPstoGetNScenarios(scip: *mut SCIP) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " includes the tim file reader into SCIP\n\n  @ingroup FileReaderIncludes"]
    pub fn SCIPincludeReaderTim(scip: *mut SCIP) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " reads the stage information for a stochastic programming instance in SMPS format"]
    pub fn SCIPreadTim(
        scip: *mut SCIP,
        filename: *const ::std::os::raw::c_char,
        result: *mut SCIP_RESULT,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " @}"]
    pub fn SCIPtimHasRead(reader: *mut SCIP_READER) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn SCIPtimGetNStages(scip: *mut SCIP) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SCIPtimGetStageName(
        scip: *mut SCIP,
        stagenum: ::std::os::raw::c_int,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn SCIPtimConsGetStageName(
        scip: *mut SCIP,
        consname: *const ::std::os::raw::c_char,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn SCIPtimFindStage(
        scip: *mut SCIP,
        stage: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SCIPtimGetStageVars(
        scip: *mut SCIP,
        stagenum: ::std::os::raw::c_int,
    ) -> *mut *mut SCIP_VAR;
}
extern "C" {
    pub fn SCIPtimGetStageConss(
        scip: *mut SCIP,
        stagenum: ::std::os::raw::c_int,
    ) -> *mut *mut SCIP_CONS;
}
extern "C" {
    pub fn SCIPtimGetStageNVars(
        scip: *mut SCIP,
        stagenum: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SCIPtimGetStageNConss(
        scip: *mut SCIP,
        stagenum: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " includes the wbo file reader into SCIP\n\n  @ingroup FileReaderIncludes"]
    pub fn SCIPincludeReaderWbo(scip: *mut SCIP) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " includes the zpl file reader into SCIP\n\n  @ingroup FileReaderIncludes"]
    pub fn SCIPincludeReaderZpl(scip: *mut SCIP) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " creates the edge-concave separator and includes it in SCIP\n\n @ingroup SeparatorIncludes"]
    pub fn SCIPincludeSepaEccuts(scip: *mut SCIP) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " creates the Chvatal-Gomory-MIP cut separator and includes it in SCIP\n\n @ingroup SeparatorIncludes"]
    pub fn SCIPincludeSepaCGMIP(scip: *mut SCIP) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " creates the clique separator and includes it in SCIP\n\n @ingroup SeparatorIncludes"]
    pub fn SCIPincludeSepaClique(scip: *mut SCIP) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " creates the closecuts separator and includes it in SCIP\n\n @ingroup SeparatorIncludes"]
    pub fn SCIPincludeSepaClosecuts(scip: *mut SCIP) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " sets point to be used as base point for computing the point to be separated\n\n  The point is only stored if separation of relative interior points is used. The solution is copied."]
    pub fn SCIPsetBasePointClosecuts(scip: *mut SCIP, sol: *mut SCIP_SOL) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " creates the aggregation separator and includes it in SCIP\n\n @ingroup SeparatorIncludes"]
    pub fn SCIPincludeSepaAggregation(scip: *mut SCIP) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " creates the convexproj separator and includes it in SCIP\n\n @ingroup SeparatorIncludes"]
    pub fn SCIPincludeSepaConvexproj(scip: *mut SCIP) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " creates the disjunctive cut separator and includes it in SCIP\n\n @ingroup SeparatorIncludes"]
    pub fn SCIPincludeSepaDisjunctive(scip: *mut SCIP) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " creates the gauge separator and includes it in SCIP\n\n @ingroup SeparatorIncludes"]
    pub fn SCIPincludeSepaGauge(scip: *mut SCIP) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " creates the Gomory MIR cut separator and includes it in SCIP\n\n @ingroup SeparatorIncludes"]
    pub fn SCIPincludeSepaGomory(scip: *mut SCIP) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " creates the impliedbounds separator and includes it in SCIP\n\n @ingroup SeparatorIncludes"]
    pub fn SCIPincludeSepaImpliedbounds(scip: *mut SCIP) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " creates the interminor separator and includes it in SCIP\n\n @ingroup SeparatorIncludes"]
    pub fn SCIPincludeSepaInterminor(scip: *mut SCIP) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " creates the integer objective value separator and includes it in SCIP\n\n @ingroup SeparatorIncludes"]
    pub fn SCIPincludeSepaIntobj(scip: *mut SCIP) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " creates the Lagromory separator and includes it in SCIP\n\n @ingroup SeparatorIncludes"]
    pub fn SCIPincludeSepaLagromory(scip: *mut SCIP) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " creates the mcf separator and includes it in SCIP\n\n @ingroup SeparatorIncludes"]
    pub fn SCIPincludeSepaMcf(scip: *mut SCIP) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " creates the minor separator and includes it in SCIP\n\n @ingroup SeparatorIncludes"]
    pub fn SCIPincludeSepaMinor(scip: *mut SCIP) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " creates the mixing separator and includes it in SCIP\n\n @ingroup SeparatorIncludes"]
    pub fn SCIPincludeSepaMixing(scip: *mut SCIP) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " creates the oddcycle separator and includes it in SCIP\n\n @ingroup SeparatorIncludes"]
    pub fn SCIPincludeSepaOddcycle(scip: *mut SCIP) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " creates the rapidlearning separator and includes it in SCIP\n\n @ingroup SeparatorIncludes"]
    pub fn SCIPincludeSepaRapidlearning(scip: *mut SCIP) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " creates the RLT separator and includes it in SCIP\n\n @ingroup SeparatorIncludes"]
    pub fn SCIPincludeSepaRlt(scip: *mut SCIP) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " creates the {0,1/2}-cut separator and includes it in SCIP\n\n @ingroup SeparatorIncludes"]
    pub fn SCIPincludeSepaZerohalf(scip: *mut SCIP) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " evaluates command line parameters and runs SCIP appropriately in the given SCIP instance"]
    pub fn SCIPprocessShellArguments(
        scip: *mut SCIP,
        argc: ::std::os::raw::c_int,
        argv: *mut *mut ::std::os::raw::c_char,
        defaultsetname: *const ::std::os::raw::c_char,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " creates a SCIP instance with default plugins, evaluates command line parameters, runs SCIP appropriately,\n  and frees the SCIP instance"]
    pub fn SCIPrunShell(
        argc: ::std::os::raw::c_int,
        argv: *mut *mut ::std::os::raw::c_char,
        defaultsetname: *const ::std::os::raw::c_char,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " compute non-trivial orbits of symmetry group\n\n  The non-trivial orbits of the group action are stored in the array orbits of length npermvars. This array contains\n  the indices of variables from the permvars array such that variables that are contained in the same orbit appear\n  consecutively in the orbits array. The variables of the i-th orbit have indices\n  orbits[orbitbegins[i]], ... , orbits[orbitbegins[i + 1] - 1].\n  Note that the description of the orbits ends at orbitbegins[norbits] - 1."]
    pub fn SCIPcomputeOrbitsSym(
        scip: *mut SCIP,
        issigned: ::std::os::raw::c_uint,
        permvars: *mut *mut SCIP_VAR,
        npermvars: ::std::os::raw::c_int,
        perms: *mut *mut ::std::os::raw::c_int,
        nperms: ::std::os::raw::c_int,
        orbits: *mut ::std::os::raw::c_int,
        orbitbegins: *mut ::std::os::raw::c_int,
        norbits: *mut ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " compute non-trivial orbits of symmetry group using filtered generators\n\n  The non-trivial orbits of the group action are stored in the array orbits of length npermvars. This array contains\n  the indices of variables from the permvars array such that variables that are contained in the same orbit appear\n  consecutively in the orbits array. The variables of the i-th orbit have indices\n  orbits[orbitbegins[i]], ... , orbits[orbitbegins[i + 1] - 1].\n  Note that the description of the orbits ends at orbitbegins[norbits] - 1.\n\n  Only permutations that are not inactive (as marked by @p inactiveperms) are used. Thus, one can use this array to\n  filter out permutations."]
    pub fn SCIPcomputeOrbitsFilterSym(
        scip: *mut SCIP,
        npermvars: ::std::os::raw::c_int,
        permstrans: *mut *mut ::std::os::raw::c_int,
        nperms: ::std::os::raw::c_int,
        inactiveperms: *mut u8,
        orbits: *mut ::std::os::raw::c_int,
        orbitbegins: *mut ::std::os::raw::c_int,
        norbits: *mut ::std::os::raw::c_int,
        components: *mut ::std::os::raw::c_int,
        componentbegins: *mut ::std::os::raw::c_int,
        vartocomponent: *mut ::std::os::raw::c_int,
        componentblocked: *mut ::std::os::raw::c_uint,
        ncomponents: ::std::os::raw::c_int,
        nmovedpermvars: ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " compute non-trivial orbits of symmetry group\n\n  The non-trivial orbits of the group action are stored in the array orbits of length npermvars. This array contains\n  the indices of variables from the permvars array such that variables that are contained in the same orbit appear\n  consecutively in the orbits array. The variables of the i-th orbit have indices\n  orbits[orbitbegins[i]], ... , orbits[orbitbegins[i + 1] - 1].\n  Note that the description of the orbits ends at orbitbegins[norbits] - 1.\n\n  This function is adapted from SCIPcomputeOrbitsFilterSym()."]
    pub fn SCIPcomputeOrbitsComponentsSym(
        scip: *mut SCIP,
        npermvars: ::std::os::raw::c_int,
        permstrans: *mut *mut ::std::os::raw::c_int,
        nperms: ::std::os::raw::c_int,
        components: *mut ::std::os::raw::c_int,
        componentbegins: *mut ::std::os::raw::c_int,
        vartocomponent: *mut ::std::os::raw::c_int,
        ncomponents: ::std::os::raw::c_int,
        orbits: *mut ::std::os::raw::c_int,
        orbitbegins: *mut ::std::os::raw::c_int,
        norbits: *mut ::std::os::raw::c_int,
        varorbitmap: *mut ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " Compute orbit of a given variable and store it in @p orbit. The first entry of the orbit will\n  be the given variable index and the rest is filled with the remaining variables excluding\n  the ones specified in @p ignoredvars.\n\n  @pre orbit is an initialized array of size propdata->npermvars\n  @pre at least one of @p perms and @p permstrans should not be NULL"]
    pub fn SCIPcomputeOrbitVar(
        scip: *mut SCIP,
        npermvars: ::std::os::raw::c_int,
        perms: *mut *mut ::std::os::raw::c_int,
        permstrans: *mut *mut ::std::os::raw::c_int,
        components: *mut ::std::os::raw::c_int,
        componentbegins: *mut ::std::os::raw::c_int,
        ignoredvars: *mut u8,
        varfound: *mut u8,
        varidx: ::std::os::raw::c_int,
        component: ::std::os::raw::c_int,
        orbit: *mut ::std::os::raw::c_int,
        orbitsize: *mut ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " Checks whether a permutation is a composition of 2-cycles and in this case determine the number of overall\n  2-cycles and binary 2-cycles. It is a composition of 2-cycles iff @p ntwocyclesperm > 0 upon termination."]
    pub fn SCIPisInvolutionPerm(
        perm: *mut ::std::os::raw::c_int,
        vars: *mut *mut SCIP_VAR,
        nvars: ::std::os::raw::c_int,
        ntwocyclesperm: *mut ::std::os::raw::c_int,
        nbincyclesperm: *mut ::std::os::raw::c_int,
        earlytermination: ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " determine number of variables affected by symmetry group"]
    pub fn SCIPdetermineNVarsAffectedSym(
        scip: *mut SCIP,
        perms: *mut *mut ::std::os::raw::c_int,
        nperms: ::std::os::raw::c_int,
        permvars: *mut *mut SCIP_VAR,
        npermvars: ::std::os::raw::c_int,
        nvarsaffected: *mut ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " compute components of symmetry group"]
    pub fn SCIPcomputeComponentsSym(
        scip: *mut SCIP,
        symtype: SYM_SYMTYPE,
        perms: *mut *mut ::std::os::raw::c_int,
        nperms: ::std::os::raw::c_int,
        permvars: *mut *mut SCIP_VAR,
        npermvars: ::std::os::raw::c_int,
        transposed: ::std::os::raw::c_uint,
        components: *mut *mut ::std::os::raw::c_int,
        componentbegins: *mut *mut ::std::os::raw::c_int,
        vartocomponent: *mut *mut ::std::os::raw::c_int,
        componentblocked: *mut *mut ::std::os::raw::c_uint,
        ncomponents: *mut ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " Given a matrix with nrows and \\#perms + 1 columns whose first nfilledcols columns contain entries of variables, this routine\n  checks whether the 2-cycles of perm intersect each row of column coltoextend in exactly one position. In this case,\n  we add one column to the suborbitope of the first nfilledcols columns.\n\n  @pre Every non-trivial cycle of perm is a 2-cycle.\n  @pre perm has nrows many 2-cycles"]
    pub fn SCIPextendSubOrbitope(
        suborbitope: *mut *mut ::std::os::raw::c_int,
        nrows: ::std::os::raw::c_int,
        nfilledcols: ::std::os::raw::c_int,
        coltoextend: ::std::os::raw::c_int,
        perm: *mut ::std::os::raw::c_int,
        leftextension: ::std::os::raw::c_uint,
        nusedelems: *mut *mut ::std::os::raw::c_int,
        permvars: *mut *mut SCIP_VAR,
        rowisbinary: *mut u8,
        success: *mut ::std::os::raw::c_uint,
        infeasible: *mut ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " generate variable matrix for orbitope constraint handler"]
    pub fn SCIPgenerateOrbitopeVarsMatrix(
        scip: *mut SCIP,
        vars: *mut *mut *mut *mut SCIP_VAR,
        nrows: ::std::os::raw::c_int,
        ncols: ::std::os::raw::c_int,
        permvars: *mut *mut SCIP_VAR,
        npermvars: ::std::os::raw::c_int,
        orbitopevaridx: *mut *mut ::std::os::raw::c_int,
        columnorder: *mut ::std::os::raw::c_int,
        nusedelems: *mut ::std::os::raw::c_int,
        rowisbinary: *mut u8,
        infeasible: *mut ::std::os::raw::c_uint,
        storelexorder: ::std::os::raw::c_uint,
        lexorder: *mut *mut ::std::os::raw::c_int,
        nvarsorder: *mut ::std::os::raw::c_int,
        maxnvarsorder: *mut ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " checks whether an orbitope is a packing or partitioning orbitope"]
    pub fn SCIPisPackingPartitioningOrbitope(
        scip: *mut SCIP,
        vars: *mut *mut *mut SCIP_VAR,
        nrows: ::std::os::raw::c_int,
        ncols: ::std::os::raw::c_int,
        pprows: *mut *mut ::std::os::raw::c_uint,
        npprows: *mut ::std::os::raw::c_int,
        type_: *mut SCIP_ORBITOPETYPE,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " detects whether permutations define single or double lex matrices\n\n  A single lex matrix is a matrix whose columns can be partitioned into blocks such that the\n  columns within each block can be permuted arbitrarily. A double lex matrix is a single lex\n  matrix such that also blocks of rows have the aforementioned property."]
    pub fn SCIPdetectSingleOrDoubleLexMatrices(
        scip: *mut SCIP,
        detectsinglelex: ::std::os::raw::c_uint,
        perms: *mut *mut ::std::os::raw::c_int,
        nperms: ::std::os::raw::c_int,
        permlen: ::std::os::raw::c_int,
        success: *mut ::std::os::raw::c_uint,
        isorbitope: *mut ::std::os::raw::c_uint,
        lexmatrix: *mut *mut *mut ::std::os::raw::c_int,
        nrows: *mut ::std::os::raw::c_int,
        ncols: *mut ::std::os::raw::c_int,
        lexrowsbegin: *mut *mut ::std::os::raw::c_int,
        lexcolsbegin: *mut *mut ::std::os::raw::c_int,
        nrowmatrices: *mut ::std::os::raw::c_int,
        ncolmatrices: *mut ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " helper function to test if val1 = val2 while permitting infinity-values"]
    pub fn SCIPsymEQ(scip: *mut SCIP, val1: f64, val2: f64) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " helper function to test if val1 <= val2 while permitting infinity-values"]
    pub fn SCIPsymLE(scip: *mut SCIP, val1: f64, val2: f64) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " helper function to test if val1 >= val2 while permitting infinity-values"]
    pub fn SCIPsymGE(scip: *mut SCIP, val1: f64, val2: f64) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " helper function to test if val1 < val2 while permitting infinity-values"]
    pub fn SCIPsymLT(scip: *mut SCIP, val1: f64, val2: f64) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " helper function to test if val1 > val2 while permitting infinity-values"]
    pub fn SCIPsymGT(scip: *mut SCIP, val1: f64, val2: f64) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " creates the default statistics tables and includes them in SCIP\n\n  @ingroup TableIncludes"]
    pub fn SCIPincludeTableDefault(scip: *mut SCIP) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " creates the concurrent SCIP solver plugins and includes them in SCIP"]
    pub fn SCIPincludeConcurrentScipSolvers(scip: *mut SCIP) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " creates the default Benders' decomposition and includes it in SCIP\n\n  @ingroup BendersIncludes"]
    pub fn SCIPincludeBendersDefault(scip: *mut SCIP) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " Creates a default Benders' decomposition algorithm and activates it in SCIP"]
    pub fn SCIPcreateBendersDefault(
        scip: *mut SCIP,
        subproblems: *mut *mut SCIP,
        nsubproblems: ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " creates the hybrid separator and includes it in SCIP\n\n @ingroup CutSelectorIncludes"]
    pub fn SCIPincludeCutselHybrid(scip: *mut SCIP) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " perform a cut selection algorithm for the given array of cuts\n\n  This is the selection method of the hybrid cut selector which uses a weighted sum of the\n  efficacy, parallelism, directed cutoff distance, and the integral support.\n  The input cuts array gets resorted s.t the selected cuts come first and the remaining\n  ones are the end."]
    pub fn SCIPselectCutsHybrid(
        scip: *mut SCIP,
        cuts: *mut *mut SCIP_ROW,
        forcedcuts: *mut *mut SCIP_ROW,
        randnumgen: *mut SCIP_RANDNUMGEN,
        goodscorefac: f64,
        badscorefac: f64,
        goodmaxparall: f64,
        maxparall: f64,
        dircutoffdistweight: f64,
        efficacyweight: f64,
        objparalweight: f64,
        intsupportweight: f64,
        ncuts: ::std::os::raw::c_int,
        nforcedcuts: ::std::os::raw::c_int,
        maxselectedcuts: ::std::os::raw::c_int,
        nselectedcuts: *mut ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " creates the dynamic hybrid separator and includes it in SCIP\n\n @ingroup CutSelectorIncludes"]
    pub fn SCIPincludeCutselDynamic(scip: *mut SCIP) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " perform a cut selection algorithm for the given array of cuts\n\n  This is an extension of the hybrid cutselector to employ a dynamic range\n  when applying orthogonality filtering, dependent on the efficacy ratio between cuts.\n\n  The input cuts array should be resorted such that the selected cuts come first."]
    pub fn SCIPselectCutsDynamic(
        scip: *mut SCIP,
        cuts: *mut *mut SCIP_ROW,
        forcedcuts: *mut *mut SCIP_ROW,
        randnumgen: *mut SCIP_RANDNUMGEN,
        filtermode: ::std::os::raw::c_char,
        mingain: f64,
        maxparall: f64,
        dircutoffdistweight: f64,
        efficacyweight: f64,
        objparalweight: f64,
        intsupportweight: f64,
        ncuts: ::std::os::raw::c_int,
        nforcedcuts: ::std::os::raw::c_int,
        maxselectedcuts: ::std::os::raw::c_int,
        nselectedcuts: *mut ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " creates the ensemble separator and includes it in SCIP\n\n @ingroup CutSelectorIncludes"]
    pub fn SCIPincludeCutselEnsemble(scip: *mut SCIP) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " perform a cut selection algorithm for the given array of cuts\n\n  This is the selection method of the ensemble cut selector. It uses a weighted sum of normalised efficacy,\n  normalised directed cutoff distance, normalised expected improvements, objective parallelism,\n  integer support, sparsity, dynamism, pseudo-costs, and variable locks.\n  In addition to the weighted sum score, there are optionally parallelism-based filtering and penalties,\n  and density filtering.\n  There are also additional budget constraints on the number of cuts that should be added.\n  The input cuts array gets re-sorted such that the selected cuts come first and the remaining ones are the end."]
    pub fn SCIPselectCutsEnsemble(
        scip: *mut SCIP,
        cuts: *mut *mut SCIP_ROW,
        forcedcuts: *mut *mut SCIP_ROW,
        cutseldata: *mut SCIP_CUTSELDATA,
        root: ::std::os::raw::c_uint,
        ncuts: ::std::os::raw::c_int,
        nforcedcuts: ::std::os::raw::c_int,
        maxselectedcuts: ::std::os::raw::c_int,
        nselectedcuts: *mut ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " creates the handler for variable index expressions and includes it into SCIP\n\n @ingroup ExprhdlrIncludes"]
    pub fn SCIPincludeExprhdlrVaridx(scip: *mut SCIP) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " creates a variable index expression"]
    pub fn SCIPcreateExprVaridx(
        scip: *mut SCIP,
        expr: *mut *mut SCIP_EXPR,
        varidx: ::std::os::raw::c_int,
        ownercreate: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                expr: *mut SCIP_EXPR,
                ownerdata: *mut *mut SCIP_EXPR_OWNERDATA,
                ownerfree: *mut ::std::option::Option<
                    unsafe extern "C" fn(
                        scip: *mut SCIP,
                        expr: *mut SCIP_EXPR,
                        ownerdata: *mut *mut SCIP_EXPR_OWNERDATA,
                    ) -> SCIP_RETCODE,
                >,
                ownerprint: *mut ::std::option::Option<
                    unsafe extern "C" fn(
                        scip: *mut SCIP,
                        file: *mut FILE,
                        expr: *mut SCIP_EXPR,
                        ownerdata: *mut SCIP_EXPR_OWNERDATA,
                    ) -> SCIP_RETCODE,
                >,
                ownerevalactivity: *mut ::std::option::Option<
                    unsafe extern "C" fn(
                        scip: *mut SCIP,
                        expr: *mut SCIP_EXPR,
                        ownerdata: *mut SCIP_EXPR_OWNERDATA,
                    ) -> SCIP_RETCODE,
                >,
                ownercreatedata: *mut ::std::os::raw::c_void,
            ) -> SCIP_RETCODE,
        >,
        ownercreatedata: *mut ::std::os::raw::c_void,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " indicates whether expression is varidx expression"]
    pub fn SCIPisExprVaridx(scip: *mut SCIP, expr: *mut SCIP_EXPR) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " gives the index stored in a varidx expression"]
    pub fn SCIPgetIndexExprVaridx(expr: *mut SCIP_EXPR) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " sets the index stored in a varidx expression"]
    pub fn SCIPsetIndexExprVaridx(expr: *mut SCIP_EXPR, newindex: ::std::os::raw::c_int);
}
extern "C" {
    #[doc = " create solver interface for Ipopt solver and includes it into SCIP, if Ipopt is available\n\n @ingroup NLPIIncludes"]
    pub fn SCIPincludeNlpSolverIpopt(scip: *mut SCIP) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " gets string that identifies Ipopt (version number)"]
    pub fn SCIPgetSolverNameIpopt() -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " gets string that describes Ipopt"]
    pub fn SCIPgetSolverDescIpopt() -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " returns whether Ipopt is available, i.e., whether it has been linked in"]
    pub fn SCIPisIpoptAvailableIpopt() -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " gives a pointer to the NLPIORACLE object stored in Ipopt-NLPI's NLPI problem data structure"]
    pub fn SCIPgetNlpiOracleIpopt(
        nlpiproblem: *mut SCIP_NLPIPROBLEM,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " Calls Lapacks Dsyev routine to compute eigenvalues and eigenvectors of a dense matrix.\n\n This uses Ipopt's interface to Lapack."]
    pub fn SCIPcallLapackDsyevIpopt(
        computeeigenvectors: ::std::os::raw::c_uint,
        N: ::std::os::raw::c_int,
        a: *mut f64,
        w: *mut f64,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " solves a linear problem of the form Ax = b for a regular matrix A\n\n  Calls Lapacks DGETRF routine to calculate a LU factorization and uses this factorization to solve\n  the linear problem Ax = b.\n\n This uses Ipopt's interface to Lapack."]
    pub fn SCIPsolveLinearEquationsIpopt(
        N: ::std::os::raw::c_int,
        A: *mut f64,
        b: *mut f64,
        x: *mut f64,
        success: *mut ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " create solver interface for filterSQP solver and include it into SCIP, if filterSQP is available\n\n @ingroup NLPIIncludes"]
    pub fn SCIPincludeNlpSolverFilterSQP(scip: *mut SCIP) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " gets string that identifies filterSQP"]
    pub fn SCIPgetSolverNameFilterSQP() -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " gets string that describes filterSQP"]
    pub fn SCIPgetSolverDescFilterSQP() -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " returns whether filterSQP is available, i.e., whether it has been linked in"]
    pub fn SCIPisFilterSQPAvailableFilterSQP() -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " create solver interface for Worhp solver and includes it into SCIP, if Worhp is available\n\n @ingroup NLPIIncludes"]
    pub fn SCIPincludeNlpSolverWorhp(
        scip: *mut SCIP,
        useip: ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " gets string that identifies Worhp (version number)"]
    pub fn SCIPgetSolverNameWorhp() -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " gets string that describes Worhp (version number)"]
    pub fn SCIPgetSolverDescWorhp() -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " returns whether Worhp is available, i.e., whether it has been linked in"]
    pub fn SCIPisWorhpAvailableWorhp() -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " create solver interface for the solver \"All\" and includes it into SCIP, if at least 2 NLPIs have already been included\n\n This method should be called after all other NLP solver interfaces have been included.\n\n @ingroup NLPIIncludes"]
    pub fn SCIPincludeNlpSolverAll(scip: *mut SCIP) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " includes default SCIP plugins into SCIP"]
    pub fn SCIPincludeDefaultPlugins(scip: *mut SCIP) -> SCIP_RETCODE;
}
pub type __builtin_va_list = [__va_list_tag; 1usize];
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __va_list_tag {
    pub gp_offset: ::std::os::raw::c_uint,
    pub fp_offset: ::std::os::raw::c_uint,
    pub overflow_arg_area: *mut ::std::os::raw::c_void,
    pub reg_save_area: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout___va_list_tag() {
    const UNINIT: ::std::mem::MaybeUninit<__va_list_tag> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__va_list_tag>(),
        24usize,
        concat!("Size of: ", stringify!(__va_list_tag))
    );
    assert_eq!(
        ::std::mem::align_of::<__va_list_tag>(),
        8usize,
        concat!("Alignment of ", stringify!(__va_list_tag))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).gp_offset) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(gp_offset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fp_offset) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(fp_offset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).overflow_arg_area) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(overflow_arg_area)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reg_save_area) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(reg_save_area)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __locale_data {
    pub _address: u8,
}
